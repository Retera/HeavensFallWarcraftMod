//===========================================================================
// Blizzard.j ( define Jass2 functions that need to be in every map script )
//===========================================================================


globals

//globals from CSData:
        constant integer CSData__MAX_HANDLE_ID_COUNT = 408000
        // values lower than 8191: very fast, but very unsafe.
        // values bigger than 8191: not that fast, the bigger the number is the slower the function gets
        // Most maps don't really need a value bigger than 50000 here, but if you are unsure, leave it
        // as the rather inflated value of 408000
        hashtable CSData__ht
//endglobals from CSData
//globals from GroupUtils:
    //* Group for use with all instant enumerations
    group ENUM_GROUP = CreateGroup()
    
    //* Temporary references for GroupRefresh
    boolean GroupUtils___Flag                                              = false
    group GroupUtils___Refr                                                = null
    
    //* Assorted constants
    constant integer GroupUtils___MAX_HANDLE_COUNT                         = 408000
    constant integer GroupUtils___MIN_HANDLE_ID                            = 0x100000
    
    //* Arrays and counter for the group stack
    group array GroupUtils___Groups
// processed:     integer array GroupUtils___Status[GroupUtils___MAX_HANDLE_COUNT]
    integer GroupUtils___Count                                             = 0
//endglobals from GroupUtils
//globals from TimerUtils:
        hashtable TimerUtils___hasht //I <3 blizz
        timer array TimerUtils___tT
        integer TimerUtils___tN = 0
        constant integer TimerUtils___HELD=0x28829022
        //use a totally random number here, the more improbable someone uses it, the better.
//endglobals from TimerUtils
//globals from CSSafeCache:

        gamecache     cs_cache   = null
        integer array cs_array1
        integer array cs_array3
        integer array cs_array2
        integer array CSSafeCache__cs_freeindexes
        integer array CSSafeCache__cs_pairx
        integer array CSSafeCache__cs_pairy
        integer array CSSafeCache__cs_freepairs

//endglobals from CSSafeCache
//globals from CasterSystem:
        //
        // Caster Unit type rawcode  (changes betwen maps, always use it inside '')
        //
        constant  integer    cs_CasterUnitId         = 'e013'

        // cs_TIMER_CYCLE : Cycle value for the projectile movement in seconds (Each 0.04 the projectiles get moved)
        // 0.01 looks smooth but is lag friendly
        // 0.025 looks smooth and probably matches wc3's frame rate (so in theory, lower values than it are not needed)
        // 0.1 looks horrible but is not laggy
        // 0.04 is decent for the human eye and very efficient.
        // 0.035 is ... well, a little smoother than 0.04
        // 0.05 would be an improvement in efficiency but probably doesn't look too well )
        //
        constant real       cs_TIMER_CYCLE          = 0.035

        //
        // The eat tree ability, don't need to change this rawcode unless you modiffied that ability in your map, in that case copy it, reset the copied one and use its rawcode here.
        //
        constant integer    cs_DamageTreeDetectorId = 'Aeat'

        //
        // Medivh's Crow form ability, don't need to change this rawcode unless you
        // modiffied that ability in your map, in that case copy it, reset the copied one and use its rawcode here:
        //
        constant integer    cs_FlyingHeightHack     = 'Amrf'

        //
        // This must point to an inventory ability with 6 slots that does not add bonuses, you don't need one unless
        // the caster system item hiding functions are used in your map
        //
        constant integer    cs_DummyInventory_Id    = 'null'

        //
        //Maximum collision size in your map - Affects the caster system's area cast/damage functions
        //
        constant real       cs_MaxUnitCollisionSize = 55.0

        //
        // Next are default attack and damage types for the old caster system functions or when using 0 as damageoptions
        //
        constant attacktype cs_DefaultAttackType    = ATTACK_TYPE_CHAOS
        constant damagetype cs_DefaultDamageType    = DAMAGE_TYPE_UNIVERSAL
        
        //
        // cs_InitialCastersNumber: Number of casters to create on map init:
        //
        constant integer cs_InitialCastersNumber    = 12
        
        //old ones (udg_ preffix forced for compat ( )
        unit          udg_currentcaster = null
        real array    udg_castervars
        group         udg_casters       = null
        integer       udg_currentabi    = 0
        unit          udg_currenthurter = null
        real          udg_delayhack     = 0.
        location      udg_sourcehack    = null

        //--
        integer array cs_missiles
        integer       cs_missilecount   = 0
        timer         cs_movementtimer        = CreateTimer()
        boolean       cs_movementtimer_active = false

        constant real cs_RectLimitOffSet = 50.0
        real cs_game_maxx
        real cs_game_maxy
        real cs_game_miny
        real cs_game_minx
        timer cs_sourcehacktimer = CreateTimer()
        timer cs_delayhacktimer  = CreateTimer()
       attacktype cs_dopt_Atype          = null
       damagetype cs_dopt_Dtype          = null
       unittype   cs_dopt_ExceptionUtype = null
       real       cs_dopt_ExceptionFct   = 1.0

       unittype   cs_dopt_OnlyUtype      = null
       unittype   cs_dopt_IgnoreUtype    = null



       integer    cs_dopt_EnemyAlly      = 0 //[ 0 = onlyenemies, 1= forceall, 2=onlyallies]
       integer    cs_dopt_dfab1    = 'null'
       real       cs_dopt_dfab1_fc = 1.0
       integer    cs_dopt_dfab2    = 'null'
       real       cs_dopt_dfab2_fc = 1.
       integer    cs_dopt_dfab3    = 'null'
       real       cs_dopt_dfab3_fc = 1.

       real       cs_dopt_Ally_fc  = 1.
        unit cs_dmg_caster=null
        constant integer cs_TYPE_COLLISIONMISSILE=2
        constant integer cs_TYPE_PROJECTILE=1
        boolean CasterSystem___eventhandlers_passives=false
        trigger CasterSystem___events_probablytemp_learntrig=null
        triggeraction CasterSystem___events_probablytemp_learntriga=null
        unit CasterSystem___acquiringunit
        integer CasterSystem___acquiredabil
        group CasterSystem___CSItemStorage_gr=null
         item CasterSystem___returnitem
//endglobals from CasterSystem
//globals from CSDamagers:
        constant real CSDamagers__EPSILON=0.000001
        group    CSDamagers__damagerflag
        group CSDamagers__enumgroup
        group CSDamagers__loggroup
        boolexpr CSDamagers__procfilter
        real     CSDamagers__radius
        real     CSDamagers__centerx
        real     CSDamagers__centery
        unit array CSDamagers__inrange
        integer    CSDamagers__an

//endglobals from CSDamagers
    //-----------------------------------------------------------------------
    // Variables
    //

    // User-defined
    gamecache               rdg_spelltemplates         = null
    real                    rdg_TempReal               = 0
    integer array           rdg_WallVars
    integer                 rdg_InsertUnitTypeHere     = 0
    integer                 rdg_InsertItemTypeHere     = 0
    dialog                  rdg_RaceChoice             = null
    button array            rdg_RaceChoiceButton
    integer                 rdg_numberofdoneplayers    = 0
    timerdialog             rdg_BlueMoon               = null
    timer                   rdg_BlueMoonT              = null
    player                  rdg_MoonSummoner           = null
    unit                    rdg_Obelisk                = null
	boolean	                rdg_isCheats               = false
	boolean	                rdg_oldies               = false
	trigger                 rdg_enableCheats           = null
    timerdialog             rdg_AI               = null
    timer                   rdg_AITimer              = CreateTimer()

    hashtable rj_soundTable = InitHashtable()
	
    // Generated
    trigger                 rj_trg_FoodGonz            = null
    trigger                 rj_trg_Learn_Soul_Steal    = null
    trigger                 rj_trg_Invincibility_Initialize = null
    trigger                 rj_trg_Untitled_Trigger_016 = null
    trigger                 rj_trg_Invincibility_Initialize_Copy = null
    trigger                 rj_trg_Game_Initialization = null
    trigger                 rj_trg_Melee_Initialization_B = null
    trigger                 rj_trg_Untitled_Trigger_002 = null
    trigger                 rj_trg_Untitled_Trigger_004 = null
    trigger                 rj_trg_Untitled_Trigger_005 = null
    trigger                 rj_trg_Untitled_Trigger_006 = null
    trigger                 rj_trg_Untitled_Trigger_007 = null
    trigger                 rj_trg_Untitled_Trigger_008 = null
    trigger                 rj_trg_Turtle_Grow         = null
    trigger                 rj_trg_FL_Orb_Knockback    = null
    trigger                 rj_trg_Untitled_Trigger_020 = null
    trigger                 rj_trg_Tidal_Pool_Attack   = null
    trigger                 rj_trg_Gold_Mine_Fix       = null
    trigger                 rj_trg_Corruption          = null
    trigger                 rj_trg_Blood_Frenzy        = null
    trigger                 rj_trg_Untitled_Trigger_001 = null
    trigger                 rj_trg_Morph_Fix           = null
    trigger                 rj_trg_Aid_of_Demonic_Helpers = null
    trigger                 rj_trg_Demonic_Helper_Movement = null
    trigger                 rj_trg_Demonic_Helper_Attack = null
    trigger                 rj_trg_Demonic_Helper_Death = null
    trigger                 rj_trg_Blizzard            = null
    trigger                 rj_trg_ForceWall           = null
    trigger                 rj_trg_Forcewall_Death     = null
    trigger                 rj_trg_Forcewall_Unsummon  = null
    trigger                 rj_trg_ForceWall_Fix_Bug   = null
    trigger                 rj_trg_Summon_Wall         = null
    trigger                 rj_trg_ForceWall_Copy_Copy = null
    trigger                 rj_trg_Eat                 = null
    trigger                 rj_trg_Firey_Attack        = null
    trigger                 rj_trg_Firey_Attack_Copy_2 = null
    trigger                 rj_trg_Firey_Attack_Copy   = null
    trigger                 rj_trg_Invincibility_Cast  = null
    trigger                 rj_trg_Invulnerablize      = null
    trigger                 rj_trg_Invulnerablize_Turn_Off = null
    trigger                 rj_trg_Steal_Trees         = null
    trigger                 rj_trg_Snitch              = null
    trigger                 rj_trg_Splitting_Strike    = null
    trigger                 rj_trg_Narcolepsy_Cast     = null
    trigger                 rj_trg_Narcolepsy_Timer    = null
    trigger                 rj_trg_Explosion           = null
    trigger                 rj_trg_Morph_Fix_Copy      = null
    trigger                 rj_trg_Demonic_Helper_Movement_Copy = null
    trigger                 rj_trg_Demonic_Helper_Movement_Copy_Copy = null
    trigger                 rj_trg_Demonic_Helper_Death_Copy = null
    trigger                 rj_trg_ForceWall_Generator = null
    trigger                 rj_trg_Untitled_Trigger_003 = null
    trigger                 rj_trg_ForceWall_Copy      = null
    trigger                 rj_trg_Corpse              = null
    trigger                 rj_trg_Caster_Setup        = null
    trigger                 rj_trg_Casting_Functions   = null
    trigger                 rj_trg_Damage_and_Projectiles = null
    trigger                 rj_trg_Collision_Missiles  = null
    trigger                 rj_trg_Damagers_and_DamagerGroups = null
    trigger                 rj_trg_Damage_and_Target_Options = null
    trigger                 rj_trg_CSCache_Module      = null
    trigger                 rj_trg_Spell_Events_Module = null
    trigger                 rj_trg_Spell_Helpers       = null
    trigger                 rj_trg_Safe_item_hiding    = null
    trigger                 rj_trg_Vexorian_Spell_Factory = null
    trigger                 rj_trg_Readme_for_Spell_Users = null
    trigger                 rj_trg_Readme_for_Spell_Makers = null
    trigger                 rj_trg_Extra_notes         = null
    trigger                 rj_trg_Version_History     = null
    trigger                 rj_trg_Nova_Spells         = null
    trigger                 rj_trg_TimedBarrel_Spells  = null
    trigger                 rj_trg_Charge_Template     = null
    trigger                 rj_trg_FireSpawner_Template = null
    trigger                 rj_trg_Shield_Template     = null
    trigger                 rj_trg_Aura_Template       = null
    trigger                 rj_trg_Spiral_Template     = null
    trigger                 rj_trg_Beam_Template       = null
    trigger                 rj_trg_Cone_Template       = null
    trigger                 rj_trg_SpellCast_Template  = null
    trigger                 rj_trg_Wave_Template       = null
    trigger                 rj_trg_Knockback_Wave_Template = null
    trigger                 rj_trg_Toggleable_Template = null
    trigger                 rj_trg_Slash_Template      = null
    trigger                 rj_trg_Jump_Template       = null
    trigger                 rj_trg_ChannelAura_Template = null
    trigger                 rj_trg_Chain_Template      = null
    trigger                 rj_trg_Nova_Spells_Copy    = null
    trigger                 rj_trg_TimedBarrel_Spells_Copy = null
    trigger                 rj_trg_Charge_Template_Copy = null
    trigger                 rj_trg_FireSpawner_Template_Copy = null
    trigger                 rj_trg_Shield_Template_Copy = null
    trigger                 rj_trg_Aura_Template_Copy  = null
    trigger                 rj_trg_Spiral_Template_Copy = null
    trigger                 rj_trg_Beam_Template_Copy  = null
    trigger                 rj_trg_Cone_Template_Copy  = null
    trigger                 rj_trg_SpellCast_Template_Copy = null
    trigger                 rj_trg_Wave_Template_Copy  = null
    trigger                 rj_trg_Toggleable_Template_Copy = null
    trigger                 rj_trg_Slash_Template_Copy = null
    trigger                 rj_trg_Jump_Template_Copy  = null
    trigger                 rj_trg_ChannelAura_Template_Copy = null
    trigger                 rj_trg_Chain_Template_Copy = null
    trigger                 rj_trg_Untitled_Trigger_019 = null
    trigger                 rj_trg_Untitled_Trigger_018 = null
    trigger                 rj_trg_Get                 = null
    trigger                 rj_trg_CasterDeath         = null
    trigger                 rj_trg_BuildingDeath       = null
    trigger                 rj_trg_TimerExpire         = null
    trigger                 rj_trg_Untitled_Trigger_017 = null
    trigger                 rj_trg_Untitled_Trigger_015 = null
    trigger                 rj_trg_DNCAlter            = null
    trigger                 rj_trg_Untitled_Trigger_013 = null
    trigger                 rj_trg_Untitled_Trigger_012 = null
    trigger                 rj_trg_Untitled_Trigger_014 = null
    trigger                 rj_trg_BuildingDeath_Copy_2 = null
    trigger                 rj_trg_Untitled_Trigger_010 = null
    trigger                 rj_trg_BuildingDeath_Copy  = null
    trigger                 rj_trg_Untitled_Trigger_011 = null
    trigger                 rj_trg_Untitled_Trigger_010_Copy = null
    trigger                 rj_trg_Get_Copy            = null
    trigger                 rj_trg_Get_Copy_Copy       = null
    trigger                 rj_trg_Untitled_Trigger_009 = null
    trigger                 rj_trg_Coral_of_the_Gentle_Rain = null
    trigger                 rj_trg_fast = null
    trigger                 rj_trg_fastunit = null
    trigger                 rj_trg_fastbuild = null
    trigger                 rj_trg_fasttech = null
    trigger                 rj_trg_vision = null
    trigger                 rj_trg_reset = null
    trigger                 rj_trg_money = null
	
	real array				rj_foodMax

    gamecache               rdg_cscache                = null
    hashtable               rdg_cstable                = null
    hashtable               rdg_cstablex               = null
    integer array           rdg_csarray1
    integer array           rdg_csarray3
    integer array           rdg_csarray2
    location array          rdg_csfreeindexes
    
    gamecache                   udg_spelltemplates = null
    

    unit                    rdg_currentcaster          = null
    real array              rdg_castervars
    group                   rdg_casters                = null
    integer                 rdg_currentabi             = 0
    unit                    rdg_currenthurter          = null
    real                    rdg_delayhack              = 0
    location                rdg_sourcehack             = null


trigger l__library_init

//JASSHelper struct globals:
constant integer si__CasterSystem___csrecy=1
integer si__CasterSystem___csrecy_F=0
integer si__CasterSystem___csrecy_I=0
integer array si__CasterSystem___csrecy_V
unit array s__CasterSystem___csrecy_caster
integer array s__CasterSystem___csrecy_abil
constant integer si__CasterSystem___cssabi=2
integer si__CasterSystem___cssabi_F=0
integer si__CasterSystem___cssabi_I=0
integer array si__CasterSystem___cssabi_V
effect array s__CasterSystem___cssabi_fx
unit array s__CasterSystem___cssabi_caster
integer array s__CasterSystem___cssabi_abil
constant integer si__CasterSystem___dostruct=3
integer si__CasterSystem___dostruct_F=0
integer si__CasterSystem___dostruct_I=0
integer array si__CasterSystem___dostruct_V
integer array s__CasterSystem___dostruct_value
attacktype array s__CasterSystem___dostruct_attt
damagetype array s__CasterSystem___dostruct_dmgt
unittype array s__CasterSystem___dostruct_excp
real array s__CasterSystem___dostruct_excf
unittype array s__CasterSystem___dostruct_only
integer array s__CasterSystem___dostruct_allied
integer array s__CasterSystem___dostruct_dfab1
real array s__CasterSystem___dostruct_dfab1_fc
integer array s__CasterSystem___dostruct_dfab2
real array s__CasterSystem___dostruct_dfab2_fc
integer array s__CasterSystem___dostruct_dfab3
real array s__CasterSystem___dostruct_dfab3_fc
unittype array s__CasterSystem___dostruct_ign
real array s__CasterSystem___dostruct_ally_fc
constant integer si__csmissile=4
integer si__csmissile_F=0
integer si__csmissile_I=0
integer array si__csmissile_V
integer array si__csmissile_type
trigger array st__csmissile_onDestroy
integer array s__csmissile_mtype
unit array s__csmissile_m
constant integer si__cscollisionmissile=5
integer array s__cscollisionmissile_state
trigger array s__cscollisionmissile_t
triggeraction array s__cscollisionmissile_ac
real array s__cscollisionmissile_collision
real array s__cscollisionmissile_speed
real array s__cscollisionmissile_aspeed
real array s__cscollisionmissile_f
real array s__cscollisionmissile_maxd
integer array s__cscollisionmissile_ttype
constant integer s__cscollisionmissile_ttype_widget=2
constant integer s__cscollisionmissile_ttype_point=1
constant integer s__cscollisionmissile_ttype_none=0
real array s__cscollisionmissile_tx
real array s__cscollisionmissile_ty
widget array s__cscollisionmissile_tw
boolean array s__cscollisionmissile_pfx
real array s__cscollisionmissile_pfx_current
real array s__cscollisionmissile_pfx_dur
string array s__cscollisionmissile_pfx_path
boolean array s__cscollisionmissile_new
effect array s__cscollisionmissile_fx
integer array s__cscollisionmissile_tag
constant integer si__csprojectile=6
boolean array s__csprojectile_tounit
unit array s__csprojectile_target
real array s__csprojectile_z2
real array s__csprojectile_x2
real array s__csprojectile_y2
real array s__csprojectile_speed
real array s__csprojectile_acel
boolean array s__csprojectile_done
effect array s__csprojectile_fx
real array s__csprojectile_z2o
integer array s__csprojectile_N
constant integer si__CasterSystem___itemholder=7
integer si__CasterSystem___itemholder_F=0
integer si__CasterSystem___itemholder_I=0
integer array si__CasterSystem___itemholder_V
unit array s__CasterSystem___itemholder_s
item array s__CasterSystem___itemholder_it
constant integer si__CSDamagers__data=8
integer si__CSDamagers__data_F=0
integer si__CSDamagers__data_I=0
integer array si__CSDamagers__data_V
boolean array s__CSDamagers__data_expired
boolean array s__CSDamagers__data_end
unit array s__CSDamagers__data_hurter
real array s__CSDamagers__data_damage
real array s__CSDamagers__data_area
integer array s__CSDamagers__data_DamageOptions
boolean array s__CSDamagers__data_trees
boolean array s__CSDamagers__data_selfdestruct
integer array s__CSDamagers__data_damagers
timer array s__CSDamagers__data_thetimer
timer array s__CSDamagers__data_lifespan
constant integer si__CSDamagers__damagerdata=9
integer si__CSDamagers__damagerdata_F=0
integer si__CSDamagers__damagerdata_I=0
integer array si__CSDamagers__damagerdata_V
unit array s__CSDamagers__damagerdata_u
effect array s__CSDamagers__damagerdata_fx
timer array s__CSDamagers__damagerdata_lifespan
integer array s__CSDamagers__damagerdata_abil
integer array s__CSDamagers__damagerdata_parent
integer array s__CSDamagers__damagerdata_prev
integer array s__CSDamagers__damagerdata_next
integer array s__GroupUtils___Status
integer array s__2GroupUtils___Status
integer array s__3GroupUtils___Status
integer array s__4GroupUtils___Status
integer array s__5GroupUtils___Status
integer array s__6GroupUtils___Status
integer array s__7GroupUtils___Status
integer array s__8GroupUtils___Status
integer array s__9GroupUtils___Status
integer array s__10GroupUtils___Status
integer array s__11GroupUtils___Status
integer array s__12GroupUtils___Status
integer array s__13GroupUtils___Status
integer array s__14GroupUtils___Status
integer array s__15GroupUtils___Status
integer array s__16GroupUtils___Status
integer array s__17GroupUtils___Status
integer array s__18GroupUtils___Status
integer array s__19GroupUtils___Status
integer array s__20GroupUtils___Status
integer array s__21GroupUtils___Status
integer array s__22GroupUtils___Status
integer array s__23GroupUtils___Status
integer array s__24GroupUtils___Status
integer array s__25GroupUtils___Status
integer array s__26GroupUtils___Status
integer array s__27GroupUtils___Status
integer array s__28GroupUtils___Status
integer array s__29GroupUtils___Status
integer array s__30GroupUtils___Status
integer array s__31GroupUtils___Status
integer array s__32GroupUtils___Status
integer array s__33GroupUtils___Status
integer array s__34GroupUtils___Status
integer array s__35GroupUtils___Status
integer array s__36GroupUtils___Status
integer array s__37GroupUtils___Status
integer array s__38GroupUtils___Status
integer array s__39GroupUtils___Status
integer array s__40GroupUtils___Status
integer array s__41GroupUtils___Status
integer array s__42GroupUtils___Status
integer array s__43GroupUtils___Status
integer array s__44GroupUtils___Status
integer array s__45GroupUtils___Status
integer array s__46GroupUtils___Status
integer array s__47GroupUtils___Status
integer array s__48GroupUtils___Status
integer array s__49GroupUtils___Status
integer array s__50GroupUtils___Status
trigger st__CSDamagers__damagerdata_onDestroy
trigger array st___prototype10
timer f__arg_timer1
integer f__arg_this

    //-----------------------------------------------------------------------
    // Constants
    //

    // Misc constants
    constant real      bj_PI                            = 3.14159
    constant real      bj_E                             = 2.71828
    constant real      bj_CELLWIDTH                     = 128.0
    constant real      bj_CLIFFHEIGHT                   = 128.0
    constant real      bj_UNIT_FACING                   = 270.0
    constant real      bj_RADTODEG                      = 180.0/bj_PI
    constant real      bj_DEGTORAD                      = bj_PI/180.0
    constant real      bj_TEXT_DELAY_QUEST              = 20.00
    constant real      bj_TEXT_DELAY_QUESTUPDATE        = 20.00
    constant real      bj_TEXT_DELAY_QUESTDONE          = 20.00
    constant real      bj_TEXT_DELAY_QUESTFAILED        = 20.00
    constant real      bj_TEXT_DELAY_QUESTREQUIREMENT   = 20.00
    constant real      bj_TEXT_DELAY_MISSIONFAILED      = 20.00
    constant real      bj_TEXT_DELAY_ALWAYSHINT         = 12.00
    constant real      bj_TEXT_DELAY_HINT               = 12.00
    constant real      bj_TEXT_DELAY_SECRET             = 10.00
    constant real      bj_TEXT_DELAY_UNITACQUIRED       = 15.00
    constant real      bj_TEXT_DELAY_UNITAVAILABLE      = 10.00
    constant real      bj_TEXT_DELAY_ITEMACQUIRED       = 10.00
    constant real      bj_TEXT_DELAY_WARNING            = 12.00
    constant real      bj_QUEUE_DELAY_QUEST             =  5.00
    constant real      bj_QUEUE_DELAY_HINT              =  5.00
    constant real      bj_QUEUE_DELAY_SECRET            =  3.00
    constant real      bj_HANDICAP_EASY                 = 60.00
    constant real      bj_GAME_STARTED_THRESHOLD        =  0.01
    constant real      bj_WAIT_FOR_COND_MIN_INTERVAL    =  0.10
    constant real      bj_POLLED_WAIT_INTERVAL          =  0.10
    constant real      bj_POLLED_WAIT_SKIP_THRESHOLD    =  2.00

    // Game constants
    constant integer   bj_MAX_INVENTORY                 =   6
    constant integer   bj_MAX_PLAYERS                   =  12
    constant integer   bj_PLAYER_NEUTRAL_VICTIM         =  13
    constant integer   bj_PLAYER_NEUTRAL_EXTRA          =  14
    constant integer   bj_MAX_PLAYER_SLOTS              =  16
    constant integer   bj_MAX_SKELETONS                 =  25
    constant integer   bj_MAX_STOCK_ITEM_SLOTS          =  11
    constant integer   bj_MAX_STOCK_UNIT_SLOTS          =  11
    constant integer   bj_MAX_ITEM_LEVEL                =  10

    // Ideally these would be looked up from Units/MiscData.txt,
    // but there is currently no script functionality exposed to do that
    constant real      bj_TOD_DAWN                      = 6.00
    constant real      bj_TOD_DUSK                      = 18.00

    // Melee game settings:
    //   - Starting Time of Day (TOD)
    //   - Starting Gold
    //   - Starting Lumber
    //   - Starting Hero Tokens (free heroes)
    //   - Max heroes allowed per player
    //   - Max heroes allowed per hero type
    //   - Distance from start loc to search for nearby mines
    //
    constant real      bj_MELEE_STARTING_TOD            = 8.00
    constant integer   bj_MELEE_STARTING_GOLD_V0        = 750
    constant integer   bj_MELEE_STARTING_GOLD_V1        = 500
    constant integer   bj_MELEE_STARTING_LUMBER_V0      = 200
    constant integer   bj_MELEE_STARTING_LUMBER_V1      = 150
    constant integer   bj_MELEE_STARTING_HERO_TOKENS    = 1
    constant integer   bj_MELEE_HERO_LIMIT              = 3
    constant integer   bj_MELEE_HERO_TYPE_LIMIT         = 1
    constant real      bj_MELEE_MINE_SEARCH_RADIUS      = 2000
    constant real      bj_MELEE_CLEAR_UNITS_RADIUS      = 1500
    constant real      bj_MELEE_CRIPPLE_TIMEOUT         = 120.00
    constant real      bj_MELEE_CRIPPLE_MSG_DURATION    = 20.00
    constant integer   bj_MELEE_MAX_TWINKED_HEROES_V0   = 3
    constant integer   bj_MELEE_MAX_TWINKED_HEROES_V1   = 1

    // Delay between a creep's death and the time it may drop an item.
    constant real      bj_CREEP_ITEM_DELAY              = 0.50

    // Timing settings for Marketplace inventories.
    constant real      bj_STOCK_RESTOCK_INITIAL_DELAY   = 120
    constant real      bj_STOCK_RESTOCK_INTERVAL        = 30
    constant integer   bj_STOCK_MAX_ITERATIONS          = 20

    // Max events registered by a single "dest dies in region" event.
    constant integer   bj_MAX_DEST_IN_REGION_EVENTS     = 64

    // Camera settings
    constant integer   bj_CAMERA_MIN_FARZ               = 100
    constant integer   bj_CAMERA_DEFAULT_DISTANCE       = 1650
    constant integer   bj_CAMERA_DEFAULT_FARZ           = 5000
    constant integer   bj_CAMERA_DEFAULT_AOA            = 304
    constant integer   bj_CAMERA_DEFAULT_FOV            = 70
    constant integer   bj_CAMERA_DEFAULT_ROLL           = 0
    constant integer   bj_CAMERA_DEFAULT_ROTATION       = 90

    // Rescue
    constant real      bj_RESCUE_PING_TIME              = 2.00

    // Transmission behavior settings
    constant real      bj_NOTHING_SOUND_DURATION        = 5.00
    constant real      bj_TRANSMISSION_PING_TIME        = 1.00
    constant integer   bj_TRANSMISSION_IND_RED          = 255
    constant integer   bj_TRANSMISSION_IND_BLUE         = 255
    constant integer   bj_TRANSMISSION_IND_GREEN        = 255
    constant integer   bj_TRANSMISSION_IND_ALPHA        = 255
    constant real      bj_TRANSMISSION_PORT_HANGTIME    = 1.50

    // Cinematic mode settings
    constant real      bj_CINEMODE_INTERFACEFADE        = 0.50
    constant gamespeed bj_CINEMODE_GAMESPEED            = MAP_SPEED_NORMAL

    // Cinematic mode volume levels
    constant real      bj_CINEMODE_VOLUME_UNITMOVEMENT  = 0.40
    constant real      bj_CINEMODE_VOLUME_UNITSOUNDS    = 0.00
    constant real      bj_CINEMODE_VOLUME_COMBAT        = 0.40
    constant real      bj_CINEMODE_VOLUME_SPELLS        = 0.40
    constant real      bj_CINEMODE_VOLUME_UI            = 0.00
    constant real      bj_CINEMODE_VOLUME_MUSIC         = 0.55
    constant real      bj_CINEMODE_VOLUME_AMBIENTSOUNDS = 1.00
    constant real      bj_CINEMODE_VOLUME_FIRE          = 0.60

    // Speech mode volume levels
    constant real      bj_SPEECH_VOLUME_UNITMOVEMENT    = 0.25
    constant real      bj_SPEECH_VOLUME_UNITSOUNDS      = 0.00
    constant real      bj_SPEECH_VOLUME_COMBAT          = 0.25
    constant real      bj_SPEECH_VOLUME_SPELLS          = 0.25
    constant real      bj_SPEECH_VOLUME_UI              = 0.00
    constant real      bj_SPEECH_VOLUME_MUSIC           = 0.55
    constant real      bj_SPEECH_VOLUME_AMBIENTSOUNDS   = 1.00
    constant real      bj_SPEECH_VOLUME_FIRE            = 0.60

    // Smart pan settings
    constant real      bj_SMARTPAN_TRESHOLD_PAN         = 500
    constant real      bj_SMARTPAN_TRESHOLD_SNAP        = 3500

    // QueuedTriggerExecute settings
    constant integer   bj_MAX_QUEUED_TRIGGERS           = 100
    constant real      bj_QUEUED_TRIGGER_TIMEOUT        = 180.00

    // Campaign indexing constants
    constant integer   bj_CAMPAIGN_INDEX_T        = 0
    constant integer   bj_CAMPAIGN_INDEX_H        = 1
    constant integer   bj_CAMPAIGN_INDEX_U        = 2
    constant integer   bj_CAMPAIGN_INDEX_O        = 3
    constant integer   bj_CAMPAIGN_INDEX_N        = 4
    constant integer   bj_CAMPAIGN_INDEX_XN       = 5
    constant integer   bj_CAMPAIGN_INDEX_XH       = 6
    constant integer   bj_CAMPAIGN_INDEX_XU       = 7
    constant integer   bj_CAMPAIGN_INDEX_XO       = 8

    // Campaign offset constants (for mission indexing)
    constant integer   bj_CAMPAIGN_OFFSET_T       = 0
    constant integer   bj_CAMPAIGN_OFFSET_H       = 1
    constant integer   bj_CAMPAIGN_OFFSET_U       = 2
    constant integer   bj_CAMPAIGN_OFFSET_O       = 3
    constant integer   bj_CAMPAIGN_OFFSET_N       = 4
    constant integer   bj_CAMPAIGN_OFFSET_XN      = 0
    constant integer   bj_CAMPAIGN_OFFSET_XH      = 1
    constant integer   bj_CAMPAIGN_OFFSET_XU      = 2
    constant integer   bj_CAMPAIGN_OFFSET_XO      = 3

    // Mission indexing constants
    // Tutorial
    constant integer   bj_MISSION_INDEX_T00       = bj_CAMPAIGN_OFFSET_T * 1000 + 0
    constant integer   bj_MISSION_INDEX_T01       = bj_CAMPAIGN_OFFSET_T * 1000 + 1
    // Human
    constant integer   bj_MISSION_INDEX_H00       = bj_CAMPAIGN_OFFSET_H * 1000 + 0
    constant integer   bj_MISSION_INDEX_H01       = bj_CAMPAIGN_OFFSET_H * 1000 + 1
    constant integer   bj_MISSION_INDEX_H02       = bj_CAMPAIGN_OFFSET_H * 1000 + 2
    constant integer   bj_MISSION_INDEX_H03       = bj_CAMPAIGN_OFFSET_H * 1000 + 3
    constant integer   bj_MISSION_INDEX_H04       = bj_CAMPAIGN_OFFSET_H * 1000 + 4
    constant integer   bj_MISSION_INDEX_H05       = bj_CAMPAIGN_OFFSET_H * 1000 + 5
    constant integer   bj_MISSION_INDEX_H06       = bj_CAMPAIGN_OFFSET_H * 1000 + 6
    constant integer   bj_MISSION_INDEX_H07       = bj_CAMPAIGN_OFFSET_H * 1000 + 7
    constant integer   bj_MISSION_INDEX_H08       = bj_CAMPAIGN_OFFSET_H * 1000 + 8
    constant integer   bj_MISSION_INDEX_H09       = bj_CAMPAIGN_OFFSET_H * 1000 + 9
    constant integer   bj_MISSION_INDEX_H10       = bj_CAMPAIGN_OFFSET_H * 1000 + 10
    constant integer   bj_MISSION_INDEX_H11       = bj_CAMPAIGN_OFFSET_H * 1000 + 11
    // Undead
    constant integer   bj_MISSION_INDEX_U00       = bj_CAMPAIGN_OFFSET_U * 1000 + 0
    constant integer   bj_MISSION_INDEX_U01       = bj_CAMPAIGN_OFFSET_U * 1000 + 1
    constant integer   bj_MISSION_INDEX_U02       = bj_CAMPAIGN_OFFSET_U * 1000 + 2
    constant integer   bj_MISSION_INDEX_U03       = bj_CAMPAIGN_OFFSET_U * 1000 + 3
    constant integer   bj_MISSION_INDEX_U05       = bj_CAMPAIGN_OFFSET_U * 1000 + 4
    constant integer   bj_MISSION_INDEX_U07       = bj_CAMPAIGN_OFFSET_U * 1000 + 5
    constant integer   bj_MISSION_INDEX_U08       = bj_CAMPAIGN_OFFSET_U * 1000 + 6
    constant integer   bj_MISSION_INDEX_U09       = bj_CAMPAIGN_OFFSET_U * 1000 + 7
    constant integer   bj_MISSION_INDEX_U10       = bj_CAMPAIGN_OFFSET_U * 1000 + 8
    constant integer   bj_MISSION_INDEX_U11       = bj_CAMPAIGN_OFFSET_U * 1000 + 9
    // Orc
    constant integer   bj_MISSION_INDEX_O00       = bj_CAMPAIGN_OFFSET_O * 1000 + 0
    constant integer   bj_MISSION_INDEX_O01       = bj_CAMPAIGN_OFFSET_O * 1000 + 1
    constant integer   bj_MISSION_INDEX_O02       = bj_CAMPAIGN_OFFSET_O * 1000 + 2
    constant integer   bj_MISSION_INDEX_O03       = bj_CAMPAIGN_OFFSET_O * 1000 + 3
    constant integer   bj_MISSION_INDEX_O04       = bj_CAMPAIGN_OFFSET_O * 1000 + 4
    constant integer   bj_MISSION_INDEX_O05       = bj_CAMPAIGN_OFFSET_O * 1000 + 5
    constant integer   bj_MISSION_INDEX_O06       = bj_CAMPAIGN_OFFSET_O * 1000 + 6
    constant integer   bj_MISSION_INDEX_O07       = bj_CAMPAIGN_OFFSET_O * 1000 + 7
    constant integer   bj_MISSION_INDEX_O08       = bj_CAMPAIGN_OFFSET_O * 1000 + 8
    constant integer   bj_MISSION_INDEX_O09       = bj_CAMPAIGN_OFFSET_O * 1000 + 9
    constant integer   bj_MISSION_INDEX_O10       = bj_CAMPAIGN_OFFSET_O * 1000 + 10
    // Night Elf
    constant integer   bj_MISSION_INDEX_N00       = bj_CAMPAIGN_OFFSET_N * 1000 + 0
    constant integer   bj_MISSION_INDEX_N01       = bj_CAMPAIGN_OFFSET_N * 1000 + 1
    constant integer   bj_MISSION_INDEX_N02       = bj_CAMPAIGN_OFFSET_N * 1000 + 2
    constant integer   bj_MISSION_INDEX_N03       = bj_CAMPAIGN_OFFSET_N * 1000 + 3
    constant integer   bj_MISSION_INDEX_N04       = bj_CAMPAIGN_OFFSET_N * 1000 + 4
    constant integer   bj_MISSION_INDEX_N05       = bj_CAMPAIGN_OFFSET_N * 1000 + 5
    constant integer   bj_MISSION_INDEX_N06       = bj_CAMPAIGN_OFFSET_N * 1000 + 6
    constant integer   bj_MISSION_INDEX_N07       = bj_CAMPAIGN_OFFSET_N * 1000 + 7
    constant integer   bj_MISSION_INDEX_N08       = bj_CAMPAIGN_OFFSET_N * 1000 + 8
    constant integer   bj_MISSION_INDEX_N09       = bj_CAMPAIGN_OFFSET_N * 1000 + 9
    // Expansion Night Elf
    constant integer   bj_MISSION_INDEX_XN00       = bj_CAMPAIGN_OFFSET_XN * 1000 + 0
    constant integer   bj_MISSION_INDEX_XN01       = bj_CAMPAIGN_OFFSET_XN * 1000 + 1
    constant integer   bj_MISSION_INDEX_XN02       = bj_CAMPAIGN_OFFSET_XN * 1000 + 2
    constant integer   bj_MISSION_INDEX_XN03       = bj_CAMPAIGN_OFFSET_XN * 1000 + 3
    constant integer   bj_MISSION_INDEX_XN04       = bj_CAMPAIGN_OFFSET_XN * 1000 + 4
    constant integer   bj_MISSION_INDEX_XN05       = bj_CAMPAIGN_OFFSET_XN * 1000 + 5
    constant integer   bj_MISSION_INDEX_XN06       = bj_CAMPAIGN_OFFSET_XN * 1000 + 6
    constant integer   bj_MISSION_INDEX_XN07       = bj_CAMPAIGN_OFFSET_XN * 1000 + 7
    constant integer   bj_MISSION_INDEX_XN08       = bj_CAMPAIGN_OFFSET_XN * 1000 + 8
    constant integer   bj_MISSION_INDEX_XN09       = bj_CAMPAIGN_OFFSET_XN * 1000 + 9
    constant integer   bj_MISSION_INDEX_XN10       = bj_CAMPAIGN_OFFSET_XN * 1000 + 10
    // Expansion Human
    constant integer   bj_MISSION_INDEX_XH00       = bj_CAMPAIGN_OFFSET_XH * 1000 + 0
    constant integer   bj_MISSION_INDEX_XH01       = bj_CAMPAIGN_OFFSET_XH * 1000 + 1
    constant integer   bj_MISSION_INDEX_XH02       = bj_CAMPAIGN_OFFSET_XH * 1000 + 2
    constant integer   bj_MISSION_INDEX_XH03       = bj_CAMPAIGN_OFFSET_XH * 1000 + 3
    constant integer   bj_MISSION_INDEX_XH04       = bj_CAMPAIGN_OFFSET_XH * 1000 + 4
    constant integer   bj_MISSION_INDEX_XH05       = bj_CAMPAIGN_OFFSET_XH * 1000 + 5
    constant integer   bj_MISSION_INDEX_XH06       = bj_CAMPAIGN_OFFSET_XH * 1000 + 6
    constant integer   bj_MISSION_INDEX_XH07       = bj_CAMPAIGN_OFFSET_XH * 1000 + 7
    constant integer   bj_MISSION_INDEX_XH08       = bj_CAMPAIGN_OFFSET_XH * 1000 + 8
    constant integer   bj_MISSION_INDEX_XH09       = bj_CAMPAIGN_OFFSET_XH * 1000 + 9
    // Expansion Undead
    constant integer   bj_MISSION_INDEX_XU00       = bj_CAMPAIGN_OFFSET_XU * 1000 + 0
    constant integer   bj_MISSION_INDEX_XU01       = bj_CAMPAIGN_OFFSET_XU * 1000 + 1
    constant integer   bj_MISSION_INDEX_XU02       = bj_CAMPAIGN_OFFSET_XU * 1000 + 2
    constant integer   bj_MISSION_INDEX_XU03       = bj_CAMPAIGN_OFFSET_XU * 1000 + 3
    constant integer   bj_MISSION_INDEX_XU04       = bj_CAMPAIGN_OFFSET_XU * 1000 + 4
    constant integer   bj_MISSION_INDEX_XU05       = bj_CAMPAIGN_OFFSET_XU * 1000 + 5
    constant integer   bj_MISSION_INDEX_XU06       = bj_CAMPAIGN_OFFSET_XU * 1000 + 6
    constant integer   bj_MISSION_INDEX_XU07       = bj_CAMPAIGN_OFFSET_XU * 1000 + 7
    constant integer   bj_MISSION_INDEX_XU08       = bj_CAMPAIGN_OFFSET_XU * 1000 + 8
    constant integer   bj_MISSION_INDEX_XU09       = bj_CAMPAIGN_OFFSET_XU * 1000 + 9
    constant integer   bj_MISSION_INDEX_XU10       = bj_CAMPAIGN_OFFSET_XU * 1000 + 10
    constant integer   bj_MISSION_INDEX_XU11       = bj_CAMPAIGN_OFFSET_XU * 1000 + 11
    constant integer   bj_MISSION_INDEX_XU12       = bj_CAMPAIGN_OFFSET_XU * 1000 + 12
    constant integer   bj_MISSION_INDEX_XU13       = bj_CAMPAIGN_OFFSET_XU * 1000 + 13

    // Expansion Orc
    constant integer   bj_MISSION_INDEX_XO00       = bj_CAMPAIGN_OFFSET_XO * 1000 + 0

    // Cinematic indexing constants
    constant integer   bj_CINEMATICINDEX_TOP      = 0
    constant integer   bj_CINEMATICINDEX_HOP      = 1
    constant integer   bj_CINEMATICINDEX_HED      = 2
    constant integer   bj_CINEMATICINDEX_OOP      = 3
    constant integer   bj_CINEMATICINDEX_OED      = 4
    constant integer   bj_CINEMATICINDEX_UOP      = 5
    constant integer   bj_CINEMATICINDEX_UED      = 6
    constant integer   bj_CINEMATICINDEX_NOP      = 7
    constant integer   bj_CINEMATICINDEX_NED      = 8
    constant integer   bj_CINEMATICINDEX_XOP      = 9
    constant integer   bj_CINEMATICINDEX_XED      = 10

    // Alliance settings
    constant integer   bj_ALLIANCE_UNALLIED        = 0
    constant integer   bj_ALLIANCE_UNALLIED_VISION = 1
    constant integer   bj_ALLIANCE_ALLIED          = 2
    constant integer   bj_ALLIANCE_ALLIED_VISION   = 3
    constant integer   bj_ALLIANCE_ALLIED_UNITS    = 4
    constant integer   bj_ALLIANCE_ALLIED_ADVUNITS = 5
    constant integer   bj_ALLIANCE_NEUTRAL         = 6
    constant integer   bj_ALLIANCE_NEUTRAL_VISION  = 7

    // Keyboard Event Types
    constant integer   bj_KEYEVENTTYPE_DEPRESS     = 0
    constant integer   bj_KEYEVENTTYPE_RELEASE     = 1

    // Keyboard Event Keys
    constant integer   bj_KEYEVENTKEY_LEFT         = 0
    constant integer   bj_KEYEVENTKEY_RIGHT        = 1
    constant integer   bj_KEYEVENTKEY_DOWN         = 2
    constant integer   bj_KEYEVENTKEY_UP           = 3

    // Transmission timing methods
    constant integer   bj_TIMETYPE_ADD             = 0
    constant integer   bj_TIMETYPE_SET             = 1
    constant integer   bj_TIMETYPE_SUB             = 2

    // Camera bounds adjustment methods
    constant integer   bj_CAMERABOUNDS_ADJUST_ADD  = 0
    constant integer   bj_CAMERABOUNDS_ADJUST_SUB  = 1

    // Quest creation states
    constant integer   bj_QUESTTYPE_REQ_DISCOVERED   = 0
    constant integer   bj_QUESTTYPE_REQ_UNDISCOVERED = 1
    constant integer   bj_QUESTTYPE_OPT_DISCOVERED   = 2
    constant integer   bj_QUESTTYPE_OPT_UNDISCOVERED = 3

    // Quest message types
    constant integer   bj_QUESTMESSAGE_DISCOVERED    = 0
    constant integer   bj_QUESTMESSAGE_UPDATED       = 1
    constant integer   bj_QUESTMESSAGE_COMPLETED     = 2
    constant integer   bj_QUESTMESSAGE_FAILED        = 3
    constant integer   bj_QUESTMESSAGE_REQUIREMENT   = 4
    constant integer   bj_QUESTMESSAGE_MISSIONFAILED = 5
    constant integer   bj_QUESTMESSAGE_ALWAYSHINT    = 6
    constant integer   bj_QUESTMESSAGE_HINT          = 7
    constant integer   bj_QUESTMESSAGE_SECRET        = 8
    constant integer   bj_QUESTMESSAGE_UNITACQUIRED  = 9
    constant integer   bj_QUESTMESSAGE_UNITAVAILABLE = 10
    constant integer   bj_QUESTMESSAGE_ITEMACQUIRED  = 11
    constant integer   bj_QUESTMESSAGE_WARNING       = 12

    // Leaderboard sorting methods
    constant integer   bj_SORTTYPE_SORTBYVALUE     = 0
    constant integer   bj_SORTTYPE_SORTBYPLAYER    = 1
    constant integer   bj_SORTTYPE_SORTBYLABEL     = 2

    // Cinematic fade filter methods
    constant integer   bj_CINEFADETYPE_FADEIN      = 0
    constant integer   bj_CINEFADETYPE_FADEOUT     = 1
    constant integer   bj_CINEFADETYPE_FADEOUTIN   = 2

    // Buff removal methods
    constant integer   bj_REMOVEBUFFS_POSITIVE     = 0
    constant integer   bj_REMOVEBUFFS_NEGATIVE     = 1
    constant integer   bj_REMOVEBUFFS_ALL          = 2
    constant integer   bj_REMOVEBUFFS_NONTLIFE     = 3

    // Buff properties - polarity
    constant integer   bj_BUFF_POLARITY_POSITIVE   = 0
    constant integer   bj_BUFF_POLARITY_NEGATIVE   = 1
    constant integer   bj_BUFF_POLARITY_EITHER     = 2

    // Buff properties - resist type
    constant integer   bj_BUFF_RESIST_MAGIC        = 0
    constant integer   bj_BUFF_RESIST_PHYSICAL     = 1
    constant integer   bj_BUFF_RESIST_EITHER       = 2
    constant integer   bj_BUFF_RESIST_BOTH         = 3

    // Hero stats
    constant integer   bj_HEROSTAT_STR             = 0
    constant integer   bj_HEROSTAT_AGI             = 1
    constant integer   bj_HEROSTAT_INT             = 2

    // Hero skill point modification methods
    constant integer   bj_MODIFYMETHOD_ADD    = 0
    constant integer   bj_MODIFYMETHOD_SUB    = 1
    constant integer   bj_MODIFYMETHOD_SET    = 2

    // Unit state adjustment methods (for replaced units)
    constant integer   bj_UNIT_STATE_METHOD_ABSOLUTE = 0
    constant integer   bj_UNIT_STATE_METHOD_RELATIVE = 1
    constant integer   bj_UNIT_STATE_METHOD_DEFAULTS = 2
    constant integer   bj_UNIT_STATE_METHOD_MAXIMUM  = 3

    // Gate operations
    constant integer   bj_GATEOPERATION_CLOSE      = 0
    constant integer   bj_GATEOPERATION_OPEN       = 1
    constant integer   bj_GATEOPERATION_DESTROY    = 2

	// Game cache value types
	constant integer   bj_GAMECACHE_BOOLEAN                 = 0
	constant integer   bj_GAMECACHE_INTEGER                 = 1
	constant integer   bj_GAMECACHE_REAL                    = 2
	constant integer   bj_GAMECACHE_UNIT                    = 3
	constant integer   bj_GAMECACHE_STRING                  = 4
	
	// Hashtable value types
	constant integer   bj_HASHTABLE_BOOLEAN                 = 0
	constant integer   bj_HASHTABLE_INTEGER                 = 1
	constant integer   bj_HASHTABLE_REAL                    = 2
	constant integer   bj_HASHTABLE_STRING                  = 3
	constant integer   bj_HASHTABLE_HANDLE                  = 4

    // Item status types
    constant integer   bj_ITEM_STATUS_HIDDEN       = 0
    constant integer   bj_ITEM_STATUS_OWNED        = 1
    constant integer   bj_ITEM_STATUS_INVULNERABLE = 2
    constant integer   bj_ITEM_STATUS_POWERUP      = 3
    constant integer   bj_ITEM_STATUS_SELLABLE     = 4
    constant integer   bj_ITEM_STATUS_PAWNABLE     = 5

    // Itemcode status types
    constant integer   bj_ITEMCODE_STATUS_POWERUP  = 0
    constant integer   bj_ITEMCODE_STATUS_SELLABLE = 1
    constant integer   bj_ITEMCODE_STATUS_PAWNABLE = 2

    // Minimap ping styles
    constant integer   bj_MINIMAPPINGSTYLE_SIMPLE  = 0
    constant integer   bj_MINIMAPPINGSTYLE_FLASHY  = 1
    constant integer   bj_MINIMAPPINGSTYLE_ATTACK  = 2

    // Corpse creation settings
    constant real      bj_CORPSE_MAX_DEATH_TIME    = 8.00

    // Corpse creation styles
    constant integer   bj_CORPSETYPE_FLESH         = 0
    constant integer   bj_CORPSETYPE_BONE          = 1

    // Elevator pathing-blocker destructable code
    constant integer   bj_ELEVATOR_BLOCKER_CODE    = 'DTep'
    constant integer   bj_ELEVATOR_CODE01          = 'DTrf'
    constant integer   bj_ELEVATOR_CODE02          = 'DTrx'

    // Elevator wall codes
    constant integer   bj_ELEVATOR_WALL_TYPE_ALL        = 0
    constant integer   bj_ELEVATOR_WALL_TYPE_EAST       = 1
    constant integer   bj_ELEVATOR_WALL_TYPE_NORTH      = 2
    constant integer   bj_ELEVATOR_WALL_TYPE_SOUTH      = 3
    constant integer   bj_ELEVATOR_WALL_TYPE_WEST       = 4

    //-----------------------------------------------------------------------
    // Variables
    //

    // Force predefs
    force              bj_FORCE_ALL_PLAYERS        = null
    force array        bj_FORCE_PLAYER

    integer            bj_MELEE_MAX_TWINKED_HEROES = 0

    // Map area rects
    rect               bj_mapInitialPlayableArea   = null
    rect               bj_mapInitialCameraBounds   = null

    // Utility function vars
    integer            bj_forLoopAIndex            = 0
    integer            bj_forLoopBIndex            = 0
    integer            bj_forLoopAIndexEnd         = 0
    integer            bj_forLoopBIndexEnd         = 0

    boolean            bj_slotControlReady         = false
    boolean array      bj_slotControlUsed
    mapcontrol array   bj_slotControl

    // Game started detection vars
    timer              bj_gameStartedTimer         = null
    boolean            bj_gameStarted              = false
    timer              bj_volumeGroupsTimer        = CreateTimer()

    // Singleplayer check
    boolean            bj_isSinglePlayer           = false

    // Day/Night Cycle vars
    trigger            bj_dncSoundsDay             = null
    trigger            bj_dncSoundsNight           = null
    sound              bj_dayAmbientSound          = null
    sound              bj_nightAmbientSound        = null
    trigger            bj_dncSoundsDawn            = null
    trigger            bj_dncSoundsDusk            = null
    sound              bj_dawnSound                = null
    sound              bj_duskSound                = null
    boolean            bj_useDawnDuskSounds        = true
    boolean            bj_dncIsDaytime             = false

    // Triggered sounds
    //sound              bj_pingMinimapSound         = null
    sound              bj_rescueSound              = null
    sound              bj_questDiscoveredSound     = null
    sound              bj_questUpdatedSound        = null
    sound              bj_questCompletedSound      = null
    sound              bj_questFailedSound         = null
    sound              bj_questHintSound           = null
    sound              bj_questSecretSound         = null
    sound              bj_questItemAcquiredSound   = null
    sound              bj_questWarningSound        = null
    sound              bj_victoryDialogSound       = null
    sound              bj_defeatDialogSound        = null

    // Marketplace vars
    trigger            bj_stockItemPurchased       = null
    timer              bj_stockUpdateTimer         = null
    boolean array      bj_stockAllowedPermanent
    boolean array      bj_stockAllowedCharged
    boolean array      bj_stockAllowedArtifact
    integer            bj_stockPickedItemLevel     = 0
    itemtype           bj_stockPickedItemType

    // Melee vars
    trigger            bj_meleeVisibilityTrained   = null
    boolean            bj_meleeVisibilityIsDay     = true
    boolean            bj_meleeGrantHeroItems      = false
    location           bj_meleeNearestMineToLoc    = null
    unit               bj_meleeNearestMine         = null
    real               bj_meleeNearestMineDist     = 0.00
    boolean            bj_meleeGameOver            = false
    boolean array      bj_meleeDefeated
    boolean array      bj_meleeVictoried
    unit array         bj_ghoul
    timer array        bj_crippledTimer
    timerdialog array  bj_crippledTimerWindows
    boolean array      bj_playerIsCrippled
    boolean array      bj_playerIsExposed
    boolean            bj_finishSoonAllExposed     = false
    timerdialog        bj_finishSoonTimerDialog    = null
    integer array      bj_meleeTwinkedHeroes

    // Rescue behavior vars
    trigger            bj_rescueUnitBehavior       = null
    boolean            bj_rescueChangeColorUnit    = true
    boolean            bj_rescueChangeColorBldg    = true

    // Transmission vars
    timer              bj_cineSceneEndingTimer     = null
    sound              bj_cineSceneLastSound       = null
    trigger            bj_cineSceneBeingSkipped    = null

    // Cinematic mode vars
    gamespeed          bj_cineModePriorSpeed       = MAP_SPEED_NORMAL
    boolean            bj_cineModePriorFogSetting  = false
    boolean            bj_cineModePriorMaskSetting = false
    boolean            bj_cineModeAlreadyIn        = false
    boolean            bj_cineModePriorDawnDusk    = false
    integer            bj_cineModeSavedSeed        = 0

    // Cinematic fade vars
    timer              bj_cineFadeFinishTimer      = null
    timer              bj_cineFadeContinueTimer    = null
    real               bj_cineFadeContinueRed      = 0
    real               bj_cineFadeContinueGreen    = 0
    real               bj_cineFadeContinueBlue     = 0
    real               bj_cineFadeContinueTrans    = 0
    real               bj_cineFadeContinueDuration = 0
    string             bj_cineFadeContinueTex      = ""

    // QueuedTriggerExecute vars
    integer            bj_queuedExecTotal          = 0
    trigger array      bj_queuedExecTriggers
    boolean array      bj_queuedExecUseConds
    timer              bj_queuedExecTimeoutTimer   = CreateTimer()
    trigger            bj_queuedExecTimeout        = null

    // Helper vars (for Filter and Enum funcs)
    integer            bj_destInRegionDiesCount    = 0
    trigger            bj_destInRegionDiesTrig     = null
    integer            bj_groupCountUnits          = 0
    integer            bj_forceCountPlayers        = 0
    integer            bj_groupEnumTypeId          = 0
    player             bj_groupEnumOwningPlayer    = null
    group              bj_groupAddGroupDest        = null
    group              bj_groupRemoveGroupDest     = null
    integer            bj_groupRandomConsidered    = 0
    unit               bj_groupRandomCurrentPick   = null
    group              bj_groupLastCreatedDest     = null
    group              bj_randomSubGroupGroup      = null
    integer            bj_randomSubGroupWant       = 0
    integer            bj_randomSubGroupTotal      = 0
    real               bj_randomSubGroupChance     = 0
    integer            bj_destRandomConsidered     = 0
    destructable       bj_destRandomCurrentPick    = null
    destructable       bj_elevatorWallBlocker      = null
    destructable       bj_elevatorNeighbor         = null
    integer            bj_itemRandomConsidered     = 0
    item               bj_itemRandomCurrentPick    = null
    integer            bj_forceRandomConsidered    = 0
    player             bj_forceRandomCurrentPick   = null
    unit               bj_makeUnitRescuableUnit    = null
    boolean            bj_makeUnitRescuableFlag    = true
    boolean            bj_pauseAllUnitsFlag        = true
    location           bj_enumDestructableCenter   = null
    real               bj_enumDestructableRadius   = 0
    playercolor        bj_setPlayerTargetColor     = null
    boolean            bj_isUnitGroupDeadResult    = true
    boolean            bj_isUnitGroupEmptyResult   = true
    boolean            bj_isUnitGroupInRectResult  = true
    rect               bj_isUnitGroupInRectRect    = null
    boolean            bj_changeLevelShowScores    = false
    string             bj_changeLevelMapName       = null
    group              bj_suspendDecayFleshGroup   = CreateGroup()
    group              bj_suspendDecayBoneGroup    = CreateGroup()
    timer              bj_delayedSuspendDecayTimer = CreateTimer()
    trigger            bj_delayedSuspendDecayTrig  = null
    integer            bj_livingPlayerUnitsTypeId  = 0
    widget             bj_lastDyingWidget          = null

    // Random distribution vars
    integer            bj_randDistCount            = 0
    integer array      bj_randDistID
    integer array      bj_randDistChance

    // Last X'd vars
    unit               bj_lastCreatedUnit          = null
    item               bj_lastCreatedItem          = null
    item               bj_lastRemovedItem          = null
    unit               bj_lastHauntedGoldMine      = null
    destructable       bj_lastCreatedDestructable  = null
    group              bj_lastCreatedGroup         = CreateGroup()
    fogmodifier        bj_lastCreatedFogModifier   = null
    effect             bj_lastCreatedEffect        = null
    weathereffect      bj_lastCreatedWeatherEffect = null
    terraindeformation bj_lastCreatedTerrainDeformation = null
    quest              bj_lastCreatedQuest         = null
    questitem          bj_lastCreatedQuestItem     = null
    defeatcondition    bj_lastCreatedDefeatCondition = null
    timer              bj_lastStartedTimer         = CreateTimer()
    timerdialog        bj_lastCreatedTimerDialog   = null
    leaderboard        bj_lastCreatedLeaderboard   = null
    multiboard         bj_lastCreatedMultiboard    = null
    sound              bj_lastPlayedSound          = null
    string             bj_lastPlayedMusic          = ""
    real               bj_lastTransmissionDuration = 0
    gamecache          bj_lastCreatedGameCache     = null
    hashtable          bj_lastCreatedHashtable     = null
    unit               bj_lastLoadedUnit           = null
    button             bj_lastCreatedButton        = null
    unit               bj_lastReplacedUnit         = null
    texttag            bj_lastCreatedTextTag       = null
    lightning          bj_lastCreatedLightning     = null
    image              bj_lastCreatedImage         = null
    ubersplat          bj_lastCreatedUbersplat     = null

    // Filter function vars
    boolexpr           filterIssueHauntOrderAtLocBJ      = null
    boolexpr           filterEnumDestructablesInCircleBJ = null
    boolexpr           filterGetUnitsInRectOfPlayer      = null
    boolexpr           filterGetUnitsOfTypeIdAll         = null
    boolexpr           filterGetUnitsOfPlayerAndTypeId   = null
    boolexpr           filterMeleeTrainedUnitIsHeroBJ    = null
    boolexpr           filterLivingPlayerUnitsOfTypeId   = null

    // Memory cleanup vars
    boolean            bj_wantDestroyGroup         = false
    
    
    //***************************************************************************
    //*
    //*  Globals of ModCraft
    //*
    //***************************************************************************

    // race constant
    constant integer   mc_RACE_ZEAR          = 1
    constant integer   mc_RACE_TIDE            = 2
    constant integer   mc_RACE_FLEGION         = 3
    constant integer   mc_RACE_TRIBE       = 4
    constant integer   mc_RACE_VOID              = 5
    constant integer   mc_RACE_ALLIES              = 6
    constant integer   mc_RACE_RISEN              = 7
    constant integer   mc_RACE_8              = 8
    constant integer   mc_RACE_9              = 9
    constant integer   mc_RACE_10             = 10
    constant integer   mc_RACE_TEST_ALLIES              = 90
    constant integer   mc_RACE_TEST_ZEAR              = 80
    constant integer   mc_RACE_TEST_TRIBE              = 70
    constant integer   mc_RACE_TEST_TIDE              = 49
    constant integer   mc_RACE_TEST_VOID              = 51
    constant integer   mc_RACE_TEST_FLEGION             = 60
endglobals



//***************************************************************************
//*
//*  Debugging Functions
//*
//***************************************************************************

//===========================================================================
function BJDebugMsg takes string msg returns nothing
    local integer i = 0
    loop
        call DisplayTimedTextToPlayer(Player(i),0,0,60,msg)
        set i = i + 1
        exitwhen i == bj_MAX_PLAYERS
    endloop
endfunction



//***************************************************************************
//*
//*  Math Utility Functions
//*
//***************************************************************************

//===========================================================================
function RMinBJ takes real a, real b returns real
    if (a < b) then
        return a
    else
        return b
    endif
endfunction

//===========================================================================
function RMaxBJ takes real a, real b returns real
    if (a < b) then
        return b
    else
        return a
    endif
endfunction

//===========================================================================
function RAbsBJ takes real a returns real
    if (a >= 0) then
        return a
    else
        return -a
    endif
endfunction

//===========================================================================
function RSignBJ takes real a returns real
    if (a >= 0.0) then
        return 1.0
    else
        return -1.0
    endif
endfunction

//===========================================================================
function IMinBJ takes integer a, integer b returns integer
    if (a < b) then
        return a
    else
        return b
    endif
endfunction

//===========================================================================
function IMaxBJ takes integer a, integer b returns integer
    if (a < b) then
        return b
    else
        return a
    endif
endfunction

//===========================================================================
function IAbsBJ takes integer a returns integer
    if (a >= 0) then
        return a
    else
        return -a
    endif
endfunction

//===========================================================================
function ISignBJ takes integer a returns integer
    if (a >= 0) then
        return 1
    else
        return -1
    endif
endfunction

//===========================================================================
function SinBJ takes real degrees returns real
    return Sin(degrees * bj_DEGTORAD)
endfunction

//===========================================================================
function CosBJ takes real degrees returns real
    return Cos(degrees * bj_DEGTORAD)
endfunction

//===========================================================================
function TanBJ takes real degrees returns real
    return Tan(degrees * bj_DEGTORAD)
endfunction

//===========================================================================
function AsinBJ takes real degrees returns real
    return Asin(degrees) * bj_RADTODEG
endfunction

//===========================================================================
function AcosBJ takes real degrees returns real
    return Acos(degrees) * bj_RADTODEG
endfunction

//===========================================================================
function AtanBJ takes real degrees returns real
    return Atan(degrees) * bj_RADTODEG
endfunction

//===========================================================================
function Atan2BJ takes real y, real x returns real
    return Atan2(y, x) * bj_RADTODEG
endfunction

//===========================================================================
function AngleBetweenPoints takes location locA, location locB returns real
    return bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
endfunction

//===========================================================================
function DistanceBetweenPoints takes location locA, location locB returns real
    local real dx = GetLocationX(locB) - GetLocationX(locA)
    local real dy = GetLocationY(locB) - GetLocationY(locA)
    return SquareRoot(dx * dx + dy * dy)
endfunction

//===========================================================================
function PolarProjectionBJ takes location source, real dist, real angle returns location
    local real x = GetLocationX(source) + dist * Cos(angle * bj_DEGTORAD)
    local real y = GetLocationY(source) + dist * Sin(angle * bj_DEGTORAD)
    return Location(x, y)
endfunction

//===========================================================================
function GetRandomDirectionDeg takes nothing returns real
    return GetRandomReal(0, 360)
endfunction

//===========================================================================
function GetRandomPercentageBJ takes nothing returns real
    return GetRandomReal(0, 100)
endfunction

//===========================================================================
function GetRandomLocInRect takes rect whichRect returns location
    return Location(GetRandomReal(GetRectMinX(whichRect), GetRectMaxX(whichRect)), GetRandomReal(GetRectMinY(whichRect), GetRectMaxY(whichRect)))
endfunction

//===========================================================================
// Calculate the modulus/remainder of (dividend) divided by (divisor).
// Examples:  18 mod 5 = 3.  15 mod 5 = 0.  -8 mod 5 = 2.
//
function ModuloInteger takes integer dividend, integer divisor returns integer
    local integer modulus = dividend - (dividend / divisor) * divisor

    // If the dividend was negative, the above modulus calculation will
    // be negative, but within (-divisor..0).  We can add (divisor) to
    // shift this result into the desired range of (0..divisor).
    if (modulus < 0) then
        set modulus = modulus + divisor
    endif

    return modulus
endfunction

//===========================================================================
// Calculate the modulus/remainder of (dividend) divided by (divisor).
// Examples:  13.000 mod 2.500 = 0.500.  -6.000 mod 2.500 = 1.500.
//
function ModuloReal takes real dividend, real divisor returns real
    local real modulus = dividend - I2R(R2I(dividend / divisor)) * divisor

    // If the dividend was negative, the above modulus calculation will
    // be negative, but within (-divisor..0).  We can add (divisor) to
    // shift this result into the desired range of (0..divisor).
    if (modulus < 0) then
        set modulus = modulus + divisor
    endif

    return modulus
endfunction

//===========================================================================
function OffsetLocation takes location loc, real dx, real dy returns location
    return Location(GetLocationX(loc) + dx, GetLocationY(loc) + dy)
endfunction

//===========================================================================
function OffsetRectBJ takes rect r, real dx, real dy returns rect
    return Rect( GetRectMinX(r) + dx, GetRectMinY(r) + dy, GetRectMaxX(r) + dx, GetRectMaxY(r) + dy )
endfunction

//===========================================================================
function RectFromCenterSizeBJ takes location center, real width, real height returns rect
    local real x = GetLocationX( center )
    local real y = GetLocationY( center )
    return Rect( x - width*0.5, y - height*0.5, x + width*0.5, y + height*0.5 )
endfunction

//===========================================================================
function RectContainsCoords takes rect r, real x, real y returns boolean
    return (GetRectMinX(r) <= x) and (x <= GetRectMaxX(r)) and (GetRectMinY(r) <= y) and (y <= GetRectMaxY(r))
endfunction

//===========================================================================
function RectContainsLoc takes rect r, location loc returns boolean
    return RectContainsCoords(r, GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
function RectContainsUnit takes rect r, unit whichUnit returns boolean
    return RectContainsCoords(r, GetUnitX(whichUnit), GetUnitY(whichUnit))
endfunction

//===========================================================================
function RectContainsItem takes item whichItem, rect r returns boolean
    if (whichItem == null) then
        return false
    endif

    if (IsItemOwned(whichItem)) then
        return false
    endif

    return RectContainsCoords(r, GetItemX(whichItem), GetItemY(whichItem))
endfunction



//***************************************************************************
//*
//*  Utility Constructs
//*
//***************************************************************************

//===========================================================================
// Runs the trigger's actions if the trigger's conditions evaluate to true.
//
function ConditionalTriggerExecute takes trigger trig returns nothing
    if TriggerEvaluate(trig) then
        call TriggerExecute(trig)
    endif
endfunction

//===========================================================================
// Runs the trigger's actions if the trigger's conditions evaluate to true.
//
function TriggerExecuteBJ takes trigger trig, boolean checkConditions returns boolean
    if checkConditions then
        if not (TriggerEvaluate(trig)) then
            return false
        endif
    endif
    call TriggerExecute(trig)
    return true
endfunction

//===========================================================================
// Arranges for a trigger to fire almost immediately, except that the calling
// trigger is not interrupted as is the case with a TriggerExecute call.
// Since the trigger executes normally, its conditions are still evaluated.
//
function PostTriggerExecuteBJ takes trigger trig, boolean checkConditions returns boolean
    if checkConditions then
        if not (TriggerEvaluate(trig)) then
            return false
        endif
    endif
    call TriggerRegisterTimerEvent(trig, 0, false)
    return true
endfunction

//===========================================================================
// Debug - Display the contents of the trigger queue (as either null or "x"
// for each entry).
function QueuedTriggerCheck takes nothing returns nothing
    local string s = "TrigQueue Check "
    local integer i

    set i = 0
    loop
        exitwhen i >= bj_queuedExecTotal
        set s = s + "q[" + I2S(i) + "]="
        if (bj_queuedExecTriggers[i] == null) then
            set s = s + "null "
        else
            set s = s + "x "
        endif
        set i = i + 1
    endloop
    set s = s + "(" + I2S(bj_queuedExecTotal) + " total)"
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,600,s)
endfunction

//===========================================================================
// Searches the queue for a given trigger, returning the index of the
// trigger within the queue if it is found, or -1 if it is not found.
//
function QueuedTriggerGetIndex takes trigger trig returns integer
    // Determine which, if any, of the queued triggers is being removed.
    local integer index     = 0
    loop
        exitwhen index >= bj_queuedExecTotal
        if (bj_queuedExecTriggers[index] == trig) then
            return index
        endif
        set index = index + 1
    endloop
    return -1
endfunction

//===========================================================================
// Removes a trigger from the trigger queue, shifting other triggers down
// to fill the unused space.  If the currently running trigger is removed
// in this manner, this function does NOT attempt to run the next trigger.
//
function QueuedTriggerRemoveByIndex takes integer trigIndex returns boolean
    local integer index

    // If the to-be-removed index is out of range, fail.
    if (trigIndex >= bj_queuedExecTotal) then
        return false
    endif

    // Shift all queue entries down to fill in the gap.
    set bj_queuedExecTotal = bj_queuedExecTotal - 1
    set index = trigIndex
    loop
        exitwhen index >= bj_queuedExecTotal
        set bj_queuedExecTriggers[index] = bj_queuedExecTriggers[index + 1]
        set bj_queuedExecUseConds[index] = bj_queuedExecUseConds[index + 1]
        set index = index + 1
    endloop
    return true
endfunction

//===========================================================================
// Attempt to execute the first trigger in the queue.  If it fails, remove
// it and execute the next one.  Continue this cycle until a trigger runs,
// or until the queue is empty.
//
function QueuedTriggerAttemptExec takes nothing returns boolean
    loop
        exitwhen bj_queuedExecTotal == 0

        if TriggerExecuteBJ(bj_queuedExecTriggers[0], bj_queuedExecUseConds[0]) then
            // Timeout the queue if it sits at the front of the queue for too long.
            call TimerStart(bj_queuedExecTimeoutTimer, bj_QUEUED_TRIGGER_TIMEOUT, false, null)
            return true
        endif

        call QueuedTriggerRemoveByIndex(0)
    endloop
    return false
endfunction

//===========================================================================
// Queues a trigger to be executed, assuring that such triggers are not
// executed at the same time.
//
function QueuedTriggerAddBJ takes trigger trig, boolean checkConditions returns boolean
    // Make sure our queue isn't full.  If it is, return failure.
    if (bj_queuedExecTotal >= bj_MAX_QUEUED_TRIGGERS) then
        return false
    endif

    // Add the trigger to an array of to-be-executed triggers.
    set bj_queuedExecTriggers[bj_queuedExecTotal] = trig
    set bj_queuedExecUseConds[bj_queuedExecTotal] = checkConditions
    set bj_queuedExecTotal = bj_queuedExecTotal + 1

    // If this is the only trigger in the queue, run it.
    if (bj_queuedExecTotal == 1) then
        call QueuedTriggerAttemptExec()
    endif
    return true
endfunction

//===========================================================================
// Denotes the end of a queued trigger. Be sure to call this only once per
// queued trigger, or risk stepping on the toes of other queued triggers.
//
function QueuedTriggerRemoveBJ takes trigger trig returns nothing
    local integer index
    local integer trigIndex
    local boolean trigExecuted

    // Find the trigger's index.
    set trigIndex = QueuedTriggerGetIndex(trig)
    if (trigIndex == -1) then
        return
    endif

    // Shuffle the other trigger entries down to fill in the gap.
    call QueuedTriggerRemoveByIndex(trigIndex)

    // If we just axed the currently running trigger, run the next one.
    if (trigIndex == 0) then
        call PauseTimer(bj_queuedExecTimeoutTimer)
        call QueuedTriggerAttemptExec()
    endif
endfunction

//===========================================================================
// Denotes the end of a queued trigger. Be sure to call this only once per
// queued trigger, lest you step on the toes of other queued triggers.
//
function QueuedTriggerDoneBJ takes nothing returns nothing
    local integer index

    // Make sure there's something on the queue to remove.
    if (bj_queuedExecTotal <= 0) then
        return
    endif

    // Remove the currently running trigger from the array.
    call QueuedTriggerRemoveByIndex(0)

    // If other triggers are waiting to run, run one of them.
    call PauseTimer(bj_queuedExecTimeoutTimer)
    call QueuedTriggerAttemptExec()
endfunction

//===========================================================================
// Empty the trigger queue.
//
function QueuedTriggerClearBJ takes nothing returns nothing
    call PauseTimer(bj_queuedExecTimeoutTimer)
    set bj_queuedExecTotal = 0
endfunction

//===========================================================================
// Remove all but the currently executing trigger from the trigger queue.
//
function QueuedTriggerClearInactiveBJ takes nothing returns nothing
    set bj_queuedExecTotal = IMinBJ(bj_queuedExecTotal, 1)
endfunction

//===========================================================================
function QueuedTriggerCountBJ takes nothing returns integer
    return bj_queuedExecTotal
endfunction

//===========================================================================
function IsTriggerQueueEmptyBJ takes nothing returns boolean
    return bj_queuedExecTotal <= 0
endfunction

//===========================================================================
function IsTriggerQueuedBJ takes trigger trig returns boolean
    return QueuedTriggerGetIndex(trig) != -1
endfunction

//===========================================================================
function GetForLoopIndexA takes nothing returns integer
    return bj_forLoopAIndex
endfunction

//===========================================================================
function SetForLoopIndexA takes integer newIndex returns nothing
    set bj_forLoopAIndex = newIndex
endfunction

//===========================================================================
function GetForLoopIndexB takes nothing returns integer
    return bj_forLoopBIndex
endfunction

//===========================================================================
function SetForLoopIndexB takes integer newIndex returns nothing
    set bj_forLoopBIndex = newIndex
endfunction

//===========================================================================
// We can't do game-time waits, so this simulates one by starting a timer
// and polling until the timer expires.
function PolledWait takes real duration returns nothing
    local timer t
    local real  timeRemaining

    if (duration > 0) then
        set t = CreateTimer()
        call TimerStart(t, duration, false, null)
        loop
            set timeRemaining = TimerGetRemaining(t)
            exitwhen timeRemaining <= 0

            // If we have a bit of time left, skip past 10% of the remaining
            // duration instead of checking every interval, to minimize the
            // polling on long waits.
            if (timeRemaining > bj_POLLED_WAIT_SKIP_THRESHOLD) then
                call TriggerSleepAction(0.1 * timeRemaining)
            else
                call TriggerSleepAction(bj_POLLED_WAIT_INTERVAL)
            endif
        endloop
        call DestroyTimer(t)
    endif
endfunction

//===========================================================================
function IntegerTertiaryOp takes boolean flag, integer valueA, integer valueB returns integer
    if flag then
        return valueA
    else
        return valueB
    endif
endfunction


//***************************************************************************
//*
//*  General Utility Functions
//*  These functions exist purely to make the trigger dialogs cleaner and
//*  more comprehensible.
//*
//***************************************************************************

//===========================================================================
function DoNothing takes nothing returns nothing
endfunction

//===========================================================================
// This function does nothing.  WorldEdit should should eventually ignore
// CommentString triggers during script generation, but until such a time,
// this function will serve as a stub.
//
function CommentString takes string commentString returns nothing
endfunction

//===========================================================================
// This function returns the input string, converting it from the localized text, if necessary
//
function StringIdentity takes string theString returns string
    return GetLocalizedString(theString)
endfunction

//===========================================================================
function GetBooleanAnd takes boolean valueA, boolean valueB returns boolean
    return valueA and valueB
endfunction

//===========================================================================
function GetBooleanOr takes boolean valueA, boolean valueB returns boolean
    return valueA or valueB
endfunction

//===========================================================================
// Converts a percentage (real, 0..100) into a scaled integer (0..max),
// clipping the result to 0..max in case the input is invalid.
//
function PercentToInt takes real percentage, integer max returns integer
    local integer result = R2I(percentage * I2R(max) * 0.01)

    if (result < 0) then
        set result = 0
    elseif (result > max) then
        set result = max
    endif

    return result
endfunction

//===========================================================================
function PercentTo255 takes real percentage returns integer
    return PercentToInt(percentage, 255)
endfunction

//===========================================================================
function GetTimeOfDay takes nothing returns real
    return GetFloatGameState(GAME_STATE_TIME_OF_DAY)
endfunction

//===========================================================================
function SetTimeOfDay takes real whatTime returns nothing
    call SetFloatGameState(GAME_STATE_TIME_OF_DAY, whatTime)
endfunction

//===========================================================================
function SetTimeOfDayScalePercentBJ takes real scalePercent returns nothing
    call SetTimeOfDayScale(scalePercent * 0.01)
endfunction

//===========================================================================
function GetTimeOfDayScalePercentBJ takes nothing returns real
    return GetTimeOfDayScale() * 100
endfunction

//===========================================================================
function PlaySound takes string soundName returns nothing
    local sound soundHandle = CreateSound(soundName, false, false, true, 12700, 12700, "")
    call StartSound(soundHandle)
    call KillSoundWhenDone(soundHandle)
endfunction

//===========================================================================
function CompareLocationsBJ takes location A, location B returns boolean
    return GetLocationX(A) == GetLocationX(B) and GetLocationY(A) == GetLocationY(B)
endfunction

//===========================================================================
function CompareRectsBJ takes rect A, rect B returns boolean
    return GetRectMinX(A) == GetRectMinX(B) and GetRectMinY(A) == GetRectMinY(B) and GetRectMaxX(A) == GetRectMaxX(B) and GetRectMaxY(A) == GetRectMaxY(B)
endfunction

//===========================================================================
// Returns a square rect that exactly encompasses the specified circle.
//
function GetRectFromCircleBJ takes location center, real radius returns rect
    local real centerX = GetLocationX(center)
    local real centerY = GetLocationY(center)
    return Rect(centerX - radius, centerY - radius, centerX + radius, centerY + radius)
endfunction



//***************************************************************************
//*
//*  Camera Utility Functions
//*
//***************************************************************************

//===========================================================================
function GetCurrentCameraSetup takes nothing returns camerasetup
    local camerasetup theCam = CreateCameraSetup()
    local real duration = 0
    call CameraSetupSetField(theCam, CAMERA_FIELD_TARGET_DISTANCE, GetCameraField(CAMERA_FIELD_TARGET_DISTANCE), duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_FARZ,            GetCameraField(CAMERA_FIELD_FARZ),            duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_ZOFFSET,         GetCameraField(CAMERA_FIELD_ZOFFSET),         duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_ANGLE_OF_ATTACK, bj_RADTODEG * GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK), duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_FIELD_OF_VIEW,   bj_RADTODEG * GetCameraField(CAMERA_FIELD_FIELD_OF_VIEW),   duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_ROLL,            bj_RADTODEG * GetCameraField(CAMERA_FIELD_ROLL),            duration)
    call CameraSetupSetField(theCam, CAMERA_FIELD_ROTATION,        bj_RADTODEG * GetCameraField(CAMERA_FIELD_ROTATION),        duration)
    call CameraSetupSetDestPosition(theCam, GetCameraTargetPositionX(), GetCameraTargetPositionY(), duration)
    return theCam
endfunction

//===========================================================================
function CameraSetupApplyForPlayer takes boolean doPan, camerasetup whichSetup, player whichPlayer, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call CameraSetupApplyForceDuration(whichSetup, doPan, duration)
    endif
endfunction

//===========================================================================
function CameraSetupGetFieldSwap takes camerafield whichField, camerasetup whichSetup returns real
    return CameraSetupGetField(whichSetup, whichField)
endfunction

//===========================================================================
function SetCameraFieldForPlayer takes player whichPlayer, camerafield whichField, real value, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraField(whichField, value, duration)
    endif
endfunction

//===========================================================================
function SetCameraTargetControllerNoZForPlayer takes player whichPlayer, unit whichUnit, real xoffset, real yoffset, boolean inheritOrientation returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraTargetController(whichUnit, xoffset, yoffset, inheritOrientation)
    endif
endfunction

//===========================================================================
function SetCameraPositionForPlayer takes player whichPlayer, real x, real y returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraPosition(x, y)
    endif
endfunction

//===========================================================================
function SetCameraPositionLocForPlayer takes player whichPlayer, location loc returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraPosition(GetLocationX(loc), GetLocationY(loc))
    endif
endfunction

//===========================================================================
function RotateCameraAroundLocBJ takes real degrees, location loc, player whichPlayer, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraRotateMode(GetLocationX(loc), GetLocationY(loc), bj_DEGTORAD * degrees, duration)
    endif
endfunction

//===========================================================================
function PanCameraToForPlayer takes player whichPlayer, real x, real y returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PanCameraTo(x, y)
    endif
endfunction

//===========================================================================
function PanCameraToLocForPlayer takes player whichPlayer, location loc returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PanCameraTo(GetLocationX(loc), GetLocationY(loc))
    endif
endfunction

//===========================================================================
function PanCameraToTimedForPlayer takes player whichPlayer, real x, real y, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PanCameraToTimed(x, y, duration)
    endif
endfunction

//===========================================================================
function PanCameraToTimedLocForPlayer takes player whichPlayer, location loc, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), duration)
    endif
endfunction

//===========================================================================
function PanCameraToTimedLocWithZForPlayer takes player whichPlayer, location loc, real zOffset, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PanCameraToTimedWithZ(GetLocationX(loc), GetLocationY(loc), zOffset, duration)
    endif
endfunction

//===========================================================================
function SmartCameraPanBJ takes player whichPlayer, location loc, real duration returns nothing
    local real dist
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        set dist = DistanceBetweenPoints(loc, GetCameraTargetPositionLoc())
        if (dist >= bj_SMARTPAN_TRESHOLD_SNAP) then
            // If the user is too far away, snap the camera.
            call PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), 0)
        elseif (dist >= bj_SMARTPAN_TRESHOLD_PAN) then
            // If the user is moderately close, pan the camera.
            call PanCameraToTimed(GetLocationX(loc), GetLocationY(loc), duration)
        else
            // User is close enough, so don't touch the camera.
        endif
    endif
endfunction

//===========================================================================
function SetCinematicCameraForPlayer takes player whichPlayer, string cameraModelFile returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCinematicCamera(cameraModelFile)
    endif
endfunction

//===========================================================================
function ResetToGameCameraForPlayer takes player whichPlayer, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ResetToGameCamera(duration)
    endif
endfunction

//===========================================================================
function CameraSetSourceNoiseForPlayer takes player whichPlayer, real magnitude, real velocity returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call CameraSetSourceNoise(magnitude, velocity)
    endif
endfunction

//===========================================================================
function CameraSetTargetNoiseForPlayer takes player whichPlayer, real magnitude, real velocity returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call CameraSetTargetNoise(magnitude, velocity)
    endif
endfunction

//===========================================================================
function CameraSetEQNoiseForPlayer takes player whichPlayer, real magnitude returns nothing
    local real richter = magnitude
    if (richter > 5.0) then
        set richter = 5.0
    endif
    if (richter < 2.0) then
        set richter = 2.0
    endif
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call CameraSetTargetNoiseEx(magnitude*2.0, magnitude*Pow(10,richter),true)
        call CameraSetSourceNoiseEx(magnitude*2.0, magnitude*Pow(10,richter),true)
    endif
endfunction

//===========================================================================
function CameraClearNoiseForPlayer takes player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call CameraSetSourceNoise(0, 0)
        call CameraSetTargetNoise(0, 0)
    endif
endfunction

//===========================================================================
// Query the current camera bounds.
//
function GetCurrentCameraBoundsMapRectBJ takes nothing returns rect
    return Rect(GetCameraBoundMinX(), GetCameraBoundMinY(), GetCameraBoundMaxX(), GetCameraBoundMaxY())
endfunction

//===========================================================================
// Query the initial camera bounds, as defined at map init.
//
function GetCameraBoundsMapRect takes nothing returns rect
    return bj_mapInitialCameraBounds
endfunction

//===========================================================================
// Query the playable map area, as defined at map init.
//
function GetPlayableMapRect takes nothing returns rect
    return bj_mapInitialPlayableArea
endfunction

//===========================================================================
// Query the entire map area, as defined at map init.
//
function GetEntireMapRect takes nothing returns rect
    return GetWorldBounds()
endfunction

//===========================================================================
function SetCameraBoundsToRect takes rect r returns nothing
    local real minX = GetRectMinX(r)
    local real minY = GetRectMinY(r)
    local real maxX = GetRectMaxX(r)
    local real maxY = GetRectMaxY(r)
    call SetCameraBounds(minX, minY, minX, maxY, maxX, maxY, maxX, minY)
endfunction

//===========================================================================
function SetCameraBoundsToRectForPlayerBJ takes player whichPlayer, rect r returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraBoundsToRect(r)
    endif
endfunction

//===========================================================================
function AdjustCameraBoundsBJ takes integer adjustMethod, real dxWest, real dxEast, real dyNorth, real dySouth returns nothing
    local real minX = 0
    local real minY = 0
    local real maxX = 0
    local real maxY = 0
    local real scale = 0

    if (adjustMethod == bj_CAMERABOUNDS_ADJUST_ADD) then
        set scale = 1
    elseif (adjustMethod == bj_CAMERABOUNDS_ADJUST_SUB) then
        set scale = -1
    else
        // Unrecognized adjustment method - ignore the request.
        return
    endif

    // Adjust the actual camera values
    set minX = GetCameraBoundMinX() - scale * dxWest
    set maxX = GetCameraBoundMaxX() + scale * dxEast
    set minY = GetCameraBoundMinY() - scale * dySouth
    set maxY = GetCameraBoundMaxY() + scale * dyNorth

    // Make sure the camera bounds are still valid.
    if (maxX < minX) then
        set minX = (minX + maxX) * 0.5
        set maxX = minX
    endif
    if (maxY < minY) then
        set minY = (minY + maxY) * 0.5
        set maxY = minY
    endif

    // Apply the new camera values.
    call SetCameraBounds(minX, minY, minX, maxY, maxX, maxY, maxX, minY)
endfunction

//===========================================================================
function AdjustCameraBoundsForPlayerBJ takes integer adjustMethod, player whichPlayer, real dxWest, real dxEast, real dyNorth, real dySouth returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call AdjustCameraBoundsBJ(adjustMethod, dxWest, dxEast, dyNorth, dySouth)
    endif
endfunction

//===========================================================================
function SetCameraQuickPositionForPlayer takes player whichPlayer, real x, real y returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraQuickPosition(x, y)
    endif
endfunction

//===========================================================================
function SetCameraQuickPositionLocForPlayer takes player whichPlayer, location loc returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraQuickPosition(GetLocationX(loc), GetLocationY(loc))
    endif
endfunction

//===========================================================================
function SetCameraQuickPositionLoc takes location loc returns nothing
    call SetCameraQuickPosition(GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
function StopCameraForPlayerBJ takes player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call StopCamera()
    endif
endfunction

//===========================================================================
function SetCameraOrientControllerForPlayerBJ takes player whichPlayer, unit whichUnit, real xoffset, real yoffset returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetCameraOrientController(whichUnit, xoffset, yoffset)
    endif
endfunction

//===========================================================================
function CameraSetSmoothingFactorBJ takes real factor returns nothing
    call CameraSetSmoothingFactor(factor)
endfunction

//===========================================================================
function CameraResetSmoothingFactorBJ takes nothing returns nothing
    call CameraSetSmoothingFactor(0)
endfunction



//***************************************************************************
//*
//*  Text Utility Functions
//*
//***************************************************************************

//===========================================================================
function DisplayTextToForce takes force toForce, string message returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), toForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, message)
    endif
endfunction

//===========================================================================
function DisplayTimedTextToForce takes force toForce, real duration, string message returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), toForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, duration, message)
    endif
endfunction

//===========================================================================
function ClearTextMessagesBJ takes force toForce returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), toForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ClearTextMessages()
    endif
endfunction

//===========================================================================
// The parameters for the API Substring function are unintuitive, so this
// merely performs a translation for the starting index.
//
function SubStringBJ takes string source, integer start, integer end returns string
    return SubString(source, start-1, end)
endfunction  
  
function GetHandleIdBJ takes handle h returns integer
    return GetHandleId(h)
endfunction

function StringHashBJ takes string s returns integer
    return StringHash(s)
endfunction



//***************************************************************************
//*
//*  Event Registration Utility Functions
//*
//***************************************************************************

//===========================================================================
function TriggerRegisterTimerEventPeriodic takes trigger trig, real timeout returns event
    return TriggerRegisterTimerEvent(trig, timeout, true)
endfunction

//===========================================================================
function TriggerRegisterTimerEventSingle takes trigger trig, real timeout returns event
    return TriggerRegisterTimerEvent(trig, timeout, false)
endfunction

//===========================================================================
function TriggerRegisterTimerExpireEventBJ takes trigger trig, timer t returns event
    return TriggerRegisterTimerExpireEvent(trig, t)
endfunction

//===========================================================================
function TriggerRegisterPlayerUnitEventSimple takes trigger trig, player whichPlayer, playerunitevent whichEvent returns event
    return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, whichEvent, null)
endfunction

//===========================================================================
function TriggerRegisterAnyUnitEventBJ takes trigger trig, playerunitevent whichEvent returns nothing
    local integer index

    set index = 0
    loop
        call TriggerRegisterPlayerUnitEvent(trig, Player(index), whichEvent, null)

        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop
endfunction

//===========================================================================
function TriggerRegisterPlayerSelectionEventBJ takes trigger trig, player whichPlayer, boolean selected returns event
    if selected then
        return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, EVENT_PLAYER_UNIT_SELECTED, null)
    else
        return TriggerRegisterPlayerUnitEvent(trig, whichPlayer, EVENT_PLAYER_UNIT_DESELECTED, null)
    endif
endfunction

//===========================================================================
function TriggerRegisterPlayerKeyEventBJ takes trigger trig, player whichPlayer, integer keType, integer keKey returns event
    if (keType == bj_KEYEVENTTYPE_DEPRESS) then
        // Depress event - find out what key
        if (keKey == bj_KEYEVENTKEY_LEFT) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_LEFT_DOWN)
        elseif (keKey == bj_KEYEVENTKEY_RIGHT) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_RIGHT_DOWN)
        elseif (keKey == bj_KEYEVENTKEY_DOWN) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_DOWN_DOWN)
        elseif (keKey == bj_KEYEVENTKEY_UP) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_UP_DOWN)
        else
            // Unrecognized key - ignore the request and return failure.
            return null
        endif
    elseif (keType == bj_KEYEVENTTYPE_RELEASE) then
        // Release event - find out what key
        if (keKey == bj_KEYEVENTKEY_LEFT) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_LEFT_UP)
        elseif (keKey == bj_KEYEVENTKEY_RIGHT) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_RIGHT_UP)
        elseif (keKey == bj_KEYEVENTKEY_DOWN) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_DOWN_UP)
        elseif (keKey == bj_KEYEVENTKEY_UP) then
            return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ARROW_UP_UP)
        else
            // Unrecognized key - ignore the request and return failure.
            return null
        endif
    else
        // Unrecognized type - ignore the request and return failure.
        return null
    endif
endfunction

//===========================================================================
function TriggerRegisterPlayerEventVictory takes trigger trig, player whichPlayer returns event
    return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_VICTORY)
endfunction

//===========================================================================
function TriggerRegisterPlayerEventDefeat takes trigger trig, player whichPlayer returns event
    return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_DEFEAT)
endfunction

//===========================================================================
function TriggerRegisterPlayerEventLeave takes trigger trig, player whichPlayer returns event
    return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_LEAVE)
endfunction

//===========================================================================
function TriggerRegisterPlayerEventAllianceChanged takes trigger trig, player whichPlayer returns event
    return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_ALLIANCE_CHANGED)
endfunction

//===========================================================================
function TriggerRegisterPlayerEventEndCinematic takes trigger trig, player whichPlayer returns event
    return TriggerRegisterPlayerEvent(trig, whichPlayer, EVENT_PLAYER_END_CINEMATIC)
endfunction

//===========================================================================
function TriggerRegisterGameStateEventTimeOfDay takes trigger trig, limitop opcode, real limitval returns event
    return TriggerRegisterGameStateEvent(trig, GAME_STATE_TIME_OF_DAY, opcode, limitval)
endfunction

//===========================================================================
function TriggerRegisterEnterRegionSimple takes trigger trig, region whichRegion returns event
    return TriggerRegisterEnterRegion(trig, whichRegion, null)
endfunction

//===========================================================================
function TriggerRegisterLeaveRegionSimple takes trigger trig, region whichRegion returns event
    return TriggerRegisterLeaveRegion(trig, whichRegion, null)
endfunction

//===========================================================================
function TriggerRegisterEnterRectSimple takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    return TriggerRegisterEnterRegion(trig, rectRegion, null)
endfunction

//===========================================================================
function TriggerRegisterLeaveRectSimple takes trigger trig, rect r returns event
    local region rectRegion = CreateRegion()
    call RegionAddRect(rectRegion, r)
    return TriggerRegisterLeaveRegion(trig, rectRegion, null)
endfunction

//===========================================================================
function TriggerRegisterDistanceBetweenUnits takes trigger trig, unit whichUnit, boolexpr condition, real range returns event
    return TriggerRegisterUnitInRange(trig, whichUnit, range, condition)
endfunction

//===========================================================================
function TriggerRegisterUnitInRangeSimple takes trigger trig, real range, unit whichUnit returns event
    return TriggerRegisterUnitInRange(trig, whichUnit, range, null)
endfunction

//===========================================================================
function TriggerRegisterUnitLifeEvent takes trigger trig, unit whichUnit, limitop opcode, real limitval returns event
    return TriggerRegisterUnitStateEvent(trig, whichUnit, UNIT_STATE_LIFE, opcode, limitval)
endfunction

//===========================================================================
function TriggerRegisterUnitManaEvent takes trigger trig, unit whichUnit, limitop opcode, real limitval returns event
    return TriggerRegisterUnitStateEvent(trig, whichUnit, UNIT_STATE_MANA, opcode, limitval)
endfunction

//===========================================================================
function TriggerRegisterDialogEventBJ takes trigger trig, dialog whichDialog returns event
    return TriggerRegisterDialogEvent(trig, whichDialog)
endfunction

//===========================================================================
function TriggerRegisterShowSkillEventBJ takes trigger trig returns event
    return TriggerRegisterGameEvent(trig, EVENT_GAME_SHOW_SKILL)
endfunction

//===========================================================================
function TriggerRegisterBuildSubmenuEventBJ takes trigger trig returns event
    return TriggerRegisterGameEvent(trig, EVENT_GAME_BUILD_SUBMENU)
endfunction

//===========================================================================
function TriggerRegisterGameLoadedEventBJ takes trigger trig returns event
    return TriggerRegisterGameEvent(trig, EVENT_GAME_LOADED)
endfunction

//===========================================================================
function TriggerRegisterGameSavedEventBJ takes trigger trig returns event
    return TriggerRegisterGameEvent(trig, EVENT_GAME_SAVE)
endfunction

//===========================================================================
function RegisterDestDeathInRegionEnum takes nothing returns nothing
    set bj_destInRegionDiesCount = bj_destInRegionDiesCount + 1
    if (bj_destInRegionDiesCount <= bj_MAX_DEST_IN_REGION_EVENTS) then
        call TriggerRegisterDeathEvent(bj_destInRegionDiesTrig, GetEnumDestructable())
    endif
endfunction

//===========================================================================
function TriggerRegisterDestDeathInRegionEvent takes trigger trig, rect r returns nothing
    set bj_destInRegionDiesTrig = trig
    set bj_destInRegionDiesCount = 0
    call EnumDestructablesInRect(r, null, function RegisterDestDeathInRegionEnum)
endfunction



//***************************************************************************
//*
//*  Environment Utility Functions
//*
//***************************************************************************

//===========================================================================
function AddWeatherEffectSaveLast takes rect where, integer effectID returns weathereffect
    set bj_lastCreatedWeatherEffect = AddWeatherEffect(where, effectID)
    return bj_lastCreatedWeatherEffect
endfunction

//===========================================================================
function GetLastCreatedWeatherEffect takes nothing returns weathereffect
    return bj_lastCreatedWeatherEffect
endfunction

//===========================================================================
function RemoveWeatherEffectBJ takes weathereffect whichWeatherEffect returns nothing
    call RemoveWeatherEffect(whichWeatherEffect)
endfunction

//===========================================================================
function TerrainDeformationCraterBJ takes real duration, boolean permanent, location where, real radius, real depth returns terraindeformation
    set bj_lastCreatedTerrainDeformation = TerrainDeformCrater(GetLocationX(where), GetLocationY(where), radius, depth, R2I(duration * 1000), permanent)
    return bj_lastCreatedTerrainDeformation
endfunction

//===========================================================================
function TerrainDeformationRippleBJ takes real duration, boolean limitNeg, location where, real startRadius, real endRadius, real depth, real wavePeriod, real waveWidth returns terraindeformation
    local real spaceWave
    local real timeWave
    local real radiusRatio

    if (endRadius <= 0 or waveWidth <= 0 or wavePeriod <= 0) then
        return null
    endif

    set timeWave = 2.0 * duration / wavePeriod
    set spaceWave = 2.0 * endRadius / waveWidth
    set radiusRatio = startRadius / endRadius

    set bj_lastCreatedTerrainDeformation = TerrainDeformRipple(GetLocationX(where), GetLocationY(where), endRadius, depth, R2I(duration * 1000), 1, spaceWave, timeWave, radiusRatio, limitNeg)
    return bj_lastCreatedTerrainDeformation
endfunction

//===========================================================================
function TerrainDeformationWaveBJ takes real duration, location source, location target, real radius, real depth, real trailDelay returns terraindeformation
    local real distance
    local real dirX
    local real dirY
    local real speed

    set distance = DistanceBetweenPoints(source, target)
    if (distance == 0 or duration <= 0) then
        return null
    endif

    set dirX = (GetLocationX(target) - GetLocationX(source)) / distance
    set dirY = (GetLocationY(target) - GetLocationY(source)) / distance
    set speed = distance / duration

    set bj_lastCreatedTerrainDeformation = TerrainDeformWave(GetLocationX(source), GetLocationY(source), dirX, dirY, distance, speed, radius, depth, R2I(trailDelay * 1000), 1)
    return bj_lastCreatedTerrainDeformation
endfunction

//===========================================================================
function TerrainDeformationRandomBJ takes real duration, location where, real radius, real minDelta, real maxDelta, real updateInterval returns terraindeformation
    set bj_lastCreatedTerrainDeformation = TerrainDeformRandom(GetLocationX(where), GetLocationY(where), radius, minDelta, maxDelta, R2I(duration * 1000), R2I(updateInterval * 1000))
    return bj_lastCreatedTerrainDeformation
endfunction

//===========================================================================
function TerrainDeformationStopBJ takes terraindeformation deformation, real duration returns nothing
    call TerrainDeformStop(deformation, R2I(duration * 1000))
endfunction

//===========================================================================
function GetLastCreatedTerrainDeformation takes nothing returns terraindeformation
    return bj_lastCreatedTerrainDeformation
endfunction

//===========================================================================
function AddLightningLoc takes string codeName, location where1, location where2 returns lightning
    set bj_lastCreatedLightning = AddLightningEx(codeName, true, GetLocationX(where1), GetLocationY(where1), GetLocationZ(where1), GetLocationX(where2), GetLocationY(where2), GetLocationZ(where2))
    return bj_lastCreatedLightning
endfunction

//===========================================================================
function DestroyLightningBJ takes lightning whichBolt returns boolean
    return DestroyLightning(whichBolt)
endfunction

//===========================================================================
function MoveLightningLoc takes lightning whichBolt, location where1, location where2 returns boolean
    return MoveLightningEx(whichBolt, true, GetLocationX(where1), GetLocationY(where1), GetLocationZ(where1), GetLocationX(where2), GetLocationY(where2), GetLocationZ(where2))
endfunction

//===========================================================================
function GetLightningColorABJ takes lightning whichBolt returns real
    return GetLightningColorA(whichBolt)
endfunction

//===========================================================================
function GetLightningColorRBJ takes lightning whichBolt returns real
    return GetLightningColorR(whichBolt)
endfunction

//===========================================================================
function GetLightningColorGBJ takes lightning whichBolt returns real
    return GetLightningColorG(whichBolt)
endfunction

//===========================================================================
function GetLightningColorBBJ takes lightning whichBolt returns real
    return GetLightningColorB(whichBolt)
endfunction

//===========================================================================
function SetLightningColorBJ takes lightning whichBolt, real r, real g, real b, real a returns boolean
    return SetLightningColor(whichBolt, r, g, b, a)
endfunction

//===========================================================================
function GetLastCreatedLightningBJ takes nothing returns lightning
    return bj_lastCreatedLightning
endfunction

//===========================================================================
function GetAbilityEffectBJ takes integer abilcode, effecttype t, integer index returns string
    return GetAbilityEffectById(abilcode, t, index)
endfunction

//===========================================================================
function GetAbilitySoundBJ takes integer abilcode, soundtype t returns string
    return GetAbilitySoundById(abilcode, t)
endfunction


//===========================================================================
function GetTerrainCliffLevelBJ takes location where returns integer
    return GetTerrainCliffLevel(GetLocationX(where), GetLocationY(where))
endfunction

//===========================================================================
function GetTerrainTypeBJ takes location where returns integer
    return GetTerrainType(GetLocationX(where), GetLocationY(where))
endfunction

//===========================================================================
function GetTerrainVarianceBJ takes location where returns integer
    return GetTerrainVariance(GetLocationX(where), GetLocationY(where))
endfunction

//===========================================================================
function SetTerrainTypeBJ takes location where, integer terrainType, integer variation, integer area, integer shape returns nothing
    call SetTerrainType(GetLocationX(where), GetLocationY(where), terrainType, variation, area, shape)
endfunction

//===========================================================================
function IsTerrainPathableBJ takes location where, pathingtype t returns boolean
    return IsTerrainPathable(GetLocationX(where), GetLocationY(where), t)
endfunction

//===========================================================================
function SetTerrainPathableBJ takes location where, pathingtype t, boolean flag returns nothing
    call SetTerrainPathable(GetLocationX(where), GetLocationY(where), t, flag)
endfunction

//===========================================================================
function SetWaterBaseColorBJ takes real red, real green, real blue, real transparency returns nothing
    call SetWaterBaseColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function CreateFogModifierRectSimple takes player whichPlayer, fogstate whichFogState, rect r, boolean afterUnits returns fogmodifier
    set bj_lastCreatedFogModifier = CreateFogModifierRect(whichPlayer, whichFogState, r, true, afterUnits)
    return bj_lastCreatedFogModifier
endfunction

//===========================================================================
function CreateFogModifierRadiusLocSimple takes player whichPlayer, fogstate whichFogState, location center, real radius, boolean afterUnits returns fogmodifier
    set bj_lastCreatedFogModifier = CreateFogModifierRadiusLoc(whichPlayer, whichFogState, center, radius, true, afterUnits)
    return bj_lastCreatedFogModifier
endfunction

//===========================================================================
// Version of CreateFogModifierRect that assumes use of sharedVision and
// gives the option of immediately enabling the modifier, so that triggers
// can default to modifiers that are immediately enabled.
//
function CreateFogModifierRectBJ takes boolean enabled, player whichPlayer, fogstate whichFogState, rect r returns fogmodifier
    set bj_lastCreatedFogModifier = CreateFogModifierRect(whichPlayer, whichFogState, r, true, false)
    if enabled then
        call FogModifierStart(bj_lastCreatedFogModifier)
    endif
    return bj_lastCreatedFogModifier
endfunction

//===========================================================================
// Version of CreateFogModifierRadius that assumes use of sharedVision and
// gives the option of immediately enabling the modifier, so that triggers
// can default to modifiers that are immediately enabled.
//
function CreateFogModifierRadiusLocBJ takes boolean enabled, player whichPlayer, fogstate whichFogState, location center, real radius returns fogmodifier
    set bj_lastCreatedFogModifier = CreateFogModifierRadiusLoc(whichPlayer, whichFogState, center, radius, true, false)
    if enabled then
        call FogModifierStart(bj_lastCreatedFogModifier)
    endif
    return bj_lastCreatedFogModifier
endfunction

//===========================================================================
function GetLastCreatedFogModifier takes nothing returns fogmodifier
    return bj_lastCreatedFogModifier
endfunction

//===========================================================================
function FogEnableOn takes nothing returns nothing
    call FogEnable(true)
endfunction

//===========================================================================
function FogEnableOff takes nothing returns nothing
    call FogEnable(false)
endfunction

//===========================================================================
function FogMaskEnableOn takes nothing returns nothing
    call FogMaskEnable(true)
endfunction

//===========================================================================
function FogMaskEnableOff takes nothing returns nothing
    call FogMaskEnable(false)
endfunction

//===========================================================================
function UseTimeOfDayBJ takes boolean flag returns nothing
    call SuspendTimeOfDay(not flag)
endfunction

//===========================================================================
function SetTerrainFogExBJ takes integer style, real zstart, real zend, real density, real red, real green, real blue returns nothing
    call SetTerrainFogEx(style, zstart, zend, density, red * 0.01, green * 0.01, blue * 0.01)
endfunction

//===========================================================================
function ResetTerrainFogBJ takes nothing returns nothing
    call ResetTerrainFog()
endfunction

//===========================================================================
function SetDoodadAnimationBJ takes string animName, integer doodadID, real radius, location center returns nothing
    call SetDoodadAnimation(GetLocationX(center), GetLocationY(center), radius, doodadID, false, animName, false)
endfunction

//===========================================================================
function SetDoodadAnimationRectBJ takes string animName, integer doodadID, rect r returns nothing
    call SetDoodadAnimationRect(r, doodadID, animName, false)
endfunction

//===========================================================================
function AddUnitAnimationPropertiesBJ takes boolean add, string animProperties, unit whichUnit returns nothing
    call AddUnitAnimationProperties(whichUnit, animProperties, add)
endfunction


//============================================================================
function CreateImageBJ takes string file, real size, location where, real zOffset, integer imageType returns image
    set bj_lastCreatedImage = CreateImage(file, size, size, size, GetLocationX(where), GetLocationY(where), zOffset, 0, 0, 0, imageType)
    return bj_lastCreatedImage
endfunction

//============================================================================
function ShowImageBJ takes boolean flag, image whichImage returns nothing
    call ShowImage(whichImage, flag)
endfunction

//============================================================================
function SetImagePositionBJ takes image whichImage, location where, real zOffset returns nothing
    call SetImagePosition(whichImage, GetLocationX(where), GetLocationY(where), zOffset)
endfunction

//============================================================================
function SetImageColorBJ takes image whichImage, real red, real green, real blue, real alpha returns nothing
    call SetImageColor(whichImage, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-alpha))
endfunction

//============================================================================
function GetLastCreatedImage takes nothing returns image
    return bj_lastCreatedImage
endfunction

//============================================================================
function CreateUbersplatBJ takes location where, string name, real red, real green, real blue, real alpha, boolean forcePaused, boolean noBirthTime returns ubersplat
    set bj_lastCreatedUbersplat = CreateUbersplat(GetLocationX(where), GetLocationY(where), name, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-alpha), forcePaused, noBirthTime)
    return bj_lastCreatedUbersplat
endfunction

//============================================================================
function ShowUbersplatBJ takes boolean flag, ubersplat whichSplat returns nothing
    call ShowUbersplat(whichSplat, flag)
endfunction

//============================================================================
function GetLastCreatedUbersplat takes nothing returns ubersplat
    return bj_lastCreatedUbersplat
endfunction


//***************************************************************************
//*
//*  Sound Utility Functions
//*
//***************************************************************************

//===========================================================================
function PlaySoundBJ takes sound soundHandle returns nothing
    set bj_lastPlayedSound = soundHandle
    if (soundHandle != null) then
        call StartSound(soundHandle)
    endif
endfunction

//===========================================================================
function StopSoundBJ takes sound soundHandle, boolean fadeOut returns nothing
    call StopSound(soundHandle, false, fadeOut)
endfunction

//===========================================================================
function SetSoundVolumeBJ takes sound soundHandle, real volumePercent returns nothing
    call SetSoundVolume(soundHandle, PercentToInt(volumePercent, 127))
endfunction

//===========================================================================
function SetSoundOffsetBJ takes real newOffset, sound soundHandle returns nothing
    call SetSoundPlayPosition(soundHandle, R2I(newOffset * 1000))
endfunction

//===========================================================================
function SetSoundDistanceCutoffBJ takes sound soundHandle, real cutoff returns nothing
    call SetSoundDistanceCutoff(soundHandle, cutoff)
endfunction

//===========================================================================
function SetSoundPitchBJ takes sound soundHandle, real pitch returns nothing
    call SetSoundPitch(soundHandle, pitch)
endfunction

//===========================================================================
function SetSoundPositionLocBJ takes sound soundHandle, location loc, real z returns nothing
    call SetSoundPosition(soundHandle, GetLocationX(loc), GetLocationY(loc), z)
endfunction

//===========================================================================
function AttachSoundToUnitBJ takes sound soundHandle, unit whichUnit returns nothing
    call AttachSoundToUnit(soundHandle, whichUnit)
endfunction

//===========================================================================
function SetSoundConeAnglesBJ takes sound soundHandle, real inside, real outside, real outsideVolumePercent returns nothing
    call SetSoundConeAngles(soundHandle, inside, outside, PercentToInt(outsideVolumePercent, 127))
endfunction

//===========================================================================
function KillSoundWhenDoneBJ takes sound soundHandle returns nothing
    call KillSoundWhenDone(soundHandle)
endfunction

//===========================================================================
function PlaySoundAtPointBJ takes sound soundHandle, real volumePercent, location loc, real z returns nothing
    call SetSoundPositionLocBJ(soundHandle, loc, z)
    call SetSoundVolumeBJ(soundHandle, volumePercent)
    call PlaySoundBJ(soundHandle)
endfunction

//===========================================================================
function PlaySoundOnUnitBJ takes sound soundHandle, real volumePercent, unit whichUnit returns nothing
    call AttachSoundToUnitBJ(soundHandle, whichUnit)
    call SetSoundVolumeBJ(soundHandle, volumePercent)
    call PlaySoundBJ(soundHandle)
endfunction

//===========================================================================
function PlaySoundFromOffsetBJ takes sound soundHandle, real volumePercent, real startingOffset returns nothing
    call SetSoundVolumeBJ(soundHandle, volumePercent)
    call PlaySoundBJ(soundHandle)
    call SetSoundOffsetBJ(startingOffset, soundHandle)
endfunction

//===========================================================================
function PlayMusicBJ takes string musicFileName returns nothing
    set bj_lastPlayedMusic = musicFileName
    call PlayMusic(musicFileName)
endfunction

//===========================================================================
function PlayMusicExBJ takes string musicFileName, real startingOffset, real fadeInTime returns nothing
    set bj_lastPlayedMusic = musicFileName
    call PlayMusicEx(musicFileName, R2I(startingOffset * 1000), R2I(fadeInTime * 1000))
endfunction

//===========================================================================
function SetMusicOffsetBJ takes real newOffset returns nothing
    call SetMusicPlayPosition(R2I(newOffset * 1000))
endfunction

//===========================================================================
function PlayThematicMusicBJ takes string musicName returns nothing
    call PlayThematicMusic(musicName)
endfunction

//===========================================================================
function PlayThematicMusicExBJ takes string musicName, real startingOffset returns nothing
    call PlayThematicMusicEx(musicName, R2I(startingOffset * 1000))
endfunction

//===========================================================================
function SetThematicMusicOffsetBJ takes real newOffset returns nothing
    call SetThematicMusicPlayPosition(R2I(newOffset * 1000))
endfunction

//===========================================================================
function EndThematicMusicBJ takes nothing returns nothing
    call EndThematicMusic()
endfunction

//===========================================================================
function StopMusicBJ takes boolean fadeOut returns nothing
    call StopMusic(fadeOut)
endfunction

//===========================================================================
function ResumeMusicBJ takes nothing returns nothing
    call ResumeMusic()
endfunction

//===========================================================================
function SetMusicVolumeBJ takes real volumePercent returns nothing
    call SetMusicVolume(PercentToInt(volumePercent, 127))
endfunction

//===========================================================================
function GetSoundDurationBJ takes sound soundHandle returns real
    if (soundHandle == null) then
        return bj_NOTHING_SOUND_DURATION
    else
        return I2R(GetSoundDuration(soundHandle)) * 0.001
    endif
endfunction

//===========================================================================
function GetSoundFileDurationBJ takes string musicFileName returns real
    return I2R(GetSoundFileDuration(musicFileName)) * 0.001
endfunction

//===========================================================================
function GetLastPlayedSound takes nothing returns sound
    return bj_lastPlayedSound
endfunction

//===========================================================================
function GetLastPlayedMusic takes nothing returns string
    return bj_lastPlayedMusic
endfunction

//===========================================================================
function VolumeGroupSetVolumeBJ takes volumegroup vgroup, real percent returns nothing
    call VolumeGroupSetVolume(vgroup, percent * 0.01)
endfunction

//===========================================================================
function SetCineModeVolumeGroupsImmediateBJ takes nothing returns nothing
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITMOVEMENT,  bj_CINEMODE_VOLUME_UNITMOVEMENT)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITSOUNDS,    bj_CINEMODE_VOLUME_UNITSOUNDS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_COMBAT,        bj_CINEMODE_VOLUME_COMBAT)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_SPELLS,        bj_CINEMODE_VOLUME_SPELLS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UI,            bj_CINEMODE_VOLUME_UI)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_MUSIC,         bj_CINEMODE_VOLUME_MUSIC)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_AMBIENTSOUNDS, bj_CINEMODE_VOLUME_AMBIENTSOUNDS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_FIRE,          bj_CINEMODE_VOLUME_FIRE)
endfunction

//===========================================================================
function SetCineModeVolumeGroupsBJ takes nothing returns nothing
    // Delay the request if it occurs at map init.
    if bj_gameStarted then
        call SetCineModeVolumeGroupsImmediateBJ()
    else
        call TimerStart(bj_volumeGroupsTimer, bj_GAME_STARTED_THRESHOLD, false, function SetCineModeVolumeGroupsImmediateBJ)
    endif
endfunction

//===========================================================================
function SetSpeechVolumeGroupsImmediateBJ takes nothing returns nothing
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITMOVEMENT,  bj_SPEECH_VOLUME_UNITMOVEMENT)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UNITSOUNDS,    bj_SPEECH_VOLUME_UNITSOUNDS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_COMBAT,        bj_SPEECH_VOLUME_COMBAT)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_SPELLS,        bj_SPEECH_VOLUME_SPELLS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_UI,            bj_SPEECH_VOLUME_UI)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_MUSIC,         bj_SPEECH_VOLUME_MUSIC)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_AMBIENTSOUNDS, bj_SPEECH_VOLUME_AMBIENTSOUNDS)
    call VolumeGroupSetVolume(SOUND_VOLUMEGROUP_FIRE,          bj_SPEECH_VOLUME_FIRE)
endfunction

//===========================================================================
function SetSpeechVolumeGroupsBJ takes nothing returns nothing
    // Delay the request if it occurs at map init.
    if bj_gameStarted then
        call SetSpeechVolumeGroupsImmediateBJ()
    else
        call TimerStart(bj_volumeGroupsTimer, bj_GAME_STARTED_THRESHOLD, false, function SetSpeechVolumeGroupsImmediateBJ)
    endif
endfunction

//===========================================================================
function VolumeGroupResetImmediateBJ takes nothing returns nothing
    call VolumeGroupReset()
endfunction

//===========================================================================
function VolumeGroupResetBJ takes nothing returns nothing
    // Delay the request if it occurs at map init.
    if bj_gameStarted then
        call VolumeGroupResetImmediateBJ()
    else
        call TimerStart(bj_volumeGroupsTimer, bj_GAME_STARTED_THRESHOLD, false, function VolumeGroupResetImmediateBJ)
    endif
endfunction

//===========================================================================
function GetSoundIsPlayingBJ takes sound soundHandle returns boolean
    return GetSoundIsLoading(soundHandle) or GetSoundIsPlaying(soundHandle)
endfunction

//===========================================================================
function WaitForSoundBJ takes sound soundHandle, real offset returns nothing
    call TriggerWaitForSound( soundHandle, offset )
endfunction

//===========================================================================
function SetMapMusicIndexedBJ takes string musicName, integer index returns nothing
    call SetMapMusic(musicName, false, index)
endfunction

//===========================================================================
function SetMapMusicRandomBJ takes string musicName returns nothing
    call SetMapMusic(musicName, true, 0)
endfunction

//===========================================================================
function ClearMapMusicBJ takes nothing returns nothing
    call ClearMapMusic()
endfunction

//===========================================================================
function SetStackedSoundBJ takes boolean add, sound soundHandle, rect r returns nothing
    local real width = GetRectMaxX(r) - GetRectMinX(r)
    local real height = GetRectMaxY(r) - GetRectMinY(r)

    call SetSoundPosition(soundHandle, GetRectCenterX(r), GetRectCenterY(r), 0)
    if add then
        call RegisterStackedSound(soundHandle, true, width, height)
    else
        call UnregisterStackedSound(soundHandle, true, width, height)
    endif
endfunction

//===========================================================================
function StartSoundForPlayerBJ takes player whichPlayer, sound soundHandle returns nothing
    if (whichPlayer == GetLocalPlayer()) then
        call StartSound(soundHandle)
    endif
endfunction

//===========================================================================
function VolumeGroupSetVolumeForPlayerBJ takes player whichPlayer, volumegroup vgroup, real scale returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        call VolumeGroupSetVolume(vgroup, scale)
    endif
endfunction

//===========================================================================
function EnableDawnDusk takes boolean flag returns nothing
    set bj_useDawnDuskSounds = flag
endfunction

//===========================================================================
function IsDawnDuskEnabled takes nothing returns boolean
    return bj_useDawnDuskSounds
endfunction



//***************************************************************************
//*
//*  Day/Night ambient sounds
//*
//***************************************************************************

//===========================================================================
function SetAmbientDaySound takes string inLabel returns nothing
    local real ToD

    // Stop old sound, if necessary
    if (bj_dayAmbientSound != null) then
        call StopSound(bj_dayAmbientSound, true, true)
    endif

    // Create new sound
    set bj_dayAmbientSound = CreateMIDISound(inLabel, 20, 20)

    // Start the sound if necessary, based on current time
    set ToD = GetTimeOfDay()
    if (ToD >= bj_TOD_DAWN and ToD < bj_TOD_DUSK) then
        call StartSound(bj_dayAmbientSound)
    endif
endfunction

//===========================================================================
function SetAmbientNightSound takes string inLabel returns nothing
    local real ToD

    // Stop old sound, if necessary
    if (bj_nightAmbientSound != null) then
        call StopSound(bj_nightAmbientSound, true, true)
    endif

    // Create new sound
    set bj_nightAmbientSound = CreateMIDISound(inLabel, 20, 20)

    // Start the sound if necessary, based on current time
    set ToD = GetTimeOfDay()
    if (ToD < bj_TOD_DAWN or ToD >= bj_TOD_DUSK) then
        call StartSound(bj_nightAmbientSound)
    endif
endfunction



//***************************************************************************
//*
//*  Special Effect Utility Functions
//*
//***************************************************************************

//===========================================================================
function AddSpecialEffectLocBJ takes location where, string modelName returns effect
    set bj_lastCreatedEffect = AddSpecialEffectLoc(modelName, where)
    return bj_lastCreatedEffect
endfunction

//===========================================================================
function AddSpecialEffectTargetUnitBJ takes string attachPointName, widget targetWidget, string modelName returns effect
    set bj_lastCreatedEffect = AddSpecialEffectTarget(modelName, targetWidget, attachPointName)
    return bj_lastCreatedEffect
endfunction

//===========================================================================
// Two distinct trigger actions can't share the same function name, so this
// dummy function simply mimics the behavior of an existing call.
//
// Commented out - Destructibles have no attachment points.
//
//function AddSpecialEffectTargetDestructableBJ takes string attachPointName, widget targetWidget, string modelName returns effect
//    return AddSpecialEffectTargetUnitBJ(attachPointName, targetWidget, modelName)
//endfunction

//===========================================================================
// Two distinct trigger actions can't share the same function name, so this
// dummy function simply mimics the behavior of an existing call.
//
// Commented out - Items have no attachment points.
//
//function AddSpecialEffectTargetItemBJ takes string attachPointName, widget targetWidget, string modelName returns effect
//    return AddSpecialEffectTargetUnitBJ(attachPointName, targetWidget, modelName)
//endfunction

//===========================================================================
function DestroyEffectBJ takes effect whichEffect returns nothing
    call DestroyEffect(whichEffect)
endfunction

//===========================================================================
function GetLastCreatedEffectBJ takes nothing returns effect
    return bj_lastCreatedEffect
endfunction



//***************************************************************************
//*
//*  Hero and Item Utility Functions
//*
//***************************************************************************

//===========================================================================
function GetItemLoc takes item whichItem returns location
    return Location(GetItemX(whichItem), GetItemY(whichItem))
endfunction

//===========================================================================
function GetItemLifeBJ takes widget whichWidget returns real
    return GetWidgetLife(whichWidget)
endfunction

//===========================================================================
function SetItemLifeBJ takes widget whichWidget, real life returns nothing
    call SetWidgetLife(whichWidget, life)
endfunction

//===========================================================================
function AddHeroXPSwapped takes integer xpToAdd, unit whichHero, boolean showEyeCandy returns nothing
    call AddHeroXP(whichHero, xpToAdd, showEyeCandy)
endfunction

//===========================================================================
function SetHeroLevelBJ takes unit whichHero, integer newLevel, boolean showEyeCandy returns nothing
    local integer oldLevel = GetHeroLevel(whichHero)

    if (newLevel > oldLevel) then
        call SetHeroLevel(whichHero, newLevel, showEyeCandy)
    elseif (newLevel < oldLevel) then
        call UnitStripHeroLevel(whichHero, oldLevel - newLevel)
    else
        // No change in level - ignore the request.
    endif
endfunction

//===========================================================================
function DecUnitAbilityLevelSwapped takes integer abilcode, unit whichUnit returns integer
    return DecUnitAbilityLevel(whichUnit, abilcode)
endfunction

//===========================================================================
function IncUnitAbilityLevelSwapped takes integer abilcode, unit whichUnit returns integer
    return IncUnitAbilityLevel(whichUnit, abilcode)
endfunction

//===========================================================================
function SetUnitAbilityLevelSwapped takes integer abilcode, unit whichUnit, integer level returns integer
    return SetUnitAbilityLevel(whichUnit, abilcode, level)
endfunction

//===========================================================================
function GetUnitAbilityLevelSwapped takes integer abilcode, unit whichUnit returns integer
    return GetUnitAbilityLevel(whichUnit, abilcode)
endfunction

//===========================================================================
function UnitHasBuffBJ takes unit whichUnit, integer buffcode returns boolean
    return (GetUnitAbilityLevel(whichUnit, buffcode) > 0)
endfunction

//===========================================================================
function UnitRemoveBuffBJ takes integer buffcode, unit whichUnit returns boolean
    return UnitRemoveAbility(whichUnit, buffcode)
endfunction

//===========================================================================
function UnitAddItemSwapped takes item whichItem, unit whichHero returns boolean
    return UnitAddItem(whichHero, whichItem)
endfunction

//===========================================================================
function UnitAddItemByIdSwapped takes integer itemId, unit whichHero returns item
    // Create the item at the hero's feet first, and then give it to him.
    // This is to ensure that the item will be left at the hero's feet if
    // his inventory is full. 
    set bj_lastCreatedItem = CreateItem(itemId, GetUnitX(whichHero), GetUnitY(whichHero))
    call UnitAddItem(whichHero, bj_lastCreatedItem)
    return bj_lastCreatedItem
endfunction

//===========================================================================
function UnitRemoveItemSwapped takes item whichItem, unit whichHero returns nothing
    set bj_lastRemovedItem = whichItem
    call UnitRemoveItem(whichHero, whichItem)
endfunction

//===========================================================================
// Translates 0-based slot indices to 1-based slot indices.
//
function UnitRemoveItemFromSlotSwapped takes integer itemSlot, unit whichHero returns item
    set bj_lastRemovedItem = UnitRemoveItemFromSlot(whichHero, itemSlot-1)
    return bj_lastRemovedItem
endfunction

//===========================================================================
function CreateItemLoc takes integer itemId, location loc returns item
    set bj_lastCreatedItem = CreateItem(itemId, GetLocationX(loc), GetLocationY(loc))
    return bj_lastCreatedItem
endfunction

//===========================================================================
function GetLastCreatedItem takes nothing returns item
    return bj_lastCreatedItem
endfunction

//===========================================================================
function GetLastRemovedItem takes nothing returns item
    return bj_lastRemovedItem
endfunction

//===========================================================================
function SetItemPositionLoc takes item whichItem, location loc returns nothing
    call SetItemPosition(whichItem, GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
function GetLearnedSkillBJ takes nothing returns integer
    return GetLearnedSkill()
endfunction

//===========================================================================
function SuspendHeroXPBJ takes boolean flag, unit whichHero returns nothing
    call SuspendHeroXP(whichHero, not flag)
endfunction

//===========================================================================
function SetPlayerHandicapXPBJ takes player whichPlayer, real handicapPercent returns nothing
    call SetPlayerHandicapXP(whichPlayer, handicapPercent * 0.01)
endfunction

//===========================================================================
function GetPlayerHandicapXPBJ takes player whichPlayer returns real
    return GetPlayerHandicapXP(whichPlayer) * 100
endfunction

//===========================================================================
function SetPlayerHandicapBJ takes player whichPlayer, real handicapPercent returns nothing
    call SetPlayerHandicap(whichPlayer, handicapPercent * 0.01)
endfunction

//===========================================================================
function GetPlayerHandicapBJ takes player whichPlayer returns real
    return GetPlayerHandicap(whichPlayer) * 100
endfunction

//===========================================================================
function GetHeroStatBJ takes integer whichStat, unit whichHero, boolean includeBonuses returns integer
    if (whichStat == bj_HEROSTAT_STR) then
        return GetHeroStr(whichHero, includeBonuses)
    elseif (whichStat == bj_HEROSTAT_AGI) then
        return GetHeroAgi(whichHero, includeBonuses)
    elseif (whichStat == bj_HEROSTAT_INT) then
        return GetHeroInt(whichHero, includeBonuses)
    else
        // Unrecognized hero stat - return 0
        return 0
    endif
endfunction

//===========================================================================
function SetHeroStat takes unit whichHero, integer whichStat, integer value returns nothing
    // Ignore requests for negative hero stats.
    if (value <= 0) then
        return
    endif

    if (whichStat == bj_HEROSTAT_STR) then
        call SetHeroStr(whichHero, value, true)
    elseif (whichStat == bj_HEROSTAT_AGI) then
        call SetHeroAgi(whichHero, value, true)
    elseif (whichStat == bj_HEROSTAT_INT) then
        call SetHeroInt(whichHero, value, true)
    else
        // Unrecognized hero stat - ignore the request.
    endif
endfunction

//===========================================================================
function ModifyHeroStat takes integer whichStat, unit whichHero, integer modifyMethod, integer value returns nothing
    if (modifyMethod == bj_MODIFYMETHOD_ADD) then
        call SetHeroStat(whichHero, whichStat, GetHeroStatBJ(whichStat, whichHero, false) + value)
    elseif (modifyMethod == bj_MODIFYMETHOD_SUB) then
        call SetHeroStat(whichHero, whichStat, GetHeroStatBJ(whichStat, whichHero, false) - value)
    elseif (modifyMethod == bj_MODIFYMETHOD_SET) then
        call SetHeroStat(whichHero, whichStat, value)
    else
        // Unrecognized modification method - ignore the request.
    endif
endfunction

//===========================================================================
function ModifyHeroSkillPoints takes unit whichHero, integer modifyMethod, integer value returns boolean
    if (modifyMethod == bj_MODIFYMETHOD_ADD) then
        return UnitModifySkillPoints(whichHero, value)
    elseif (modifyMethod == bj_MODIFYMETHOD_SUB) then
        return UnitModifySkillPoints(whichHero, -value)
    elseif (modifyMethod == bj_MODIFYMETHOD_SET) then
        return UnitModifySkillPoints(whichHero, value - GetHeroSkillPoints(whichHero))
    else
        // Unrecognized modification method - ignore the request and return failure.
        return false
    endif
endfunction

//===========================================================================
function UnitDropItemPointBJ takes unit whichUnit, item whichItem, real x, real y returns boolean
    return UnitDropItemPoint(whichUnit, whichItem, x, y)
endfunction

//===========================================================================
function UnitDropItemPointLoc takes unit whichUnit, item whichItem, location loc returns boolean
    return UnitDropItemPoint(whichUnit, whichItem, GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
function UnitDropItemSlotBJ takes unit whichUnit, item whichItem, integer slot returns boolean
    return UnitDropItemSlot(whichUnit, whichItem, slot-1)
endfunction

//===========================================================================
function UnitDropItemTargetBJ takes unit whichUnit, item whichItem, widget target returns boolean
    return UnitDropItemTarget(whichUnit, whichItem, target)
endfunction

//===========================================================================
// Two distinct trigger actions can't share the same function name, so this
// dummy function simply mimics the behavior of an existing call.
//
function UnitUseItemDestructable takes unit whichUnit, item whichItem, widget target returns boolean
    return UnitUseItemTarget(whichUnit, whichItem, target)
endfunction

//===========================================================================
function UnitUseItemPointLoc takes unit whichUnit, item whichItem, location loc returns boolean
    return UnitUseItemPoint(whichUnit, whichItem, GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
// Translates 0-based slot indices to 1-based slot indices.
//
function UnitItemInSlotBJ takes unit whichUnit, integer itemSlot returns item
    return UnitItemInSlot(whichUnit, itemSlot-1)
endfunction

//===========================================================================
// Translates 0-based slot indices to 1-based slot indices.
//
function GetInventoryIndexOfItemTypeBJ takes unit whichUnit, integer itemId returns integer
    local integer index
    local item    indexItem

    set index = 0
    loop
        set indexItem = UnitItemInSlot(whichUnit, index)
        if (indexItem != null) and (GetItemTypeId(indexItem) == itemId) then
            return index + 1
        endif

        set index = index + 1
        exitwhen index >= bj_MAX_INVENTORY
    endloop
    return 0
endfunction

//===========================================================================
function GetItemOfTypeFromUnitBJ takes unit whichUnit, integer itemId returns item
    local integer index = GetInventoryIndexOfItemTypeBJ(whichUnit, itemId)

    if (index == 0) then
        return null
    else
        return UnitItemInSlot(whichUnit, index - 1)
    endif
endfunction

//===========================================================================
function UnitHasItemOfTypeBJ takes unit whichUnit, integer itemId returns boolean
    return GetInventoryIndexOfItemTypeBJ(whichUnit, itemId) > 0
endfunction

//===========================================================================
function UnitInventoryCount takes unit whichUnit returns integer
    local integer index = 0
    local integer count = 0

    loop
        if (UnitItemInSlot(whichUnit, index) != null) then
            set count = count + 1
        endif

        set index = index + 1
        exitwhen index >= bj_MAX_INVENTORY
    endloop

    return count
endfunction

//===========================================================================
function UnitInventorySizeBJ takes unit whichUnit returns integer
    return UnitInventorySize(whichUnit)
endfunction

//===========================================================================
function SetItemInvulnerableBJ takes item whichItem, boolean flag returns nothing
    call SetItemInvulnerable(whichItem, flag)
endfunction

//===========================================================================
function SetItemDropOnDeathBJ takes item whichItem, boolean flag returns nothing
    call SetItemDropOnDeath(whichItem, flag)
endfunction

//===========================================================================
function SetItemDroppableBJ takes item whichItem, boolean flag returns nothing
    call SetItemDroppable(whichItem, flag)
endfunction

//===========================================================================
function SetItemPlayerBJ takes item whichItem, player whichPlayer, boolean changeColor returns nothing
    call SetItemPlayer(whichItem, whichPlayer, changeColor)
endfunction

//===========================================================================
function SetItemVisibleBJ takes boolean show, item whichItem returns nothing
    call SetItemVisible(whichItem, show)
endfunction

//===========================================================================
function IsItemHiddenBJ takes item whichItem returns boolean
    return not IsItemVisible(whichItem)
endfunction

//===========================================================================
function ChooseRandomItemBJ takes integer level returns integer
    return ChooseRandomItem(level)
endfunction

//===========================================================================
function ChooseRandomItemExBJ takes integer level, itemtype whichType returns integer
    return ChooseRandomItemEx(whichType, level)
endfunction

//===========================================================================
function ChooseRandomNPBuildingBJ takes nothing returns integer
    return ChooseRandomNPBuilding()
endfunction

//===========================================================================
function ChooseRandomCreepBJ takes integer level returns integer
    return ChooseRandomCreep(level)
endfunction

//===========================================================================
function EnumItemsInRectBJ takes rect r, code actionFunc returns nothing
    call EnumItemsInRect(r, null, actionFunc)
endfunction

//===========================================================================
// See GroupPickRandomUnitEnum for the details of this algorithm.
//
function RandomItemInRectBJEnum takes nothing returns nothing
    set bj_itemRandomConsidered = bj_itemRandomConsidered + 1
    if (GetRandomInt(1, bj_itemRandomConsidered) == 1) then
        set bj_itemRandomCurrentPick = GetEnumItem()
    endif
endfunction

//===========================================================================
// Picks a random item from within a rect, matching a condition
//
function RandomItemInRectBJ takes rect r, boolexpr filter returns item
    set bj_itemRandomConsidered = 0
    set bj_itemRandomCurrentPick = null
    call EnumItemsInRect(r, filter, function RandomItemInRectBJEnum)
    call DestroyBoolExpr(filter)
    return bj_itemRandomCurrentPick
endfunction

//===========================================================================
// Picks a random item from within a rect
//
function RandomItemInRectSimpleBJ takes rect r returns item
    return RandomItemInRectBJ(r, null)
endfunction

//===========================================================================
function CheckItemStatus takes item whichItem, integer status returns boolean
    if (status == bj_ITEM_STATUS_HIDDEN) then
        return not IsItemVisible(whichItem)
    elseif (status == bj_ITEM_STATUS_OWNED) then
        return IsItemOwned(whichItem)
    elseif (status == bj_ITEM_STATUS_INVULNERABLE) then
        return IsItemInvulnerable(whichItem)
    elseif (status == bj_ITEM_STATUS_POWERUP) then
        return IsItemPowerup(whichItem)
    elseif (status == bj_ITEM_STATUS_SELLABLE) then
        return IsItemSellable(whichItem)
    elseif (status == bj_ITEM_STATUS_PAWNABLE) then
        return IsItemPawnable(whichItem)
    else
        // Unrecognized status - return false
        return false
    endif
endfunction

//===========================================================================
function CheckItemcodeStatus takes integer itemId, integer status returns boolean
    if (status == bj_ITEMCODE_STATUS_POWERUP) then
        return IsItemIdPowerup(itemId)
    elseif (status == bj_ITEMCODE_STATUS_SELLABLE) then
        return IsItemIdSellable(itemId)
    elseif (status == bj_ITEMCODE_STATUS_PAWNABLE) then
        return IsItemIdPawnable(itemId)
    else
        // Unrecognized status - return false
        return false
    endif
endfunction



//***************************************************************************
//*
//*  Unit Utility Functions
//*
//***************************************************************************

//===========================================================================
function UnitId2OrderIdBJ takes integer unitId returns integer
    return unitId
endfunction

//===========================================================================
function String2UnitIdBJ takes string unitIdString returns integer
    return UnitId(unitIdString)
endfunction

//===========================================================================
function UnitId2StringBJ takes integer unitId returns string
    local string unitString = UnitId2String(unitId)

    if (unitString != null) then
        return unitString
    endif

    // The unitId was not recognized - return an empty string.
    return ""
endfunction

//===========================================================================
function String2OrderIdBJ takes string orderIdString returns integer
    local integer orderId
    
    // Check to see if it's a generic order.
    set orderId = OrderId(orderIdString)
    if (orderId != 0) then
        return orderId
    endif

    // Check to see if it's a (train) unit order.
    set orderId = UnitId(orderIdString)
    if (orderId != 0) then
        return orderId
    endif

    // Unrecognized - return 0
    return 0
endfunction

//===========================================================================
function OrderId2StringBJ takes integer orderId returns string
    local string orderString

    // Check to see if it's a generic order.
    set orderString = OrderId2String(orderId)
    if (orderString != null) then
        return orderString
    endif

    // Check to see if it's a (train) unit order.
    set orderString = UnitId2String(orderId)
    if (orderString != null) then
        return orderString
    endif

    // Unrecognized - return an empty string.
    return ""
endfunction

//===========================================================================
function GetIssuedOrderIdBJ takes nothing returns integer
    return GetIssuedOrderId()
endfunction

//===========================================================================
function GetKillingUnitBJ takes nothing returns unit
    return GetKillingUnit()
endfunction

//===========================================================================
function CreateUnitAtLocSaveLast takes player id, integer unitid, location loc, real face returns unit
    if (unitid == 'ugol') then
        set bj_lastCreatedUnit = CreateBlightedGoldmine(id, GetLocationX(loc), GetLocationY(loc), face)
    else
        set bj_lastCreatedUnit = CreateUnitAtLoc(id, unitid, loc, face)
    endif

    return bj_lastCreatedUnit
endfunction

//===========================================================================
function GetLastCreatedUnit takes nothing returns unit
    return bj_lastCreatedUnit
endfunction

//===========================================================================
function CreateNUnitsAtLoc takes integer count, integer unitId, player whichPlayer, location loc, real face returns group
    call GroupClear(bj_lastCreatedGroup)
    loop
        set count = count - 1
        exitwhen count < 0
        call CreateUnitAtLocSaveLast(whichPlayer, unitId, loc, face)
        call GroupAddUnit(bj_lastCreatedGroup, bj_lastCreatedUnit)
    endloop
    return bj_lastCreatedGroup
endfunction

//===========================================================================
function CreateNUnitsAtLocFacingLocBJ takes integer count, integer unitId, player whichPlayer, location loc, location lookAt returns group
    return CreateNUnitsAtLoc(count, unitId, whichPlayer, loc, AngleBetweenPoints(loc, lookAt))
endfunction

//===========================================================================
function GetLastCreatedGroupEnum takes nothing returns nothing
    call GroupAddUnit(bj_groupLastCreatedDest, GetEnumUnit())
endfunction

//===========================================================================
function GetLastCreatedGroup takes nothing returns group
    set bj_groupLastCreatedDest = CreateGroup()
    call ForGroup(bj_lastCreatedGroup, function GetLastCreatedGroupEnum)
    return bj_groupLastCreatedDest
endfunction

//===========================================================================
function CreateCorpseLocBJ takes integer unitid, player whichPlayer, location loc returns unit
    set bj_lastCreatedUnit = CreateCorpse(whichPlayer, unitid, GetLocationX(loc), GetLocationY(loc), GetRandomReal(0, 360))
    return bj_lastCreatedUnit
endfunction

//===========================================================================
function UnitSuspendDecayBJ takes boolean suspend, unit whichUnit returns nothing
    call UnitSuspendDecay(whichUnit, suspend)
endfunction

//===========================================================================
function DelayedSuspendDecayStopAnimEnum takes nothing returns nothing
    local unit enumUnit = GetEnumUnit()

    if (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0) then
        call SetUnitTimeScale(enumUnit, 0.0001)
    endif
endfunction

//===========================================================================
function DelayedSuspendDecayBoneEnum takes nothing returns nothing
    local unit enumUnit = GetEnumUnit()

    if (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0) then
        call UnitSuspendDecay(enumUnit, true)
        call SetUnitTimeScale(enumUnit, 0.0001)
    endif
endfunction

//===========================================================================
// Game code explicitly sets the animation back to "decay bone" after the
// initial corpse fades away, so we reset it now.  It's best not to show
// off corpses thus created until after this grace period has passed.
//
function DelayedSuspendDecayFleshEnum takes nothing returns nothing
    local unit enumUnit = GetEnumUnit()

    if (GetUnitState(enumUnit, UNIT_STATE_LIFE) <= 0) then
        call UnitSuspendDecay(enumUnit, true)
        call SetUnitTimeScale(enumUnit, 10.0)
        call SetUnitAnimation(enumUnit, "decay flesh")
    endif
endfunction

//===========================================================================
// Waits a short period of time to ensure that the corpse is decaying, and
// then suspend the animation and corpse decay.
//
function DelayedSuspendDecay takes nothing returns nothing
    local group boneGroup
    local group fleshGroup

    // Switch the global unit groups over to local variables and recreate
    // the global versions, so that this function can handle overlapping
    // calls.
    set boneGroup = bj_suspendDecayBoneGroup
    set fleshGroup = bj_suspendDecayFleshGroup
    set bj_suspendDecayBoneGroup = CreateGroup()
    set bj_suspendDecayFleshGroup = CreateGroup()

    call ForGroup(fleshGroup, function DelayedSuspendDecayStopAnimEnum)
    call ForGroup(boneGroup, function DelayedSuspendDecayStopAnimEnum)

    call TriggerSleepAction(bj_CORPSE_MAX_DEATH_TIME)
    call ForGroup(fleshGroup, function DelayedSuspendDecayFleshEnum)
    call ForGroup(boneGroup, function DelayedSuspendDecayBoneEnum)

    call TriggerSleepAction(0.05)
    call ForGroup(fleshGroup, function DelayedSuspendDecayStopAnimEnum)

    call DestroyGroup(boneGroup)
    call DestroyGroup(fleshGroup)
endfunction

//===========================================================================
function DelayedSuspendDecayCreate takes nothing returns nothing
    set bj_delayedSuspendDecayTrig = CreateTrigger()
    call TriggerRegisterTimerExpireEvent(bj_delayedSuspendDecayTrig, bj_delayedSuspendDecayTimer)
    call TriggerAddAction(bj_delayedSuspendDecayTrig, function DelayedSuspendDecay)
endfunction

//===========================================================================
function CreatePermanentCorpseLocBJ takes integer style, integer unitid, player whichPlayer, location loc, real facing returns unit
    set bj_lastCreatedUnit = CreateCorpse(whichPlayer, unitid, GetLocationX(loc), GetLocationY(loc), facing)
    call SetUnitBlendTime(bj_lastCreatedUnit, 0)

    if (style == bj_CORPSETYPE_FLESH) then
        call SetUnitAnimation(bj_lastCreatedUnit, "decay flesh")
        call GroupAddUnit(bj_suspendDecayFleshGroup, bj_lastCreatedUnit)
    elseif (style == bj_CORPSETYPE_BONE) then
        call SetUnitAnimation(bj_lastCreatedUnit, "decay bone")
        call GroupAddUnit(bj_suspendDecayBoneGroup, bj_lastCreatedUnit)
    else
        // Unknown decay style - treat as skeletal.
        call SetUnitAnimation(bj_lastCreatedUnit, "decay bone")
        call GroupAddUnit(bj_suspendDecayBoneGroup, bj_lastCreatedUnit)
    endif

    call TimerStart(bj_delayedSuspendDecayTimer, 0.05, false, null)
    return bj_lastCreatedUnit
endfunction

//===========================================================================
function GetUnitStateSwap takes unitstate whichState, unit whichUnit returns real
    return GetUnitState(whichUnit, whichState)
endfunction

//===========================================================================
function GetUnitStatePercent takes unit whichUnit, unitstate whichState, unitstate whichMaxState returns real
    local real value    = GetUnitState(whichUnit, whichState)
    local real maxValue = GetUnitState(whichUnit, whichMaxState)

    // Return 0 for null units.
    if (whichUnit == null) or (maxValue == 0) then
        return 0.0
    endif

    return value / maxValue * 100.0
endfunction

//===========================================================================
function GetUnitLifePercent takes unit whichUnit returns real
    return GetUnitStatePercent(whichUnit, UNIT_STATE_LIFE, UNIT_STATE_MAX_LIFE)
endfunction

//===========================================================================
function GetUnitManaPercent takes unit whichUnit returns real
    return GetUnitStatePercent(whichUnit, UNIT_STATE_MANA, UNIT_STATE_MAX_MANA)
endfunction

//===========================================================================
function SelectUnitSingle takes unit whichUnit returns nothing
    call ClearSelection()
    call SelectUnit(whichUnit, true)
endfunction

//===========================================================================
function SelectGroupBJEnum takes nothing returns nothing
    call SelectUnit( GetEnumUnit(), true )
endfunction

//===========================================================================
function SelectGroupBJ takes group g returns nothing
    call ClearSelection()
    call ForGroup( g, function SelectGroupBJEnum )
endfunction

//===========================================================================
function SelectUnitAdd takes unit whichUnit returns nothing
    call SelectUnit(whichUnit, true)
endfunction

//===========================================================================
function SelectUnitRemove takes unit whichUnit returns nothing
    call SelectUnit(whichUnit, false)
endfunction

//===========================================================================
function ClearSelectionForPlayer takes player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ClearSelection()
    endif
endfunction

//===========================================================================
function SelectUnitForPlayerSingle takes unit whichUnit, player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ClearSelection()
        call SelectUnit(whichUnit, true)
    endif
endfunction

//===========================================================================
function SelectGroupForPlayerBJ takes group g, player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ClearSelection()
        call ForGroup( g, function SelectGroupBJEnum )
    endif
endfunction

//===========================================================================
function SelectUnitAddForPlayer takes unit whichUnit, player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SelectUnit(whichUnit, true)
    endif
endfunction

//===========================================================================
function SelectUnitRemoveForPlayer takes unit whichUnit, player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SelectUnit(whichUnit, false)
    endif
endfunction

//===========================================================================
function SetUnitLifeBJ takes unit whichUnit, real newValue returns nothing
    call SetUnitState(whichUnit, UNIT_STATE_LIFE, RMaxBJ(0,newValue))
endfunction

//===========================================================================
function SetUnitManaBJ takes unit whichUnit, real newValue returns nothing
    call SetUnitState(whichUnit, UNIT_STATE_MANA, RMaxBJ(0,newValue))
endfunction

//===========================================================================
function SetUnitLifePercentBJ takes unit whichUnit, real percent returns nothing
    call SetUnitState(whichUnit, UNIT_STATE_LIFE, GetUnitState(whichUnit, UNIT_STATE_MAX_LIFE) * RMaxBJ(0,percent) * 0.01)
endfunction

//===========================================================================
function SetUnitManaPercentBJ takes unit whichUnit, real percent returns nothing
    call SetUnitState(whichUnit, UNIT_STATE_MANA, GetUnitState(whichUnit, UNIT_STATE_MAX_MANA) * RMaxBJ(0,percent) * 0.01)
endfunction

//===========================================================================
function IsUnitDeadBJ takes unit whichUnit returns boolean
    return GetUnitState(whichUnit, UNIT_STATE_LIFE) <= 0
endfunction

//===========================================================================
function IsUnitAliveBJ takes unit whichUnit returns boolean
    return not IsUnitDeadBJ(whichUnit)
endfunction

//===========================================================================
function IsUnitGroupDeadBJEnum takes nothing returns nothing
    if not IsUnitDeadBJ(GetEnumUnit()) then
        set bj_isUnitGroupDeadResult = false
    endif
endfunction

//===========================================================================
// Returns true if every unit of the group is dead.
//
function IsUnitGroupDeadBJ takes group g returns boolean
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_isUnitGroupDeadResult = true
    call ForGroup(g, function IsUnitGroupDeadBJEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(g)
    endif
    return bj_isUnitGroupDeadResult
endfunction

//===========================================================================
function IsUnitGroupEmptyBJEnum takes nothing returns nothing
    set bj_isUnitGroupEmptyResult = false
endfunction

//===========================================================================
// Returns true if the group contains no units.
//
function IsUnitGroupEmptyBJ takes group g returns boolean
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_isUnitGroupEmptyResult = true
    call ForGroup(g, function IsUnitGroupEmptyBJEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(g)
    endif
    return bj_isUnitGroupEmptyResult
endfunction

//===========================================================================
function IsUnitGroupInRectBJEnum takes nothing returns nothing
    if not RectContainsUnit(bj_isUnitGroupInRectRect, GetEnumUnit()) then
        set bj_isUnitGroupInRectResult = false
    endif
endfunction

//===========================================================================
// Returns true if every unit of the group is within the given rect.
//
function IsUnitGroupInRectBJ takes group g, rect r returns boolean
    set bj_isUnitGroupInRectResult = true
    set bj_isUnitGroupInRectRect = r
    call ForGroup(g, function IsUnitGroupInRectBJEnum)
    return bj_isUnitGroupInRectResult
endfunction

//===========================================================================
function IsUnitHiddenBJ takes unit whichUnit returns boolean
    return IsUnitHidden(whichUnit)
endfunction

//===========================================================================
function ShowUnitHide takes unit whichUnit returns nothing
    call ShowUnit(whichUnit, false)
endfunction

//===========================================================================
function ShowUnitShow takes unit whichUnit returns nothing
    // Prevent dead heroes from being unhidden.
    if (IsUnitType(whichUnit, UNIT_TYPE_HERO) and IsUnitDeadBJ(whichUnit)) then
        return
    endif

    call ShowUnit(whichUnit, true)
endfunction

//===========================================================================
function IssueHauntOrderAtLocBJFilter takes nothing returns boolean
    return GetUnitTypeId(GetFilterUnit()) == 'ngol'
endfunction

//===========================================================================
function IssueHauntOrderAtLocBJ takes unit whichPeon, location loc returns boolean
    local group g = null
    local unit goldMine = null

    // Search for a gold mine within a 1-cell radius of the specified location.
    set g = CreateGroup()
    call GroupEnumUnitsInRangeOfLoc(g, loc, 2*bj_CELLWIDTH, filterIssueHauntOrderAtLocBJ)
    set goldMine = FirstOfGroup(g)
    call DestroyGroup(g)

    // If no mine was found, abort the request.
    if (goldMine == null) then
        return false
    endif

    // Issue the Haunt Gold Mine order.
    return IssueTargetOrderById(whichPeon, 'ugol', goldMine)
endfunction

//===========================================================================
function IssueBuildOrderByIdLocBJ takes unit whichPeon, integer unitId, location loc returns boolean
    if (unitId == 'ugol') then
        return IssueHauntOrderAtLocBJ(whichPeon, loc)
    else
        return IssueBuildOrderById(whichPeon, unitId, GetLocationX(loc), GetLocationY(loc))
    endif
endfunction

//===========================================================================
function IssueTrainOrderByIdBJ takes unit whichUnit, integer unitId returns boolean
    return IssueImmediateOrderById(whichUnit, unitId)
endfunction

//===========================================================================
function GroupTrainOrderByIdBJ takes group g, integer unitId returns boolean
    return GroupImmediateOrderById(g, unitId)
endfunction

//===========================================================================
function IssueUpgradeOrderByIdBJ takes unit whichUnit, integer techId returns boolean
    return IssueImmediateOrderById(whichUnit, techId)
endfunction

//===========================================================================
function GetAttackedUnitBJ takes nothing returns unit
    return GetTriggerUnit()
endfunction

//===========================================================================
function SetUnitFlyHeightBJ takes unit whichUnit, real newHeight, real rate returns nothing
    call SetUnitFlyHeight(whichUnit, newHeight, rate)
endfunction

//===========================================================================
function SetUnitTurnSpeedBJ takes unit whichUnit, real turnSpeed returns nothing
    call SetUnitTurnSpeed(whichUnit, turnSpeed)
endfunction

//===========================================================================
function SetUnitPropWindowBJ takes unit whichUnit, real propWindow returns nothing
    local real angle = propWindow
    if (angle <= 0) then
        set angle = 1
    elseif (angle >= 360) then
        set angle = 359
    endif
    set angle = angle * bj_DEGTORAD

    call SetUnitPropWindow(whichUnit, angle)
endfunction

//===========================================================================
function GetUnitPropWindowBJ takes unit whichUnit returns real
    return GetUnitPropWindow(whichUnit) * bj_RADTODEG
endfunction

//===========================================================================
function GetUnitDefaultPropWindowBJ takes unit whichUnit returns real
    return GetUnitDefaultPropWindow(whichUnit)
endfunction

//===========================================================================
function SetUnitBlendTimeBJ takes unit whichUnit, real blendTime returns nothing
    call SetUnitBlendTime(whichUnit, blendTime)
endfunction

//===========================================================================
function SetUnitAcquireRangeBJ takes unit whichUnit, real acquireRange returns nothing
    call SetUnitAcquireRange(whichUnit, acquireRange)
endfunction

//===========================================================================
function UnitSetCanSleepBJ takes unit whichUnit, boolean canSleep returns nothing
    call UnitAddSleep(whichUnit, canSleep)
endfunction

//===========================================================================
function UnitCanSleepBJ takes unit whichUnit returns boolean
    return UnitCanSleep(whichUnit)
endfunction

//===========================================================================
function UnitWakeUpBJ takes unit whichUnit returns nothing
    call UnitWakeUp(whichUnit)
endfunction

//===========================================================================
function UnitIsSleepingBJ takes unit whichUnit returns boolean
    return UnitIsSleeping(whichUnit)
endfunction

//===========================================================================
function WakePlayerUnitsEnum takes nothing returns nothing
    call UnitWakeUp(GetEnumUnit())
endfunction

//===========================================================================
function WakePlayerUnits takes player whichPlayer returns nothing
    local group g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, whichPlayer, null)
    call ForGroup(g, function WakePlayerUnitsEnum)
    call DestroyGroup(g)
endfunction

//===========================================================================
function EnableCreepSleepBJ takes boolean enable returns nothing
    call SetPlayerState(Player(PLAYER_NEUTRAL_AGGRESSIVE), PLAYER_STATE_NO_CREEP_SLEEP, IntegerTertiaryOp(enable, 0, 1))

    // If we're disabling, attempt to wake any already-sleeping creeps.
    if (not enable) then
        call WakePlayerUnits(Player(PLAYER_NEUTRAL_AGGRESSIVE))
    endif
endfunction

//===========================================================================
function UnitGenerateAlarms takes unit whichUnit, boolean generate returns boolean
    return UnitIgnoreAlarm(whichUnit, not generate)
endfunction

//===========================================================================
function DoesUnitGenerateAlarms takes unit whichUnit returns boolean
    return not UnitIgnoreAlarmToggled(whichUnit)
endfunction

//===========================================================================
function PauseAllUnitsBJEnum takes nothing returns nothing
    call PauseUnit( GetEnumUnit(), bj_pauseAllUnitsFlag )
endfunction

//===========================================================================
// Pause all units 
function PauseAllUnitsBJ takes boolean pause returns nothing
    local integer index
    local player  indexPlayer
    local group   g

    set bj_pauseAllUnitsFlag = pause
    set g = CreateGroup()
    set index = 0
    loop
        set indexPlayer = Player( index )

        // If this is a computer slot, pause/resume the AI.
        if (GetPlayerController( indexPlayer ) == MAP_CONTROL_COMPUTER) then
            call PauseCompAI( indexPlayer, pause )
        endif

        // Enumerate and unpause every unit owned by the player.
        call GroupEnumUnitsOfPlayer( g, indexPlayer, null )
        call ForGroup( g, function PauseAllUnitsBJEnum )
        call GroupClear( g )

        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop
    call DestroyGroup(g)
endfunction

//===========================================================================
function PauseUnitBJ takes boolean pause, unit whichUnit returns nothing
    call PauseUnit(whichUnit, pause)
endfunction

//===========================================================================
function IsUnitPausedBJ takes unit whichUnit returns boolean
    return IsUnitPaused(whichUnit)
endfunction

//===========================================================================
function UnitPauseTimedLifeBJ takes boolean flag, unit whichUnit returns nothing
    call UnitPauseTimedLife(whichUnit, flag)
endfunction

//===========================================================================
function UnitApplyTimedLifeBJ takes real duration, integer buffId, unit whichUnit returns nothing
    call UnitApplyTimedLife(whichUnit, buffId, duration)
endfunction

//===========================================================================
function UnitShareVisionBJ takes boolean share, unit whichUnit, player whichPlayer returns nothing
    call UnitShareVision(whichUnit, whichPlayer, share)
endfunction

//===========================================================================
function UnitRemoveBuffsBJ takes integer buffType, unit whichUnit returns nothing
    if (buffType == bj_REMOVEBUFFS_POSITIVE) then
        call UnitRemoveBuffs(whichUnit, true, false)
    elseif (buffType == bj_REMOVEBUFFS_NEGATIVE) then
        call UnitRemoveBuffs(whichUnit, false, true)
    elseif (buffType == bj_REMOVEBUFFS_ALL) then
        call UnitRemoveBuffs(whichUnit, true, true)
    elseif (buffType == bj_REMOVEBUFFS_NONTLIFE) then
        call UnitRemoveBuffsEx(whichUnit, true, true, false, false, false, true, false)
    else
        // Unrecognized dispel type - ignore the request.
    endif
endfunction

//===========================================================================
function UnitRemoveBuffsExBJ takes integer polarity, integer resist, unit whichUnit, boolean bTLife, boolean bAura returns nothing
    local boolean bPos   = (polarity == bj_BUFF_POLARITY_EITHER) or (polarity == bj_BUFF_POLARITY_POSITIVE)
    local boolean bNeg   = (polarity == bj_BUFF_POLARITY_EITHER) or (polarity == bj_BUFF_POLARITY_NEGATIVE)
    local boolean bMagic = (resist == bj_BUFF_RESIST_BOTH) or (resist == bj_BUFF_RESIST_MAGIC)
    local boolean bPhys  = (resist == bj_BUFF_RESIST_BOTH) or (resist == bj_BUFF_RESIST_PHYSICAL)

    call UnitRemoveBuffsEx(whichUnit, bPos, bNeg, bMagic, bPhys, bTLife, bAura, false)
endfunction

//===========================================================================
function UnitCountBuffsExBJ takes integer polarity, integer resist, unit whichUnit, boolean bTLife, boolean bAura returns integer
    local boolean bPos   = (polarity == bj_BUFF_POLARITY_EITHER) or (polarity == bj_BUFF_POLARITY_POSITIVE)
    local boolean bNeg   = (polarity == bj_BUFF_POLARITY_EITHER) or (polarity == bj_BUFF_POLARITY_NEGATIVE)
    local boolean bMagic = (resist == bj_BUFF_RESIST_BOTH) or (resist == bj_BUFF_RESIST_MAGIC)
    local boolean bPhys  = (resist == bj_BUFF_RESIST_BOTH) or (resist == bj_BUFF_RESIST_PHYSICAL)

    return UnitCountBuffsEx(whichUnit, bPos, bNeg, bMagic, bPhys, bTLife, bAura, false)
endfunction

//===========================================================================
function UnitRemoveAbilityBJ takes integer abilityId, unit whichUnit returns boolean
    return UnitRemoveAbility(whichUnit, abilityId)
endfunction

//===========================================================================
function UnitAddAbilityBJ takes integer abilityId, unit whichUnit returns boolean
    return UnitAddAbility(whichUnit, abilityId)
endfunction

//===========================================================================
function UnitRemoveTypeBJ takes unittype whichType, unit whichUnit returns boolean
    return UnitRemoveType(whichUnit, whichType)
endfunction

//===========================================================================
function UnitAddTypeBJ takes unittype whichType, unit whichUnit returns boolean
    return UnitAddType(whichUnit, whichType)
endfunction

//===========================================================================
function UnitMakeAbilityPermanentBJ takes boolean permanent, integer abilityId, unit whichUnit returns boolean
    return UnitMakeAbilityPermanent(whichUnit, permanent, abilityId)
endfunction

//===========================================================================
function SetUnitExplodedBJ takes unit whichUnit, boolean exploded returns nothing
    call SetUnitExploded(whichUnit, exploded)
endfunction

//===========================================================================
function ExplodeUnitBJ takes unit whichUnit returns nothing
    call SetUnitExploded(whichUnit, true)
    call KillUnit(whichUnit)
endfunction

//===========================================================================
function GetTransportUnitBJ takes nothing returns unit
    return GetTransportUnit()
endfunction

//===========================================================================
function GetLoadedUnitBJ takes nothing returns unit
    return GetLoadedUnit()
endfunction

//===========================================================================
function IsUnitInTransportBJ takes unit whichUnit, unit whichTransport returns boolean
    return IsUnitInTransport(whichUnit, whichTransport)
endfunction

//===========================================================================
function IsUnitLoadedBJ takes unit whichUnit returns boolean
    return IsUnitLoaded(whichUnit)
endfunction

//===========================================================================
function IsUnitIllusionBJ takes unit whichUnit returns boolean
    return IsUnitIllusion(whichUnit)
endfunction

//===========================================================================
// This attempts to replace a unit with a new unit type by creating a new
// unit of the desired type using the old unit's location, facing, etc.
//
function ReplaceUnitBJ takes unit whichUnit, integer newUnitId, integer unitStateMethod returns unit
    local unit    oldUnit = whichUnit
    local unit    newUnit
    local boolean wasHidden
    local integer index
    local item    indexItem
    local real    oldRatio

    // If we have bogus data, don't attempt the replace.
    if (oldUnit == null) then
        set bj_lastReplacedUnit = oldUnit
        return oldUnit
    endif

    // Hide the original unit.
    set wasHidden = IsUnitHidden(oldUnit)
    call ShowUnit(oldUnit, false)

    // Create the replacement unit.
    if (newUnitId == 'ugol') then
        set newUnit = CreateBlightedGoldmine(GetOwningPlayer(oldUnit), GetUnitX(oldUnit), GetUnitY(oldUnit), GetUnitFacing(oldUnit))
    else
        set newUnit = CreateUnit(GetOwningPlayer(oldUnit), newUnitId, GetUnitX(oldUnit), GetUnitY(oldUnit), GetUnitFacing(oldUnit))
    endif

    // Set the unit's life and mana according to the requested method.
    if (unitStateMethod == bj_UNIT_STATE_METHOD_RELATIVE) then
        // Set the replacement's current/max life ratio to that of the old unit.
        // If both units have mana, do the same for mana.
        if (GetUnitState(oldUnit, UNIT_STATE_MAX_LIFE) > 0) then
            set oldRatio = GetUnitState(oldUnit, UNIT_STATE_LIFE) / GetUnitState(oldUnit, UNIT_STATE_MAX_LIFE)
            call SetUnitState(newUnit, UNIT_STATE_LIFE, oldRatio * GetUnitState(newUnit, UNIT_STATE_MAX_LIFE))
        endif

        if (GetUnitState(oldUnit, UNIT_STATE_MAX_MANA) > 0) and (GetUnitState(newUnit, UNIT_STATE_MAX_MANA) > 0) then
            set oldRatio = GetUnitState(oldUnit, UNIT_STATE_MANA) / GetUnitState(oldUnit, UNIT_STATE_MAX_MANA)
            call SetUnitState(newUnit, UNIT_STATE_MANA, oldRatio * GetUnitState(newUnit, UNIT_STATE_MAX_MANA))
        endif
    elseif (unitStateMethod == bj_UNIT_STATE_METHOD_ABSOLUTE) then
        // Set the replacement's current life to that of the old unit.
        // If the new unit has mana, do the same for mana.
        call SetUnitState(newUnit, UNIT_STATE_LIFE, GetUnitState(oldUnit, UNIT_STATE_LIFE))
        if (GetUnitState(newUnit, UNIT_STATE_MAX_MANA) > 0) then
            call SetUnitState(newUnit, UNIT_STATE_MANA, GetUnitState(oldUnit, UNIT_STATE_MANA))
        endif
    elseif (unitStateMethod == bj_UNIT_STATE_METHOD_DEFAULTS) then
        // The newly created unit should already have default life and mana.
    elseif (unitStateMethod == bj_UNIT_STATE_METHOD_MAXIMUM) then
        // Use max life and mana.
        call SetUnitState(newUnit, UNIT_STATE_LIFE, GetUnitState(newUnit, UNIT_STATE_MAX_LIFE))
        call SetUnitState(newUnit, UNIT_STATE_MANA, GetUnitState(newUnit, UNIT_STATE_MAX_MANA))
    else
        // Unrecognized unit state method - ignore the request.
    endif

    // Mirror properties of the old unit onto the new unit.
    //call PauseUnit(newUnit, IsUnitPaused(oldUnit))
    call SetResourceAmount(newUnit, GetResourceAmount(oldUnit))

    // If both the old and new units are heroes, handle their hero info.
    if (IsUnitType(oldUnit, UNIT_TYPE_HERO) and IsUnitType(newUnit, UNIT_TYPE_HERO)) then
        call SetHeroXP(newUnit, GetHeroXP(oldUnit), false)

        set index = 0
        loop
            set indexItem = UnitItemInSlot(oldUnit, index)
            if (indexItem != null) then
                call UnitRemoveItem(oldUnit, indexItem)
                call UnitAddItem(newUnit, indexItem)
            endif

            set index = index + 1
            exitwhen index >= bj_MAX_INVENTORY
        endloop
    endif

    // Remove or kill the original unit.  It is sometimes unsafe to remove
    // hidden units, so kill the original unit if it was previously hidden.
    if wasHidden then
        call KillUnit(oldUnit)
        call RemoveUnit(oldUnit)
    else
        call RemoveUnit(oldUnit)
    endif

    set bj_lastReplacedUnit = newUnit
    return newUnit
endfunction

//===========================================================================
function GetLastReplacedUnitBJ takes nothing returns unit
    return bj_lastReplacedUnit
endfunction

//===========================================================================
function SetUnitPositionLocFacingBJ takes unit whichUnit, location loc, real facing returns nothing
    call SetUnitPositionLoc(whichUnit, loc)
    call SetUnitFacing(whichUnit, facing)
endfunction

//===========================================================================
function SetUnitPositionLocFacingLocBJ takes unit whichUnit, location loc, location lookAt returns nothing
    call SetUnitPositionLoc(whichUnit, loc)
    call SetUnitFacing(whichUnit, AngleBetweenPoints(loc, lookAt))
endfunction

//===========================================================================
function AddItemToStockBJ takes integer itemId, unit whichUnit, integer currentStock, integer stockMax returns nothing
    call AddItemToStock(whichUnit, itemId, currentStock, stockMax)
endfunction

//===========================================================================
function AddUnitToStockBJ takes integer unitId, unit whichUnit, integer currentStock, integer stockMax returns nothing
    call AddUnitToStock(whichUnit, unitId, currentStock, stockMax)
endfunction

//===========================================================================
function RemoveItemFromStockBJ takes integer itemId, unit whichUnit returns nothing
    call RemoveItemFromStock(whichUnit, itemId)
endfunction

//===========================================================================
function RemoveUnitFromStockBJ takes integer unitId, unit whichUnit returns nothing
    call RemoveUnitFromStock(whichUnit, unitId)
endfunction

//===========================================================================
function SetUnitUseFoodBJ takes boolean enable, unit whichUnit returns nothing
    call SetUnitUseFood(whichUnit, enable)
endfunction

//===========================================================================
function UnitDamagePointLoc takes unit whichUnit, real delay, real radius, location loc, real amount, attacktype whichAttack, damagetype whichDamage returns boolean
    return UnitDamagePoint(whichUnit, delay, radius, GetLocationX(loc), GetLocationY(loc), amount, true, false, whichAttack, whichDamage, WEAPON_TYPE_WHOKNOWS)
endfunction

//===========================================================================
function UnitDamageTargetBJ takes unit whichUnit, unit target, real amount, attacktype whichAttack, damagetype whichDamage returns boolean
    return UnitDamageTarget(whichUnit, target, amount, true, false, whichAttack, whichDamage, WEAPON_TYPE_WHOKNOWS)
endfunction



//***************************************************************************
//*
//*  Destructable Utility Functions
//*
//***************************************************************************

//===========================================================================
function CreateDestructableLoc takes integer objectid, location loc, real facing, real scale, integer variation returns destructable
    set bj_lastCreatedDestructable = CreateDestructable(objectid, GetLocationX(loc), GetLocationY(loc), facing, scale, variation)
    return bj_lastCreatedDestructable
endfunction

//===========================================================================
function CreateDeadDestructableLocBJ takes integer objectid, location loc, real facing, real scale, integer variation returns destructable
    set bj_lastCreatedDestructable = CreateDeadDestructable(objectid, GetLocationX(loc), GetLocationY(loc), facing, scale, variation)
    return bj_lastCreatedDestructable
endfunction

//===========================================================================
function GetLastCreatedDestructable takes nothing returns destructable
    return bj_lastCreatedDestructable
endfunction

//===========================================================================
function ShowDestructableBJ takes boolean flag, destructable d returns nothing
    call ShowDestructable(d, flag)
endfunction

//===========================================================================
function SetDestructableInvulnerableBJ takes destructable d, boolean flag returns nothing
    call SetDestructableInvulnerable(d, flag)
endfunction

//===========================================================================
function IsDestructableInvulnerableBJ takes destructable d returns boolean
    return IsDestructableInvulnerable(d)
endfunction

//===========================================================================
function GetDestructableLoc takes destructable whichDestructable returns location
    return Location(GetDestructableX(whichDestructable), GetDestructableY(whichDestructable))
endfunction

//===========================================================================
function EnumDestructablesInRectAll takes rect r, code actionFunc returns nothing
    call EnumDestructablesInRect(r, null, actionFunc)
endfunction

//===========================================================================
function EnumDestructablesInCircleBJFilter takes nothing returns boolean
    local location destLoc = GetDestructableLoc(GetFilterDestructable())
    local boolean result

    set result = DistanceBetweenPoints(destLoc, bj_enumDestructableCenter) <= bj_enumDestructableRadius
    call RemoveLocation(destLoc)
    return result
endfunction

//===========================================================================
function IsDestructableDeadBJ takes destructable d returns boolean
    return GetDestructableLife(d) <= 0
endfunction

//===========================================================================
function IsDestructableAliveBJ takes destructable d returns boolean
    return not IsDestructableDeadBJ(d)
endfunction

//===========================================================================
// See GroupPickRandomUnitEnum for the details of this algorithm.
//
function RandomDestructableInRectBJEnum takes nothing returns nothing
    set bj_destRandomConsidered = bj_destRandomConsidered + 1
    if (GetRandomInt(1,bj_destRandomConsidered) == 1) then
        set bj_destRandomCurrentPick = GetEnumDestructable()
    endif
endfunction

//===========================================================================
// Picks a random destructable from within a rect, matching a condition
//
function RandomDestructableInRectBJ takes rect r, boolexpr filter returns destructable
    set bj_destRandomConsidered = 0
    set bj_destRandomCurrentPick = null
    call EnumDestructablesInRect(r, filter, function RandomDestructableInRectBJEnum)
    call DestroyBoolExpr(filter)
    return bj_destRandomCurrentPick
endfunction

//===========================================================================
// Picks a random destructable from within a rect
//
function RandomDestructableInRectSimpleBJ takes rect r returns destructable
    return RandomDestructableInRectBJ(r, null)
endfunction

//===========================================================================
// Enumerates within a rect, with a filter to narrow the enumeration down
// objects within a circular area.
//
function EnumDestructablesInCircleBJ takes real radius, location loc, code actionFunc returns nothing
    local rect r

    if (radius >= 0) then
        set bj_enumDestructableCenter = loc
        set bj_enumDestructableRadius = radius
        set r = GetRectFromCircleBJ(loc, radius)
        call EnumDestructablesInRect(r, filterEnumDestructablesInCircleBJ, actionFunc)
        call RemoveRect(r)
    endif
endfunction

//===========================================================================
function SetDestructableLifePercentBJ takes destructable d, real percent returns nothing
    call SetDestructableLife(d, GetDestructableMaxLife(d) * percent * 0.01)
endfunction

//===========================================================================
function SetDestructableMaxLifeBJ takes destructable d, real max returns nothing
    call SetDestructableMaxLife(d, max)
endfunction

//===========================================================================
function ModifyGateBJ takes integer gateOperation, destructable d returns nothing
    if (gateOperation == bj_GATEOPERATION_CLOSE) then
        if (GetDestructableLife(d) <= 0) then
            call DestructableRestoreLife(d, GetDestructableMaxLife(d), true)
        endif
        call SetDestructableAnimation(d, "stand")
    elseif (gateOperation == bj_GATEOPERATION_OPEN) then
        if (GetDestructableLife(d) > 0) then
            call KillDestructable(d)
        endif
        call SetDestructableAnimation(d, "death alternate")
    elseif (gateOperation == bj_GATEOPERATION_DESTROY) then
        if (GetDestructableLife(d) > 0) then
            call KillDestructable(d)
        endif
        call SetDestructableAnimation(d, "death")
    else
        // Unrecognized gate state - ignore the request.
    endif
endfunction

//===========================================================================
// Determine the elevator's height from its occlusion height.
//
function GetElevatorHeight takes destructable d returns integer
    local integer height

    set height = 1 + R2I(GetDestructableOccluderHeight(d) / bj_CLIFFHEIGHT)
    if (height < 1) or (height > 3) then
        set height = 1
    endif
    return height
endfunction

//===========================================================================
// To properly animate an elevator, we must know not only what height we
// want to change to, but also what height we are currently at.  This code
// determines the elevator's current height from its occlusion height.
// Arbitrarily changing an elevator's occlusion height is thus inadvisable.
//
function ChangeElevatorHeight takes destructable d, integer newHeight returns nothing
    local integer oldHeight

    // Cap the new height within the supported range.
    set newHeight = IMaxBJ(1, newHeight)
    set newHeight = IMinBJ(3, newHeight)

    // Find out what height the elevator is already at.
    set oldHeight = GetElevatorHeight(d)

    // Set the elevator's occlusion height.
    call SetDestructableOccluderHeight(d, bj_CLIFFHEIGHT*(newHeight-1))

    if (newHeight == 1) then
        if (oldHeight == 2) then
            call SetDestructableAnimation(d, "birth")
            call QueueDestructableAnimation(d, "stand")
        elseif (oldHeight == 3) then
            call SetDestructableAnimation(d, "birth third")
            call QueueDestructableAnimation(d, "stand")
        else
            // Unrecognized old height - snap to new height.
            call SetDestructableAnimation(d, "stand")
        endif
    elseif (newHeight == 2) then
        if (oldHeight == 1) then
            call SetDestructableAnimation(d, "death")
            call QueueDestructableAnimation(d, "stand second")
        elseif (oldHeight == 3) then
            call SetDestructableAnimation(d, "birth second")
            call QueueDestructableAnimation(d, "stand second")
        else
            // Unrecognized old height - snap to new height.
            call SetDestructableAnimation(d, "stand second")
        endif
    elseif (newHeight == 3) then
        if (oldHeight == 1) then
            call SetDestructableAnimation(d, "death third")
            call QueueDestructableAnimation(d, "stand third")
        elseif (oldHeight == 2) then
            call SetDestructableAnimation(d, "death second")
            call QueueDestructableAnimation(d, "stand third")
        else
            // Unrecognized old height - snap to new height.
            call SetDestructableAnimation(d, "stand third")
        endif
    else
        // Unrecognized new height - ignore the request.
    endif
endfunction

//===========================================================================
// Grab the unit and throw his own coords in his face, forcing him to push
// and shove until he finds a spot where noone will bother him.
//
function NudgeUnitsInRectEnum takes nothing returns nothing
    local unit nudgee = GetEnumUnit()

    call SetUnitPosition(nudgee, GetUnitX(nudgee), GetUnitY(nudgee))
endfunction

//===========================================================================
function NudgeItemsInRectEnum takes nothing returns nothing
    local item nudgee = GetEnumItem()

    call SetItemPosition(nudgee, GetItemX(nudgee), GetItemY(nudgee))
endfunction

//===========================================================================
// Nudge the items and units within a given rect ever so gently, so as to
// encourage them to find locations where they can peacefully coexist with
// pathing restrictions and live happy, fruitful lives.
//
function NudgeObjectsInRect takes rect nudgeArea returns nothing
    local group        g

    set g = CreateGroup()
    call GroupEnumUnitsInRect(g, nudgeArea, null)
    call ForGroup(g, function NudgeUnitsInRectEnum)
    call DestroyGroup(g)

    call EnumItemsInRect(nudgeArea, null, function NudgeItemsInRectEnum)
endfunction

//===========================================================================
function NearbyElevatorExistsEnum takes nothing returns nothing
    local destructable d     = GetEnumDestructable()
    local integer      dType = GetDestructableTypeId(d)

    if (dType == bj_ELEVATOR_CODE01) or (dType == bj_ELEVATOR_CODE02) then
        set bj_elevatorNeighbor = d
    endif
endfunction

//===========================================================================
function NearbyElevatorExists takes real x, real y returns boolean
    local real findThreshold = 32
    local rect r

    // If another elevator is overlapping this one, ignore the wall.
    set r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold)
    set bj_elevatorNeighbor = null
    call EnumDestructablesInRect(r, null, function NearbyElevatorExistsEnum)
    call RemoveRect(r)

    return bj_elevatorNeighbor != null
endfunction

//===========================================================================
function FindElevatorWallBlockerEnum takes nothing returns nothing
    set bj_elevatorWallBlocker = GetEnumDestructable()
endfunction

//===========================================================================
// This toggles pathing on or off for one wall of an elevator by killing
// or reviving a pathing blocker at the appropriate location (and creating
// the pathing blocker in the first place, if it does not yet exist).
//
function ChangeElevatorWallBlocker takes real x, real y, real facing, boolean open returns nothing
    local destructable blocker = null
    local real         findThreshold = 32
    local real         nudgeLength   = 4.25 * bj_CELLWIDTH
    local real         nudgeWidth    = 1.25 * bj_CELLWIDTH
    local rect         r

    // Search for the pathing blocker within the general area.
    set r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold)
    set bj_elevatorWallBlocker = null
    call EnumDestructablesInRect(r, null, function FindElevatorWallBlockerEnum)
    call RemoveRect(r)
    set blocker = bj_elevatorWallBlocker

    // Ensure that the blocker exists.
    if (blocker == null) then
        set blocker = CreateDeadDestructable(bj_ELEVATOR_BLOCKER_CODE, x, y, facing, 1, 0)
    elseif (GetDestructableTypeId(blocker) != bj_ELEVATOR_BLOCKER_CODE) then
        // If a different destructible exists in the blocker's spot, ignore
        // the request.  (Two destructibles cannot occupy the same location
        // on the map, so we cannot create an elevator blocker here.)
        return
    endif

    if (open) then
        // Ensure that the blocker is dead.
        if (GetDestructableLife(blocker) > 0) then
            call KillDestructable(blocker)
        endif
    else
        // Ensure that the blocker is alive.
        if (GetDestructableLife(blocker) <= 0) then
            call DestructableRestoreLife(blocker, GetDestructableMaxLife(blocker), false)
        endif

        // Nudge any objects standing in the blocker's way.
        if (facing == 0) then
            set r = Rect(x - nudgeWidth/2, y - nudgeLength/2, x + nudgeWidth/2, y + nudgeLength/2)
            call NudgeObjectsInRect(r)
            call RemoveRect(r)
        elseif (facing == 90) then
            set r = Rect(x - nudgeLength/2, y - nudgeWidth/2, x + nudgeLength/2, y + nudgeWidth/2)
            call NudgeObjectsInRect(r)
            call RemoveRect(r)
        else
            // Unrecognized blocker angle - don't nudge anything.
        endif
    endif
endfunction

//===========================================================================
function ChangeElevatorWalls takes boolean open, integer walls, destructable d returns nothing
    local real x = GetDestructableX(d)
    local real y = GetDestructableY(d)
    local real distToBlocker = 192
    local real distToNeighbor = 256

    if (walls == bj_ELEVATOR_WALL_TYPE_ALL) or (walls == bj_ELEVATOR_WALL_TYPE_EAST) then
        if (not NearbyElevatorExists(x + distToNeighbor, y)) then
            call ChangeElevatorWallBlocker(x + distToBlocker, y, 0, open)
        endif
    endif

    if (walls == bj_ELEVATOR_WALL_TYPE_ALL) or (walls == bj_ELEVATOR_WALL_TYPE_NORTH) then
        if (not NearbyElevatorExists(x, y + distToNeighbor)) then
            call ChangeElevatorWallBlocker(x, y + distToBlocker, 90, open)
        endif
    endif

    if (walls == bj_ELEVATOR_WALL_TYPE_ALL) or (walls == bj_ELEVATOR_WALL_TYPE_SOUTH) then
        if (not NearbyElevatorExists(x, y - distToNeighbor)) then
            call ChangeElevatorWallBlocker(x, y - distToBlocker, 90, open)
        endif
    endif

    if (walls == bj_ELEVATOR_WALL_TYPE_ALL) or (walls == bj_ELEVATOR_WALL_TYPE_WEST) then
        if (not NearbyElevatorExists(x - distToNeighbor, y)) then
            call ChangeElevatorWallBlocker(x - distToBlocker, y, 0, open)
        endif
    endif
endfunction



//***************************************************************************
//*
//*  Neutral Building Utility Functions
//*
//***************************************************************************

//===========================================================================
function WaygateActivateBJ takes boolean activate, unit waygate returns nothing
    call WaygateActivate(waygate, activate)
endfunction

//===========================================================================
function WaygateIsActiveBJ takes unit waygate returns boolean
    return WaygateIsActive(waygate)
endfunction

//===========================================================================
function WaygateSetDestinationLocBJ takes unit waygate, location loc returns nothing
    call WaygateSetDestination(waygate, GetLocationX(loc), GetLocationY(loc))
endfunction

//===========================================================================
function WaygateGetDestinationLocBJ takes unit waygate returns location
    return Location(WaygateGetDestinationX(waygate), WaygateGetDestinationY(waygate))
endfunction

//===========================================================================
function UnitSetUsesAltIconBJ takes boolean flag, unit whichUnit returns nothing
    call UnitSetUsesAltIcon(whichUnit, flag)
endfunction



//***************************************************************************
//*
//*  UI Utility Functions
//*
//***************************************************************************

//===========================================================================
function ForceUIKeyBJ takes player whichPlayer, string key returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ForceUIKey(key)
    endif
endfunction

//===========================================================================
function ForceUICancelBJ takes player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ForceUICancel()
    endif
endfunction



//***************************************************************************
//*
//*  Group and Force Utility Functions
//*
//***************************************************************************

//===========================================================================
function ForGroupBJ takes group whichGroup, code callback returns nothing
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    call ForGroup(whichGroup, callback)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(whichGroup)
    endif
endfunction

//===========================================================================
function GroupAddUnitSimple takes unit whichUnit, group whichGroup returns nothing
    call GroupAddUnit(whichGroup, whichUnit)
endfunction

//===========================================================================
function GroupRemoveUnitSimple takes unit whichUnit, group whichGroup returns nothing
    call GroupRemoveUnit(whichGroup, whichUnit)
endfunction

//===========================================================================
function GroupAddGroupEnum takes nothing returns nothing
    call GroupAddUnit(bj_groupAddGroupDest, GetEnumUnit())
endfunction

//===========================================================================
function GroupAddGroup takes group sourceGroup, group destGroup returns nothing
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_groupAddGroupDest = destGroup
    call ForGroup(sourceGroup, function GroupAddGroupEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(sourceGroup)
    endif
endfunction

//===========================================================================
function GroupRemoveGroupEnum takes nothing returns nothing
    call GroupRemoveUnit(bj_groupRemoveGroupDest, GetEnumUnit())
endfunction

//===========================================================================
function GroupRemoveGroup takes group sourceGroup, group destGroup returns nothing
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_groupRemoveGroupDest = destGroup
    call ForGroup(sourceGroup, function GroupRemoveGroupEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(sourceGroup)
    endif
endfunction

//===========================================================================
function ForceAddPlayerSimple takes player whichPlayer, force whichForce returns nothing
    call ForceAddPlayer(whichForce, whichPlayer)
endfunction

//===========================================================================
function ForceRemovePlayerSimple takes player whichPlayer, force whichForce returns nothing
    call ForceRemovePlayer(whichForce, whichPlayer)
endfunction

//===========================================================================
// Consider each unit, one at a time, keeping a "current pick".   Once all units
// are considered, this "current pick" will be the resulting random unit.
//
// The chance of picking a given unit over the "current pick" is 1/N, where N is
// the number of units considered thusfar (including the current consideration).
//
function GroupPickRandomUnitEnum takes nothing returns nothing
    set bj_groupRandomConsidered = bj_groupRandomConsidered + 1
    if (GetRandomInt(1,bj_groupRandomConsidered) == 1) then
        set bj_groupRandomCurrentPick = GetEnumUnit()
    endif
endfunction

//===========================================================================
// Picks a random unit from a group.
//
function GroupPickRandomUnit takes group whichGroup returns unit
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_groupRandomConsidered = 0
    set bj_groupRandomCurrentPick = null
    call ForGroup(whichGroup, function GroupPickRandomUnitEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(whichGroup)
    endif
    return bj_groupRandomCurrentPick
endfunction

//===========================================================================
// See GroupPickRandomUnitEnum for the details of this algorithm.
//
function ForcePickRandomPlayerEnum takes nothing returns nothing
    set bj_forceRandomConsidered = bj_forceRandomConsidered + 1
    if (GetRandomInt(1,bj_forceRandomConsidered) == 1) then
        set bj_forceRandomCurrentPick = GetEnumPlayer()
    endif
endfunction

//===========================================================================
// Picks a random player from a force.
//
function ForcePickRandomPlayer takes force whichForce returns player
    set bj_forceRandomConsidered = 0
    set bj_forceRandomCurrentPick = null
    call ForForce(whichForce, function ForcePickRandomPlayerEnum)
    return bj_forceRandomCurrentPick
endfunction

//===========================================================================
function EnumUnitsSelected takes player whichPlayer, boolexpr enumFilter, code enumAction returns nothing
    local group g = CreateGroup()
    call SyncSelections()
    call GroupEnumUnitsSelected(g, whichPlayer, enumFilter)
    call DestroyBoolExpr(enumFilter)
    call ForGroup(g, enumAction)
    call DestroyGroup(g)
endfunction

//===========================================================================
function GetUnitsInRectMatching takes rect r, boolexpr filter returns group
    local group g = CreateGroup()
    call GroupEnumUnitsInRect(g, r, filter)
    call DestroyBoolExpr(filter)
    return g
endfunction

//===========================================================================
function GetUnitsInRectAll takes rect r returns group
    return GetUnitsInRectMatching(r, null)
endfunction

//===========================================================================
function GetUnitsInRectOfPlayerFilter takes nothing returns boolean
    return GetOwningPlayer(GetFilterUnit()) == bj_groupEnumOwningPlayer
endfunction

//===========================================================================
function GetUnitsInRectOfPlayer takes rect r, player whichPlayer returns group
    local group g = CreateGroup()
    set bj_groupEnumOwningPlayer = whichPlayer
    call GroupEnumUnitsInRect(g, r, filterGetUnitsInRectOfPlayer)
    return g
endfunction

//===========================================================================
function GetUnitsInRangeOfLocMatching takes real radius, location whichLocation, boolexpr filter returns group
    local group g = CreateGroup()
    call GroupEnumUnitsInRangeOfLoc(g, whichLocation, radius, filter)
    call DestroyBoolExpr(filter)
    return g
endfunction

//===========================================================================
function GetUnitsInRangeOfLocAll takes real radius, location whichLocation returns group
    return GetUnitsInRangeOfLocMatching(radius, whichLocation, null)
endfunction

//===========================================================================
function GetUnitsOfTypeIdAllFilter takes nothing returns boolean
    return GetUnitTypeId(GetFilterUnit()) == bj_groupEnumTypeId
endfunction

//===========================================================================
function GetUnitsOfTypeIdAll takes integer unitid returns group
    local group   result = CreateGroup()
    local group   g      = CreateGroup()
    local integer index

    set index = 0
    loop
        set bj_groupEnumTypeId = unitid
        call GroupClear(g)
        call GroupEnumUnitsOfPlayer(g, Player(index), filterGetUnitsOfTypeIdAll)
        call GroupAddGroup(g, result)

        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop
    call DestroyGroup(g)

    return result
endfunction

//===========================================================================
function GetUnitsOfPlayerMatching takes player whichPlayer, boolexpr filter returns group
    local group g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, whichPlayer, filter)
    call DestroyBoolExpr(filter)
    return g
endfunction

//===========================================================================
function GetUnitsOfPlayerAll takes player whichPlayer returns group
    return GetUnitsOfPlayerMatching(whichPlayer, null)
endfunction

//===========================================================================
function GetUnitsOfPlayerAndTypeIdFilter takes nothing returns boolean
    return GetUnitTypeId(GetFilterUnit()) == bj_groupEnumTypeId
endfunction

//===========================================================================
function GetUnitsOfPlayerAndTypeId takes player whichPlayer, integer unitid returns group
    local group g = CreateGroup()
    set bj_groupEnumTypeId = unitid
    call GroupEnumUnitsOfPlayer(g, whichPlayer, filterGetUnitsOfPlayerAndTypeId)
    return g
endfunction

//===========================================================================
function GetUnitsSelectedAll takes player whichPlayer returns group
    local group g = CreateGroup()
    call SyncSelections()
    call GroupEnumUnitsSelected(g, whichPlayer, null)
    return g
endfunction

//===========================================================================
function GetForceOfPlayer takes player whichPlayer returns force
    local force f = CreateForce()
    call ForceAddPlayer(f, whichPlayer)
    return f
endfunction

//===========================================================================
function GetPlayersAll takes nothing returns force
    return bj_FORCE_ALL_PLAYERS
endfunction

//===========================================================================
function GetPlayersByMapControl takes mapcontrol whichControl returns force
    local force f = CreateForce()
    local integer playerIndex
    local player  indexPlayer

    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if GetPlayerController(indexPlayer) == whichControl then
            call ForceAddPlayer(f, indexPlayer)
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYER_SLOTS
    endloop

    return f
endfunction

//===========================================================================
function GetPlayersAllies takes player whichPlayer returns force
    local force f = CreateForce()
    call ForceEnumAllies(f, whichPlayer, null)
    return f
endfunction

//===========================================================================
function GetPlayersEnemies takes player whichPlayer returns force
    local force f = CreateForce()
    call ForceEnumEnemies(f, whichPlayer, null)
    return f
endfunction

//===========================================================================
function GetPlayersMatching takes boolexpr filter returns force
    local force f = CreateForce()
    call ForceEnumPlayers(f, filter)
    call DestroyBoolExpr(filter)
    return f
endfunction

//===========================================================================
function CountUnitsInGroupEnum takes nothing returns nothing
    set bj_groupCountUnits = bj_groupCountUnits + 1
endfunction

//===========================================================================
function CountUnitsInGroup takes group g returns integer
    // If the user wants the group destroyed, remember that fact and clear
    // the flag, in case it is used again in the callback.
    local boolean wantDestroy = bj_wantDestroyGroup
    set bj_wantDestroyGroup = false

    set bj_groupCountUnits = 0
    call ForGroup(g, function CountUnitsInGroupEnum)

    // If the user wants the group destroyed, do so now.
    if (wantDestroy) then
        call DestroyGroup(g)
    endif
    return bj_groupCountUnits
endfunction

//===========================================================================
function CountPlayersInForceEnum takes nothing returns nothing
    set bj_forceCountPlayers = bj_forceCountPlayers + 1
endfunction

//===========================================================================
function CountPlayersInForceBJ takes force f returns integer
    set bj_forceCountPlayers = 0
    call ForForce(f, function CountPlayersInForceEnum)
    return bj_forceCountPlayers
endfunction

//===========================================================================
function GetRandomSubGroupEnum takes nothing returns nothing
    if (bj_randomSubGroupWant > 0) then
        if (bj_randomSubGroupWant >= bj_randomSubGroupTotal) or (GetRandomReal(0,1) < bj_randomSubGroupChance) then
            // We either need every remaining unit, or the unit passed its chance check.
            call GroupAddUnit(bj_randomSubGroupGroup, GetEnumUnit())
            set bj_randomSubGroupWant = bj_randomSubGroupWant - 1
        endif
    endif
    set bj_randomSubGroupTotal = bj_randomSubGroupTotal - 1
endfunction

//===========================================================================
function GetRandomSubGroup takes integer count, group sourceGroup returns group
    local group g = CreateGroup()

    set bj_randomSubGroupGroup = g
    set bj_randomSubGroupWant  = count
    set bj_randomSubGroupTotal = CountUnitsInGroup(sourceGroup)

    if (bj_randomSubGroupWant <= 0 or bj_randomSubGroupTotal <= 0) then
        return g
    endif

    set bj_randomSubGroupChance = I2R(bj_randomSubGroupWant) / I2R(bj_randomSubGroupTotal)
    call ForGroup(sourceGroup, function GetRandomSubGroupEnum)
    return g
endfunction

//===========================================================================
function LivingPlayerUnitsOfTypeIdFilter takes nothing returns boolean
    local unit filterUnit = GetFilterUnit()
    return IsUnitAliveBJ(filterUnit) and GetUnitTypeId(filterUnit) == bj_livingPlayerUnitsTypeId
endfunction

//===========================================================================
function CountLivingPlayerUnitsOfTypeId takes integer unitId, player whichPlayer returns integer
    local group g
    local integer matchedCount

    set g = CreateGroup()
    set bj_livingPlayerUnitsTypeId = unitId
    call GroupEnumUnitsOfPlayer(g, whichPlayer, filterLivingPlayerUnitsOfTypeId)
    set matchedCount = CountUnitsInGroup(g)
    call DestroyGroup(g)

    return matchedCount
endfunction

//===========================================================================
function LivingPlayerBuildingsOfTypeIdFilter takes nothing returns boolean
    local unit filterUnit = GetFilterUnit()
    return IsUnitAliveBJ(filterUnit) and GetUnitTypeId(filterUnit) == bj_livingPlayerUnitsTypeId and IsUnitType(filterUnit,UNIT_TYPE_STRUCTURE) == true
endfunction

//===========================================================================
function CountLivingPlayerBuildingsOfTypeId takes integer unitId, player whichPlayer returns integer
    local group g
    local integer matchedCount

    set g = CreateGroup()
    set bj_livingPlayerUnitsTypeId = unitId
    call GroupEnumUnitsOfPlayer(g, whichPlayer, Filter(function LivingPlayerBuildingsOfTypeIdFilter))
    set matchedCount = CountUnitsInGroup(g)
    call DestroyGroup(g)

    return matchedCount
endfunction


//***************************************************************************
//*
//*  Animation Utility Functions
//*
//***************************************************************************

//===========================================================================
function ResetUnitAnimation takes unit whichUnit returns nothing
    call SetUnitAnimation(whichUnit, "stand")
endfunction

//===========================================================================
function SetUnitTimeScalePercent takes unit whichUnit, real percentScale returns nothing
    call SetUnitTimeScale(whichUnit, percentScale * 0.01)
endfunction

//===========================================================================
function SetUnitScalePercent takes unit whichUnit, real percentScaleX, real percentScaleY, real percentScaleZ returns nothing
    call SetUnitScale(whichUnit, percentScaleX * 0.01, percentScaleY * 0.01, percentScaleZ * 0.01)
endfunction

//===========================================================================
// This version differs from the common.j interface in that the alpha value
// is reversed so as to be displayed as transparency, and all four parameters
// are treated as percentages rather than bytes.
//
function SetUnitVertexColorBJ takes unit whichUnit, real red, real green, real blue, real transparency returns nothing
    call SetUnitVertexColor(whichUnit, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function UnitAddIndicatorBJ takes unit whichUnit, real red, real green, real blue, real transparency returns nothing
    call AddIndicator(whichUnit, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function DestructableAddIndicatorBJ takes destructable whichDestructable, real red, real green, real blue, real transparency returns nothing
    call AddIndicator(whichDestructable, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function ItemAddIndicatorBJ takes item whichItem, real red, real green, real blue, real transparency returns nothing
    call AddIndicator(whichItem, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
// Sets a unit's facing to point directly at a location.
//
function SetUnitFacingToFaceLocTimed takes unit whichUnit, location target, real duration returns nothing
    local location unitLoc = GetUnitLoc(whichUnit)

    call SetUnitFacingTimed(whichUnit, AngleBetweenPoints(unitLoc, target), duration)
    call RemoveLocation(unitLoc)
endfunction

//===========================================================================
// Sets a unit's facing to point directly at another unit.
//
function SetUnitFacingToFaceUnitTimed takes unit whichUnit, unit target, real duration returns nothing
    local location unitLoc = GetUnitLoc(target)

    call SetUnitFacingToFaceLocTimed(whichUnit, unitLoc, duration)
    call RemoveLocation(unitLoc)
endfunction

//===========================================================================
function QueueUnitAnimationBJ takes unit whichUnit, string whichAnimation returns nothing
    call QueueUnitAnimation(whichUnit, whichAnimation)
endfunction

//===========================================================================
function SetDestructableAnimationBJ takes destructable d, string whichAnimation returns nothing
    call SetDestructableAnimation(d, whichAnimation)
endfunction

//===========================================================================
function QueueDestructableAnimationBJ takes destructable d, string whichAnimation returns nothing
    call QueueDestructableAnimation(d, whichAnimation)
endfunction

//===========================================================================
function SetDestAnimationSpeedPercent takes destructable d, real percentScale returns nothing
    call SetDestructableAnimationSpeed(d, percentScale * 0.01)
endfunction



//***************************************************************************
//*
//*  Dialog Utility Functions
//*
//***************************************************************************

//===========================================================================
function DialogDisplayBJ takes boolean flag, dialog whichDialog, player whichPlayer returns nothing
    call DialogDisplay(whichPlayer, whichDialog, flag)
endfunction

//===========================================================================
function DialogSetMessageBJ takes dialog whichDialog, string message returns nothing
    call DialogSetMessage(whichDialog, message)
endfunction

//===========================================================================
function DialogAddButtonBJ takes dialog whichDialog, string buttonText returns button
    set bj_lastCreatedButton = DialogAddButton(whichDialog, buttonText,0)
    return bj_lastCreatedButton
endfunction

//===========================================================================
function DialogAddButtonWithHotkeyBJ takes dialog whichDialog, string buttonText, integer hotkey returns button
    set bj_lastCreatedButton = DialogAddButton(whichDialog, buttonText,hotkey)
    return bj_lastCreatedButton
endfunction

//===========================================================================
function DialogClearBJ takes dialog whichDialog returns nothing
    call DialogClear(whichDialog)
endfunction

//===========================================================================
function GetLastCreatedButtonBJ takes nothing returns button
    return bj_lastCreatedButton
endfunction

//===========================================================================
function GetClickedButtonBJ takes nothing returns button
    return GetClickedButton()
endfunction

//===========================================================================
function GetClickedDialogBJ takes nothing returns dialog
    return GetClickedDialog()
endfunction



//***************************************************************************
//*
//*  Alliance Utility Functions
//*
//***************************************************************************

//===========================================================================
function SetPlayerAllianceBJ takes player sourcePlayer, alliancetype whichAllianceSetting, boolean value, player otherPlayer returns nothing
    // Prevent players from attempting to ally with themselves.
    if (sourcePlayer == otherPlayer) then
        return
    endif

    call SetPlayerAlliance(sourcePlayer, otherPlayer, whichAllianceSetting, value)
endfunction

//===========================================================================
// Set all flags used by the in-game "Ally" checkbox.
//
function SetPlayerAllianceStateAllyBJ takes player sourcePlayer, player otherPlayer, boolean flag returns nothing
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_PASSIVE,       flag)
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_HELP_REQUEST,  flag)
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_HELP_RESPONSE, flag)
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_XP,     flag)
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_SPELLS, flag)
endfunction

//===========================================================================
// Set all flags used by the in-game "Shared Vision" checkbox.
//
function SetPlayerAllianceStateVisionBJ takes player sourcePlayer, player otherPlayer, boolean flag returns nothing
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_VISION, flag)
endfunction

//===========================================================================
// Set all flags used by the in-game "Shared Units" checkbox.
//
function SetPlayerAllianceStateControlBJ takes player sourcePlayer, player otherPlayer, boolean flag returns nothing
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_CONTROL, flag)
endfunction

//===========================================================================
// Set all flags used by the in-game "Shared Units" checkbox with the Full
// Shared Unit Control feature enabled.
//
function SetPlayerAllianceStateFullControlBJ takes player sourcePlayer, player otherPlayer, boolean flag returns nothing
    call SetPlayerAlliance(sourcePlayer, otherPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, flag)
endfunction

//===========================================================================
function SetPlayerAllianceStateBJ takes player sourcePlayer, player otherPlayer, integer allianceState returns nothing
    // Prevent players from attempting to ally with themselves.
    if (sourcePlayer == otherPlayer) then
        return
    endif

    if allianceState == bj_ALLIANCE_UNALLIED then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
    elseif allianceState == bj_ALLIANCE_UNALLIED_VISION then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
    elseif allianceState == bj_ALLIANCE_ALLIED then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
    elseif allianceState == bj_ALLIANCE_ALLIED_VISION then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
    elseif allianceState == bj_ALLIANCE_ALLIED_UNITS then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
    elseif allianceState == bj_ALLIANCE_ALLIED_ADVUNITS then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, true  )
    elseif allianceState == bj_ALLIANCE_NEUTRAL then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
        call SetPlayerAlliance( sourcePlayer, otherPlayer, ALLIANCE_PASSIVE, true )
    elseif allianceState == bj_ALLIANCE_NEUTRAL_VISION then
        call SetPlayerAllianceStateAllyBJ(        sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateVisionBJ(      sourcePlayer, otherPlayer, true  )
        call SetPlayerAllianceStateControlBJ(     sourcePlayer, otherPlayer, false )
        call SetPlayerAllianceStateFullControlBJ( sourcePlayer, otherPlayer, false )
        call SetPlayerAlliance( sourcePlayer, otherPlayer, ALLIANCE_PASSIVE, true )
    else
        // Unrecognized alliance state - ignore the request.
    endif
endfunction

//===========================================================================
// Set the alliance states for an entire force towards another force.
//
function SetForceAllianceStateBJ takes force sourceForce, force targetForce, integer allianceState returns nothing
    local integer sourceIndex
    local integer targetIndex

    set sourceIndex = 0
    loop

        if (sourceForce==bj_FORCE_ALL_PLAYERS or IsPlayerInForce(Player(sourceIndex), sourceForce)) then
            set targetIndex = 0
            loop
                if (targetForce==bj_FORCE_ALL_PLAYERS or IsPlayerInForce(Player(targetIndex), targetForce)) then
                    call SetPlayerAllianceStateBJ(Player(sourceIndex), Player(targetIndex), allianceState)
                endif

                set targetIndex = targetIndex + 1
                exitwhen targetIndex == bj_MAX_PLAYER_SLOTS
            endloop
        endif

        set sourceIndex = sourceIndex + 1
        exitwhen sourceIndex == bj_MAX_PLAYER_SLOTS
    endloop
endfunction

//===========================================================================
// Test to see if two players are co-allied (allied with each other).
//
function PlayersAreCoAllied takes player playerA, player playerB returns boolean
    // Players are considered to be allied with themselves.
    if (playerA == playerB) then
        return true
    endif

    // Co-allies are both allied with each other.
    if GetPlayerAlliance(playerA, playerB, ALLIANCE_PASSIVE) then
        if GetPlayerAlliance(playerB, playerA, ALLIANCE_PASSIVE) then
            return true
        endif
    endif
    return false
endfunction

//===========================================================================
// Force (whichPlayer) AI player to share vision and advanced unit control 
// with all AI players of its allies.
//
function ShareEverythingWithTeamAI takes player whichPlayer returns nothing
    local integer playerIndex
    local player  indexPlayer

    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if (PlayersAreCoAllied(whichPlayer, indexPlayer) and whichPlayer != indexPlayer) then
            if (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER) then
                call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_VISION, true)
                call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_CONTROL, true)
                call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, true)
            endif
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Force (whichPlayer) to share vision and advanced unit control with all of his/her allies.
//
function ShareEverythingWithTeam takes player whichPlayer returns nothing
    local integer playerIndex
    local player  indexPlayer

    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if (PlayersAreCoAllied(whichPlayer, indexPlayer) and whichPlayer != indexPlayer) then
            call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_VISION, true)
            call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_CONTROL, true)
            call SetPlayerAlliance(indexPlayer, whichPlayer, ALLIANCE_SHARED_CONTROL, true)
            call SetPlayerAlliance(whichPlayer, indexPlayer, ALLIANCE_SHARED_ADVANCED_CONTROL, true)
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Creates a 'Neutral Victim' player slot.  This slot is passive towards all
// other players, but all other players are aggressive towards him/her.
// 
function ConfigureNeutralVictim takes nothing returns nothing
    local integer index
    local player indexPlayer
    local player neutralVictim = Player(bj_PLAYER_NEUTRAL_VICTIM)

    set index = 0
    loop
        set indexPlayer = Player(index)

        call SetPlayerAlliance(neutralVictim, indexPlayer, ALLIANCE_PASSIVE, true)
        call SetPlayerAlliance(indexPlayer, neutralVictim, ALLIANCE_PASSIVE, false)

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // Neutral Victim and Neutral Aggressive should not fight each other.
    set indexPlayer = Player(PLAYER_NEUTRAL_AGGRESSIVE)
    call SetPlayerAlliance(neutralVictim, indexPlayer, ALLIANCE_PASSIVE, true)
    call SetPlayerAlliance(indexPlayer, neutralVictim, ALLIANCE_PASSIVE, true)

    // Neutral Victim does not give bounties.
    call SetPlayerState(neutralVictim, PLAYER_STATE_GIVES_BOUNTY, 0)
endfunction

//===========================================================================
function MakeUnitsPassiveForPlayerEnum takes nothing returns nothing
    call SetUnitOwner(GetEnumUnit(), Player(bj_PLAYER_NEUTRAL_VICTIM), false)
endfunction

//===========================================================================
// Change ownership for every unit of (whichPlayer)'s team to neutral passive.
//
function MakeUnitsPassiveForPlayer takes player whichPlayer returns nothing
    local group   playerUnits = CreateGroup()
    call CachePlayerHeroData(whichPlayer)
    call GroupEnumUnitsOfPlayer(playerUnits, whichPlayer, null)
    call ForGroup(playerUnits, function MakeUnitsPassiveForPlayerEnum)
    call DestroyGroup(playerUnits)
endfunction

//===========================================================================
// Change ownership for every unit of (whichPlayer)'s team to neutral passive.
//
function MakeUnitsPassiveForTeam takes player whichPlayer returns nothing
    local integer playerIndex
    local player  indexPlayer

    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if PlayersAreCoAllied(whichPlayer, indexPlayer) then
            call MakeUnitsPassiveForPlayer(indexPlayer)
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Determine whether or not victory/defeat is disabled via cheat codes.
//
function AllowVictoryDefeat takes playergameresult gameResult returns boolean
    if (gameResult == PLAYER_GAME_RESULT_VICTORY) then
        return not IsNoVictoryCheat()
    endif
    if (gameResult == PLAYER_GAME_RESULT_DEFEAT) then
        return not IsNoDefeatCheat()
    endif
    if (gameResult == PLAYER_GAME_RESULT_NEUTRAL) then
        return (not IsNoVictoryCheat()) and (not IsNoDefeatCheat())
    endif
    return true
endfunction

//===========================================================================
function EndGameBJ takes nothing returns nothing
    call EndGame( true )
endfunction

//===========================================================================
function MeleeVictoryDialogBJ takes player whichPlayer, boolean leftGame returns nothing
    local trigger t = CreateTrigger()
    local dialog  d = DialogCreate()
    local string formatString

    // Display "player was victorious" or "player has left the game" message
    if (leftGame) then
        set formatString = GetLocalizedString( "PLAYER_LEFT_GAME" )
    else
        set formatString = GetLocalizedString( "PLAYER_VICTORIOUS" )
    endif

    call DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, formatString)

    call DialogSetMessage( d, GetLocalizedString( "GAMEOVER_VICTORY_MSG" ) )
    call DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE_GAME" ), GetLocalizedHotkey("GAMEOVER_CONTINUE_GAME") )

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_QUIT_GAME" ), GetLocalizedHotkey("GAMEOVER_QUIT_GAME") ) )

    call DialogDisplay( whichPlayer, d, true )
    call StartSoundForPlayerBJ( whichPlayer, bj_victoryDialogSound )
endfunction

//===========================================================================
function MeleeDefeatDialogBJ takes player whichPlayer, boolean leftGame returns nothing
    local trigger t = CreateTrigger()
    local dialog  d = DialogCreate()
    local string formatString

    // Display "player was defeated" or "player has left the game" message
    if (leftGame) then
        set formatString = GetLocalizedString( "PLAYER_LEFT_GAME" )
    else
        set formatString = GetLocalizedString( "PLAYER_DEFEATED" )
    endif

    call DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, formatString)

    call DialogSetMessage( d, GetLocalizedString( "GAMEOVER_DEFEAT_MSG" ) )

    // Only show the continue button if the game is not over and observers on death are allowed
    if (not bj_meleeGameOver and IsMapFlagSet(MAP_OBSERVERS_ON_DEATH)) then
        call DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE_OBSERVING" ), GetLocalizedHotkey("GAMEOVER_CONTINUE_OBSERVING") )
    endif

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_QUIT_GAME" ), GetLocalizedHotkey("GAMEOVER_QUIT_GAME") ) )

    call DialogDisplay( whichPlayer, d, true )
    call StartSoundForPlayerBJ( whichPlayer, bj_defeatDialogSound )
endfunction

//===========================================================================
function GameOverDialogBJ takes player whichPlayer, boolean leftGame returns nothing
    local trigger t = CreateTrigger()
    local dialog  d = DialogCreate()
    local string  s

    // Display "player left the game" message
    call DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_LEFT_GAME" ))

    if (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0) then
        set s = GetLocalizedString( "GAMEOVER_DISCONNECTED" )
    else
        set s = GetLocalizedString( "GAMEOVER_GAME_OVER" )
    endif

    call DialogSetMessage( d, s )

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddQuitButton( d, true, GetLocalizedString( "GAMEOVER_OK" ), GetLocalizedHotkey("GAMEOVER_OK") ) )

    call DialogDisplay( whichPlayer, d, true )
    call StartSoundForPlayerBJ( whichPlayer, bj_defeatDialogSound )
endfunction

//===========================================================================
function RemovePlayerPreserveUnitsBJ takes player whichPlayer, playergameresult gameResult, boolean leftGame returns nothing
    if AllowVictoryDefeat(gameResult) then

        call RemovePlayer(whichPlayer, gameResult)

        if( gameResult == PLAYER_GAME_RESULT_VICTORY ) then
            call MeleeVictoryDialogBJ( whichPlayer, leftGame )
            return
        elseif( gameResult == PLAYER_GAME_RESULT_DEFEAT ) then
            call MeleeDefeatDialogBJ( whichPlayer, leftGame )
        else
            call GameOverDialogBJ( whichPlayer, leftGame )
        endif

    endif
endfunction

//===========================================================================
function CustomVictoryOkBJ takes nothing returns nothing
    if bj_isSinglePlayer then
        call PauseGame( false )
        // Bump the difficulty back up to the default.
        call SetGameDifficulty(GetDefaultDifficulty())
    endif

    if (bj_changeLevelMapName == null) then
        call EndGame( bj_changeLevelShowScores )
    else
        call ChangeLevel( bj_changeLevelMapName, bj_changeLevelShowScores )
    endif
endfunction

//===========================================================================
function CustomVictoryQuitBJ takes nothing returns nothing
    if bj_isSinglePlayer then
        call PauseGame( false )
        // Bump the difficulty back up to the default.
        call SetGameDifficulty(GetDefaultDifficulty())
    endif

    call EndGame( bj_changeLevelShowScores )
endfunction

//===========================================================================
function CustomVictoryDialogBJ takes player whichPlayer returns nothing
    local trigger t = CreateTrigger()
    local dialog  d = DialogCreate()

    call DialogSetMessage( d, GetLocalizedString( "GAMEOVER_VICTORY_MSG" ) )

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_CONTINUE" ), GetLocalizedHotkey("GAMEOVER_CONTINUE") ) )
    call TriggerAddAction( t, function CustomVictoryOkBJ )

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_QUIT_MISSION" ), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION") ) )
    call TriggerAddAction( t, function CustomVictoryQuitBJ )

    if (GetLocalPlayer() == whichPlayer) then
        call EnableUserControl( true )
        if bj_isSinglePlayer then
            call PauseGame( true )
        endif
        call EnableUserUI(false)
    endif

    call DialogDisplay( whichPlayer, d, true )
    call VolumeGroupSetVolumeForPlayerBJ( whichPlayer, SOUND_VOLUMEGROUP_UI, 1.0 )
    call StartSoundForPlayerBJ( whichPlayer, bj_victoryDialogSound )
endfunction

//===========================================================================
function CustomVictorySkipBJ takes player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        if bj_isSinglePlayer then
            // Bump the difficulty back up to the default.
            call SetGameDifficulty(GetDefaultDifficulty())
        endif

        if (bj_changeLevelMapName == null) then
            call EndGame( bj_changeLevelShowScores )
        else
            call ChangeLevel( bj_changeLevelMapName, bj_changeLevelShowScores )
        endif
    endif
endfunction

//===========================================================================
function CustomVictoryBJ takes player whichPlayer, boolean showDialog, boolean showScores returns nothing
    if AllowVictoryDefeat( PLAYER_GAME_RESULT_VICTORY ) then
        call RemovePlayer( whichPlayer, PLAYER_GAME_RESULT_VICTORY )

        if not bj_isSinglePlayer then
            call DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_VICTORIOUS" ) )
        endif

        // UI only needs to be displayed to users.
        if (GetPlayerController(whichPlayer) == MAP_CONTROL_USER) then
            set bj_changeLevelShowScores = showScores
            if showDialog then
                call CustomVictoryDialogBJ( whichPlayer )
            else
                call CustomVictorySkipBJ( whichPlayer )
            endif
        endif
    endif
endfunction

//===========================================================================
function CustomDefeatRestartBJ takes nothing returns nothing
    call PauseGame( false )
    call RestartGame( true )
endfunction

//===========================================================================
function CustomDefeatReduceDifficultyBJ takes nothing returns nothing
    local gamedifficulty diff = GetGameDifficulty()

    call PauseGame( false )

    // Knock the difficulty down, if possible.
    if (diff == MAP_DIFFICULTY_EASY) then
        // Sorry, but it doesn't get any easier than this.
    elseif (diff == MAP_DIFFICULTY_NORMAL) then
        call SetGameDifficulty(MAP_DIFFICULTY_EASY)
    elseif (diff == MAP_DIFFICULTY_HARD) then
        call SetGameDifficulty(MAP_DIFFICULTY_NORMAL)
    else
        // Unrecognized difficulty
    endif

    call RestartGame( true )
endfunction

//===========================================================================
function CustomDefeatLoadBJ takes nothing returns nothing
    call PauseGame( false )
    call DisplayLoadDialog()
endfunction

//===========================================================================
function CustomDefeatQuitBJ takes nothing returns nothing
    if bj_isSinglePlayer then
        call PauseGame( false )
    endif

    // Bump the difficulty back up to the default.
    call SetGameDifficulty(GetDefaultDifficulty())
    call EndGame( true )
endfunction

//===========================================================================
function CustomDefeatDialogBJ takes player whichPlayer, string message returns nothing
    local trigger t = CreateTrigger()
    local dialog  d = DialogCreate()

    call DialogSetMessage( d, message )

    if bj_isSinglePlayer then
        set t = CreateTrigger()
        call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_RESTART" ), GetLocalizedHotkey("GAMEOVER_RESTART") ) )
        call TriggerAddAction( t, function CustomDefeatRestartBJ )

        if (GetGameDifficulty() != MAP_DIFFICULTY_EASY) then
            set t = CreateTrigger()
            call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_REDUCE_DIFFICULTY" ), GetLocalizedHotkey("GAMEOVER_REDUCE_DIFFICULTY") ) )
            call TriggerAddAction( t, function CustomDefeatReduceDifficultyBJ )
        endif

        set t = CreateTrigger()
        call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_LOAD" ), GetLocalizedHotkey("GAMEOVER_LOAD") ) )
        call TriggerAddAction( t, function CustomDefeatLoadBJ )
    endif

    set t = CreateTrigger()
    call TriggerRegisterDialogButtonEvent( t, DialogAddButton( d, GetLocalizedString( "GAMEOVER_QUIT_MISSION" ), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION") ) )
    call TriggerAddAction( t, function CustomDefeatQuitBJ )

    if (GetLocalPlayer() == whichPlayer) then
        call EnableUserControl( true )
        if bj_isSinglePlayer then
            call PauseGame( true )
        endif
        call EnableUserUI(false)
    endif

    call DialogDisplay( whichPlayer, d, true )
    call VolumeGroupSetVolumeForPlayerBJ( whichPlayer, SOUND_VOLUMEGROUP_UI, 1.0 )
    call StartSoundForPlayerBJ( whichPlayer, bj_defeatDialogSound )
endfunction

//===========================================================================
function CustomDefeatBJ takes player whichPlayer, string message returns nothing
    if AllowVictoryDefeat( PLAYER_GAME_RESULT_DEFEAT ) then
        call RemovePlayer( whichPlayer, PLAYER_GAME_RESULT_DEFEAT )

        if not bj_isSinglePlayer then
            call DisplayTimedTextFromPlayer(whichPlayer, 0, 0, 60, GetLocalizedString( "PLAYER_DEFEATED" ) )
        endif

        // UI only needs to be displayed to users.
        if (GetPlayerController(whichPlayer) == MAP_CONTROL_USER) then
            call CustomDefeatDialogBJ( whichPlayer, message )
        endif
    endif
endfunction

//===========================================================================
function SetNextLevelBJ takes string nextLevel returns nothing
    if (nextLevel == "") then
        set bj_changeLevelMapName = null
    else
        set bj_changeLevelMapName = nextLevel
    endif
endfunction

//===========================================================================
function SetPlayerOnScoreScreenBJ takes boolean flag, player whichPlayer returns nothing
    call SetPlayerOnScoreScreen(whichPlayer, flag)
endfunction



//***************************************************************************
//*
//*  Quest Utility Functions
//*
//***************************************************************************

//===========================================================================
function CreateQuestBJ takes integer questType, string title, string description, string iconPath returns quest
    local boolean required   = (questType == bj_QUESTTYPE_REQ_DISCOVERED) or (questType == bj_QUESTTYPE_REQ_UNDISCOVERED)
    local boolean discovered = (questType == bj_QUESTTYPE_REQ_DISCOVERED) or (questType == bj_QUESTTYPE_OPT_DISCOVERED)

    set bj_lastCreatedQuest = CreateQuest()
    call QuestSetTitle(bj_lastCreatedQuest, title)
    call QuestSetDescription(bj_lastCreatedQuest, description)
    call QuestSetIconPath(bj_lastCreatedQuest, iconPath)
    call QuestSetRequired(bj_lastCreatedQuest, required)
    call QuestSetDiscovered(bj_lastCreatedQuest, discovered)
    call QuestSetCompleted(bj_lastCreatedQuest, false)
    return bj_lastCreatedQuest
endfunction

//===========================================================================
function DestroyQuestBJ takes quest whichQuest returns nothing
    call DestroyQuest(whichQuest)
endfunction

//===========================================================================
function QuestSetEnabledBJ takes boolean enabled, quest whichQuest returns nothing
    call QuestSetEnabled(whichQuest, enabled)
endfunction

//===========================================================================
function QuestSetTitleBJ takes quest whichQuest, string title returns nothing
    call QuestSetTitle(whichQuest, title)
endfunction

//===========================================================================
function QuestSetDescriptionBJ takes quest whichQuest, string description returns nothing
    call QuestSetDescription(whichQuest, description)
endfunction

//===========================================================================
function QuestSetCompletedBJ takes quest whichQuest, boolean completed returns nothing
    call QuestSetCompleted(whichQuest, completed)
endfunction

//===========================================================================
function QuestSetFailedBJ takes quest whichQuest, boolean failed returns nothing
    call QuestSetFailed(whichQuest, failed)
endfunction

//===========================================================================
function QuestSetDiscoveredBJ takes quest whichQuest, boolean discovered returns nothing
    call QuestSetDiscovered(whichQuest, discovered)
endfunction

//===========================================================================
function GetLastCreatedQuestBJ takes nothing returns quest
    return bj_lastCreatedQuest
endfunction

//===========================================================================
function CreateQuestItemBJ takes quest whichQuest, string description returns questitem
    set bj_lastCreatedQuestItem = QuestCreateItem(whichQuest)
    call QuestItemSetDescription(bj_lastCreatedQuestItem, description)
    call QuestItemSetCompleted(bj_lastCreatedQuestItem, false)
    return bj_lastCreatedQuestItem
endfunction

//===========================================================================
function QuestItemSetDescriptionBJ takes questitem whichQuestItem, string description returns nothing
    call QuestItemSetDescription(whichQuestItem, description)
endfunction

//===========================================================================
function QuestItemSetCompletedBJ takes questitem whichQuestItem, boolean completed returns nothing
    call QuestItemSetCompleted(whichQuestItem, completed)
endfunction

//===========================================================================
function GetLastCreatedQuestItemBJ takes nothing returns questitem
    return bj_lastCreatedQuestItem
endfunction

//===========================================================================
function CreateDefeatConditionBJ takes string description returns defeatcondition
    set bj_lastCreatedDefeatCondition = CreateDefeatCondition()
    call DefeatConditionSetDescription(bj_lastCreatedDefeatCondition, description)
    return bj_lastCreatedDefeatCondition
endfunction

//===========================================================================
function DestroyDefeatConditionBJ takes defeatcondition whichCondition returns nothing
    call DestroyDefeatCondition(whichCondition)
endfunction

//===========================================================================
function DefeatConditionSetDescriptionBJ takes defeatcondition whichCondition, string description returns nothing
    call DefeatConditionSetDescription(whichCondition, description)
endfunction

//===========================================================================
function GetLastCreatedDefeatConditionBJ takes nothing returns defeatcondition
    return bj_lastCreatedDefeatCondition
endfunction

//===========================================================================
function FlashQuestDialogButtonBJ takes nothing returns nothing
    call FlashQuestDialogButton()
endfunction

//===========================================================================
function QuestMessageBJ takes force f, integer messageType, string message returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), f)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        if (messageType == bj_QUESTMESSAGE_DISCOVERED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUEST, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUEST, message)
            call StartSound(bj_questDiscoveredSound)
            call FlashQuestDialogButton()

        elseif (messageType == bj_QUESTMESSAGE_UPDATED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTUPDATE, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTUPDATE, message)
            call StartSound(bj_questUpdatedSound)
            call FlashQuestDialogButton()

        elseif (messageType == bj_QUESTMESSAGE_COMPLETED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTDONE, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTDONE, message)
            call StartSound(bj_questCompletedSound)
            call FlashQuestDialogButton()

        elseif (messageType == bj_QUESTMESSAGE_FAILED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTFAILED, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTFAILED, message)
            call StartSound(bj_questFailedSound)
            call FlashQuestDialogButton()

        elseif (messageType == bj_QUESTMESSAGE_REQUIREMENT) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_QUESTREQUIREMENT, message)

        elseif (messageType == bj_QUESTMESSAGE_MISSIONFAILED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_MISSIONFAILED, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_MISSIONFAILED, message)
            call StartSound(bj_questFailedSound)

        elseif (messageType == bj_QUESTMESSAGE_HINT) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_HINT, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_HINT, message)
            call StartSound(bj_questHintSound)

        elseif (messageType == bj_QUESTMESSAGE_ALWAYSHINT) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_ALWAYSHINT, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_ALWAYSHINT, message)
            call StartSound(bj_questHintSound)

        elseif (messageType == bj_QUESTMESSAGE_SECRET) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_SECRET, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_SECRET, message)
            call StartSound(bj_questSecretSound)

        elseif (messageType == bj_QUESTMESSAGE_UNITACQUIRED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_UNITACQUIRED, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_UNITACQUIRED, message)
            call StartSound(bj_questHintSound)

        elseif (messageType == bj_QUESTMESSAGE_UNITAVAILABLE) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_UNITAVAILABLE, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_UNITAVAILABLE, message)
            call StartSound(bj_questHintSound)

        elseif (messageType == bj_QUESTMESSAGE_ITEMACQUIRED) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_ITEMACQUIRED, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_ITEMACQUIRED, message)
            call StartSound(bj_questItemAcquiredSound)

        elseif (messageType == bj_QUESTMESSAGE_WARNING) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_WARNING, " ")
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_TEXT_DELAY_WARNING, message)
            call StartSound(bj_questWarningSound)

        else
            // Unrecognized message type - ignore the request.
        endif
    endif
endfunction



//***************************************************************************
//*
//*  Timer Utility Functions
//*
//***************************************************************************

//===========================================================================
function StartTimerBJ takes timer t, boolean periodic, real timeout returns timer
    set bj_lastStartedTimer = t
    call TimerStart(t, timeout, periodic, null)
    return bj_lastStartedTimer
endfunction

//===========================================================================
function CreateTimerBJ takes boolean periodic, real timeout returns timer
    set bj_lastStartedTimer = CreateTimer()
    call TimerStart(bj_lastStartedTimer, timeout, periodic, null)
    return bj_lastStartedTimer
endfunction

//===========================================================================
function DestroyTimerBJ takes timer whichTimer returns nothing
    call DestroyTimer(whichTimer)
endfunction

//===========================================================================
function PauseTimerBJ takes boolean pause, timer whichTimer returns nothing
    if pause then
        call PauseTimer(whichTimer)
    else
        call ResumeTimer(whichTimer)
    endif
endfunction

//===========================================================================
function GetLastCreatedTimerBJ takes nothing returns timer
    return bj_lastStartedTimer
endfunction

//===========================================================================
function CreateTimerDialogBJ takes timer t, string title returns timerdialog
    set bj_lastCreatedTimerDialog = CreateTimerDialog(t)
    call TimerDialogSetTitle(bj_lastCreatedTimerDialog, title)
    call TimerDialogDisplay(bj_lastCreatedTimerDialog, true)
    return bj_lastCreatedTimerDialog
endfunction

//===========================================================================
function DestroyTimerDialogBJ takes timerdialog td returns nothing
    call DestroyTimerDialog(td)
endfunction

//===========================================================================
function TimerDialogSetTitleBJ takes timerdialog td, string title returns nothing
    call TimerDialogSetTitle(td, title)
endfunction

//===========================================================================
function TimerDialogSetTitleColorBJ takes timerdialog td, real red, real green, real blue, real transparency returns nothing
    call TimerDialogSetTitleColor(td, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function TimerDialogSetTimeColorBJ takes timerdialog td, real red, real green, real blue, real transparency returns nothing
    call TimerDialogSetTimeColor(td, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function TimerDialogSetSpeedBJ takes timerdialog td, real speedMultFactor returns nothing
    call TimerDialogSetSpeed(td, speedMultFactor)
endfunction

//===========================================================================
function TimerDialogDisplayForPlayerBJ takes boolean show, timerdialog td, player whichPlayer returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call TimerDialogDisplay(td, show)
    endif
endfunction

//===========================================================================
function TimerDialogDisplayBJ takes boolean show, timerdialog td returns nothing
    call TimerDialogDisplay(td, show)
endfunction

//===========================================================================
function GetLastCreatedTimerDialogBJ takes nothing returns timerdialog
    return bj_lastCreatedTimerDialog
endfunction



//***************************************************************************
//*
//*  Leaderboard Utility Functions
//*
//***************************************************************************

//===========================================================================
function LeaderboardResizeBJ takes leaderboard lb returns nothing
    local integer size = LeaderboardGetItemCount(lb)

    if (LeaderboardGetLabelText(lb) == "") then
        set size = size - 1
    endif
    call LeaderboardSetSizeByItemCount(lb, size)
endfunction

//===========================================================================
function LeaderboardSetPlayerItemValueBJ takes player whichPlayer, leaderboard lb, integer val returns nothing
    call LeaderboardSetItemValue(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), val)
endfunction

//===========================================================================
function LeaderboardSetPlayerItemLabelBJ takes player whichPlayer, leaderboard lb, string val returns nothing
    call LeaderboardSetItemLabel(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), val)
endfunction

//===========================================================================
function LeaderboardSetPlayerItemStyleBJ takes player whichPlayer, leaderboard lb, boolean showLabel, boolean showValue, boolean showIcon returns nothing
    call LeaderboardSetItemStyle(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), showLabel, showValue, showIcon)
endfunction

//===========================================================================
function LeaderboardSetPlayerItemLabelColorBJ takes player whichPlayer, leaderboard lb, real red, real green, real blue, real transparency returns nothing
    call LeaderboardSetItemLabelColor(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function LeaderboardSetPlayerItemValueColorBJ takes player whichPlayer, leaderboard lb, real red, real green, real blue, real transparency returns nothing
    call LeaderboardSetItemValueColor(lb, LeaderboardGetPlayerIndex(lb, whichPlayer), PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function LeaderboardSetLabelColorBJ takes leaderboard lb, real red, real green, real blue, real transparency returns nothing
    call LeaderboardSetLabelColor(lb, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function LeaderboardSetValueColorBJ takes leaderboard lb, real red, real green, real blue, real transparency returns nothing
    call LeaderboardSetValueColor(lb, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function LeaderboardSetLabelBJ takes leaderboard lb, string label returns nothing
    call LeaderboardSetLabel(lb, label)
    call LeaderboardResizeBJ(lb)
endfunction

//===========================================================================
function LeaderboardSetStyleBJ takes leaderboard lb, boolean showLabel, boolean showNames, boolean showValues, boolean showIcons returns nothing
    call LeaderboardSetStyle(lb, showLabel, showNames, showValues, showIcons)
endfunction

//===========================================================================
function LeaderboardGetItemCountBJ takes leaderboard lb returns integer
    return LeaderboardGetItemCount(lb)
endfunction

//===========================================================================
function LeaderboardHasPlayerItemBJ takes leaderboard lb, player whichPlayer returns boolean
    return LeaderboardHasPlayerItem(lb, whichPlayer)
endfunction

//===========================================================================
function ForceSetLeaderboardBJ takes leaderboard lb, force toForce returns nothing
    local integer index
    local player  indexPlayer

    set index = 0
    loop
        set indexPlayer = Player(index)
        if IsPlayerInForce(indexPlayer, toForce) then
            call PlayerSetLeaderboard(indexPlayer, lb)
        endif
        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
function CreateLeaderboardBJ takes force toForce, string label returns leaderboard
    set bj_lastCreatedLeaderboard = CreateLeaderboard()
    call LeaderboardSetLabel(bj_lastCreatedLeaderboard, label)
    call ForceSetLeaderboardBJ(bj_lastCreatedLeaderboard, toForce)
    call LeaderboardDisplay(bj_lastCreatedLeaderboard, true)
    return bj_lastCreatedLeaderboard
endfunction

//===========================================================================
function DestroyLeaderboardBJ takes leaderboard lb returns nothing
    call DestroyLeaderboard(lb)
endfunction

//===========================================================================
function LeaderboardDisplayBJ takes boolean show, leaderboard lb returns nothing
    call LeaderboardDisplay(lb, show)
endfunction

//===========================================================================
function LeaderboardAddItemBJ takes player whichPlayer, leaderboard lb, string label, integer value returns nothing
    if (LeaderboardHasPlayerItem(lb, whichPlayer)) then
        call LeaderboardRemovePlayerItem(lb, whichPlayer)
    endif
    call LeaderboardAddItem(lb, label, value, whichPlayer)
    call LeaderboardResizeBJ(lb)
    //call LeaderboardSetSizeByItemCount(lb, LeaderboardGetItemCount(lb))
endfunction

//===========================================================================
function LeaderboardRemovePlayerItemBJ takes player whichPlayer, leaderboard lb returns nothing
    call LeaderboardRemovePlayerItem(lb, whichPlayer)
    call LeaderboardResizeBJ(lb)
endfunction

//===========================================================================
function LeaderboardSortItemsBJ takes leaderboard lb, integer sortType, boolean ascending returns nothing
    if (sortType == bj_SORTTYPE_SORTBYVALUE) then
        call LeaderboardSortItemsByValue(lb, ascending)
    elseif (sortType == bj_SORTTYPE_SORTBYPLAYER) then
        call LeaderboardSortItemsByPlayer(lb, ascending)
    elseif (sortType == bj_SORTTYPE_SORTBYLABEL) then
        call LeaderboardSortItemsByLabel(lb, ascending)
    else
        // Unrecognized sort type - ignore the request.
    endif
endfunction

//===========================================================================
function LeaderboardSortItemsByPlayerBJ takes leaderboard lb, boolean ascending returns nothing
    call LeaderboardSortItemsByPlayer(lb, ascending)
endfunction

//===========================================================================
function LeaderboardSortItemsByLabelBJ takes leaderboard lb, boolean ascending returns nothing
    call LeaderboardSortItemsByLabel(lb, ascending)
endfunction

//===========================================================================
function LeaderboardGetPlayerIndexBJ takes player whichPlayer, leaderboard lb returns integer
    return LeaderboardGetPlayerIndex(lb, whichPlayer) + 1
endfunction

//===========================================================================
// Returns the player who is occupying a specified position in a leaderboard.
// The position parameter is expected in the range of 1..16.
//
function LeaderboardGetIndexedPlayerBJ takes integer position, leaderboard lb returns player
    local integer index
    local player  indexPlayer

    set index = 0
    loop
        set indexPlayer = Player(index)
        if (LeaderboardGetPlayerIndex(lb, indexPlayer) == position - 1) then
            return indexPlayer
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    return Player(PLAYER_NEUTRAL_PASSIVE)
endfunction

//===========================================================================
function PlayerGetLeaderboardBJ takes player whichPlayer returns leaderboard
    return PlayerGetLeaderboard(whichPlayer)
endfunction

//===========================================================================
function GetLastCreatedLeaderboard takes nothing returns leaderboard
    return bj_lastCreatedLeaderboard
endfunction

//***************************************************************************
//*
//*  Multiboard Utility Functions
//*
//***************************************************************************

//===========================================================================
function CreateMultiboardBJ takes integer cols, integer rows, string title returns multiboard
    set bj_lastCreatedMultiboard = CreateMultiboard()
    call MultiboardSetRowCount(bj_lastCreatedMultiboard, rows)
    call MultiboardSetColumnCount(bj_lastCreatedMultiboard, cols)
    call MultiboardSetTitleText(bj_lastCreatedMultiboard, title)
    call MultiboardDisplay(bj_lastCreatedMultiboard, true)
    return bj_lastCreatedMultiboard
endfunction

//===========================================================================
function DestroyMultiboardBJ takes multiboard mb returns nothing
    call DestroyMultiboard(mb)
endfunction

//===========================================================================
function GetLastCreatedMultiboard takes nothing returns multiboard
    return bj_lastCreatedMultiboard
endfunction

//===========================================================================
function MultiboardDisplayBJ takes boolean show, multiboard mb returns nothing
    call MultiboardDisplay(mb, show)
endfunction

//===========================================================================
function MultiboardMinimizeBJ takes boolean minimize, multiboard mb returns nothing
    call MultiboardMinimize(mb, minimize)
endfunction

//===========================================================================
function MultiboardSetTitleTextColorBJ takes multiboard mb, real red, real green, real blue, real transparency returns nothing
    call MultiboardSetTitleTextColor(mb, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function MultiboardAllowDisplayBJ takes boolean flag returns nothing
    call MultiboardSuppressDisplay(not flag)
endfunction

//===========================================================================
function MultiboardSetItemStyleBJ takes multiboard mb, integer col, integer row, boolean showValue, boolean showIcon returns nothing
    local integer curRow = 0
    local integer curCol = 0
    local integer numRows = MultiboardGetRowCount(mb)
    local integer numCols = MultiboardGetColumnCount(mb)
    local multiboarditem mbitem = null

    // Loop over rows, using 1-based index
    loop
        set curRow = curRow + 1
        exitwhen curRow > numRows

        // Apply setting to the requested row, or all rows (if row is 0)
        if (row == 0 or row == curRow) then
            // Loop over columns, using 1-based index
            set curCol = 0
            loop
                set curCol = curCol + 1
                exitwhen curCol > numCols

                // Apply setting to the requested column, or all columns (if col is 0)
                if (col == 0 or col == curCol) then
                    set mbitem = MultiboardGetItem(mb, curRow - 1, curCol - 1)
                    call MultiboardSetItemStyle(mbitem, showValue, showIcon)
                    call MultiboardReleaseItem(mbitem)
                endif
            endloop
        endif
    endloop
endfunction

//===========================================================================
function MultiboardSetItemValueBJ takes multiboard mb, integer col, integer row, string val returns nothing
    local integer curRow = 0
    local integer curCol = 0
    local integer numRows = MultiboardGetRowCount(mb)
    local integer numCols = MultiboardGetColumnCount(mb)
    local multiboarditem mbitem = null

    // Loop over rows, using 1-based index
    loop
        set curRow = curRow + 1
        exitwhen curRow > numRows

        // Apply setting to the requested row, or all rows (if row is 0)
        if (row == 0 or row == curRow) then
            // Loop over columns, using 1-based index
            set curCol = 0
            loop
                set curCol = curCol + 1
                exitwhen curCol > numCols

                // Apply setting to the requested column, or all columns (if col is 0)
                if (col == 0 or col == curCol) then
                    set mbitem = MultiboardGetItem(mb, curRow - 1, curCol - 1)
                    call MultiboardSetItemValue(mbitem, val)
                    call MultiboardReleaseItem(mbitem)
                endif
            endloop
        endif
    endloop
endfunction

//===========================================================================
function MultiboardSetItemColorBJ takes multiboard mb, integer col, integer row, real red, real green, real blue, real transparency returns nothing
    local integer curRow = 0
    local integer curCol = 0
    local integer numRows = MultiboardGetRowCount(mb)
    local integer numCols = MultiboardGetColumnCount(mb)
    local multiboarditem mbitem = null

    // Loop over rows, using 1-based index
    loop
        set curRow = curRow + 1
        exitwhen curRow > numRows

        // Apply setting to the requested row, or all rows (if row is 0)
        if (row == 0 or row == curRow) then
            // Loop over columns, using 1-based index
            set curCol = 0
            loop
                set curCol = curCol + 1
                exitwhen curCol > numCols

                // Apply setting to the requested column, or all columns (if col is 0)
                if (col == 0 or col == curCol) then
                    set mbitem = MultiboardGetItem(mb, curRow - 1, curCol - 1)
                    call MultiboardSetItemValueColor(mbitem, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
                    call MultiboardReleaseItem(mbitem)
                endif
            endloop
        endif
    endloop
endfunction

//===========================================================================
function MultiboardSetItemWidthBJ takes multiboard mb, integer col, integer row, real width returns nothing
    local integer curRow = 0
    local integer curCol = 0
    local integer numRows = MultiboardGetRowCount(mb)
    local integer numCols = MultiboardGetColumnCount(mb)
    local multiboarditem mbitem = null

    // Loop over rows, using 1-based index
    loop
        set curRow = curRow + 1
        exitwhen curRow > numRows

        // Apply setting to the requested row, or all rows (if row is 0)
        if (row == 0 or row == curRow) then
            // Loop over columns, using 1-based index
            set curCol = 0
            loop
                set curCol = curCol + 1
                exitwhen curCol > numCols

                // Apply setting to the requested column, or all columns (if col is 0)
                if (col == 0 or col == curCol) then
                    set mbitem = MultiboardGetItem(mb, curRow - 1, curCol - 1)
                    call MultiboardSetItemWidth(mbitem, width/100.0)
                    call MultiboardReleaseItem(mbitem)
                endif
            endloop
        endif
    endloop
endfunction

//===========================================================================
function MultiboardSetItemIconBJ takes multiboard mb, integer col, integer row, string iconFileName returns nothing
    local integer curRow = 0
    local integer curCol = 0
    local integer numRows = MultiboardGetRowCount(mb)
    local integer numCols = MultiboardGetColumnCount(mb)
    local multiboarditem mbitem = null

    // Loop over rows, using 1-based index
    loop
        set curRow = curRow + 1
        exitwhen curRow > numRows

        // Apply setting to the requested row, or all rows (if row is 0)
        if (row == 0 or row == curRow) then
            // Loop over columns, using 1-based index
            set curCol = 0
            loop
                set curCol = curCol + 1
                exitwhen curCol > numCols

                // Apply setting to the requested column, or all columns (if col is 0)
                if (col == 0 or col == curCol) then
                    set mbitem = MultiboardGetItem(mb, curRow - 1, curCol - 1)
                    call MultiboardSetItemIcon(mbitem, iconFileName)
                    call MultiboardReleaseItem(mbitem)
                endif
            endloop
        endif
    endloop
endfunction



//***************************************************************************
//*
//*  Text Tag Utility Functions
//*
//***************************************************************************

//===========================================================================
// Scale the font size linearly such that size 10 equates to height 0.023.
// Screen-relative font heights are harder to grasp and than font sizes.
//
function TextTagSize2Height takes real size returns real
    return size * 0.023 / 10
endfunction

//===========================================================================
// Scale the speed linearly such that speed 128 equates to 0.071.
// Screen-relative speeds are hard to grasp.
//
function TextTagSpeed2Velocity takes real speed returns real
    return speed * 0.071 / 128
endfunction

//===========================================================================
function SetTextTagColorBJ takes texttag tt, real red, real green, real blue, real transparency returns nothing
    call SetTextTagColor(tt, PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100.0-transparency))
endfunction

//===========================================================================
function SetTextTagVelocityBJ takes texttag tt, real speed, real angle returns nothing
    local real vel = TextTagSpeed2Velocity(speed)
    local real xvel = vel * Cos(angle * bj_DEGTORAD)
    local real yvel = vel * Sin(angle * bj_DEGTORAD)

    call SetTextTagVelocity(tt, xvel, yvel)
endfunction

//===========================================================================
function SetTextTagTextBJ takes texttag tt, string s, real size returns nothing
    local real textHeight = TextTagSize2Height(size)

    call SetTextTagText(tt, s, textHeight)
endfunction

//===========================================================================
function SetTextTagPosBJ takes texttag tt, location loc, real zOffset returns nothing
    call SetTextTagPos(tt, GetLocationX(loc), GetLocationY(loc), zOffset)
endfunction

//===========================================================================
function SetTextTagPosUnitBJ takes texttag tt, unit whichUnit, real zOffset returns nothing
    call SetTextTagPosUnit(tt, whichUnit, zOffset)
endfunction

//===========================================================================
function SetTextTagSuspendedBJ takes texttag tt, boolean flag returns nothing
    call SetTextTagSuspended(tt, flag)
endfunction

//===========================================================================
function SetTextTagPermanentBJ takes texttag tt, boolean flag returns nothing
    call SetTextTagPermanent(tt, flag)
endfunction

//===========================================================================
function SetTextTagAgeBJ takes texttag tt, real age returns nothing
    call SetTextTagAge(tt, age)
endfunction

//===========================================================================
function SetTextTagLifespanBJ takes texttag tt, real lifespan returns nothing
    call SetTextTagLifespan(tt, lifespan)
endfunction

//===========================================================================
function SetTextTagFadepointBJ takes texttag tt, real fadepoint returns nothing
    call SetTextTagFadepoint(tt, fadepoint)
endfunction

//===========================================================================
function CreateTextTagLocBJ takes string s, location loc, real zOffset, real size, real red, real green, real blue, real transparency returns texttag
    set bj_lastCreatedTextTag = CreateTextTag()
    call SetTextTagTextBJ(bj_lastCreatedTextTag, s, size)
    call SetTextTagPosBJ(bj_lastCreatedTextTag, loc, zOffset)
    call SetTextTagColorBJ(bj_lastCreatedTextTag, red, green, blue, transparency)

    return bj_lastCreatedTextTag
endfunction

//===========================================================================
function CreateTextTagUnitBJ takes string s, unit whichUnit, real zOffset, real size, real red, real green, real blue, real transparency returns texttag
    set bj_lastCreatedTextTag = CreateTextTag()
    call SetTextTagTextBJ(bj_lastCreatedTextTag, s, size)
    call SetTextTagPosUnitBJ(bj_lastCreatedTextTag, whichUnit, zOffset)
    call SetTextTagColorBJ(bj_lastCreatedTextTag, red, green, blue, transparency)

    return bj_lastCreatedTextTag
endfunction

//===========================================================================
function DestroyTextTagBJ takes texttag tt returns nothing
    call DestroyTextTag(tt)
endfunction

//===========================================================================
function ShowTextTagForceBJ takes boolean show, texttag tt, force whichForce returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call SetTextTagVisibility(tt, show)
    endif
endfunction

//===========================================================================
function GetLastCreatedTextTag takes nothing returns texttag
    return bj_lastCreatedTextTag
endfunction



//***************************************************************************
//*
//*  Cinematic Utility Functions
//*
//***************************************************************************

//===========================================================================
function PauseGameOn takes nothing returns nothing
    call PauseGame(true)
endfunction

//===========================================================================
function PauseGameOff takes nothing returns nothing
    call PauseGame(false)
endfunction

//===========================================================================
function SetUserControlForceOn takes force whichForce returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call EnableUserControl(true)
    endif
endfunction

//===========================================================================
function SetUserControlForceOff takes force whichForce returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call EnableUserControl(false)
    endif
endfunction

//===========================================================================
function ShowInterfaceForceOn takes force whichForce, real fadeDuration returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ShowInterface(true, fadeDuration)
    endif
endfunction

//===========================================================================
function ShowInterfaceForceOff takes force whichForce, real fadeDuration returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call ShowInterface(false, fadeDuration)
    endif
endfunction

//===========================================================================
function PingMinimapForForce takes force whichForce, real x, real y, real duration returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PingMinimap(x, y, duration)
        //call StartSound(bj_pingMinimapSound)
    endif
endfunction

//===========================================================================
function PingMinimapLocForForce takes force whichForce, location loc, real duration returns nothing
    call PingMinimapForForce(whichForce, GetLocationX(loc), GetLocationY(loc), duration)
endfunction

//===========================================================================
function PingMinimapForPlayer takes player whichPlayer, real x, real y, real duration returns nothing
    if (GetLocalPlayer() == whichPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call PingMinimap(x, y, duration)
        //call StartSound(bj_pingMinimapSound)
    endif
endfunction

//===========================================================================
function PingMinimapLocForPlayer takes player whichPlayer, location loc, real duration returns nothing
    call PingMinimapForPlayer(whichPlayer, GetLocationX(loc), GetLocationY(loc), duration)
endfunction

//===========================================================================
function PingMinimapForForceEx takes force whichForce, real x, real y, real duration, integer style, real red, real green, real blue returns nothing
    local integer red255   = PercentTo255(red)
    local integer green255 = PercentTo255(green)
    local integer blue255  = PercentTo255(blue)

    if (IsPlayerInForce(GetLocalPlayer(), whichForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        // Prevent 100% red simple and flashy pings, as they become "attack" pings.
        if (red255 == 255) and (green255 == 0) and (blue255 == 0) then
            set red255 = 254
        endif

        if (style == bj_MINIMAPPINGSTYLE_SIMPLE) then
            call PingMinimapEx(x, y, duration, red255, green255, blue255, false)
        elseif (style == bj_MINIMAPPINGSTYLE_FLASHY) then
            call PingMinimapEx(x, y, duration, red255, green255, blue255, true)
        elseif (style == bj_MINIMAPPINGSTYLE_ATTACK) then
            call PingMinimapEx(x, y, duration, 255, 0, 0, false)
        else
            // Unrecognized ping style - ignore the request.
        endif
        
        //call StartSound(bj_pingMinimapSound)
    endif
endfunction

//===========================================================================
function PingMinimapLocForForceEx takes force whichForce, location loc, real duration, integer style, real red, real green, real blue returns nothing
    call PingMinimapForForceEx(whichForce, GetLocationX(loc), GetLocationY(loc), duration, style, red, green, blue)
endfunction

//===========================================================================
function EnableWorldFogBoundaryBJ takes boolean enable, force f returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), f)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call EnableWorldFogBoundary(enable)
    endif
endfunction

//===========================================================================
function EnableOcclusionBJ takes boolean enable, force f returns nothing
    if (IsPlayerInForce(GetLocalPlayer(), f)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.
        call EnableOcclusion(enable)
    endif
endfunction



//***************************************************************************
//*
//*  Cinematic Transmission Utility Functions
//*
//***************************************************************************

//===========================================================================
// If cancelled, stop the sound and end the cinematic scene.
//
function CancelCineSceneBJ takes nothing returns nothing
    call StopSoundBJ(bj_cineSceneLastSound, true)
    call EndCinematicScene()
endfunction

//===========================================================================
// Init a trigger to listen for END_CINEMATIC events and respond to them if
// a cinematic scene is in progress.  For performance reasons, this should
// only be called once a cinematic scene has been started, so that maps
// lacking such scenes do not bother to register for these events.
//
function TryInitCinematicBehaviorBJ takes nothing returns nothing
    local integer index

    if (bj_cineSceneBeingSkipped == null) then
        set bj_cineSceneBeingSkipped = CreateTrigger()
        set index = 0
        loop
            call TriggerRegisterPlayerEvent(bj_cineSceneBeingSkipped, Player(index), EVENT_PLAYER_END_CINEMATIC)
            set index = index + 1
            exitwhen index == bj_MAX_PLAYERS
        endloop
        call TriggerAddAction(bj_cineSceneBeingSkipped, function CancelCineSceneBJ)
    endif
endfunction

//===========================================================================
function SetCinematicSceneBJ takes sound soundHandle, integer portraitUnitId, playercolor color, string speakerTitle, string text, real sceneDuration, real voiceoverDuration returns nothing
    set bj_cineSceneLastSound = soundHandle
    call PlaySoundBJ(soundHandle)
    call SetCinematicScene(portraitUnitId, color, speakerTitle, text, sceneDuration, voiceoverDuration)
endfunction

//===========================================================================
function GetTransmissionDuration takes sound soundHandle, integer timeType, real timeVal returns real
    local real duration

    if (timeType == bj_TIMETYPE_ADD) then
        set duration = GetSoundDurationBJ(soundHandle) + timeVal
    elseif (timeType == bj_TIMETYPE_SET) then
        set duration = timeVal
    elseif (timeType == bj_TIMETYPE_SUB) then
        set duration = GetSoundDurationBJ(soundHandle) - timeVal
    else
        // Unrecognized timeType - ignore timeVal.
        set duration = GetSoundDurationBJ(soundHandle)
    endif

    // Make sure we have a non-negative duration.
    if (duration < 0) then
        set duration = 0
    endif
    return duration
endfunction

//===========================================================================
function WaitTransmissionDuration takes sound soundHandle, integer timeType, real timeVal returns nothing
    if (timeType == bj_TIMETYPE_SET) then
        // If we have a static duration wait, just perform the wait.
        call TriggerSleepAction(timeVal)

    elseif (soundHandle == null) then
        // If the sound does not exist, perform a default length wait.
        call TriggerSleepAction(bj_NOTHING_SOUND_DURATION)

    elseif (timeType == bj_TIMETYPE_SUB) then
        // If the transmission is cutting off the sound, wait for the sound
        // to be mostly finished.
        call WaitForSoundBJ(soundHandle, timeVal)

    elseif (timeType == bj_TIMETYPE_ADD) then
        // If the transmission is extending beyond the sound's length, wait
        // for it to finish, and then wait the additional time.
        call WaitForSoundBJ(soundHandle, 0)
        call TriggerSleepAction(timeVal)

    else
        // Unrecognized timeType - ignore.
    endif
endfunction

//===========================================================================
function DoTransmissionBasicsXYBJ takes integer unitId, playercolor color, real x, real y, sound soundHandle, string unitName, string message, real duration returns nothing
    call SetCinematicSceneBJ(soundHandle, unitId, color, unitName, message, duration + bj_TRANSMISSION_PORT_HANGTIME, duration)

    if (unitId != 0) then
        call PingMinimap(x, y, bj_TRANSMISSION_PING_TIME)
        //call SetCameraQuickPosition(x, y)
    endif
endfunction

//===========================================================================
// Display a text message to a Player Group with an accompanying sound,
// portrait, speech indicator, and all that good stuff.
//   - Query duration of sound
//   - Play sound
//   - Display text message for duration
//   - Display animating portrait for duration
//   - Display a speech indicator for the unit
//   - Ping the minimap
//
function TransmissionFromUnitWithNameBJ takes force toForce, unit whichUnit, string unitName, sound soundHandle, string message, integer timeType, real timeVal, boolean wait returns nothing
    call TryInitCinematicBehaviorBJ()

    // Ensure that the time value is non-negative.
    set timeVal = RMaxBJ(timeVal, 0)

    set bj_lastTransmissionDuration = GetTransmissionDuration(soundHandle, timeType, timeVal)
    set bj_lastPlayedSound = soundHandle

    if (IsPlayerInForce(GetLocalPlayer(), toForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        if (whichUnit == null) then
            // If the unit reference is invalid, send the transmission from the center of the map with no portrait.
            call DoTransmissionBasicsXYBJ(0, PLAYER_COLOR_RED, 0, 0, soundHandle, unitName, message, bj_lastTransmissionDuration)
        else
            call DoTransmissionBasicsXYBJ(GetUnitTypeId(whichUnit), GetPlayerColor(GetOwningPlayer(whichUnit)), GetUnitX(whichUnit), GetUnitY(whichUnit), soundHandle, unitName, message, bj_lastTransmissionDuration)
            if (not IsUnitHidden(whichUnit)) then
                call UnitAddIndicator(whichUnit, bj_TRANSMISSION_IND_RED, bj_TRANSMISSION_IND_BLUE, bj_TRANSMISSION_IND_GREEN, bj_TRANSMISSION_IND_ALPHA)
            endif
        endif
    endif

    if wait and (bj_lastTransmissionDuration > 0) then
        // call TriggerSleepAction(bj_lastTransmissionDuration)
        call WaitTransmissionDuration(soundHandle, timeType, timeVal)
    endif

endfunction

//===========================================================================
// This operates like TransmissionFromUnitWithNameBJ, but for a unit type
// rather than a unit instance.  As such, no speech indicator is employed.
//
function TransmissionFromUnitTypeWithNameBJ takes force toForce, player fromPlayer, integer unitId, string unitName, location loc, sound soundHandle, string message, integer timeType, real timeVal, boolean wait returns nothing
    call TryInitCinematicBehaviorBJ()

    // Ensure that the time value is non-negative.
    set timeVal = RMaxBJ(timeVal, 0)

    set bj_lastTransmissionDuration = GetTransmissionDuration(soundHandle, timeType, timeVal)
    set bj_lastPlayedSound = soundHandle

    if (IsPlayerInForce(GetLocalPlayer(), toForce)) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        call DoTransmissionBasicsXYBJ(unitId, GetPlayerColor(fromPlayer), GetLocationX(loc), GetLocationY(loc), soundHandle, unitName, message, bj_lastTransmissionDuration)
    endif

    if wait and (bj_lastTransmissionDuration > 0) then
        // call TriggerSleepAction(bj_lastTransmissionDuration)
        call WaitTransmissionDuration(soundHandle, timeType, timeVal)
    endif

endfunction

//===========================================================================
function GetLastTransmissionDurationBJ takes nothing returns real
    return bj_lastTransmissionDuration
endfunction

//===========================================================================
function ForceCinematicSubtitlesBJ takes boolean flag returns nothing
    call ForceCinematicSubtitles(flag)
endfunction


//***************************************************************************
//*
//*  Cinematic Mode Utility Functions
//*
//***************************************************************************

//===========================================================================
// Makes many common UI settings changes at once, for use when beginning and
// ending cinematic sequences.  Note that some affects apply to all players,
// such as game speed.  This is unavoidable.
//   - Clear the screen of text messages
//   - Hide interface UI (letterbox mode)
//   - Hide game messages (ally under attack, etc.)
//   - Disable user control
//   - Disable occlusion
//   - Set game speed (for all players)
//   - Lock game speed (for all players)
//   - Disable black mask (for all players)
//   - Disable fog of war (for all players)
//   - Disable world boundary fog (for all players)
//   - Dim non-speech sound channels
//   - End any outstanding music themes
//   - Fix the random seed to a set value
//   - Reset the camera smoothing factor
//
function CinematicModeExBJ takes boolean cineMode, force forForce, real interfaceFadeTime returns nothing
    // If the game hasn't started yet, perform interface fades immediately
    if (not bj_gameStarted) then
        set interfaceFadeTime = 0
    endif

    if (cineMode) then
        // Save the UI state so that we can restore it later.
        if (not bj_cineModeAlreadyIn) then
            set bj_cineModeAlreadyIn = true
            set bj_cineModePriorSpeed = GetGameSpeed()
            set bj_cineModePriorFogSetting = IsFogEnabled()
            set bj_cineModePriorMaskSetting = IsFogMaskEnabled()
            set bj_cineModePriorDawnDusk = IsDawnDuskEnabled()
            set bj_cineModeSavedSeed = GetRandomInt(0, 1000000)
        endif

        // Perform local changes
        if (IsPlayerInForce(GetLocalPlayer(), forForce)) then
            // Use only local code (no net traffic) within this block to avoid desyncs.
            call ClearTextMessages()
            call ShowInterface(false, interfaceFadeTime)
            call EnableUserControl(false)
            call EnableOcclusion(false)
            call SetCineModeVolumeGroupsBJ()
        endif

        // Perform global changes
        call SetGameSpeed(bj_CINEMODE_GAMESPEED)
        call SetMapFlag(MAP_LOCK_SPEED, true)
        call FogMaskEnable(false)
        call FogEnable(false)
        call EnableWorldFogBoundary(false)
        call EnableDawnDusk(false)

        // Use a fixed random seed, so that cinematics play consistently.
        call SetRandomSeed(0)
    else
        set bj_cineModeAlreadyIn = false

        // Perform local changes
        if (IsPlayerInForce(GetLocalPlayer(), forForce)) then
            // Use only local code (no net traffic) within this block to avoid desyncs.
            call ShowInterface(true, interfaceFadeTime)
            call EnableUserControl(true)
            call EnableOcclusion(true)
            call VolumeGroupReset()
            call EndThematicMusic()
            call CameraResetSmoothingFactorBJ()
        endif

        // Perform global changes
        call SetMapFlag(MAP_LOCK_SPEED, false)
        call SetGameSpeed(bj_cineModePriorSpeed)
        call FogMaskEnable(bj_cineModePriorMaskSetting)
        call FogEnable(bj_cineModePriorFogSetting)
        call EnableWorldFogBoundary(true)
        call EnableDawnDusk(bj_cineModePriorDawnDusk)
        call SetRandomSeed(bj_cineModeSavedSeed)
    endif
endfunction

//===========================================================================
function CinematicModeBJ takes boolean cineMode, force forForce returns nothing
    call CinematicModeExBJ(cineMode, forForce, bj_CINEMODE_INTERFACEFADE)
endfunction



//***************************************************************************
//*
//*  Cinematic Filter Utility Functions
//*
//***************************************************************************

//===========================================================================
function DisplayCineFilterBJ takes boolean flag returns nothing
    call DisplayCineFilter(flag)
endfunction

//===========================================================================
function CinematicFadeCommonBJ takes real red, real green, real blue, real duration, string tex, real startTrans, real endTrans returns nothing
    if (duration == 0) then
        // If the fade is instant, use the same starting and ending values,
        // so that we effectively do a set rather than a fade.
        set startTrans = endTrans
    endif
    call EnableUserUI(false)
    call SetCineFilterTexture(tex)
    call SetCineFilterBlendMode(BLEND_MODE_BLEND)
    call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
    call SetCineFilterStartUV(0, 0, 1, 1)
    call SetCineFilterEndUV(0, 0, 1, 1)
    call SetCineFilterStartColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100-startTrans))
    call SetCineFilterEndColor(PercentTo255(red), PercentTo255(green), PercentTo255(blue), PercentTo255(100-endTrans))
    call SetCineFilterDuration(duration)
    call DisplayCineFilter(true)
endfunction

//===========================================================================
function FinishCinematicFadeBJ takes nothing returns nothing
    call DestroyTimer(bj_cineFadeFinishTimer)
    set bj_cineFadeFinishTimer = null
    call DisplayCineFilter(false)
    call EnableUserUI(true)
endfunction

//===========================================================================
function FinishCinematicFadeAfterBJ takes real duration returns nothing
    // Create a timer to end the cinematic fade.
    set bj_cineFadeFinishTimer = CreateTimer()
    call TimerStart(bj_cineFadeFinishTimer, duration, false, function FinishCinematicFadeBJ)
endfunction

//===========================================================================
function ContinueCinematicFadeBJ takes nothing returns nothing
    call DestroyTimer(bj_cineFadeContinueTimer)
    set bj_cineFadeContinueTimer = null
    call CinematicFadeCommonBJ(bj_cineFadeContinueRed, bj_cineFadeContinueGreen, bj_cineFadeContinueBlue, bj_cineFadeContinueDuration, bj_cineFadeContinueTex, bj_cineFadeContinueTrans, 100)
endfunction

//===========================================================================
function ContinueCinematicFadeAfterBJ takes real duration, real red, real green, real blue, real trans, string tex returns nothing
    set bj_cineFadeContinueRed = red
    set bj_cineFadeContinueGreen = green
    set bj_cineFadeContinueBlue = blue
    set bj_cineFadeContinueTrans = trans
    set bj_cineFadeContinueDuration = duration
    set bj_cineFadeContinueTex = tex

    // Create a timer to continue the cinematic fade.
    set bj_cineFadeContinueTimer = CreateTimer()
    call TimerStart(bj_cineFadeContinueTimer, duration, false, function ContinueCinematicFadeBJ)
endfunction

//===========================================================================
function AbortCinematicFadeBJ takes nothing returns nothing
    if (bj_cineFadeContinueTimer != null) then
        call DestroyTimer(bj_cineFadeContinueTimer)
    endif

    if (bj_cineFadeFinishTimer != null) then
        call DestroyTimer(bj_cineFadeFinishTimer)
    endif
endfunction

//===========================================================================
function CinematicFadeBJ takes integer fadetype, real duration, string tex, real red, real green, real blue, real trans returns nothing
    if (fadetype == bj_CINEFADETYPE_FADEOUT) then
        // Fade out to the requested color.
        call AbortCinematicFadeBJ()
        call CinematicFadeCommonBJ(red, green, blue, duration, tex, 100, trans)
    elseif (fadetype == bj_CINEFADETYPE_FADEIN) then
        // Fade in from the requested color.
        call AbortCinematicFadeBJ()
        call CinematicFadeCommonBJ(red, green, blue, duration, tex, trans, 100)
        call FinishCinematicFadeAfterBJ(duration)
    elseif (fadetype == bj_CINEFADETYPE_FADEOUTIN) then
        // Fade out to the requested color, and then fade back in from it.
        if (duration > 0) then
            call AbortCinematicFadeBJ()
            call CinematicFadeCommonBJ(red, green, blue, duration * 0.5, tex, 100, trans)
            call ContinueCinematicFadeAfterBJ(duration * 0.5, red, green, blue, trans, tex)
            call FinishCinematicFadeAfterBJ(duration)
        endif
    else
        // Unrecognized fadetype - ignore the request.
    endif
endfunction

//===========================================================================
function CinematicFilterGenericBJ takes real duration, blendmode bmode, string tex, real red0, real green0, real blue0, real trans0, real red1, real green1, real blue1, real trans1 returns nothing
    call AbortCinematicFadeBJ()
    call SetCineFilterTexture(tex)
    call SetCineFilterBlendMode(bmode)
    call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
    call SetCineFilterStartUV(0, 0, 1, 1)
    call SetCineFilterEndUV(0, 0, 1, 1)
    call SetCineFilterStartColor(PercentTo255(red0), PercentTo255(green0), PercentTo255(blue0), PercentTo255(100-trans0))
    call SetCineFilterEndColor(PercentTo255(red1), PercentTo255(green1), PercentTo255(blue1), PercentTo255(100-trans1))
    call SetCineFilterDuration(duration)
    call DisplayCineFilter(true)
endfunction



//***************************************************************************
//*
//*  Rescuable Unit Utility Functions
//*
//***************************************************************************

//===========================================================================
// Rescues a unit for a player.  This performs the default rescue behavior,
// including a rescue sound, flashing selection circle, ownership change,
// and optionally a unit color change.
//
function RescueUnitBJ takes unit whichUnit, player rescuer, boolean changeColor returns nothing
    if IsUnitDeadBJ(whichUnit) or (GetOwningPlayer(whichUnit) == rescuer) then
        return
    endif

    call StartSound(bj_rescueSound)
    call SetUnitOwner(whichUnit, rescuer, changeColor)
    call UnitAddIndicator(whichUnit, 0, 255, 0, 255)
    call PingMinimapForPlayer(rescuer, GetUnitX(whichUnit), GetUnitY(whichUnit), bj_RESCUE_PING_TIME)
endfunction

//===========================================================================
function TriggerActionUnitRescuedBJ takes nothing returns nothing
    local unit theUnit = GetTriggerUnit()

    if IsUnitType(theUnit, UNIT_TYPE_STRUCTURE) then
        call RescueUnitBJ(theUnit, GetOwningPlayer(GetRescuer()), bj_rescueChangeColorBldg)
    else
        call RescueUnitBJ(theUnit, GetOwningPlayer(GetRescuer()), bj_rescueChangeColorUnit)
    endif
endfunction

//===========================================================================
// Attempt to init triggers for default rescue behavior.  For performance
// reasons, this should only be attempted if a player is set to Rescuable,
// or if a specific unit is thus flagged.
//
function TryInitRescuableTriggersBJ takes nothing returns nothing
    local integer index

    if (bj_rescueUnitBehavior == null) then
        set bj_rescueUnitBehavior = CreateTrigger()
        set index = 0
        loop
            call TriggerRegisterPlayerUnitEvent(bj_rescueUnitBehavior, Player(index), EVENT_PLAYER_UNIT_RESCUED, null)
            set index = index + 1
            exitwhen index == bj_MAX_PLAYER_SLOTS
        endloop
        call TriggerAddAction(bj_rescueUnitBehavior, function TriggerActionUnitRescuedBJ)
    endif
endfunction

//===========================================================================
// Determines whether or not rescued units automatically change color upon
// being rescued.
//
function SetRescueUnitColorChangeBJ takes boolean changeColor returns nothing
    set bj_rescueChangeColorUnit = changeColor
endfunction

//===========================================================================
// Determines whether or not rescued buildings automatically change color
// upon being rescued.
//
function SetRescueBuildingColorChangeBJ takes boolean changeColor returns nothing
    set bj_rescueChangeColorBldg = changeColor
endfunction

//===========================================================================
function MakeUnitRescuableToForceBJEnum takes nothing returns nothing
    call TryInitRescuableTriggersBJ()
    call SetUnitRescuable(bj_makeUnitRescuableUnit, GetEnumPlayer(), bj_makeUnitRescuableFlag)
endfunction

//===========================================================================
function MakeUnitRescuableToForceBJ takes unit whichUnit, boolean isRescuable, force whichForce returns nothing
    // Flag the unit as rescuable/unrescuable for the appropriate players.
    set bj_makeUnitRescuableUnit = whichUnit
    set bj_makeUnitRescuableFlag = isRescuable
    call ForForce(whichForce, function MakeUnitRescuableToForceBJEnum)
endfunction

//===========================================================================
function InitRescuableBehaviorBJ takes nothing returns nothing
    local integer index

    set index = 0
    loop
        // If at least one player slot is "Rescuable"-controlled, init the
        // rescue behavior triggers.
        if (GetPlayerController(Player(index)) == MAP_CONTROL_RESCUABLE) then
            call TryInitRescuableTriggersBJ()
            return
        endif
        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction



//***************************************************************************
//*
//*  Research and Upgrade Utility Functions
//*
//***************************************************************************

//===========================================================================
function SetPlayerTechResearchedSwap takes integer techid, integer levels, player whichPlayer returns nothing
    call SetPlayerTechResearched(whichPlayer, techid, levels)
endfunction

//===========================================================================
function SetPlayerTechMaxAllowedSwap takes integer techid, integer maximum, player whichPlayer returns nothing
    call SetPlayerTechMaxAllowed(whichPlayer, techid, maximum)
endfunction

//===========================================================================
function SetPlayerMaxHeroesAllowed takes integer maximum, player whichPlayer returns nothing
    call SetPlayerTechMaxAllowed(whichPlayer, 'HERO', maximum)
endfunction

//===========================================================================
function GetPlayerTechCountSimple takes integer techid, player whichPlayer returns integer
    return GetPlayerTechCount(whichPlayer, techid, true)
endfunction

//===========================================================================
function GetPlayerTechMaxAllowedSwap takes integer techid, player whichPlayer returns integer
    return GetPlayerTechMaxAllowed(whichPlayer, techid)
endfunction

//===========================================================================
function SetPlayerAbilityAvailableBJ takes boolean avail, integer abilid, player whichPlayer returns nothing
    call SetPlayerAbilityAvailable(whichPlayer, abilid, avail)
endfunction



//***************************************************************************
//*
//*  Campaign Utility Functions
//*
//***************************************************************************

function SetCampaignMenuRaceBJ takes integer campaignNumber returns nothing
    if (campaignNumber == bj_CAMPAIGN_INDEX_T) then
        call SetCampaignMenuRace(RACE_OTHER)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_H) then
        call SetCampaignMenuRace(RACE_HUMAN)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_U) then
        call SetCampaignMenuRace(RACE_UNDEAD)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_O) then
        call SetCampaignMenuRace(RACE_ORC)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_N) then
        call SetCampaignMenuRace(RACE_NIGHTELF)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XN) then
        call SetCampaignMenuRaceEx(bj_CAMPAIGN_OFFSET_XN)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XH) then
        call SetCampaignMenuRaceEx(bj_CAMPAIGN_OFFSET_XH)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XU) then
        call SetCampaignMenuRaceEx(bj_CAMPAIGN_OFFSET_XU)
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XO) then
        call SetCampaignMenuRaceEx(bj_CAMPAIGN_OFFSET_XO)
    else
        // Unrecognized campaign - ignore the request
    endif
endfunction

//===========================================================================
// Converts a single campaign mission designation into campaign and mission
// numbers.  The 1000's digit is considered the campaign index, and the 1's
// digit is considered the mission index within that campaign.  This is done
// so that the trigger for this can use a single drop-down to list all of
// the campaign missions.
//
function SetMissionAvailableBJ takes boolean available, integer missionIndex returns nothing
    local integer campaignNumber = missionIndex / 1000
    local integer missionNumber = missionIndex - campaignNumber * 1000

    call SetMissionAvailable(campaignNumber, missionNumber, available)
endfunction

//===========================================================================
function SetCampaignAvailableBJ takes boolean available, integer campaignNumber returns nothing
    local integer campaignOffset

    if (campaignNumber == bj_CAMPAIGN_INDEX_H) then
        call SetTutorialCleared(true)
    endif

    if (campaignNumber == bj_CAMPAIGN_INDEX_XN) then
        set campaignOffset = bj_CAMPAIGN_OFFSET_XN
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XH) then
        set campaignOffset = bj_CAMPAIGN_OFFSET_XH
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XU) then
        set campaignOffset = bj_CAMPAIGN_OFFSET_XU
    elseif (campaignNumber == bj_CAMPAIGN_INDEX_XO) then
        set campaignOffset = bj_CAMPAIGN_OFFSET_XO
    else
        set campaignOffset = campaignNumber
    endif

    call SetCampaignAvailable(campaignOffset, available)
    call SetCampaignMenuRaceBJ(campaignNumber)
    call ForceCampaignSelectScreen()
endfunction

//===========================================================================
function SetCinematicAvailableBJ takes boolean available, integer cinematicIndex returns nothing
    if ( cinematicIndex == bj_CINEMATICINDEX_TOP ) then
        call SetOpCinematicAvailable( bj_CAMPAIGN_INDEX_T, available )
        call PlayCinematic( "TutorialOp" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_HOP) then
        call SetOpCinematicAvailable( bj_CAMPAIGN_INDEX_H, available )
        call PlayCinematic( "HumanOp" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_HED) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_H, available )
        call PlayCinematic( "HumanEd" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_OOP) then
        call SetOpCinematicAvailable( bj_CAMPAIGN_INDEX_O, available )
        call PlayCinematic( "OrcOp" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_OED) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_O, available )
        call PlayCinematic( "OrcEd" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_UOP) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_U, available )
        call PlayCinematic( "UndeadOp" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_UED) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_U, available )
        call PlayCinematic( "UndeadEd" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_NOP) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_N, available )
        call PlayCinematic( "NightElfOp" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_NED) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_INDEX_N, available )
        call PlayCinematic( "NightElfEd" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_XOP) then
        call SetOpCinematicAvailable( bj_CAMPAIGN_OFFSET_XN, available )
        call PlayCinematic( "IntroX" )
    elseif (cinematicIndex == bj_CINEMATICINDEX_XED) then
        call SetEdCinematicAvailable( bj_CAMPAIGN_OFFSET_XU, available )
        call PlayCinematic( "OutroX" )
    else
        // Unrecognized cinematic - ignore the request.
    endif
endfunction

//===========================================================================
function InitGameCacheBJ takes string campaignFile returns gamecache
    set bj_lastCreatedGameCache = InitGameCache(campaignFile)
    return bj_lastCreatedGameCache
endfunction

//===========================================================================
function SaveGameCacheBJ takes gamecache cache returns boolean
    return SaveGameCache(cache)
endfunction

//===========================================================================
function GetLastCreatedGameCacheBJ takes nothing returns gamecache
    return bj_lastCreatedGameCache
endfunction

//===========================================================================
function InitHashtableBJ takes nothing returns hashtable
    set bj_lastCreatedHashtable = InitHashtable()
    return bj_lastCreatedHashtable
endfunction

//===========================================================================
function GetLastCreatedHashtableBJ takes nothing returns hashtable
    return bj_lastCreatedHashtable
endfunction

//===========================================================================
function StoreRealBJ takes real value, string key, string missionKey, gamecache cache returns nothing
    call StoreReal(cache, missionKey, key, value)
endfunction

//===========================================================================
function StoreIntegerBJ takes integer value, string key, string missionKey, gamecache cache returns nothing
    call StoreInteger(cache, missionKey, key, value)
endfunction

//===========================================================================
function StoreBooleanBJ takes boolean value, string key, string missionKey, gamecache cache returns nothing
    call StoreBoolean(cache, missionKey, key, value)
endfunction

//===========================================================================
function StoreStringBJ takes string value, string key, string missionKey, gamecache cache returns boolean
    return StoreString(cache, missionKey, key, value)
endfunction

//===========================================================================
function StoreUnitBJ takes unit whichUnit, string key, string missionKey, gamecache cache returns boolean
    return StoreUnit(cache, missionKey, key, whichUnit)
endfunction

//===========================================================================
function SaveRealBJ takes real value, integer key, integer missionKey, hashtable table returns nothing
    call SaveReal(table, missionKey, key, value)
endfunction

//===========================================================================
function SaveIntegerBJ takes integer value, integer key, integer missionKey, hashtable table returns nothing
    call SaveInteger(table, missionKey, key, value)
endfunction

//===========================================================================
function SaveBooleanBJ takes boolean value, integer key, integer missionKey, hashtable table returns nothing
    call SaveBoolean(table, missionKey, key, value)
endfunction

//===========================================================================
function SaveStringBJ takes string value, integer key, integer missionKey, hashtable table returns boolean
    return SaveStr(table, missionKey, key, value)
endfunction

//===========================================================================
function SavePlayerHandleBJ takes player whichPlayer, integer key, integer missionKey, hashtable table returns boolean
    return SavePlayerHandle(table, missionKey, key, whichPlayer)
endfunction

//===========================================================================
function SaveWidgetHandleBJ takes widget whichWidget, integer key, integer missionKey, hashtable table returns boolean
    return SaveWidgetHandle(table, missionKey, key, whichWidget)
endfunction

//===========================================================================
function SaveDestructableHandleBJ takes destructable whichDestructable, integer key, integer missionKey, hashtable table returns boolean
    return SaveDestructableHandle(table, missionKey, key, whichDestructable)
endfunction

//===========================================================================
function SaveItemHandleBJ takes item whichItem, integer key, integer missionKey, hashtable table returns boolean
    return SaveItemHandle(table, missionKey, key, whichItem)
endfunction

//===========================================================================
function SaveUnitHandleBJ takes unit whichUnit, integer key, integer missionKey, hashtable table returns boolean
    return SaveUnitHandle(table, missionKey, key, whichUnit)
endfunction

//===========================================================================
function SaveAbilityHandleBJ takes ability whichAbility, integer key, integer missionKey, hashtable table returns boolean
    return SaveAbilityHandle(table, missionKey, key, whichAbility)
endfunction

//===========================================================================
function SaveTimerHandleBJ takes timer whichTimer, integer key, integer missionKey, hashtable table returns boolean
    return SaveTimerHandle(table, missionKey, key, whichTimer)
endfunction

//===========================================================================
function SaveTriggerHandleBJ takes trigger whichTrigger, integer key, integer missionKey, hashtable table returns boolean
    return SaveTriggerHandle(table, missionKey, key, whichTrigger)
endfunction

//===========================================================================
function SaveTriggerConditionHandleBJ takes triggercondition whichTriggercondition, integer key, integer missionKey, hashtable table returns boolean
    return SaveTriggerConditionHandle(table, missionKey, key, whichTriggercondition)
endfunction

//===========================================================================
function SaveTriggerActionHandleBJ takes triggeraction whichTriggeraction, integer key, integer missionKey, hashtable table returns boolean
    return SaveTriggerActionHandle(table, missionKey, key, whichTriggeraction)
endfunction

//===========================================================================
function SaveTriggerEventHandleBJ takes event whichEvent, integer key, integer missionKey, hashtable table returns boolean
    return SaveTriggerEventHandle(table, missionKey, key, whichEvent)
endfunction

//===========================================================================
function SaveForceHandleBJ takes force whichForce, integer key, integer missionKey, hashtable table returns boolean
    return SaveForceHandle(table, missionKey, key, whichForce)
endfunction

//===========================================================================
function SaveGroupHandleBJ takes group whichGroup, integer key, integer missionKey, hashtable table returns boolean
    return SaveGroupHandle(table, missionKey, key, whichGroup)
endfunction

//===========================================================================
function SaveLocationHandleBJ takes location whichLocation, integer key, integer missionKey, hashtable table returns boolean
    return SaveLocationHandle(table, missionKey, key, whichLocation)
endfunction

//===========================================================================
function SaveRectHandleBJ takes rect whichRect, integer key, integer missionKey, hashtable table returns boolean
    return SaveRectHandle(table, missionKey, key, whichRect)
endfunction

//===========================================================================
function SaveBooleanExprHandleBJ takes boolexpr whichBoolexpr, integer key, integer missionKey, hashtable table returns boolean
    return SaveBooleanExprHandle(table, missionKey, key, whichBoolexpr)
endfunction

//===========================================================================
function SaveSoundHandleBJ takes sound whichSound, integer key, integer missionKey, hashtable table returns boolean
    return SaveSoundHandle(table, missionKey, key, whichSound)
endfunction

//===========================================================================
function SaveEffectHandleBJ takes effect whichEffect, integer key, integer missionKey, hashtable table returns boolean
    return SaveEffectHandle(table, missionKey, key, whichEffect)
endfunction

//===========================================================================
function SaveUnitPoolHandleBJ takes unitpool whichUnitpool, integer key, integer missionKey, hashtable table returns boolean
    return SaveUnitPoolHandle(table, missionKey, key, whichUnitpool)
endfunction

//===========================================================================
function SaveItemPoolHandleBJ takes itempool whichItempool, integer key, integer missionKey, hashtable table returns boolean
    return SaveItemPoolHandle(table, missionKey, key, whichItempool)
endfunction

//===========================================================================
function SaveQuestHandleBJ takes quest whichQuest, integer key, integer missionKey, hashtable table returns boolean
    return SaveQuestHandle(table, missionKey, key, whichQuest)
endfunction

//===========================================================================
function SaveQuestItemHandleBJ takes questitem whichQuestitem, integer key, integer missionKey, hashtable table returns boolean
    return SaveQuestItemHandle(table, missionKey, key, whichQuestitem)
endfunction

//===========================================================================
function SaveDefeatConditionHandleBJ takes defeatcondition whichDefeatcondition, integer key, integer missionKey, hashtable table returns boolean
    return SaveDefeatConditionHandle(table, missionKey, key, whichDefeatcondition)
endfunction

//===========================================================================
function SaveTimerDialogHandleBJ takes timerdialog whichTimerdialog, integer key, integer missionKey, hashtable table returns boolean
    return SaveTimerDialogHandle(table, missionKey, key, whichTimerdialog)
endfunction

//===========================================================================
function SaveLeaderboardHandleBJ takes leaderboard whichLeaderboard, integer key, integer missionKey, hashtable table returns boolean
    return SaveLeaderboardHandle(table, missionKey, key, whichLeaderboard)
endfunction

//===========================================================================
function SaveMultiboardHandleBJ takes multiboard whichMultiboard, integer key, integer missionKey, hashtable table returns boolean
    return SaveMultiboardHandle(table, missionKey, key, whichMultiboard)
endfunction

//===========================================================================
function SaveMultiboardItemHandleBJ takes multiboarditem whichMultiboarditem, integer key, integer missionKey, hashtable table returns boolean
    return SaveMultiboardItemHandle(table, missionKey, key, whichMultiboarditem)
endfunction

//===========================================================================
function SaveTrackableHandleBJ takes trackable whichTrackable, integer key, integer missionKey, hashtable table returns boolean
    return SaveTrackableHandle(table, missionKey, key, whichTrackable)
endfunction

//===========================================================================
function SaveDialogHandleBJ takes dialog whichDialog, integer key, integer missionKey, hashtable table returns boolean
    return SaveDialogHandle(table, missionKey, key, whichDialog)
endfunction

//===========================================================================
function SaveButtonHandleBJ takes button whichButton, integer key, integer missionKey, hashtable table returns boolean
    return SaveButtonHandle(table, missionKey, key, whichButton)
endfunction

//===========================================================================
function SaveTextTagHandleBJ takes texttag whichTexttag, integer key, integer missionKey, hashtable table returns boolean
    return SaveTextTagHandle(table, missionKey, key, whichTexttag)
endfunction

//===========================================================================
function SaveLightningHandleBJ takes lightning whichLightning, integer key, integer missionKey, hashtable table returns boolean
    return SaveLightningHandle(table, missionKey, key, whichLightning)
endfunction

//===========================================================================
function SaveImageHandleBJ takes image whichImage, integer key, integer missionKey, hashtable table returns boolean
    return SaveImageHandle(table, missionKey, key, whichImage)
endfunction

//===========================================================================
function SaveUbersplatHandleBJ takes ubersplat whichUbersplat, integer key, integer missionKey, hashtable table returns boolean
    return SaveUbersplatHandle(table, missionKey, key, whichUbersplat)
endfunction

//===========================================================================
function SaveRegionHandleBJ takes region whichRegion, integer key, integer missionKey, hashtable table returns boolean
    return SaveRegionHandle(table, missionKey, key, whichRegion)
endfunction

//===========================================================================
function SaveFogStateHandleBJ takes fogstate whichFogState, integer key, integer missionKey, hashtable table returns boolean
    return SaveFogStateHandle(table, missionKey, key, whichFogState)
endfunction

//===========================================================================
function SaveFogModifierHandleBJ takes fogmodifier whichFogModifier, integer key, integer missionKey, hashtable table returns boolean
    return SaveFogModifierHandle(table, missionKey, key, whichFogModifier)
endfunction

//===========================================================================
function SaveAgentHandleBJ takes agent whichAgent, integer key, integer missionKey, hashtable table returns boolean
    return SaveAgentHandle(table, missionKey, key, whichAgent)
endfunction

//===========================================================================
function SaveHashtableHandleBJ takes hashtable whichHashtable, integer key, integer missionKey, hashtable table returns boolean
    return SaveHashtableHandle(table, missionKey, key, whichHashtable)
endfunction

//===========================================================================
function GetStoredRealBJ takes string key, string missionKey, gamecache cache returns real
    //call SyncStoredReal(cache, missionKey, key)
    return GetStoredReal(cache, missionKey, key)
endfunction

//===========================================================================
function GetStoredIntegerBJ takes string key, string missionKey, gamecache cache returns integer
    //call SyncStoredInteger(cache, missionKey, key)
    return GetStoredInteger(cache, missionKey, key)
endfunction

//===========================================================================
function GetStoredBooleanBJ takes string key, string missionKey, gamecache cache returns boolean
    //call SyncStoredBoolean(cache, missionKey, key)
    return GetStoredBoolean(cache, missionKey, key)
endfunction

//===========================================================================
function GetStoredStringBJ takes string key, string missionKey, gamecache cache returns string
    local string s

    //call SyncStoredString(cache, missionKey, key)
    set s = GetStoredString(cache, missionKey, key)
    if (s == null) then
        return ""
    else
        return s
    endif
endfunction

//===========================================================================
function LoadRealBJ takes integer key, integer missionKey, hashtable table returns real
    //call SyncStoredReal(table, missionKey, key)
    return LoadReal(table, missionKey, key)
endfunction

//===========================================================================
function LoadIntegerBJ takes integer key, integer missionKey, hashtable table returns integer
    //call SyncStoredInteger(table, missionKey, key)
    return LoadInteger(table, missionKey, key)
endfunction

//===========================================================================
function LoadBooleanBJ takes integer key, integer missionKey, hashtable table returns boolean
    //call SyncStoredBoolean(table, missionKey, key)
    return LoadBoolean(table, missionKey, key)
endfunction

//===========================================================================
function LoadStringBJ takes integer key, integer missionKey, hashtable table returns string
    local string s

    //call SyncStoredString(table, missionKey, key)
    set s = LoadStr(table, missionKey, key)
    if (s == null) then
        return ""
    else
        return s
    endif
endfunction

//===========================================================================
function LoadPlayerHandleBJ takes integer key, integer missionKey, hashtable table returns player
    return LoadPlayerHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadWidgetHandleBJ takes integer key, integer missionKey, hashtable table returns widget
    return LoadWidgetHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadDestructableHandleBJ takes integer key, integer missionKey, hashtable table returns destructable
    return LoadDestructableHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadItemHandleBJ takes integer key, integer missionKey, hashtable table returns item
    return LoadItemHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadUnitHandleBJ takes integer key, integer missionKey, hashtable table returns unit
    return LoadUnitHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadAbilityHandleBJ takes integer key, integer missionKey, hashtable table returns ability
    return LoadAbilityHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTimerHandleBJ takes integer key, integer missionKey, hashtable table returns timer
    return LoadTimerHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTriggerHandleBJ takes integer key, integer missionKey, hashtable table returns trigger
    return LoadTriggerHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTriggerConditionHandleBJ takes integer key, integer missionKey, hashtable table returns triggercondition
    return LoadTriggerConditionHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTriggerActionHandleBJ takes integer key, integer missionKey, hashtable table returns triggeraction
    return LoadTriggerActionHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTriggerEventHandleBJ takes integer key, integer missionKey, hashtable table returns event
    return LoadTriggerEventHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadForceHandleBJ takes integer key, integer missionKey, hashtable table returns force
    return LoadForceHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadGroupHandleBJ takes integer key, integer missionKey, hashtable table returns group
    return LoadGroupHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadLocationHandleBJ takes integer key, integer missionKey, hashtable table returns location
    return LoadLocationHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadRectHandleBJ takes integer key, integer missionKey, hashtable table returns rect
    return LoadRectHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadBooleanExprHandleBJ takes integer key, integer missionKey, hashtable table returns boolexpr
    return LoadBooleanExprHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadSoundHandleBJ takes integer key, integer missionKey, hashtable table returns sound
    return LoadSoundHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadEffectHandleBJ takes integer key, integer missionKey, hashtable table returns effect
    return LoadEffectHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadUnitPoolHandleBJ takes integer key, integer missionKey, hashtable table returns unitpool
    return LoadUnitPoolHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadItemPoolHandleBJ takes integer key, integer missionKey, hashtable table returns itempool
    return LoadItemPoolHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadQuestHandleBJ takes integer key, integer missionKey, hashtable table returns quest
    return LoadQuestHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadQuestItemHandleBJ takes integer key, integer missionKey, hashtable table returns questitem
    return LoadQuestItemHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadDefeatConditionHandleBJ takes integer key, integer missionKey, hashtable table returns defeatcondition
    return LoadDefeatConditionHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTimerDialogHandleBJ takes integer key, integer missionKey, hashtable table returns timerdialog
    return LoadTimerDialogHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadLeaderboardHandleBJ takes integer key, integer missionKey, hashtable table returns leaderboard
    return LoadLeaderboardHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadMultiboardHandleBJ takes integer key, integer missionKey, hashtable table returns multiboard
    return LoadMultiboardHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadMultiboardItemHandleBJ takes integer key, integer missionKey, hashtable table returns multiboarditem
    return LoadMultiboardItemHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTrackableHandleBJ takes integer key, integer missionKey, hashtable table returns trackable
    return LoadTrackableHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadDialogHandleBJ takes integer key, integer missionKey, hashtable table returns dialog
    return LoadDialogHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadButtonHandleBJ takes integer key, integer missionKey, hashtable table returns button
    return LoadButtonHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadTextTagHandleBJ takes integer key, integer missionKey, hashtable table returns texttag
    return LoadTextTagHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadLightningHandleBJ takes integer key, integer missionKey, hashtable table returns lightning
    return LoadLightningHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadImageHandleBJ takes integer key, integer missionKey, hashtable table returns image
    return LoadImageHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadUbersplatHandleBJ takes integer key, integer missionKey, hashtable table returns ubersplat
    return LoadUbersplatHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadRegionHandleBJ takes integer key, integer missionKey, hashtable table returns region
    return LoadRegionHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadFogStateHandleBJ takes integer key, integer missionKey, hashtable table returns fogstate
    return LoadFogStateHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadFogModifierHandleBJ takes integer key, integer missionKey, hashtable table returns fogmodifier
    return LoadFogModifierHandle(table, missionKey, key)
endfunction

//===========================================================================
function LoadHashtableHandleBJ takes integer key, integer missionKey, hashtable table returns hashtable
    return LoadHashtableHandle(table, missionKey, key)
endfunction

//===========================================================================
function RestoreUnitLocFacingAngleBJ takes string key, string missionKey, gamecache cache, player forWhichPlayer, location loc, real facing returns unit
    //call SyncStoredUnit(cache, missionKey, key)
    set bj_lastLoadedUnit = RestoreUnit(cache, missionKey, key, forWhichPlayer, GetLocationX(loc), GetLocationY(loc), facing)
    return bj_lastLoadedUnit
endfunction

//===========================================================================
function RestoreUnitLocFacingPointBJ takes string key, string missionKey, gamecache cache, player forWhichPlayer, location loc, location lookAt returns unit
    //call SyncStoredUnit(cache, missionKey, key)
    return RestoreUnitLocFacingAngleBJ(key, missionKey, cache, forWhichPlayer, loc, AngleBetweenPoints(loc, lookAt))
endfunction

//===========================================================================
function GetLastRestoredUnitBJ takes nothing returns unit
    return bj_lastLoadedUnit
endfunction

//===========================================================================
function FlushGameCacheBJ takes gamecache cache returns nothing
    call FlushGameCache(cache)
endfunction

//===========================================================================
function FlushStoredMissionBJ takes string missionKey, gamecache cache returns nothing
    call FlushStoredMission(cache, missionKey)
endfunction

//===========================================================================
function FlushParentHashtableBJ takes hashtable table returns nothing
    call FlushParentHashtable(table)
endfunction

//===========================================================================
function FlushChildHashtableBJ takes integer missionKey, hashtable table returns nothing
    call FlushChildHashtable(table, missionKey)
endfunction

//===========================================================================
function HaveStoredValue takes string key, integer valueType, string missionKey, gamecache cache returns boolean
    if (valueType == bj_GAMECACHE_BOOLEAN) then
        return HaveStoredBoolean(cache, missionKey, key)
    elseif (valueType == bj_GAMECACHE_INTEGER) then
        return HaveStoredInteger(cache, missionKey, key)
    elseif (valueType == bj_GAMECACHE_REAL) then
        return HaveStoredReal(cache, missionKey, key)
    elseif (valueType == bj_GAMECACHE_UNIT) then
        return HaveStoredUnit(cache, missionKey, key)
    elseif (valueType == bj_GAMECACHE_STRING) then
        return HaveStoredString(cache, missionKey, key)
    else
        // Unrecognized value type - ignore the request.
        return false
    endif
endfunction

//===========================================================================
function HaveSavedValue takes integer key, integer valueType, integer missionKey, hashtable table returns boolean
    if (valueType == bj_HASHTABLE_BOOLEAN) then
        return HaveSavedBoolean(table, missionKey, key)
    elseif (valueType == bj_HASHTABLE_INTEGER) then
        return HaveSavedInteger(table, missionKey, key)
    elseif (valueType == bj_HASHTABLE_REAL) then
        return HaveSavedReal(table, missionKey, key)
    elseif (valueType == bj_HASHTABLE_STRING) then
        return HaveSavedString(table, missionKey, key)
    elseif (valueType == bj_HASHTABLE_HANDLE) then
        return HaveSavedHandle(table, missionKey, key)
    else
        // Unrecognized value type - ignore the request.
        return false
    endif
endfunction

//===========================================================================
function ShowCustomCampaignButton takes boolean show, integer whichButton returns nothing
    call SetCustomCampaignButtonVisible(whichButton - 1, show)
endfunction

//===========================================================================
function IsCustomCampaignButtonVisibile takes integer whichButton returns boolean
    return GetCustomCampaignButtonVisible(whichButton - 1)
endfunction

//===========================================================================
function LoadGameBJ takes string loadFileName, boolean doScoreScreen returns nothing
    call LoadGame(loadFileName, doScoreScreen)
endfunction

//===========================================================================
function SaveAndChangeLevelBJ takes string saveFileName, string newLevel, boolean doScoreScreen returns nothing
    call SaveGame(saveFileName)
    call ChangeLevel(newLevel, doScoreScreen)
endfunction

//===========================================================================
function SaveAndLoadGameBJ takes string saveFileName, string loadFileName, boolean doScoreScreen returns nothing
    call SaveGame(saveFileName)
    call LoadGame(loadFileName, doScoreScreen)
endfunction

//===========================================================================
function RenameSaveDirectoryBJ takes string sourceDirName, string destDirName returns boolean
    return RenameSaveDirectory(sourceDirName, destDirName)
endfunction

//===========================================================================
function RemoveSaveDirectoryBJ takes string sourceDirName returns boolean
    return RemoveSaveDirectory(sourceDirName)
endfunction

//===========================================================================
function CopySaveGameBJ takes string sourceSaveName, string destSaveName returns boolean
    return CopySaveGame(sourceSaveName, destSaveName)
endfunction



//***************************************************************************
//*
//*  Miscellaneous Utility Functions
//*
//***************************************************************************

//===========================================================================
function GetPlayerStartLocationX takes player whichPlayer returns real
    return GetStartLocationX(GetPlayerStartLocation(whichPlayer))
endfunction

//===========================================================================
function GetPlayerStartLocationY takes player whichPlayer returns real
    return GetStartLocationY(GetPlayerStartLocation(whichPlayer))
endfunction

//===========================================================================
function GetPlayerStartLocationLoc takes player whichPlayer returns location
    return GetStartLocationLoc(GetPlayerStartLocation(whichPlayer))
endfunction

//===========================================================================
function GetRectCenter takes rect whichRect returns location
    return Location(GetRectCenterX(whichRect), GetRectCenterY(whichRect))
endfunction

//===========================================================================
function IsPlayerSlotState takes player whichPlayer, playerslotstate whichState returns boolean
    return GetPlayerSlotState(whichPlayer) == whichState
endfunction

//===========================================================================
function GetFadeFromSeconds takes real seconds returns integer
    if (seconds != 0) then
        return 128 / R2I(seconds)
    endif
    return 10000
endfunction

//===========================================================================
function GetFadeFromSecondsAsReal takes real seconds returns real
    if (seconds != 0) then
        return 128.00 / seconds
    endif
    return 10000.00
endfunction

//===========================================================================
function AdjustPlayerStateSimpleBJ takes player whichPlayer, playerstate whichPlayerState, integer delta returns nothing
    call SetPlayerState(whichPlayer, whichPlayerState, GetPlayerState(whichPlayer, whichPlayerState) + delta)
endfunction

//===========================================================================
function AdjustPlayerStateBJ takes integer delta, player whichPlayer, playerstate whichPlayerState returns nothing
    // If the change was positive, apply the difference to the player's
    // gathered resources property as well.
    if (delta > 0) then
        if (whichPlayerState == PLAYER_STATE_RESOURCE_GOLD) then
            call AdjustPlayerStateSimpleBJ(whichPlayer, PLAYER_STATE_GOLD_GATHERED, delta)
        elseif (whichPlayerState == PLAYER_STATE_RESOURCE_LUMBER) then
            call AdjustPlayerStateSimpleBJ(whichPlayer, PLAYER_STATE_LUMBER_GATHERED, delta)
        endif
    endif

    call AdjustPlayerStateSimpleBJ(whichPlayer, whichPlayerState, delta)
endfunction

//===========================================================================
function SetPlayerStateBJ takes player whichPlayer, playerstate whichPlayerState, integer value returns nothing
    local integer oldValue = GetPlayerState(whichPlayer, whichPlayerState)
    call AdjustPlayerStateBJ(value - oldValue, whichPlayer, whichPlayerState)
endfunction

//===========================================================================
function SetPlayerFlagBJ takes playerstate whichPlayerFlag, boolean flag, player whichPlayer returns nothing
    call SetPlayerState(whichPlayer, whichPlayerFlag, IntegerTertiaryOp(flag, 1, 0))
endfunction

//===========================================================================
function SetPlayerTaxRateBJ takes integer rate, playerstate whichResource, player sourcePlayer, player otherPlayer returns nothing
    call SetPlayerTaxRate(sourcePlayer, otherPlayer, whichResource, rate)
endfunction

//===========================================================================
function GetPlayerTaxRateBJ takes playerstate whichResource, player sourcePlayer, player otherPlayer returns integer
    return GetPlayerTaxRate(sourcePlayer, otherPlayer, whichResource)
endfunction

//===========================================================================
function IsPlayerFlagSetBJ takes playerstate whichPlayerFlag, player whichPlayer returns boolean
    return GetPlayerState(whichPlayer, whichPlayerFlag) == 1
endfunction

//===========================================================================
function AddResourceAmountBJ takes integer delta, unit whichUnit returns nothing
    call AddResourceAmount(whichUnit, delta)
endfunction

//===========================================================================
function GetConvertedPlayerId takes player whichPlayer returns integer
    return GetPlayerId(whichPlayer) + 1
endfunction

//===========================================================================
function ConvertedPlayer takes integer convertedPlayerId returns player
    return Player(convertedPlayerId - 1)
endfunction

//===========================================================================
function GetRectWidthBJ takes rect r returns real
    return GetRectMaxX(r) - GetRectMinX(r)
endfunction

//===========================================================================
function GetRectHeightBJ takes rect r returns real
    return GetRectMaxY(r) - GetRectMinY(r)
endfunction

//===========================================================================
// Replaces a gold mine with a blighted gold mine for the given player.
//
function BlightGoldMineForPlayerBJ takes unit goldMine, player whichPlayer returns unit
    local real    mineX
    local real    mineY
    local integer mineGold
    local unit    newMine

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(goldMine) != 'ngol' then
        return null
    endif

    // Save the Gold Mine's properties and remove it.
    set mineX    = GetUnitX(goldMine)
    set mineY    = GetUnitY(goldMine)
    set mineGold = GetResourceAmount(goldMine)
    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
    set newMine = CreateBlightedGoldmine(whichPlayer, mineX, mineY, bj_UNIT_FACING)
    call SetResourceAmount(newMine, mineGold)
    return newMine
endfunction

//===========================================================================
function BlightGoldMineForPlayer takes unit goldMine, player whichPlayer returns unit
    set bj_lastHauntedGoldMine = BlightGoldMineForPlayerBJ(goldMine, whichPlayer)
    return bj_lastHauntedGoldMine
endfunction

//===========================================================================
function GetLastHauntedGoldMine takes nothing returns unit
    return bj_lastHauntedGoldMine
endfunction

//===========================================================================
function IsPointBlightedBJ takes location where returns boolean
    return IsPointBlighted(GetLocationX(where), GetLocationY(where))
endfunction

//===========================================================================
function SetPlayerColorBJEnum takes nothing returns nothing
    call SetUnitColor(GetEnumUnit(), bj_setPlayerTargetColor)
endfunction

//===========================================================================
function SetPlayerColorBJ takes player whichPlayer, playercolor color, boolean changeExisting returns nothing
    local group g

    call SetPlayerColor(whichPlayer, color)
    if changeExisting then
        set bj_setPlayerTargetColor = color
        set g = CreateGroup()
        call GroupEnumUnitsOfPlayer(g, whichPlayer, null)
        call ForGroup(g, function SetPlayerColorBJEnum)
        call DestroyGroup(g)
    endif
endfunction

//===========================================================================
function SetPlayerUnitAvailableBJ takes integer unitId, boolean allowed, player whichPlayer returns nothing
    if allowed then
        call SetPlayerTechMaxAllowed(whichPlayer, unitId, -1)
    else
        call SetPlayerTechMaxAllowed(whichPlayer, unitId, 0)
    endif
endfunction

//===========================================================================
function LockGameSpeedBJ takes nothing returns nothing
    call SetMapFlag(MAP_LOCK_SPEED, true)
endfunction

//===========================================================================
function UnlockGameSpeedBJ takes nothing returns nothing
    call SetMapFlag(MAP_LOCK_SPEED, false)
endfunction

//===========================================================================
function IssueTargetOrderBJ takes unit whichUnit, string order, widget targetWidget returns boolean
    return IssueTargetOrder( whichUnit, order, targetWidget )
endfunction

//===========================================================================
function IssuePointOrderLocBJ takes unit whichUnit, string order, location whichLocation returns boolean
    return IssuePointOrderLoc( whichUnit, order, whichLocation )
endfunction

//===========================================================================
// Two distinct trigger actions can't share the same function name, so this
// dummy function simply mimics the behavior of an existing call.
//
function IssueTargetDestructableOrder takes unit whichUnit, string order, widget targetWidget returns boolean
    return IssueTargetOrder( whichUnit, order, targetWidget )
endfunction

function IssueTargetItemOrder takes unit whichUnit, string order, widget targetWidget returns boolean
    return IssueTargetOrder( whichUnit, order, targetWidget )
endfunction

//===========================================================================
function IssueImmediateOrderBJ takes unit whichUnit, string order returns boolean
    return IssueImmediateOrder( whichUnit, order )
endfunction

//===========================================================================
function GroupTargetOrderBJ takes group whichGroup, string order, widget targetWidget returns boolean
    return GroupTargetOrder( whichGroup, order, targetWidget )
endfunction

//===========================================================================
function GroupPointOrderLocBJ takes group whichGroup, string order, location whichLocation returns boolean
    return GroupPointOrderLoc( whichGroup, order, whichLocation )
endfunction

//===========================================================================
function GroupImmediateOrderBJ takes group whichGroup, string order returns boolean
    return GroupImmediateOrder( whichGroup, order )
endfunction

//===========================================================================
// Two distinct trigger actions can't share the same function name, so this
// dummy function simply mimics the behavior of an existing call.
//
function GroupTargetDestructableOrder takes group whichGroup, string order, widget targetWidget returns boolean
    return GroupTargetOrder( whichGroup, order, targetWidget )
endfunction

function GroupTargetItemOrder takes group whichGroup, string order, widget targetWidget returns boolean
    return GroupTargetOrder( whichGroup, order, targetWidget )
endfunction

//===========================================================================
function GetDyingDestructable takes nothing returns destructable
    return GetTriggerDestructable()
endfunction

//===========================================================================
// Rally point setting
//
function SetUnitRallyPoint takes unit whichUnit, location targPos returns nothing
    call IssuePointOrderLocBJ(whichUnit, "setrally", targPos)
endfunction

//===========================================================================
function SetUnitRallyUnit takes unit whichUnit, unit targUnit returns nothing
    call IssueTargetOrder(whichUnit, "setrally", targUnit)
endfunction

//===========================================================================
function SetUnitRallyDestructable takes unit whichUnit, destructable targDest returns nothing
    call IssueTargetOrder(whichUnit, "setrally", targDest)
endfunction

//===========================================================================
// Utility function for use by editor-generated item drop table triggers.
// This function is added as an action to all destructable drop triggers,
// so that a widget drop may be differentiated from a unit drop.
//
function SaveDyingWidget takes nothing returns nothing
    set bj_lastDyingWidget = GetTriggerWidget()
endfunction

//===========================================================================
function SetBlightRectBJ takes boolean addBlight, player whichPlayer, rect r returns nothing
    call SetBlightRect(whichPlayer, r, addBlight)
endfunction

//===========================================================================
function SetBlightRadiusLocBJ takes boolean addBlight, player whichPlayer, location loc, real radius returns nothing
    call SetBlightLoc(whichPlayer, loc, radius, addBlight)
endfunction

//===========================================================================
function GetAbilityName takes integer abilcode returns string
    return GetObjectName(abilcode)
endfunction


//***************************************************************************
//*
//*  Melee Template Visibility Settings
//*
//***************************************************************************

//===========================================================================
function MeleeStartingVisibility takes nothing returns nothing
    // Start by setting the ToD.
    call SetFloatGameState(GAME_STATE_TIME_OF_DAY, bj_MELEE_STARTING_TOD)

    // call FogMaskEnable(true)
    // call FogEnable(true)
endfunction



//***************************************************************************
//*
//*  Melee Template Starting Resources
//*
//***************************************************************************

//===========================================================================
function MeleeStartingResources takes nothing returns nothing
    local integer index
    local player  indexPlayer
    local version v
    local integer startingGold
    local integer startingLumber

    set v = VersionGet()
    if (v == VERSION_REIGN_OF_CHAOS) then
        set startingGold = bj_MELEE_STARTING_GOLD_V0
        set startingLumber = bj_MELEE_STARTING_LUMBER_V0
    else
        set startingGold = bj_MELEE_STARTING_GOLD_V1
        set startingLumber = bj_MELEE_STARTING_LUMBER_V1
    endif

    // Set each player's starting resources.
    set index = 0
    loop
        set indexPlayer = Player(index)
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
            call SetPlayerState(indexPlayer, PLAYER_STATE_RESOURCE_GOLD, startingGold)
            call SetPlayerState(indexPlayer, PLAYER_STATE_RESOURCE_LUMBER, startingLumber)
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction



//***************************************************************************
//*
//*  Melee Template Hero Limit
//*
//***************************************************************************

//===========================================================================
function ReducePlayerTechMaxAllowed takes player whichPlayer, integer techId, integer limit returns nothing
    local integer oldMax = GetPlayerTechMaxAllowed(whichPlayer, techId)

    // A value of -1 is used to indicate no limit, so check for that as well.
    if (oldMax < 0 or oldMax > limit) then
        call SetPlayerTechMaxAllowed(whichPlayer, techId, limit)
    endif
endfunction

//===========================================================================
function MeleeStartingHeroLimit takes nothing returns nothing
    local integer index

    set index = 0
    loop
        // max heroes per player
        call SetPlayerMaxHeroesAllowed(bj_MELEE_HERO_LIMIT, Player(index))

        // each player is restricted to a limit per hero type as well

//                                        ------HIGH ELVES------
        call ReducePlayerTechMaxAllowed(Player(index), 'Hamg', bj_MELEE_HERO_TYPE_LIMIT)//Greater Phoenix
        call ReducePlayerTechMaxAllowed(Player(index), 'Hmkg', bj_MELEE_HERO_TYPE_LIMIT)//Legionnaire
        call ReducePlayerTechMaxAllowed(Player(index), 'Hpal', bj_MELEE_HERO_TYPE_LIMIT)//Elvish Cavalier
        call ReducePlayerTechMaxAllowed(Player(index), 'Hblm', bj_MELEE_HERO_TYPE_LIMIT)//Blood Mage

//                                        ------DRAENEI------
        call ReducePlayerTechMaxAllowed(Player(index), 'Obla', bj_MELEE_HERO_TYPE_LIMIT)//Warlord
        call ReducePlayerTechMaxAllowed(Player(index), 'Ofar', bj_MELEE_HERO_TYPE_LIMIT)//Master Seer (Old)
        call ReducePlayerTechMaxAllowed(Player(index), 'Otch', bj_MELEE_HERO_TYPE_LIMIT)//Salamander Lord (Old)
        call ReducePlayerTechMaxAllowed(Player(index), 'Oshd', bj_MELEE_HERO_TYPE_LIMIT)//Master Athelete (Old) Now called Master Shaman
        call ReducePlayerTechMaxAllowed(Player(index), 'N02K', bj_MELEE_HERO_TYPE_LIMIT)//Elder Sage
        call ReducePlayerTechMaxAllowed(Player(index), 'N02O', bj_MELEE_HERO_TYPE_LIMIT)//Tamer of Beasts
        
        
        call ReducePlayerTechMaxAllowed(Player(index), 'Lwar', bj_MELEE_HERO_TYPE_LIMIT)//Warlord
        call ReducePlayerTechMaxAllowed(Player(index), 'Lsha', bj_MELEE_HERO_TYPE_LIMIT)//Master Seer (Old)
        call ReducePlayerTechMaxAllowed(Player(index), 'Leds', bj_MELEE_HERO_TYPE_LIMIT)//Salamander Lord (Old)
        call ReducePlayerTechMaxAllowed(Player(index), 'Ltob', bj_MELEE_HERO_TYPE_LIMIT)//Master Athelete (Old) Now called Master Shaman

//                                        ------NAGA------
        call ReducePlayerTechMaxAllowed(Player(index), 'Edem', bj_MELEE_HERO_TYPE_LIMIT)//Scyllia
        call ReducePlayerTechMaxAllowed(Player(index), 'Ekee', bj_MELEE_HERO_TYPE_LIMIT)//Sea Witch
        call ReducePlayerTechMaxAllowed(Player(index), 'Emoo', bj_MELEE_HERO_TYPE_LIMIT)//Mur'gul Slavedriver
        call ReducePlayerTechMaxAllowed(Player(index), 'Ewar', bj_MELEE_HERO_TYPE_LIMIT)//Empress

//                                        ------FORSAKEN------
        call ReducePlayerTechMaxAllowed(Player(index), 'Udea', bj_MELEE_HERO_TYPE_LIMIT)//Banshee
        call ReducePlayerTechMaxAllowed(Player(index), 'Udre', bj_MELEE_HERO_TYPE_LIMIT)//Dementoid
        call ReducePlayerTechMaxAllowed(Player(index), 'Ulic', bj_MELEE_HERO_TYPE_LIMIT)//Dark Ranger
        call ReducePlayerTechMaxAllowed(Player(index), 'Ucrl', bj_MELEE_HERO_TYPE_LIMIT)//Blue Demon

//                                        ------OLD NEUTRAL------
        call ReducePlayerTechMaxAllowed(Player(index), 'Npbm', bj_MELEE_HERO_TYPE_LIMIT)//Pandaren Brewmaster
        call ReducePlayerTechMaxAllowed(Player(index), 'Nbrn', bj_MELEE_HERO_TYPE_LIMIT)//Dark Ranger (Old)
        call ReducePlayerTechMaxAllowed(Player(index), 'Nngs', bj_MELEE_HERO_TYPE_LIMIT)//Naga Sea Witch
        call ReducePlayerTechMaxAllowed(Player(index), 'Nplh', bj_MELEE_HERO_TYPE_LIMIT)//Pit Lord
        call ReducePlayerTechMaxAllowed(Player(index), 'Nbst', bj_MELEE_HERO_TYPE_LIMIT)//Beastmaster
        call ReducePlayerTechMaxAllowed(Player(index), 'Nalc', bj_MELEE_HERO_TYPE_LIMIT)//Alchemist
        call ReducePlayerTechMaxAllowed(Player(index), 'Ntin', bj_MELEE_HERO_TYPE_LIMIT)//Tinker
        call ReducePlayerTechMaxAllowed(Player(index), 'Nfir', bj_MELEE_HERO_TYPE_LIMIT)//Firelord

//                                        ------FREEZING LEGION------
        call ReducePlayerTechMaxAllowed(Player(index), 'E016', bj_MELEE_HERO_TYPE_LIMIT)//Icelord
        call ReducePlayerTechMaxAllowed(Player(index), 'U013', bj_MELEE_HERO_TYPE_LIMIT)//Defernal Lord (Unused)
        call ReducePlayerTechMaxAllowed(Player(index), 'U017', bj_MELEE_HERO_TYPE_LIMIT)//Legion Grandmaster
        call ReducePlayerTechMaxAllowed(Player(index), 'N01O', bj_MELEE_HERO_TYPE_LIMIT)//Dungorian Translocator
        call ReducePlayerTechMaxAllowed(Player(index), 'H01A', bj_MELEE_HERO_TYPE_LIMIT)//Frost Titan (unused)
        call ReducePlayerTechMaxAllowed(Player(index), 'N03B', bj_MELEE_HERO_TYPE_LIMIT)//Lord of the Blue Inferno (unused)
        call ReducePlayerTechMaxAllowed(Player(index), 'N03F', bj_MELEE_HERO_TYPE_LIMIT)//Iceclan Champion
// Seven heroes made and only 4 are actually used! Phew!

//                                        ------FREEZING LEGION 2------
        call ReducePlayerTechMaxAllowed(Player(index), 'FHTR', bj_MELEE_HERO_TYPE_LIMIT)//Tuskarr Chieftain
        call ReducePlayerTechMaxAllowed(Player(index), 'FLGM', bj_MELEE_HERO_TYPE_LIMIT)//Legion Grandmaster
        call ReducePlayerTechMaxAllowed(Player(index), 'FCMP', bj_MELEE_HERO_TYPE_LIMIT)//Iceclan Champion
        call ReducePlayerTechMaxAllowed(Player(index), 'FMTR', bj_MELEE_HERO_TYPE_LIMIT)//Iceclan Mountaineer
// Seven heroes made and only 4 are actually used! Phew!

//                                        ------ZEAR------
        call ReducePlayerTechMaxAllowed(Player(index), 'N00H', bj_MELEE_HERO_TYPE_LIMIT)//Troll Warlord (unused)
        call ReducePlayerTechMaxAllowed(Player(index), 'N02B', bj_MELEE_HERO_TYPE_LIMIT)//Berserker
        call ReducePlayerTechMaxAllowed(Player(index), 'N00Z', bj_MELEE_HERO_TYPE_LIMIT)//Blood Magi
        call ReducePlayerTechMaxAllowed(Player(index), 'N00Y', bj_MELEE_HERO_TYPE_LIMIT)//Bonecrusher
        call ReducePlayerTechMaxAllowed(Player(index), 'N011', bj_MELEE_HERO_TYPE_LIMIT)//Warlock

//                                        ------VOID RACE------
        call ReducePlayerTechMaxAllowed(Player(index), 'U01H', bj_MELEE_HERO_TYPE_LIMIT)//Aether Flameweaver
        call ReducePlayerTechMaxAllowed(Player(index), 'U01M', bj_MELEE_HERO_TYPE_LIMIT)//Maw of Oblivion
        call ReducePlayerTechMaxAllowed(Player(index), 'U01N', bj_MELEE_HERO_TYPE_LIMIT)//Maw (Rooted)
        call ReducePlayerTechMaxAllowed(Player(index), 'U01L', bj_MELEE_HERO_TYPE_LIMIT)//Ascended Overlord
        call ReducePlayerTechMaxAllowed(Player(index), 'O01U', bj_MELEE_HERO_TYPE_LIMIT)//Void God
        call ReducePlayerTechMaxAllowed(Player(index), 'O01V', bj_MELEE_HERO_TYPE_LIMIT)//Void God (Super Destructive Win Form)

//                                        ------NEW HUMANS------
        call ReducePlayerTechMaxAllowed(Player(index), 'H035', bj_MELEE_HERO_TYPE_LIMIT)//Final Judge
        call ReducePlayerTechMaxAllowed(Player(index), 'H036', bj_MELEE_HERO_TYPE_LIMIT)//Arcane Priestess
        call ReducePlayerTechMaxAllowed(Player(index), 'H037', bj_MELEE_HERO_TYPE_LIMIT)//Horsemaster
        call ReducePlayerTechMaxAllowed(Player(index), 'H038', bj_MELEE_HERO_TYPE_LIMIT)//Ranger
		
//                                        ------OLD-NEW NEUTRAL------ 
//                    (The heroes Inherited from the original mod, soon to be replaced by the newer new heroes)
        call ReducePlayerTechMaxAllowed(Player(index), 'O014', bj_MELEE_HERO_TYPE_LIMIT)//Black Saber
        call ReducePlayerTechMaxAllowed(Player(index), 'U012', bj_MELEE_HERO_TYPE_LIMIT)//Penguin King
        call ReducePlayerTechMaxAllowed(Player(index), 'U01F', bj_MELEE_HERO_TYPE_LIMIT)//Uber Retera Hero
        call ReducePlayerTechMaxAllowed(Player(index), 'U011', bj_MELEE_HERO_TYPE_LIMIT)//Arctic Lich
        call ReducePlayerTechMaxAllowed(Player(index), 'N02L', bj_MELEE_HERO_TYPE_LIMIT)//Alchemist?
        call ReducePlayerTechMaxAllowed(Player(index), 'N014', bj_MELEE_HERO_TYPE_LIMIT)//Eredar Harvester
        call ReducePlayerTechMaxAllowed(Player(index), 'N012', bj_MELEE_HERO_TYPE_LIMIT)//Arrow Master
        call ReducePlayerTechMaxAllowed(Player(index), 'N013', bj_MELEE_HERO_TYPE_LIMIT)//Fire Reaver
        call ReducePlayerTechMaxAllowed(Player(index), 'N016', bj_MELEE_HERO_TYPE_LIMIT)//Flare Titan
        call ReducePlayerTechMaxAllowed(Player(index), 'N015', bj_MELEE_HERO_TYPE_LIMIT)//Grand Infernal
		
		
//                                        ------NEW NEUTRAL------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'O020', bj_MELEE_HERO_TYPE_LIMIT)//Harbinger of Armageddon
        call ReducePlayerTechMaxAllowed(Player(index), 'E01S', bj_MELEE_HERO_TYPE_LIMIT)//Illidan Blade Warrior
        call ReducePlayerTechMaxAllowed(Player(index), 'H03Y', bj_MELEE_HERO_TYPE_LIMIT)//Mercenary Captain
        call ReducePlayerTechMaxAllowed(Player(index), 'NZgg', bj_MELEE_HERO_TYPE_LIMIT)//Grim Guard
        call ReducePlayerTechMaxAllowed(Player(index), 'H03X', bj_MELEE_HERO_TYPE_LIMIT)//Duelist
        call ReducePlayerTechMaxAllowed(Player(index), 'NSTO', bj_MELEE_HERO_TYPE_LIMIT)//Storm Lord
        call ReducePlayerTechMaxAllowed(Player(index), 'Near', bj_MELEE_HERO_TYPE_LIMIT)//Earthshaper
        call ReducePlayerTechMaxAllowed(Player(index), 'Otnj', bj_MELEE_HERO_TYPE_LIMIT)//Tauren Juggernaught
        call ReducePlayerTechMaxAllowed(Player(index), 'Nfdj', bj_MELEE_HERO_TYPE_LIMIT)//Fire Djinn
		
//                                        ------DEV RISEN------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'U02J', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U02B', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U028', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U02A', bj_MELEE_HERO_TYPE_LIMIT)
		
		
//                                        ------OLD HUMANS------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'H00S', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'H00T', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'H00U', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'H00V', bj_MELEE_HERO_TYPE_LIMIT)

//                                        ------OLD ORCS------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'O00O', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'O00P', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'O00Q', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'O00R', bj_MELEE_HERO_TYPE_LIMIT)

//                                        ------OLD NIGHT ELF------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'E00Z', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'E010', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'E011', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'E012', bj_MELEE_HERO_TYPE_LIMIT)

//                                        ------OLD UNDEAD------ 
        call ReducePlayerTechMaxAllowed(Player(index), 'U00Q', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U00R', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U00S', bj_MELEE_HERO_TYPE_LIMIT)
        call ReducePlayerTechMaxAllowed(Player(index), 'U00T', bj_MELEE_HERO_TYPE_LIMIT)



    call SetPlayerAbilityAvailable( Player(index),'A06Z',false   )
    call SetPlayerAbilityAvailable( Player(index),'A091',false   )
    call SetPlayerAbilityAvailable( Player(index),'A07G',false   )
    call SetPlayerAbilityAvailable( Player(index),'A09C',false   )
    call SetPlayerAbilityAvailable( Player(index),'A0CV',false   )
    call SetPlayerAbilityAvailable( Player(index),'A0L8',false   )
    call SetPlayerAbilityAvailable( Player(index),'AZZS',false   )
    call SetPlayerAbilityAvailable( Player(index),'A0S9',false   )
    call SetPlayerAbilityAvailable( Player(index),'A0UZ',false   )
    call SetPlayerUnitAvailableBJ( 'e018', false, Player(index))
    call SetPlayerUnitAvailableBJ( 'h03J', false, Player(index))
    call SetPlayerUnitAvailableBJ( 'e008', false, Player(index))

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop


    set rdg_WallVars[1] = 'h01L'
    set rdg_WallVars[2] = 'h01K'
    set rdg_WallVars[3] = 'h01M'
    set rdg_WallVars[4] = 'h01N'
    set rdg_WallVars[5] = 'h01O'
    set rdg_WallVars[6] = 'h01P'
    set rdg_WallVars[7] = 'h01Q'
    set rdg_WallVars[8] = 'h01R'
    set rdg_WallVars[9] = 'h01S'
    set rdg_WallVars[10] = 'h01T'
endfunction



//***************************************************************************
//*
//*  Melee Template Granted Hero Items
//*
//***************************************************************************

//===========================================================================
function MeleeTrainedUnitIsHeroBJFilter takes nothing returns boolean
    return IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO)
endfunction

//===========================================================================
// The first N heroes trained or hired for each player start off with a
// standard set of items.  This is currently:
//   - 1x Scroll of Town Portal
//
function MeleeGrantItemsToHero takes unit whichUnit returns nothing
    local integer owner   = GetPlayerId(GetOwningPlayer(whichUnit))

    // If we haven't twinked N heroes for this player yet, twink away.
    if (bj_meleeTwinkedHeroes[owner] < bj_MELEE_MAX_TWINKED_HEROES) then
        call UnitAddItemById(whichUnit, 'stwp')
        set bj_meleeTwinkedHeroes[owner] = bj_meleeTwinkedHeroes[owner] + 1
    endif
endfunction

//===========================================================================
function MeleeGrantItemsToTrainedHero takes nothing returns nothing
    call MeleeGrantItemsToHero(GetTrainedUnit())
endfunction

//===========================================================================
function MeleeGrantItemsToHiredHero takes nothing returns nothing
    call MeleeGrantItemsToHero(GetSoldUnit())
endfunction

//===========================================================================
function MeleeGrantHeroItems takes nothing returns nothing
    local integer index
    local trigger trig

    // Initialize the twinked hero counts.
    set index = 0
    loop
        set bj_meleeTwinkedHeroes[index] = 0

        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop

    // Register for an event whenever a hero is trained, so that we can give
    // him/her their starting items.
    set index = 0
    loop
        set trig = CreateTrigger()
        call TriggerRegisterPlayerUnitEvent(trig, Player(index), EVENT_PLAYER_UNIT_TRAIN_FINISH, filterMeleeTrainedUnitIsHeroBJ)
        call TriggerAddAction(trig, function MeleeGrantItemsToTrainedHero)

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // Register for an event whenever a neutral hero is hired, so that we
    // can give him/her their starting items.
    set trig = CreateTrigger()
    call TriggerRegisterPlayerUnitEvent(trig, Player(PLAYER_NEUTRAL_PASSIVE), EVENT_PLAYER_UNIT_SELL, filterMeleeTrainedUnitIsHeroBJ)
    call TriggerAddAction(trig, function MeleeGrantItemsToHiredHero)

    // Flag that we are giving starting items to heroes, so that the melee
    // starting units code can create them as necessary.
    set bj_meleeGrantHeroItems = true
endfunction



//***************************************************************************
//*
//*  Melee Template Clear Start Locations
//*
//***************************************************************************

//===========================================================================
function MeleeClearExcessUnit takes nothing returns nothing
    local unit    theUnit = GetEnumUnit()
    local integer owner   = GetPlayerId(GetOwningPlayer(theUnit))

    if (owner == PLAYER_NEUTRAL_AGGRESSIVE) then
        // Remove any Neutral Hostile units from the area.
        call RemoveUnit(GetEnumUnit())
    elseif (owner == PLAYER_NEUTRAL_PASSIVE) then
        // Remove non-structure Neutral Passive units from the area.
        if not IsUnitType(theUnit, UNIT_TYPE_STRUCTURE) then
            call RemoveUnit(GetEnumUnit())
        endif
    endif
endfunction

//===========================================================================
function MeleeClearNearbyUnits takes real x, real y, real range returns nothing
    local group nearbyUnits
    
    set nearbyUnits = CreateGroup()
    call GroupEnumUnitsInRange(nearbyUnits, x, y, range, null)
    call ForGroup(nearbyUnits, function MeleeClearExcessUnit)
    call DestroyGroup(nearbyUnits)
endfunction

//===========================================================================
function MeleeClearExcessUnits takes nothing returns nothing
    local integer index
    local real    locX
    local real    locY
    local player  indexPlayer

    set index = 0
    loop
        set indexPlayer = Player(index)

        // If the player slot is being used, clear any nearby creeps.
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
            set locX = GetStartLocationX(GetPlayerStartLocation(indexPlayer))
            set locY = GetStartLocationY(GetPlayerStartLocation(indexPlayer))

            call MeleeClearNearbyUnits(locX, locY, bj_MELEE_CLEAR_UNITS_RADIUS)
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction



//***************************************************************************
//*
//*  Melee Template Starting Units
//*
//***************************************************************************

//===========================================================================
function MeleeEnumFindNearestMine takes nothing returns nothing
    local unit enumUnit = GetEnumUnit()
    local real dist
    local location unitLoc

    if (GetUnitTypeId(enumUnit) == 'ngol') then
        set unitLoc = GetUnitLoc(enumUnit)
        set dist = DistanceBetweenPoints(unitLoc, bj_meleeNearestMineToLoc)
        call RemoveLocation(unitLoc)

        // If this is our first mine, or the closest thusfar, use it instead.
        if (bj_meleeNearestMineDist < 0) or (dist < bj_meleeNearestMineDist) then
            set bj_meleeNearestMine = enumUnit
            set bj_meleeNearestMineDist = dist
        endif
    endif
endfunction

//===========================================================================
function MeleeFindNearestMine takes location src, real range returns unit
    local group nearbyMines

    set bj_meleeNearestMine = null
    set bj_meleeNearestMineDist = -1
    set bj_meleeNearestMineToLoc = src

    set nearbyMines = CreateGroup()
    call GroupEnumUnitsInRangeOfLoc(nearbyMines, src, range, null)
    call ForGroup(nearbyMines, function MeleeEnumFindNearestMine)
    call DestroyGroup(nearbyMines)

    return bj_meleeNearestMine
endfunction

//===========================================================================
function MeleeRandomHeroLoc takes player p, integer id1, integer id2, integer id3, integer id4, location loc returns unit
    local unit    hero = null
    local integer roll
    local integer pick
    local version v

    // The selection of heroes is dependant on the game version.
    set v = VersionGet()
    if (v == VERSION_REIGN_OF_CHAOS) then
        set roll = GetRandomInt(1,3)
    else
        set roll = GetRandomInt(1,4)
    endif

    // Translate the roll into a unitid.
    if roll == 1 then
        set pick = id1
    elseif roll == 2 then
        set pick = id2
    elseif roll == 3 then
        set pick = id3
    elseif roll == 4 then
        set pick = id4
    else
        // Unrecognized id index - pick the first hero in the list.
        set pick = id1
    endif

    // Create the hero.
    set hero = CreateUnitAtLoc(p, pick, loc, bj_UNIT_FACING)
    if bj_meleeGrantHeroItems then
        call MeleeGrantItemsToHero(hero)
    endif
    return hero
endfunction

//===========================================================================
// Returns a location which is (distance) away from (src) in the direction of (targ).
//
function MeleeGetProjectedLoc takes location src, location targ, real distance, real deltaAngle returns location
    local real srcX = GetLocationX(src)
    local real srcY = GetLocationY(src)
    local real direction = Atan2(GetLocationY(targ) - srcY, GetLocationX(targ) - srcX) + deltaAngle
    return Location(srcX + distance * Cos(direction), srcY + distance * Sin(direction))
endfunction

//===========================================================================
function MeleeGetNearestValueWithin takes real val, real minVal, real maxVal returns real
    if (val < minVal) then
        return minVal
    elseif (val > maxVal) then
        return maxVal
    else
        return val
    endif
endfunction

//===========================================================================
function MeleeGetLocWithinRect takes location src, rect r returns location
    local real withinX = MeleeGetNearestValueWithin(GetLocationX(src), GetRectMinX(r), GetRectMaxX(r))
    local real withinY = MeleeGetNearestValueWithin(GetLocationY(src), GetRectMinY(r), GetRectMaxY(r))
    return Location(withinX, withinY)
endfunction

//===========================================================================
// Starting Units for Human Players
//   - 1 Town Hall, placed at start location
//   - 5 Peasants, placed between start location and nearest gold mine
//
function MeleeStartingUnitsHuman takes player whichPlayer, location startLoc, boolean doHeroes, boolean doCamera, boolean doPreload returns nothing
    local boolean  useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO)
    local real     unitSpacing   = 64.00
    local unit     nearestMine
    local location nearMineLoc
    local location heroLoc
    local real     peonX
    local real     peonY
    local unit     townHall = null

    if (doPreload) then
        call Preloader( "scripts\\HumanMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc, bj_MELEE_MINE_SEARCH_RADIUS)
    if (nearestMine != null) then
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer, 'htow', startLoc, bj_UNIT_FACING)
        
        // Spawn Peasants near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer, 'hpea', peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX + 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX - 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45)
    else
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer, 'htow', startLoc, bj_UNIT_FACING)
        
        // Spawn Peasants directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer, 'hpea', peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'hpea', peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX, peonY - 2.00 * unitSpacing)
    endif

    if (townHall != null) then
        call UnitAddAbilityBJ('Amic', townHall)
        call UnitMakeAbilityPermanentBJ(true, 'Amic', townHall)
    endif

    if (doHeroes) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer, 'Hamg', 'Hmkg', 'Hpal', 'Hblm', heroLoc)
        else
            call SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if (doCamera) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer, peonX, peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Orc Players
//   - 1 Great Hall, placed at start location
//   - 5 Peons, placed between start location and nearest gold mine
//
function MeleeStartingUnitsOrc takes player whichPlayer, location startLoc, boolean doHeroes, boolean doCamera, boolean doPreload returns nothing
    local boolean  useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO)
    local real     unitSpacing   = 64.00
    local unit     nearestMine
    local location nearMineLoc
    local location heroLoc
    local real     peonX
    local real     peonY

    if (doPreload) then
        call Preloader( "scripts\\OrcMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc, bj_MELEE_MINE_SEARCH_RADIUS)
    if (nearestMine != null) then
        // Spawn Great Hall at the start location.
        call CreateUnitAtLoc(whichPlayer, 'ogre', startLoc, bj_UNIT_FACING)
        
        // Spawn Peons near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer, 'opeo', peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX + 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX - 0.60 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45)
    else
        // Spawn Great Hall at the start location.
        call CreateUnitAtLoc(whichPlayer, 'ogre', startLoc, bj_UNIT_FACING)
        
        // Spawn Peons directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer, 'opeo', peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'opeo', peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX, peonY - 2.00 * unitSpacing)
    endif

    if (doHeroes) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer, 'Obla', 'Ofar', 'Otch', 'Oshd', heroLoc)
        else
            call SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if (doCamera) then
        // Center the camera on the initial Peons.
        call SetCameraPositionForPlayer(whichPlayer, peonX, peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Undead Players
//   - 1 Necropolis, placed at start location
//   - 1 Haunted Gold Mine, placed on nearest gold mine
//   - 3 Acolytes, placed between start location and nearest gold mine
//   - 1 Ghoul, placed between start location and nearest gold mine
//   - Blight, centered on nearest gold mine, spread across a "large area"
//
function MeleeStartingUnitsUndead takes player whichPlayer, location startLoc, boolean doHeroes, boolean doCamera, boolean doPreload returns nothing
    local boolean  useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO)
    local real     unitSpacing   = 64.00
    local unit     nearestMine
    local location nearMineLoc
    local location nearTownLoc
    local location heroLoc
    local real     peonX
    local real     peonY
    local real     ghoulX
    local real     ghoulY

    if (doPreload) then
        call Preloader( "scripts\\UndeadMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc, bj_MELEE_MINE_SEARCH_RADIUS)
    if (nearestMine != null) then
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer, 'unpl', startLoc, bj_UNIT_FACING)
        
        // Replace the nearest gold mine with a blighted version.
        set nearestMine = BlightGoldMineForPlayerBJ(nearestMine, whichPlayer)

        // Spawn Ghoul near the Necropolis.
        set nearTownLoc = MeleeGetProjectedLoc(startLoc, GetUnitLoc(nearestMine), 288, 0)
        set ghoulX = GetLocationX(nearTownLoc)
        set ghoulY = GetLocationY(nearTownLoc)
        set bj_ghoul[GetPlayerId(whichPlayer)] = CreateUnit(whichPlayer, 'ugho', ghoulX + 0.00 * unitSpacing, ghoulY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Spawn Acolytes near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer, 'uaco', peonX + 0.00 * unitSpacing, peonY + 0.50 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'uaco', peonX + 0.65 * unitSpacing, peonY - 0.50 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'uaco', peonX - 0.65 * unitSpacing, peonY - 0.50 * unitSpacing, bj_UNIT_FACING)

        // Create a patch of blight around the gold mine.
        call SetBlightLoc(whichPlayer,nearMineLoc, 768, true)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45)
    else
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer, 'unpl', startLoc, bj_UNIT_FACING)
        
        // Spawn Acolytes and Ghoul directly south of the Necropolis.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer, 'uaco', peonX - 1.50 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'uaco', peonX - 0.50 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'uaco', peonX + 0.50 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'ugho', peonX + 1.50 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Create a patch of blight around the start location.
        call SetBlightLoc(whichPlayer,startLoc, 768, true)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX, peonY - 2.00 * unitSpacing)
    endif

    if (doHeroes) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer, 'Udea', 'Udre', 'Ulic', 'Ucrl', heroLoc)
        else
            call SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if (doCamera) then
        // Center the camera on the initial Acolytes.
        call SetCameraPositionForPlayer(whichPlayer, peonX, peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Night Elf Players
//   - 1 Tree of Life, placed by nearest gold mine, already entangled
//   - 5 Wisps, placed between Tree of Life and nearest gold mine
//
function MeleeStartingUnitsNightElf takes player whichPlayer, location startLoc, boolean doHeroes, boolean doCamera, boolean doPreload returns nothing
    local boolean  useRandomHero = IsMapFlagSet(MAP_RANDOM_HERO)
    local real     unitSpacing   = 64.00
    local real     minTreeDist   = 3.50 * bj_CELLWIDTH
    local real     minWispDist   = 1.75 * bj_CELLWIDTH
    local unit     nearestMine
    local location nearMineLoc
    local location wispLoc
    local location heroLoc
    local real     peonX
    local real     peonY
    local unit     tree

    if (doPreload) then
        call Preloader( "scripts\\NightElfMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc, bj_MELEE_MINE_SEARCH_RADIUS)
    if (nearestMine != null) then
        // Spawn Tree of Life near the mine and have it entangle the mine.
        // Project the Tree's coordinates from the gold mine, and then snap
        // the X and Y values to within minTreeDist of the Gold Mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 650, 0)
        set nearMineLoc = MeleeGetLocWithinRect(nearMineLoc, GetRectFromCircleBJ(GetUnitLoc(nearestMine), minTreeDist))
        set tree = CreateUnitAtLoc(whichPlayer, 'etol', nearMineLoc, bj_UNIT_FACING)
        call IssueTargetOrder(tree, "entangleinstant", nearestMine)

        // Spawn Wisps at the start location.
        set wispLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 320, 0)
        set wispLoc = MeleeGetLocWithinRect(wispLoc, GetRectFromCircleBJ(GetUnitLoc(nearestMine), minWispDist))
        set peonX = GetLocationX(wispLoc)
        set peonY = GetLocationY(wispLoc)
        call CreateUnit(whichPlayer, 'wser', peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX + 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX - 1.00 * unitSpacing, peonY + 0.15 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX + 0.58 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX - 0.58 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine), startLoc, 384, 45)
    else
        // Spawn Tree of Life at the start location.
        call CreateUnitAtLoc(whichPlayer, 'etol', startLoc, bj_UNIT_FACING)

        // Spawn Wisps directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer, 'wser', peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
        call CreateUnit(whichPlayer, 'wser', peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX, peonY - 2.00 * unitSpacing)
    endif

    if (doHeroes) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer, 'Edem', 'Ekee', 'Emoo', 'Ewar', heroLoc)
        else
            call SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if (doCamera) then
        // Center the camera on the initial Wisps.
        call SetCameraPositionForPlayer(whichPlayer, peonX, peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer, peonX, peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Players Whose Race is Unknown
//   - 12 Sheep, placed randomly around the start location
//
function MeleeStartingUnitsUnknownRace takes player whichPlayer, location startLoc, boolean doHeroes, boolean doCamera, boolean doPreload returns nothing
    local integer index

    if (doPreload) then
    endif

    set index = 0
    loop
        call CreateUnit(whichPlayer, 'nshe', GetLocationX(startLoc) + GetRandomReal(-256, 256), GetLocationY(startLoc) + GetRandomReal(-256, 256), GetRandomReal(0, 360))
        set index = index + 1
        exitwhen index == 12
    endloop

    if (doHeroes) then
        // Give them a "free hero" token, out of pity.
        call SetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_HERO_TOKENS, bj_MELEE_STARTING_HERO_TOKENS)
    endif

    if (doCamera) then
        // Center the camera on the initial sheep.
        call SetCameraPositionLocForPlayer(whichPlayer, startLoc)
        call SetCameraQuickPositionLocForPlayer(whichPlayer, startLoc)
    endif
endfunction

//===========================================================================

function MeleeStartingUnitsX takes nothing returns nothing
    local integer  index
    local player   indexPlayer
    local location indexStartLoc
    local race     indexRace

    call Preloader( "scripts\\SharedMelee.pld" )

    set index = 0
    loop
        set indexPlayer = Player(index)
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
        if (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER) then
            set indexStartLoc = GetStartLocationLoc(GetPlayerStartLocation(indexPlayer))
            set indexRace = GetPlayerRace(indexPlayer)

            // Create initial race-specific starting units
            if (indexRace == RACE_HUMAN) then
                call MeleeStartingUnitsHuman(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_ORC) then
                call MeleeStartingUnitsOrc(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_UNDEAD) then
                call MeleeStartingUnitsUndead(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_NIGHTELF) then
                call MeleeStartingUnitsNightElf(indexPlayer, indexStartLoc, true, true, true)
            else
                call MeleeStartingUnitsUnknownRace(indexPlayer, indexStartLoc, true, true, true)
            endif
        endif
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
    
endfunction



//===========================================================================
function MeleeStartingUnitsForPlayer takes race whichRace, player whichPlayer, location loc, boolean doHeroes returns nothing
    // Create initial race-specific starting units
    if (whichRace == RACE_HUMAN) then
        call MeleeStartingUnitsHuman(whichPlayer, loc, doHeroes, false, false)
    elseif (whichRace == RACE_ORC) then
        call MeleeStartingUnitsOrc(whichPlayer, loc, doHeroes, false, false)
    elseif (whichRace == RACE_UNDEAD) then
        call MeleeStartingUnitsUndead(whichPlayer, loc, doHeroes, false, false)
    elseif (whichRace == RACE_NIGHTELF) then
        call MeleeStartingUnitsNightElf(whichPlayer, loc, doHeroes, false, false)
    else
        // Unrecognized race - ignore the request.
    endif
endfunction



//***************************************************************************
//*
//*  Melee Template Starting AI Scripts
//*
//***************************************************************************

//===========================================================================
function PickMeleeAI takes player num, string s1, string s2, string s3 returns nothing
    local integer pick

    // easy difficulty never uses any custom AI scripts
    // that are designed to be a bit more challenging
    //
    if GetAIDifficulty(num) == AI_DIFFICULTY_NEWBIE then
        call StartMeleeAI(num,s1)
		//call BJDebugMsg("Player "+I2S(GetConvertedPlayerId(num))+" will be using the "+s1+" as their AI.")
        return
    endif

    if s2 == null then
        set pick = 1
    elseif s3 == null then
        set pick = GetRandomInt(1,2)
    else
        set pick = GetRandomInt(1,3)
    endif

    if pick == 1 then
        call StartMeleeAI(num,s1)
		//call BJDebugMsg("Player "+I2S(GetConvertedPlayerId(num))+" will be using the "+s1+" as their AI.")
    elseif pick == 2 then
        call StartMeleeAI(num,s2)
		//call BJDebugMsg("Player "+I2S(GetConvertedPlayerId(num))+" will be using the "+s2+" as their AI.")
    else
        call StartMeleeAI(num,s3)
		//call BJDebugMsg("Player "+I2S(GetConvertedPlayerId(num))+" will be using the "+s3+" as their AI.")
    endif
endfunction

//===========================================================================
function MeleeStartingAI takes nothing returns nothing
local integer  index
local player   indexPlayer
local location indexStartLoc
local race  indexRace
local real     racialHandicap

set index = 0
loop
     set indexPlayer = Player(index)
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) and not IsPlayerObserver(indexPlayer) then
            set indexStartLoc = GetStartLocationLoc(GetPlayerStartLocation(indexPlayer))

            set indexRace = GetPlayerRace(indexPlayer)
            set racialHandicap = GetPlayerHandicap(indexPlayer)
            
            // Setup AIs
            if (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER) then
                if (IsMapFlagSet(MAP_RANDOM_HERO)) then
                    if (indexRace == RACE_HUMAN and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                        call PickMeleeAI(indexPlayer, "FA_7A.ai", null, null)
                    elseif (indexRace == RACE_HUMAN) then
                        call PickMeleeAI(indexPlayer, "ZearA.ai", null, null)
                    elseif (indexRace == RACE_ORC and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
						call PickMeleeAI(indexPlayer, "CoastrunnerRushA.ai", null, null)
                    elseif (indexRace == RACE_ORC) then
                        call PickMeleeAI(indexPlayer, "draeneiA.ai", null, null)
                    elseif (indexRace == RACE_NIGHTELF) then
                        call PickMeleeAI(indexPlayer, "fl01A.ai", null, null)
                    elseif (indexRace == RACE_UNDEAD) then
                        call PickMeleeAI(indexPlayer, "voidspawnA.ai", null, null)//allows AI editor to inject AI maybe
                    else
                        call BJDebugMsg("AI race resolution error")
                    endif
                else
                    if (indexRace == RACE_HUMAN and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                        call PickMeleeAI(indexPlayer, "FA_7.ai", null, null)
                    elseif (indexRace == RACE_HUMAN) then
                        call PickMeleeAI(indexPlayer, "Zear.ai", null, null)
                    elseif (indexRace == RACE_ORC and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
						call PickMeleeAI(indexPlayer, "CoastrunnerRush.ai", null, null)
                    elseif (indexRace == RACE_ORC) then
                        call PickMeleeAI(indexPlayer, "draenei.ai", null, null)
                    elseif (indexRace == RACE_NIGHTELF) then
                        call PickMeleeAI(indexPlayer, "fl01.ai", null, null)
                    elseif (indexRace == RACE_UNDEAD) then
                        call PickMeleeAI(indexPlayer, "voidspawn.ai", null, null)//allows AI editor to inject AI maybe
                    else
                        call BJDebugMsg("AI race resolution error")
                    endif
                endif
            endif
            

            if (indexRace == RACE_ORC and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                call SetPlayerHandicapBJ(indexPlayer,100)
            elseif (indexRace == RACE_HUMAN and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                call SetPlayerHandicapBJ(indexPlayer,100)
            endif
			//if( IsPlayerRacePrefSet(indexPlayer,RACE_PREF_RANDOM) )then
			//	call SetPlayerHandicapBJ(indexPlayer,100)
			//	//call BJDebugMsg("racepref rand")
			//elseif ( IsPlayerRacePrefSet(indexPlayer,RACE_PREF_HUMAN) )then
			//	if( indexRace == mc_RACE_ALLIES or indexRace == mc_RACE_TIDE ) then
			//		call SetPlayerHandicapBJ(indexPlayer,100)
			//	else
			//		call SetPlayerHandicapBJ(indexPlayer,90)
			//	endif
			//	//call BJDebugMsg("racepref h")
			//elseif ( IsPlayerRacePrefSet(indexPlayer,RACE_PREF_ORC) )then
			//	call SetPlayerHandicapBJ(indexPlayer,80)
			//	//call BJDebugMsg("racepref o")
			//elseif ( IsPlayerRacePrefSet(indexPlayer,RACE_PREF_UNDEAD) )then
			//	call SetPlayerHandicapBJ(indexPlayer,70)
			//	//call BJDebugMsg("racepref u")
			//elseif ( IsPlayerRacePrefSet(indexPlayer,RACE_PREF_NIGHTELF) )then
			//	call SetPlayerHandicapBJ(indexPlayer,60)
			//	//call BJDebugMsg("racepref n")
			//else
			//	call SetPlayerHandicapBJ(indexPlayer,100)
			//	//call BJDebugMsg("racepref ????")
			//endif
        endif
        
     set index = index + 1
     exitwhen index == bj_MAX_PLAYERS
endloop
endfunction

function LockGuardPosition takes unit targ returns nothing
    call SetUnitCreepGuard(targ,true)
endfunction


//***************************************************************************
//*
//*  Melee Template Victory / Defeat Conditions
//*
//***************************************************************************

//===========================================================================
function MeleePlayerIsOpponent takes integer playerIndex, integer opponentIndex returns boolean
    local player thePlayer = Player(playerIndex)
    local player theOpponent = Player(opponentIndex)

    // The player himself is not an opponent.
    if (playerIndex == opponentIndex) then
        return false
    endif

    // Unused player slots are not opponents.
    if (GetPlayerSlotState(theOpponent) != PLAYER_SLOT_STATE_PLAYING) then
        return false
    endif

    // Players who are already defeated are not opponents.
    if (bj_meleeDefeated[opponentIndex]) then
        return false
    endif

    // Allied players with allied victory set are not opponents.
    if GetPlayerAlliance(thePlayer, theOpponent, ALLIANCE_PASSIVE) then
        if GetPlayerAlliance(theOpponent, thePlayer, ALLIANCE_PASSIVE) then
            if (GetPlayerState(thePlayer, PLAYER_STATE_ALLIED_VICTORY) == 1) then
                if (GetPlayerState(theOpponent, PLAYER_STATE_ALLIED_VICTORY) == 1) then
                    return false
                endif
            endif
        endif
    endif

    return true
endfunction

//===========================================================================
// Count buildings currently owned by all allies, including the player themself.
// *** Needs to be able to run for only local player (noted by Retera)
function MeleeGetAllyStructureCount takes player whichPlayer returns integer
    local integer    playerIndex
    local integer    buildingCount
    local player     indexPlayer

    // Count the number of buildings controlled by all not-yet-defeated co-allies.
    set buildingCount = 0
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)

        // uncomment to cause defeat even if you have control of ally structures, but yours have been nixed
        //if (PlayersAreCoAllied(whichPlayer, indexPlayer) and not bj_meleeDefeated[playerIndex]) then
        if (PlayersAreCoAllied(whichPlayer, indexPlayer)) then
            set buildingCount = buildingCount + GetPlayerStructureCount(indexPlayer, true)
			set buildingCount = buildingCount - (GetPlayerTypedUnitCount(indexPlayer, "custom_n03A", true, false)+GetPlayerTypedUnitCount(indexPlayer, "custom_n03J", true, false))
			if rdg_isCheats then
			    call BJDebugMsg("Building count adjusted by "+I2S((GetPlayerTypedUnitCount(indexPlayer, "custom_n03A", true, false)+GetPlayerTypedUnitCount(indexPlayer, "custom_n03J", true, false))) + " for nether childs.")
			endif
        endif
            
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    return buildingCount
endfunction

//===========================================================================
// Count allies, excluding dead players and the player themself.
//
function MeleeGetAllyCount takes player whichPlayer returns integer
    local integer playerIndex
    local integer playerCount
    local player  indexPlayer

    // Count the number of not-yet-defeated co-allies.
    set playerCount = 0
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if PlayersAreCoAllied(whichPlayer, indexPlayer) and not bj_meleeDefeated[playerIndex] and (whichPlayer != indexPlayer) then
            set playerCount = playerCount + 1
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    return playerCount
endfunction

//===========================================================================
// Counts key structures owned by a player and his or her allies, including
// structures currently upgrading or under construction.
//
// Key structures: Town Hall, Great Hall, Tree of Life, Necropolis
//

function LivingPlayerHallsFilter takes nothing returns boolean
    return (IsUnitAliveBJ(GetFilterUnit()) and IsUnitType(GetFilterUnit(),UNIT_TYPE_TOWNHALL))
endfunction

function CountLivingPlayerTownHalls takes player whichPlayer returns integer
    local group g
    local integer matchedCount
    local boolexpr b=Filter(function LivingPlayerHallsFilter)

    set g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, whichPlayer, b)
    set matchedCount = CountUnitsInGroup(g)
    call DestroyGroup(g)
    call DestroyBoolExpr(b)
    set b=null
    set g=null

    return matchedCount
endfunction

function MeleeGetAllyKeyStructureCount takes player whichPlayer returns integer
    local integer    playerIndex
    local player     indexPlayer
    local integer    keyStructs

    // Count the number of buildings controlled by all not-yet-defeated co-allies.
    set keyStructs = 0
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if (PlayersAreCoAllied(whichPlayer, indexPlayer)) then
            set keyStructs = keyStructs + CountLivingPlayerTownHalls(indexPlayer)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "townhall", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "greathall", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "treeoflife", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "necropolis", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "custom_h030", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "custom_h01C", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "custom_h012", true, true)
        //    set keyStructs = keyStructs + GetPlayerTypedUnitCount(indexPlayer, "custom_h013", true, true)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h013',indexPlayer)//Never use group functions for this, just count living units for player. Much better idea.
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h014',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h015',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h01C',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h01E',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h01F',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h012',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h02F',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h02J',indexPlayer)
        //    set keyStructs = keySructs + CountLivingPlayerUnitsOfTypeId('h030',indexPlayer)
			
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h000',indexPlayer)//Non-modded human custom ids
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h00D',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('h00E',indexPlayer)
			
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('o00C',indexPlayer)//Non-modded orc custom ids
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('o00D',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('o00E',indexPlayer)
			
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('e00M',indexPlayer)//Non-modded night elf custom ids
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('e00N',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('e00O',indexPlayer)
			
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('u00C',indexPlayer)//Non-modded undead custom ids
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('u00D',indexPlayer)
        //    set keyStructs = keyStructs + CountLivingPlayerUnitsOfTypeId('u00E',indexPlayer)
        endif
            
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    return keyStructs
endfunction

//===========================================================================
// Enum: Draw out a specific player.
//
function MeleeDoDrawEnum takes nothing returns nothing
    local player thePlayer = GetEnumPlayer()

    call CachePlayerHeroData(thePlayer)
    call RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_TIE, false)
endfunction

//===========================================================================
// Enum: Victory out a specific player.
//
function MeleeDoVictoryEnum takes nothing returns nothing
    local player thePlayer = GetEnumPlayer()
    local integer playerIndex = GetPlayerId(thePlayer)

    if (not bj_meleeVictoried[playerIndex]) then
        set bj_meleeVictoried[playerIndex] = true
        call CachePlayerHeroData(thePlayer)
        call RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_VICTORY, false)
    endif
endfunction

//===========================================================================
// Defeat out a specific player.
//
function MeleeDoDefeat takes player whichPlayer returns nothing
    set bj_meleeDefeated[GetPlayerId(whichPlayer)] = true
    call RemovePlayerPreserveUnitsBJ(whichPlayer, PLAYER_GAME_RESULT_DEFEAT, false)
endfunction

//===========================================================================
// Enum: Defeat out a specific player.
//
function MeleeDoDefeatEnum takes nothing returns nothing
    local player thePlayer = GetEnumPlayer()

    // needs to happen before ownership change
    call CachePlayerHeroData(thePlayer)
    call MakeUnitsPassiveForTeam(thePlayer)
    call MeleeDoDefeat(thePlayer)
endfunction

//===========================================================================
// A specific player left the game.
//
function MeleeDoLeave takes player whichPlayer returns nothing
    if (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0) then
        call GameOverDialogBJ( whichPlayer, true )
    else
        set bj_meleeDefeated[GetPlayerId(whichPlayer)] = true
        call RemovePlayerPreserveUnitsBJ(whichPlayer, PLAYER_GAME_RESULT_DEFEAT, true)
    endif
endfunction

//===========================================================================
// Remove all observers
// 
function MeleeRemoveObservers takes nothing returns nothing
    local integer    playerIndex
    local player     indexPlayer

    // Give all observers the game over dialog
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)

        if (IsPlayerObserver(indexPlayer)) then
            call RemovePlayerPreserveUnitsBJ(indexPlayer, PLAYER_GAME_RESULT_NEUTRAL, false)
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Test all players to determine if a team has won.  For a team to win, all
// remaining (read: undefeated) players need to be co-allied with all other
// remaining players.  If even one player is not allied towards another,
// everyone must be denied victory.
//
function MeleeCheckForVictors takes nothing returns force
    local integer    playerIndex
    local integer    opponentIndex
    local force      opponentlessPlayers = CreateForce()
    local boolean    gameOver = false

    // Check to see if any players have opponents remaining.
    set playerIndex = 0
    loop
        if (not bj_meleeDefeated[playerIndex]) then
            // Determine whether or not this player has any remaining opponents.
            set opponentIndex = 0
            loop
                // If anyone has an opponent, noone can be victorious yet.
                if MeleePlayerIsOpponent(playerIndex, opponentIndex) then
                    return CreateForce()
                endif

                set opponentIndex = opponentIndex + 1
                exitwhen opponentIndex == bj_MAX_PLAYERS
            endloop

            // Keep track of each opponentless player so that we can give
            // them a victory later.
            call ForceAddPlayer(opponentlessPlayers, Player(playerIndex))
            set gameOver = true
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    // Set the game over global flag
    set bj_meleeGameOver = gameOver

    return opponentlessPlayers
endfunction

//===========================================================================
// Test each player to determine if anyone has been defeated.
//
function MeleeCheckForLosersAndVictors takes nothing returns nothing
    local integer    playerIndex
    local player     indexPlayer
    local force      defeatedPlayers = CreateForce()
    local force      victoriousPlayers
    local boolean    gameOver = false

    // If the game is already over, do nothing
    if (bj_meleeGameOver) then
        return
    endif

    // If the game was disconnected then it is over, in this case we
    // don't want to report results for anyone as they will most likely
    // conflict with the actual game results
    if (GetIntegerGameState(GAME_STATE_DISCONNECTED) != 0) then
        set bj_meleeGameOver = true
        return
    endif

    // Check each player to see if he or she has been defeated yet.
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)

        if (not bj_meleeDefeated[playerIndex] and not bj_meleeVictoried[playerIndex]) then
            if rdg_isCheats then
                call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60, "Player"+I2S(playerIndex)+" has "+I2S(MeleeGetAllyStructureCount(indexPlayer))+" ally buildings.")
            endif
            if (MeleeGetAllyStructureCount(indexPlayer) <= 0) then

                // Keep track of each defeated player so that we can give
                // them a defeat later.
                call ForceAddPlayer(defeatedPlayers, Player(playerIndex))

                // Set their defeated flag now so MeleeCheckForVictors
                // can detect victors.
                set bj_meleeDefeated[playerIndex] = true
            endif
        endif
            
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    // Now that the defeated flags are set, check if there are any victors
    set victoriousPlayers = MeleeCheckForVictors()

    // Defeat all defeated players
    call ForForce(defeatedPlayers, function MeleeDoDefeatEnum)

    // Give victory to all victorious players
    call ForForce(victoriousPlayers, function MeleeDoVictoryEnum)

    // If the game is over we should remove all observers
    if (bj_meleeGameOver) then
        call MeleeRemoveObservers()
    endif
endfunction

//===========================================================================
// Returns a race-specific "build X or be revealed" message.
//
function MeleeGetCrippledWarningMessage takes player whichPlayer returns string
    local race r = GetPlayerRace(whichPlayer)

    if (r == RACE_HUMAN) then
        return GetLocalizedString("CRIPPLE_WARNING_HUMAN")
    elseif (r == RACE_ORC) then
        return GetLocalizedString("CRIPPLE_WARNING_ORC")
    elseif (r == RACE_NIGHTELF) then
        return GetLocalizedString("CRIPPLE_WARNING_NIGHTELF")
    elseif (r == RACE_UNDEAD) then
        return GetLocalizedString("CRIPPLE_WARNING_UNDEAD")
    else
        // Unrecognized Race
        return ""
    endif
endfunction

//===========================================================================
// Returns a race-specific "build X" label for cripple timers.
//
function MeleeGetCrippledTimerMessage takes player whichPlayer returns string
    local race r = GetPlayerRace(whichPlayer)

    if (r == RACE_HUMAN) then
        return GetLocalizedString("CRIPPLE_TIMER_HUMAN")
    elseif (r == RACE_ORC) then
        return GetLocalizedString("CRIPPLE_TIMER_ORC")
    elseif (r == RACE_NIGHTELF) then
        return GetLocalizedString("CRIPPLE_TIMER_NIGHTELF")
    elseif (r == RACE_UNDEAD) then
        return GetLocalizedString("CRIPPLE_TIMER_UNDEAD")
    else
        // Unrecognized Race
        return ""
    endif
endfunction

//===========================================================================
// Returns a race-specific "build X" label for cripple timers.
//
function MeleeGetCrippledRevealedMessage takes player whichPlayer returns string
    return GetLocalizedString("CRIPPLE_REVEALING_PREFIX") + GetPlayerName(whichPlayer) + GetLocalizedString("CRIPPLE_REVEALING_POSTFIX")
endfunction

//===========================================================================
function MeleeExposePlayer takes player whichPlayer, boolean expose returns nothing
    local integer playerIndex
    local player  indexPlayer
    local force   toExposeTo = CreateForce()

    call CripplePlayer( whichPlayer, toExposeTo, false )

    set bj_playerIsExposed[GetPlayerId(whichPlayer)] = expose
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        if (not PlayersAreCoAllied(whichPlayer, indexPlayer)) then
            call ForceAddPlayer( toExposeTo, indexPlayer )
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    call CripplePlayer( whichPlayer, toExposeTo, expose )
    call DestroyForce(toExposeTo)
endfunction

//===========================================================================
function MeleeExposeAllPlayers takes nothing returns nothing
    local integer playerIndex
    local player  indexPlayer
    local integer playerIndex2
    local player  indexPlayer2
    local force   toExposeTo = CreateForce()

    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)

        call ForceClear( toExposeTo )
        call CripplePlayer( indexPlayer, toExposeTo, false )

        set playerIndex2 = 0
        loop
            set indexPlayer2 = Player(playerIndex2)

            if playerIndex != playerIndex2 then
                if (not PlayersAreCoAllied(indexPlayer, indexPlayer2)) then
                    call ForceAddPlayer( toExposeTo, indexPlayer2 )
                endif
            endif

            set playerIndex2 = playerIndex2 + 1
            exitwhen playerIndex2 == bj_MAX_PLAYERS
        endloop

        call CripplePlayer( indexPlayer, toExposeTo, true )

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop

    call DestroyForce( toExposeTo )
endfunction

//===========================================================================
function MeleeCrippledPlayerTimeout takes nothing returns nothing
    local timer expiredTimer = GetExpiredTimer()
    local integer playerIndex
    local player  exposedPlayer

    // Determine which player's timer expired.
    set playerIndex = 0
    loop
        if (bj_crippledTimer[playerIndex] == expiredTimer) then
            exitwhen true
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
    if (playerIndex == bj_MAX_PLAYERS) then
        return
    endif
    set exposedPlayer = Player(playerIndex)

    if (GetLocalPlayer() == exposedPlayer) then
        // Use only local code (no net traffic) within this block to avoid desyncs.

        // Hide the timer window for this player.
        call TimerDialogDisplay(bj_crippledTimerWindows[playerIndex], false)
    endif

    // Display a text message to all players, explaining the exposure.
    call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, bj_MELEE_CRIPPLE_MSG_DURATION, MeleeGetCrippledRevealedMessage(exposedPlayer))

    // Expose the player.
    call MeleeExposePlayer(exposedPlayer, true)
endfunction

//===========================================================================
function MeleePlayerIsCrippled takes player whichPlayer returns boolean
    local integer allyStructures    = MeleeGetAllyStructureCount(whichPlayer)
    local integer allyKeyStructures = MeleeGetAllyKeyStructureCount(whichPlayer)

    // Dead teams are not considered to be crippled.
    return (allyStructures > 0) and (allyKeyStructures <= 0)
endfunction

//===========================================================================
// Test each player to determine if anyone has become crippled.
//
function MeleeCheckForCrippledPlayers takes nothing returns nothing
    local integer    playerIndex
    local player     indexPlayer
    local force      crippledPlayers = CreateForce()
    local boolean    isNowCrippled
    local race       indexRace

    // The "finish soon" exposure of all players overrides any "crippled" exposure
    if bj_finishSoonAllExposed then
        return
    endif

    // Check each player to see if he or she has been crippled or uncrippled.
    set playerIndex = 0
    loop
        set indexPlayer = Player(playerIndex)
        set isNowCrippled = MeleePlayerIsCrippled(indexPlayer)

        if (not bj_playerIsCrippled[playerIndex] and isNowCrippled) then

            // Player became crippled; start their cripple timer.
            set bj_playerIsCrippled[playerIndex] = true
            call TimerStart(bj_crippledTimer[playerIndex], bj_MELEE_CRIPPLE_TIMEOUT, false, function MeleeCrippledPlayerTimeout)

            if (GetLocalPlayer() == indexPlayer) then
                // Use only local code (no net traffic) within this block to avoid desyncs.

                // Show the timer window.
                call TimerDialogDisplay(bj_crippledTimerWindows[playerIndex], true)

                // Display a warning message.
                call DisplayTimedTextToPlayer(indexPlayer, 0, 0, bj_MELEE_CRIPPLE_MSG_DURATION, MeleeGetCrippledWarningMessage(indexPlayer))
            endif

        elseif (bj_playerIsCrippled[playerIndex] and not isNowCrippled) then

            // Player became uncrippled; stop their cripple timer.
            set bj_playerIsCrippled[playerIndex] = false
            call PauseTimer(bj_crippledTimer[playerIndex])

            if (GetLocalPlayer() == indexPlayer) then
                // Use only local code (no net traffic) within this block to avoid desyncs.

                // Hide the timer window for this player.
                call TimerDialogDisplay(bj_crippledTimerWindows[playerIndex], false)

                // Display a confirmation message if the player's team is still alive.
                if (MeleeGetAllyStructureCount(indexPlayer) > 0) then
                    if (bj_playerIsExposed[playerIndex]) then
                        call DisplayTimedTextToPlayer(indexPlayer, 0, 0, bj_MELEE_CRIPPLE_MSG_DURATION, GetLocalizedString("CRIPPLE_UNREVEALED"))
                    else
                        call DisplayTimedTextToPlayer(indexPlayer, 0, 0, bj_MELEE_CRIPPLE_MSG_DURATION, GetLocalizedString("CRIPPLE_UNCRIPPLED"))
                    endif
                endif
            endif

            // If the player granted shared vision, deny that vision now.
            call MeleeExposePlayer(indexPlayer, false)

        endif
            
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Determine if the lost unit should result in any defeats or victories.
//
function MeleeCheckLostUnit takes unit lostUnit returns nothing
    local player lostUnitOwner = GetOwningPlayer(lostUnit)

    // We only need to check for mortality if this was the last building.
    if (GetPlayerStructureCount(lostUnitOwner, true) <= 0) then
        call MeleeCheckForLosersAndVictors()
    endif

    // Check if the lost unit has crippled or uncrippled the player.
    // (A team with 0 units is dead, and thus considered uncrippled.)
    call MeleeCheckForCrippledPlayers()
endfunction

//===========================================================================
// Determine if the gained unit should result in any defeats, victories,
// or cripple-status changes.
//
function MeleeCheckAddedUnit takes unit addedUnit returns nothing
    local player addedUnitOwner = GetOwningPlayer(addedUnit)

    // If the player was crippled, this unit may have uncrippled him/her.
    if (bj_playerIsCrippled[GetPlayerId(addedUnitOwner)]) then
        call MeleeCheckForCrippledPlayers()
    endif
endfunction

//===========================================================================
function MeleeTriggerActionConstructCancel takes nothing returns nothing
    call MeleeCheckLostUnit(GetCancelledStructure())
endfunction

//===========================================================================
function MeleeTriggerActionUnitDeath takes nothing returns nothing
    if (IsUnitType(GetDyingUnit(), UNIT_TYPE_STRUCTURE)) then
        call MeleeCheckLostUnit(GetDyingUnit())
    endif
endfunction

//===========================================================================
function MeleeTriggerActionUnitConstructionStart takes nothing returns nothing
    call MeleeCheckAddedUnit(GetConstructingStructure())
endfunction

//===========================================================================
function MeleeTriggerActionPlayerDefeated takes nothing returns nothing
    local player thePlayer = GetTriggerPlayer()
    call CachePlayerHeroData(thePlayer)

    if (MeleeGetAllyCount(thePlayer) > 0) then
        // If at least one ally is still alive and kicking, share units with
        // them and proceed with death.
        call ShareEverythingWithTeam(thePlayer)
        if (not bj_meleeDefeated[GetPlayerId(thePlayer)]) then
            call MeleeDoDefeat(thePlayer)
        endif
    else
        // If no living allies remain, swap all units and buildings over to
        // neutral_passive and proceed with death.
        call MakeUnitsPassiveForTeam(thePlayer)
        if (not bj_meleeDefeated[GetPlayerId(thePlayer)]) then
            call MeleeDoDefeat(thePlayer)
        endif
    endif
    call MeleeCheckForLosersAndVictors()
endfunction

//===========================================================================
function MeleeTriggerActionPlayerLeft takes nothing returns nothing
    local player thePlayer = GetTriggerPlayer()

    // Just show game over for observers when they leave
    if (IsPlayerObserver(thePlayer)) then
        call RemovePlayerPreserveUnitsBJ(thePlayer, PLAYER_GAME_RESULT_NEUTRAL, false)
        return
    endif

    call CachePlayerHeroData(thePlayer)

    // This is the same as defeat except the player generates the message 
    // "player left the game" as opposed to "player was defeated".

    if (MeleeGetAllyCount(thePlayer) > 0) then
        // If at least one ally is still alive and kicking, share units with
        // them and proceed with death.
        call ShareEverythingWithTeam(thePlayer)
        call MeleeDoLeave(thePlayer)
    else
        // If no living allies remain, swap all units and buildings over to
        // neutral_passive and proceed with death.
        call MakeUnitsPassiveForTeam(thePlayer)
        call MeleeDoLeave(thePlayer)
    endif
    call MeleeCheckForLosersAndVictors()
endfunction

//===========================================================================
function MeleeTriggerActionAllianceChange takes nothing returns nothing
    call MeleeCheckForLosersAndVictors()
    call MeleeCheckForCrippledPlayers()
endfunction

//===========================================================================
function MeleeTriggerTournamentFinishSoon takes nothing returns nothing
    // Note: We may get this trigger multiple times
    local integer    playerIndex
    local player     indexPlayer
    local real       timeRemaining = GetTournamentFinishSoonTimeRemaining()

    if not bj_finishSoonAllExposed then
        set bj_finishSoonAllExposed = true

        // Reset all crippled players and their timers, and hide the local crippled timer dialog
        set playerIndex = 0
        loop
            set indexPlayer = Player(playerIndex)
            if bj_playerIsCrippled[playerIndex] then
                // Uncripple the player
                set bj_playerIsCrippled[playerIndex] = false
                call PauseTimer(bj_crippledTimer[playerIndex])

                if (GetLocalPlayer() == indexPlayer) then
                    // Use only local code (no net traffic) within this block to avoid desyncs.

                    // Hide the timer window.
                    call TimerDialogDisplay(bj_crippledTimerWindows[playerIndex], false)
                endif

            endif
            set playerIndex = playerIndex + 1
            exitwhen playerIndex == bj_MAX_PLAYERS
        endloop

        // Expose all players
        call MeleeExposeAllPlayers()
    endif

    // Show the "finish soon" timer dialog and set the real time remaining
    call TimerDialogDisplay(bj_finishSoonTimerDialog, true)
    call TimerDialogSetRealTimeRemaining(bj_finishSoonTimerDialog, timeRemaining)
endfunction


//===========================================================================
function MeleeWasUserPlayer takes player whichPlayer returns boolean
    local playerslotstate slotState

    if (GetPlayerController(whichPlayer) != MAP_CONTROL_USER) then
        return false
    endif

    set slotState = GetPlayerSlotState(whichPlayer)

    return (slotState == PLAYER_SLOT_STATE_PLAYING or slotState == PLAYER_SLOT_STATE_LEFT)
endfunction

//===========================================================================
function MeleeTournamentFinishNowRuleA takes integer multiplier returns nothing
    local integer array playerScore
    local integer array teamScore
    local force array   teamForce
    local integer       teamCount
    local integer       index
    local player        indexPlayer
    local integer       index2
    local player        indexPlayer2
    local integer       bestTeam
    local integer       bestScore
    local boolean       draw

    // Compute individual player scores
    set index = 0
    loop
        set indexPlayer = Player(index)
        if MeleeWasUserPlayer(indexPlayer) then
            set playerScore[index] = GetTournamentScore(indexPlayer)
            if playerScore[index] <= 0 then
                set playerScore[index] = 1
            endif
        else
            set playerScore[index] = 0
        endif
        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // Compute team scores and team forces
    set teamCount = 0
    set index = 0
    loop
        if playerScore[index] != 0 then
            set indexPlayer = Player(index)

            set teamScore[teamCount] = 0
            set teamForce[teamCount] = CreateForce()

            set index2 = index
            loop
                if playerScore[index2] != 0 then
                    set indexPlayer2 = Player(index2)

                    if PlayersAreCoAllied(indexPlayer, indexPlayer2) then
                        set teamScore[teamCount] = teamScore[teamCount] + playerScore[index2]
                        call ForceAddPlayer(teamForce[teamCount], indexPlayer2)
                        set playerScore[index2] = 0
                    endif
                endif

                set index2 = index2 + 1
                exitwhen index2 == bj_MAX_PLAYERS
            endloop

            set teamCount = teamCount + 1
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // The game is now over
    set bj_meleeGameOver = true

    // There should always be at least one team, but continue to work if not
    if teamCount != 0 then

        // Find best team score
        set bestTeam = -1
        set bestScore = -1
        set index = 0
        loop
            if teamScore[index] > bestScore then
                set bestTeam = index
                set bestScore = teamScore[index]
            endif

            set index = index + 1
            exitwhen index == teamCount
        endloop

        // Check whether the best team's score is 'multiplier' times better than
        // every other team. In the case of multiplier == 1 and exactly equal team
        // scores, the first team (which was randomly chosen by the server) will win.
        set draw = false
        set index = 0
        loop
            if index != bestTeam then
                if bestScore < (multiplier * teamScore[index]) then
                    set draw = true
                endif
            endif

            set index = index + 1
            exitwhen index == teamCount
        endloop

        if draw then
            // Give draw to all players on all teams
            set index = 0
            loop
                call ForForce(teamForce[index], function MeleeDoDrawEnum)

                set index = index + 1
                exitwhen index == teamCount
            endloop
        else
            // Give defeat to all players on teams other than the best team
            set index = 0
            loop
                if index != bestTeam then
                    call ForForce(teamForce[index], function MeleeDoDefeatEnum)
                endif

                set index = index + 1
                exitwhen index == teamCount
            endloop

            // Give victory to all players on the best team
            call ForForce(teamForce[bestTeam], function MeleeDoVictoryEnum)
        endif
    endif

endfunction

//===========================================================================
function MeleeTriggerTournamentFinishNow takes nothing returns nothing
    local integer rule = GetTournamentFinishNowRule()

    // If the game is already over, do nothing
    if bj_meleeGameOver then
        return
    endif

    if (rule == 1) then
        // Finals games
        call MeleeTournamentFinishNowRuleA(1)
    else
        // Preliminary games
        call MeleeTournamentFinishNowRuleA(3)
    endif

    // Since the game is over we should remove all observers
    call MeleeRemoveObservers()

endfunction

//===========================================================================
function MeleeInitVictoryDefeat takes nothing returns nothing
    local trigger trig
    local integer index
    local player indexPlayer

    // Create a timer window for the "finish soon" timeout period, it has no timer
    // because it is driven by real time (outside of the game state to avoid desyncs)
    set bj_finishSoonTimerDialog = CreateTimerDialog(null)

    // Set a trigger to fire when we receive a "finish soon" game event
    set trig = CreateTrigger()
    call TriggerRegisterGameEvent(trig , EVENT_GAME_TOURNAMENT_FINISH_SOON)
    call TriggerAddAction(trig , function MeleeTriggerTournamentFinishSoon)

    // Set a trigger to fire when we receive a "finish now" game event
    set trig = CreateTrigger()
    call TriggerRegisterGameEvent(trig , EVENT_GAME_TOURNAMENT_FINISH_NOW)
    call TriggerAddAction(trig , function MeleeTriggerTournamentFinishNow)

    // Set up each player's mortality code.
    set index = 0
    loop
        set indexPlayer = Player(index)

        // Make sure this player slot is playing.
        if ( GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING ) then
            set bj_meleeDefeated[index]=false
            set bj_meleeVictoried[index]=false

            // Create a timer and timer window in case the player is crippled.
            set bj_playerIsCrippled[index]=false
            set bj_playerIsExposed[index]=false
            set bj_crippledTimer[index]=CreateTimer()
            set bj_crippledTimerWindows[index]=CreateTimerDialog(bj_crippledTimer[index])
            call TimerDialogSetTitle(bj_crippledTimerWindows[index] , MeleeGetCrippledTimerMessage(indexPlayer))

            // Set a trigger to fire whenever a building is cancelled for this player.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL , null)
            call TriggerAddAction(trig , function MeleeTriggerActionConstructCancel)

            // Set a trigger to fire whenever a unit dies for this player.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_DEATH , null)
            call TriggerAddAction(trig , function MeleeTriggerActionUnitDeath)

            // Set a trigger to fire whenever a unit begins construction for this player
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_CONSTRUCT_START , null)
            call TriggerAddAction(trig , function MeleeTriggerActionUnitConstructionStart)

            // Set a trigger to fire whenever this player defeats-out
            set trig = CreateTrigger()
            call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_DEFEAT)
            call TriggerAddAction(trig , function MeleeTriggerActionPlayerDefeated)

            // Set a trigger to fire whenever this player leaves
            set trig = CreateTrigger()
            call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_LEAVE)
            call TriggerAddAction(trig , function MeleeTriggerActionPlayerLeft)

            // Set a trigger to fire whenever this player changes his/her alliances.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerAllianceChange(trig , indexPlayer , ALLIANCE_PASSIVE)
            call TriggerRegisterPlayerStateEvent(trig , indexPlayer , PLAYER_STATE_ALLIED_VICTORY , EQUAL , 1)
            call TriggerAddAction(trig , function MeleeTriggerActionAllianceChange)
        else
            set bj_meleeDefeated[index]=true
            set bj_meleeVictoried[index]=false

            // Handle leave events for observers
            if ( IsPlayerObserver(indexPlayer) ) then
                // Set a trigger to fire whenever this player leaves
                set trig = CreateTrigger()
                call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_LEAVE)
                call TriggerAddAction(trig , function MeleeTriggerActionPlayerLeft)
            endif
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // Test for victory / defeat at startup, in case the user has already won / lost.
    // Allow for a short time to pass first, so that the map can finish loading.
    call TimerStart(CreateTimer() , 2.0 , false , function MeleeTriggerActionAllianceChange)
endfunction



//***************************************************************************
//*
//*  Player Slot Availability
//*
//***************************************************************************

//===========================================================================
function CheckInitPlayerSlotAvailability takes nothing returns nothing
    local integer index

    if (not bj_slotControlReady) then
        set index = 0
        loop
            set bj_slotControlUsed[index] = false
            set bj_slotControl[index] = MAP_CONTROL_USER
            set index = index + 1
            exitwhen index == bj_MAX_PLAYERS
        endloop
        set bj_slotControlReady = true
    endif
endfunction

//===========================================================================
function SetPlayerSlotAvailable takes player whichPlayer, mapcontrol control returns nothing
    local integer playerIndex = GetPlayerId(whichPlayer)

    call CheckInitPlayerSlotAvailability()
    set bj_slotControlUsed[playerIndex] = true
    set bj_slotControl[playerIndex] = control
endfunction



//***************************************************************************
//*
//*  Generic Template Player-slot Initialization
//*
//***************************************************************************

//===========================================================================
function TeamInitPlayerSlots takes integer teamCount returns nothing
    local integer index
    local player  indexPlayer
    local integer team

    call SetTeams(teamCount)

    call CheckInitPlayerSlotAvailability()
    set index = 0
    set team = 0
    loop
        if (bj_slotControlUsed[index]) then
            set indexPlayer = Player(index)
            call SetPlayerTeam( indexPlayer, team )
            set team = team + 1
            if (team >= teamCount) then
                set team = 0
            endif
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
function MeleeInitPlayerSlots takes nothing returns nothing
    call TeamInitPlayerSlots(bj_MAX_PLAYERS)
endfunction

//===========================================================================
function FFAInitPlayerSlots takes nothing returns nothing
    call TeamInitPlayerSlots(bj_MAX_PLAYERS)
endfunction

//===========================================================================
function OneOnOneInitPlayerSlots takes nothing returns nothing
    // Limit the game to 2 players.
    call SetTeams(2)
    call SetPlayers(2)
    call TeamInitPlayerSlots(2)
endfunction

//===========================================================================
function InitGenericPlayerSlots takes nothing returns nothing
    local gametype gType = GetGameTypeSelected()

    if (gType == GAME_TYPE_MELEE) then
        call MeleeInitPlayerSlots()
    elseif (gType == GAME_TYPE_FFA) then
        call FFAInitPlayerSlots()
    elseif (gType == GAME_TYPE_USE_MAP_SETTINGS) then
        // Do nothing; the map-specific script handles this.
    elseif (gType == GAME_TYPE_ONE_ON_ONE) then
        call OneOnOneInitPlayerSlots()
    elseif (gType == GAME_TYPE_TWO_TEAM_PLAY) then
        call TeamInitPlayerSlots(2)
    elseif (gType == GAME_TYPE_THREE_TEAM_PLAY) then
        call TeamInitPlayerSlots(3)
    elseif (gType == GAME_TYPE_FOUR_TEAM_PLAY) then
        call TeamInitPlayerSlots(4)
    else
        // Unrecognized Game Type
    endif
endfunction



//***************************************************************************
//*
//*  Blizzard.j Initialization
//*
//***************************************************************************

//===========================================================================
function SetDNCSoundsDawn takes nothing returns nothing
    if bj_useDawnDuskSounds then
        call StartSound(bj_dawnSound)
    endif
endfunction

//===========================================================================
function SetDNCSoundsDusk takes nothing returns nothing
    if bj_useDawnDuskSounds then
        call StartSound(bj_duskSound)
    endif
endfunction

//===========================================================================
function SetDNCSoundsDay takes nothing returns nothing
    local real ToD = GetTimeOfDay()

    if (ToD >= bj_TOD_DAWN and ToD < bj_TOD_DUSK) and not bj_dncIsDaytime then
        set bj_dncIsDaytime = true

        // change ambient sounds
        call StopSound(bj_nightAmbientSound, false, true)
        call StartSound(bj_dayAmbientSound)
    endif
endfunction

//===========================================================================
function SetDNCSoundsNight takes nothing returns nothing
    local real ToD = GetTimeOfDay()

    if (ToD < bj_TOD_DAWN or ToD >= bj_TOD_DUSK) and bj_dncIsDaytime then
        set bj_dncIsDaytime = false

        // change ambient sounds
        call StopSound(bj_dayAmbientSound, false, true)
        call StartSound(bj_nightAmbientSound)
    endif
endfunction

//===========================================================================
function InitDNCSounds takes nothing returns nothing
    // Create sounds to be played at dawn and dusk.
    set bj_dawnSound = CreateSoundFromLabel("RoosterSound", false, false, false, 10000, 10000)
    set bj_duskSound = CreateSoundFromLabel("WolfSound", false, false, false, 10000, 10000)

    // Set up triggers to respond to dawn and dusk.
    set bj_dncSoundsDawn = CreateTrigger()
    call TriggerRegisterGameStateEvent(bj_dncSoundsDawn, GAME_STATE_TIME_OF_DAY, EQUAL, bj_TOD_DAWN)
    call TriggerAddAction(bj_dncSoundsDawn, function SetDNCSoundsDawn)

    set bj_dncSoundsDusk = CreateTrigger()
    call TriggerRegisterGameStateEvent(bj_dncSoundsDusk, GAME_STATE_TIME_OF_DAY, EQUAL, bj_TOD_DUSK)
    call TriggerAddAction(bj_dncSoundsDusk, function SetDNCSoundsDusk)

    // Set up triggers to respond to changes from day to night or vice-versa.
    set bj_dncSoundsDay = CreateTrigger()
    call TriggerRegisterGameStateEvent(bj_dncSoundsDay,   GAME_STATE_TIME_OF_DAY, GREATER_THAN_OR_EQUAL, bj_TOD_DAWN)
    call TriggerRegisterGameStateEvent(bj_dncSoundsDay,   GAME_STATE_TIME_OF_DAY, LESS_THAN,             bj_TOD_DUSK)
    call TriggerAddAction(bj_dncSoundsDay, function SetDNCSoundsDay)

    set bj_dncSoundsNight = CreateTrigger()
    call TriggerRegisterGameStateEvent(bj_dncSoundsNight, GAME_STATE_TIME_OF_DAY, LESS_THAN,             bj_TOD_DAWN)
    call TriggerRegisterGameStateEvent(bj_dncSoundsNight, GAME_STATE_TIME_OF_DAY, GREATER_THAN_OR_EQUAL, bj_TOD_DUSK)
    call TriggerAddAction(bj_dncSoundsNight, function SetDNCSoundsNight)
endfunction

//===========================================================================
function InitBlizzardGlobals takes nothing returns nothing
    local integer index
    local integer userControlledPlayers
    local version v

    // Init filter function vars
    set filterIssueHauntOrderAtLocBJ = Filter(function IssueHauntOrderAtLocBJFilter)
    set filterEnumDestructablesInCircleBJ = Filter(function EnumDestructablesInCircleBJFilter)
    set filterGetUnitsInRectOfPlayer = Filter(function GetUnitsInRectOfPlayerFilter)
    set filterGetUnitsOfTypeIdAll = Filter(function GetUnitsOfTypeIdAllFilter)
    set filterGetUnitsOfPlayerAndTypeId = Filter(function GetUnitsOfPlayerAndTypeIdFilter)
    set filterMeleeTrainedUnitIsHeroBJ = Filter(function MeleeTrainedUnitIsHeroBJFilter)
    set filterLivingPlayerUnitsOfTypeId = Filter(function LivingPlayerUnitsOfTypeIdFilter)

    // Init force presets
    set index = 0
    loop
        exitwhen index == bj_MAX_PLAYER_SLOTS
        set bj_FORCE_PLAYER[index] = CreateForce()
        call ForceAddPlayer(bj_FORCE_PLAYER[index], Player(index))
        set index = index + 1
    endloop

    set bj_FORCE_ALL_PLAYERS = CreateForce()
    call ForceEnumPlayers(bj_FORCE_ALL_PLAYERS, null)

    // Init Cinematic Mode history
    set bj_cineModePriorSpeed = GetGameSpeed()
    set bj_cineModePriorFogSetting = IsFogEnabled()
    set bj_cineModePriorMaskSetting = IsFogMaskEnabled()

    // Init Trigger Queue
    set index = 0
    loop
        exitwhen index >= bj_MAX_QUEUED_TRIGGERS
        set bj_queuedExecTriggers[index] = null
        set bj_queuedExecUseConds[index] = false
        set index = index + 1
    endloop

    // Init singleplayer check
    set bj_isSinglePlayer = false
    set userControlledPlayers = 0
    set index = 0
    loop
        exitwhen index >= bj_MAX_PLAYERS
        if (GetPlayerController(Player(index)) == MAP_CONTROL_USER and GetPlayerSlotState(Player(index)) == PLAYER_SLOT_STATE_PLAYING) then
            set userControlledPlayers = userControlledPlayers + 1
        endif
        set index = index + 1
    endloop
    set bj_isSinglePlayer = (userControlledPlayers == 1)

    // Init sounds
    //set bj_pingMinimapSound = CreateSoundFromLabel("AutoCastButtonClick", false, false, false, 10000, 10000)
    set bj_rescueSound = CreateSoundFromLabel("Rescue", false, false, false, 10000, 10000)
    set bj_questDiscoveredSound = CreateSoundFromLabel("QuestNew", false, false, false, 10000, 10000)
    set bj_questUpdatedSound = CreateSoundFromLabel("QuestUpdate", false, false, false, 10000, 10000)
    set bj_questCompletedSound = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000)
    set bj_questFailedSound = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000)
    set bj_questHintSound = CreateSoundFromLabel("Hint", false, false, false, 10000, 10000)
    set bj_questSecretSound = CreateSoundFromLabel("SecretFound", false, false, false, 10000, 10000)
    set bj_questItemAcquiredSound = CreateSoundFromLabel("ItemReward", false, false, false, 10000, 10000)
    set bj_questWarningSound = CreateSoundFromLabel("Warning", false, false, false, 10000, 10000)
    set bj_victoryDialogSound = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000)
    set bj_defeatDialogSound = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000)

    // Init corpse creation triggers.
    call DelayedSuspendDecayCreate()

    // Init version-specific data
    set v = VersionGet()
    if (v == VERSION_REIGN_OF_CHAOS) then
        set bj_MELEE_MAX_TWINKED_HEROES = bj_MELEE_MAX_TWINKED_HEROES_V0
    else
        set bj_MELEE_MAX_TWINKED_HEROES = bj_MELEE_MAX_TWINKED_HEROES_V1
    endif
endfunction

//===========================================================================
function InitQueuedTriggers takes nothing returns nothing
    set bj_queuedExecTimeout = CreateTrigger()
    call TriggerRegisterTimerExpireEvent(bj_queuedExecTimeout, bj_queuedExecTimeoutTimer)
    call TriggerAddAction(bj_queuedExecTimeout, function QueuedTriggerDoneBJ)
endfunction

//===========================================================================
function InitMapRects takes nothing returns nothing
    set bj_mapInitialPlayableArea = Rect(GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT), GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM), GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT), GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP))
    set bj_mapInitialCameraBounds = GetCurrentCameraBoundsMapRectBJ()
endfunction

//===========================================================================
function InitSummonableCaps takes nothing returns nothing
    local integer index

    set index = 0
    loop
        // upgraded units
        // Note: Only do this if the corresponding upgrade is not yet researched
        // Barrage - Siege Engines
        if (not GetPlayerTechResearched(Player(index), 'Rhrt', true)) then
            call SetPlayerTechMaxAllowed(Player(index), 'hrtt', 0)
        endif

        // Berserker Upgrade - Troll Berserkers
        if (not GetPlayerTechResearched(Player(index), 'Robk', true)) then
            call SetPlayerTechMaxAllowed(Player(index), 'otbk', 0)
        endif

        // max skeletons per player
        call SetPlayerTechMaxAllowed(Player(index), 'uske', bj_MAX_SKELETONS)

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
endfunction

//===========================================================================
// Update the per-class stock limits.
//
function UpdateStockAvailability takes item whichItem returns nothing
    local itemtype iType  = GetItemType(whichItem)
    local integer  iLevel = GetItemLevel(whichItem)

    // Update allowed type/level combinations.
    if (iType == ITEM_TYPE_PERMANENT) then
        set bj_stockAllowedPermanent[iLevel] = true
    elseif (iType == ITEM_TYPE_CHARGED) then
        set bj_stockAllowedCharged[iLevel] = true
    elseif (iType == ITEM_TYPE_ARTIFACT) then
        set bj_stockAllowedArtifact[iLevel] = true
    else
        // Not interested in this item type - ignore the item.
    endif
endfunction

//===========================================================================
// Find a sellable item of the given type and level, and then add it.
//
function UpdateEachStockBuildingEnum takes nothing returns nothing
    local integer iteration = 0
    local integer pickedItemId

    loop
        set pickedItemId = ChooseRandomItemEx(bj_stockPickedItemType, bj_stockPickedItemLevel)
        exitwhen IsItemIdSellable(pickedItemId)

        // If we get hung up on an entire class/level combo of unsellable
        // items, or a very unlucky series of random numbers, give up.
        set iteration = iteration + 1
        if (iteration > bj_STOCK_MAX_ITERATIONS) then
            return
        endif
    endloop
    call AddItemToStock(GetEnumUnit(), pickedItemId, 1, 1)
endfunction

//===========================================================================
function UpdateEachStockBuilding takes itemtype iType, integer iLevel returns nothing
    local group g

    set bj_stockPickedItemType = iType
    set bj_stockPickedItemLevel = iLevel

    set g = CreateGroup()
    call GroupEnumUnitsOfType(g, "marketplace", null)
    call ForGroup(g, function UpdateEachStockBuildingEnum)
    call DestroyGroup(g)
endfunction

//===========================================================================
// Update stock inventory.
//
function PerformStockUpdates takes nothing returns nothing
    local integer  pickedItemId
    local itemtype pickedItemType
    local integer  pickedItemLevel = 0
    local integer  allowedCombinations = 0
    local integer  iLevel

    // Give each type/level combination a chance of being picked.
    set iLevel = 1
    loop
        if (bj_stockAllowedPermanent[iLevel]) then
            set allowedCombinations = allowedCombinations + 1
            if (GetRandomInt(1, allowedCombinations) == 1) then
                set pickedItemType = ITEM_TYPE_PERMANENT
                set pickedItemLevel = iLevel
            endif
        endif
        if (bj_stockAllowedCharged[iLevel]) then
            set allowedCombinations = allowedCombinations + 1
            if (GetRandomInt(1, allowedCombinations) == 1) then
                set pickedItemType = ITEM_TYPE_CHARGED
                set pickedItemLevel = iLevel
            endif
        endif
        if (bj_stockAllowedArtifact[iLevel]) then
            set allowedCombinations = allowedCombinations + 1
            if (GetRandomInt(1, allowedCombinations) == 1) then
                set pickedItemType = ITEM_TYPE_ARTIFACT
                set pickedItemLevel = iLevel
            endif
        endif

        set iLevel = iLevel + 1
        exitwhen iLevel > bj_MAX_ITEM_LEVEL
    endloop

    // Make sure we found a valid item type to add.
    if (allowedCombinations == 0) then
        return
    endif

    call UpdateEachStockBuilding(pickedItemType, pickedItemLevel)
endfunction

//===========================================================================
// Perform the first update, and then arrange future updates.
//
function StartStockUpdates takes nothing returns nothing
    call PerformStockUpdates()
    call TimerStart(bj_stockUpdateTimer, bj_STOCK_RESTOCK_INTERVAL, true, function PerformStockUpdates)
endfunction

//===========================================================================
function RemovePurchasedItem takes nothing returns nothing
    call RemoveItemFromStock(GetSellingUnit(), GetItemTypeId(GetSoldItem()))
endfunction

//===========================================================================
function InitNeutralBuildings takes nothing returns nothing
    local integer iLevel

    // Chart of allowed stock items.
    set iLevel = 0
    loop
        set bj_stockAllowedPermanent[iLevel] = false
        set bj_stockAllowedCharged[iLevel] = false
        set bj_stockAllowedArtifact[iLevel] = false
        set iLevel = iLevel + 1
        exitwhen iLevel > bj_MAX_ITEM_LEVEL
    endloop

    // Limit stock inventory slots.
    call SetAllItemTypeSlots(bj_MAX_STOCK_ITEM_SLOTS)
    call SetAllUnitTypeSlots(bj_MAX_STOCK_UNIT_SLOTS)

    // Arrange the first update.
    set bj_stockUpdateTimer = CreateTimer()
    call TimerStart(bj_stockUpdateTimer, bj_STOCK_RESTOCK_INITIAL_DELAY, false, function StartStockUpdates)

    // Set up a trigger to fire whenever an item is sold.
    set bj_stockItemPurchased = CreateTrigger()
    call TriggerRegisterPlayerUnitEvent(bj_stockItemPurchased, Player(PLAYER_NEUTRAL_PASSIVE), EVENT_PLAYER_UNIT_SELL_ITEM, null)
    call TriggerAddAction(bj_stockItemPurchased, function RemovePurchasedItem)
endfunction

//===========================================================================
function MarkGameStarted takes nothing returns nothing
    set bj_gameStarted = true
    call DestroyTimer(bj_gameStartedTimer)
endfunction

//===========================================================================
function DetectGameStarted takes nothing returns nothing
    set bj_gameStartedTimer = CreateTimer()
    call TimerStart(bj_gameStartedTimer, bj_GAME_STARTED_THRESHOLD, false, function MarkGameStarted)
endfunction




//*****************************************************************************
//**********            ADDED FUNCTIONS (CASTERSYSTEM) ************************


function sc___prototype10_execute takes integer i,timer a1 returns nothing
    set f__arg_timer1=a1

    call TriggerExecute(st___prototype10[i])
endfunction
function sc___prototype10_evaluate takes integer i,timer a1 returns nothing
    set f__arg_timer1=a1

    call TriggerEvaluate(st___prototype10[i])

endfunction

function sg__GroupUtils___Status_get takes integer i returns integer
    if(i<8191) then
        return s__GroupUtils___Status[i]
    elseif(i<204775) then
        if(i<16382) then
            return s__2GroupUtils___Status[i-8191]
        elseif(i<106483) then
            if(i<24573) then
                return s__3GroupUtils___Status[i-16382]
            elseif(i<65528) then
                if(i<32764) then
                    return s__4GroupUtils___Status[i-24573]
                elseif(i<49146) then
                    if(i<40955) then
                        return s__5GroupUtils___Status[i-32764]
                    else
                        return s__6GroupUtils___Status[i-40955]
                    endif
                elseif(i<57337) then
                    return s__7GroupUtils___Status[i-49146]
                else
                    return s__8GroupUtils___Status[i-57337]
                endif
            elseif(i<73719) then
                return s__9GroupUtils___Status[i-65528]
            elseif(i<90101) then
                if(i<81910) then
                    return s__10GroupUtils___Status[i-73719]
                else
                    return s__11GroupUtils___Status[i-81910]
                endif
            elseif(i<98292) then
                return s__12GroupUtils___Status[i-90101]
            else
                return s__13GroupUtils___Status[i-98292]
            endif
        elseif(i<114674) then
            return s__14GroupUtils___Status[i-106483]
        elseif(i<155629) then
            if(i<122865) then
                return s__15GroupUtils___Status[i-114674]
            elseif(i<139247) then
                if(i<131056) then
                    return s__16GroupUtils___Status[i-122865]
                else
                    return s__17GroupUtils___Status[i-131056]
                endif
            elseif(i<147438) then
                return s__18GroupUtils___Status[i-139247]
            else
                return s__19GroupUtils___Status[i-147438]
            endif
        elseif(i<163820) then
            return s__20GroupUtils___Status[i-155629]
        elseif(i<180202) then
            if(i<172011) then
                return s__21GroupUtils___Status[i-163820]
            else
                return s__22GroupUtils___Status[i-172011]
            endif
        elseif(i<188393) then
            return s__23GroupUtils___Status[i-180202]
        elseif(i<196584) then
            return s__24GroupUtils___Status[i-188393]
        else
            return s__25GroupUtils___Status[i-196584]
        endif
    elseif(i<212966) then
        return s__26GroupUtils___Status[i-204775]
    elseif(i<311258) then
        if(i<221157) then
            return s__27GroupUtils___Status[i-212966]
        elseif(i<262112) then
            if(i<229348) then
                return s__28GroupUtils___Status[i-221157]
            elseif(i<245730) then
                if(i<237539) then
                    return s__29GroupUtils___Status[i-229348]
                else
                    return s__30GroupUtils___Status[i-237539]
                endif
            elseif(i<253921) then
                return s__31GroupUtils___Status[i-245730]
            else
                return s__32GroupUtils___Status[i-253921]
            endif
        elseif(i<270303) then
            return s__33GroupUtils___Status[i-262112]
        elseif(i<286685) then
            if(i<278494) then
                return s__34GroupUtils___Status[i-270303]
            else
                return s__35GroupUtils___Status[i-278494]
            endif
        elseif(i<294876) then
            return s__36GroupUtils___Status[i-286685]
        elseif(i<303067) then
            return s__37GroupUtils___Status[i-294876]
        else
            return s__38GroupUtils___Status[i-303067]
        endif
    elseif(i<319449) then
        return s__39GroupUtils___Status[i-311258]
    elseif(i<360404) then
        if(i<327640) then
            return s__40GroupUtils___Status[i-319449]
        elseif(i<344022) then
            if(i<335831) then
                return s__41GroupUtils___Status[i-327640]
            else
                return s__42GroupUtils___Status[i-335831]
            endif
        elseif(i<352213) then
            return s__43GroupUtils___Status[i-344022]
        else
            return s__44GroupUtils___Status[i-352213]
        endif
    elseif(i<368595) then
        return s__45GroupUtils___Status[i-360404]
    elseif(i<384977) then
        if(i<376786) then
            return s__46GroupUtils___Status[i-368595]
        else
            return s__47GroupUtils___Status[i-376786]
        endif
    elseif(i<393168) then
        return s__48GroupUtils___Status[i-384977]
    elseif(i<401359) then
        return s__49GroupUtils___Status[i-393168]
    else
        return s__50GroupUtils___Status[i-401359]
    endif
endfunction

function sg__GroupUtils___Status_set takes integer i,integer v returns nothing
    if(i<8191) then
        set s__GroupUtils___Status[i]=v
    elseif(i<204775) then
        if(i<16382) then
            set s__2GroupUtils___Status[i-8191]=v
        elseif(i<106483) then
            if(i<24573) then
                set s__3GroupUtils___Status[i-16382]=v
            elseif(i<65528) then
                if(i<32764) then
                    set s__4GroupUtils___Status[i-24573]=v
                elseif(i<49146) then
                    if(i<40955) then
                        set s__5GroupUtils___Status[i-32764]=v
                    else
                        set s__6GroupUtils___Status[i-40955]=v
                    endif
                elseif(i<57337) then
                    set s__7GroupUtils___Status[i-49146]=v
                else
                    set s__8GroupUtils___Status[i-57337]=v
                endif
            elseif(i<73719) then
                set s__9GroupUtils___Status[i-65528]=v
            elseif(i<90101) then
                if(i<81910) then
                    set s__10GroupUtils___Status[i-73719]=v
                else
                    set s__11GroupUtils___Status[i-81910]=v
                endif
            elseif(i<98292) then
                set s__12GroupUtils___Status[i-90101]=v
            else
                set s__13GroupUtils___Status[i-98292]=v
            endif
        elseif(i<114674) then
            set s__14GroupUtils___Status[i-106483]=v
        elseif(i<155629) then
            if(i<122865) then
                set s__15GroupUtils___Status[i-114674]=v
            elseif(i<139247) then
                if(i<131056) then
                    set s__16GroupUtils___Status[i-122865]=v
                else
                    set s__17GroupUtils___Status[i-131056]=v
                endif
            elseif(i<147438) then
                set s__18GroupUtils___Status[i-139247]=v
            else
                set s__19GroupUtils___Status[i-147438]=v
            endif
        elseif(i<163820) then
            set s__20GroupUtils___Status[i-155629]=v
        elseif(i<180202) then
            if(i<172011) then
                set s__21GroupUtils___Status[i-163820]=v
            else
                set s__22GroupUtils___Status[i-172011]=v
            endif
        elseif(i<188393) then
            set s__23GroupUtils___Status[i-180202]=v
        elseif(i<196584) then
            set s__24GroupUtils___Status[i-188393]=v
        else
            set s__25GroupUtils___Status[i-196584]=v
        endif
    elseif(i<212966) then
        set s__26GroupUtils___Status[i-204775]=v
    elseif(i<311258) then
        if(i<221157) then
            set s__27GroupUtils___Status[i-212966]=v
        elseif(i<262112) then
            if(i<229348) then
                set s__28GroupUtils___Status[i-221157]=v
            elseif(i<245730) then
                if(i<237539) then
                    set s__29GroupUtils___Status[i-229348]=v
                else
                    set s__30GroupUtils___Status[i-237539]=v
                endif
            elseif(i<253921) then
                set s__31GroupUtils___Status[i-245730]=v
            else
                set s__32GroupUtils___Status[i-253921]=v
            endif
        elseif(i<270303) then
            set s__33GroupUtils___Status[i-262112]=v
        elseif(i<286685) then
            if(i<278494) then
                set s__34GroupUtils___Status[i-270303]=v
            else
                set s__35GroupUtils___Status[i-278494]=v
            endif
        elseif(i<294876) then
            set s__36GroupUtils___Status[i-286685]=v
        elseif(i<303067) then
            set s__37GroupUtils___Status[i-294876]=v
        else
            set s__38GroupUtils___Status[i-303067]=v
        endif
    elseif(i<319449) then
        set s__39GroupUtils___Status[i-311258]=v
    elseif(i<360404) then
        if(i<327640) then
            set s__40GroupUtils___Status[i-319449]=v
        elseif(i<344022) then
            if(i<335831) then
                set s__41GroupUtils___Status[i-327640]=v
            else
                set s__42GroupUtils___Status[i-335831]=v
            endif
        elseif(i<352213) then
            set s__43GroupUtils___Status[i-344022]=v
        else
            set s__44GroupUtils___Status[i-352213]=v
        endif
    elseif(i<368595) then
        set s__45GroupUtils___Status[i-360404]=v
    elseif(i<384977) then
        if(i<376786) then
            set s__46GroupUtils___Status[i-368595]=v
        else
            set s__47GroupUtils___Status[i-376786]=v
        endif
    elseif(i<393168) then
        set s__48GroupUtils___Status[i-384977]=v
    elseif(i<401359) then
        set s__49GroupUtils___Status[i-393168]=v
    else
        set s__50GroupUtils___Status[i-401359]=v
    endif
endfunction

//Generated allocator of CasterSystem___csrecy
function s__CasterSystem___csrecy__allocate takes nothing returns integer
 local integer this=si__CasterSystem___csrecy_F
    if (this!=0) then
        set si__CasterSystem___csrecy_F=si__CasterSystem___csrecy_V[this]
    else
        set si__CasterSystem___csrecy_I=si__CasterSystem___csrecy_I+1
        set this=si__CasterSystem___csrecy_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CasterSystem___csrecy_V[this]=-1
 return this
endfunction

//Generated destructor of CasterSystem___csrecy
function s__CasterSystem___csrecy_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CasterSystem___csrecy_V[this]!=-1) then
        return
    endif
    set si__CasterSystem___csrecy_V[this]=si__CasterSystem___csrecy_F
    set si__CasterSystem___csrecy_F=this
endfunction

//Generated method caller for CSDamagers__damagerdata.onDestroy
function sc__CSDamagers__damagerdata_onDestroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__CSDamagers__damagerdata_onDestroy)
endfunction

//Generated allocator of CSDamagers__damagerdata
function s__CSDamagers__damagerdata__allocate takes nothing returns integer
 local integer this=si__CSDamagers__damagerdata_F
    if (this!=0) then
        set si__CSDamagers__damagerdata_F=si__CSDamagers__damagerdata_V[this]
    else
        set si__CSDamagers__damagerdata_I=si__CSDamagers__damagerdata_I+1
        set this=si__CSDamagers__damagerdata_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__CSDamagers__damagerdata_abil[this]=0
   set s__CSDamagers__damagerdata_prev[this]=0
   set s__CSDamagers__damagerdata_next[this]=0
    set si__CSDamagers__damagerdata_V[this]=-1
 return this
endfunction

//Generated destructor of CSDamagers__damagerdata
function sc__CSDamagers__damagerdata_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CSDamagers__damagerdata_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__CSDamagers__damagerdata_onDestroy)
    set si__CSDamagers__damagerdata_V[this]=si__CSDamagers__damagerdata_F
    set si__CSDamagers__damagerdata_F=this
endfunction

//Generated allocator of CSDamagers__data
function s__CSDamagers__data__allocate takes nothing returns integer
 local integer this=si__CSDamagers__data_F
    if (this!=0) then
        set si__CSDamagers__data_F=si__CSDamagers__data_V[this]
    else
        set si__CSDamagers__data_I=si__CSDamagers__data_I+1
        set this=si__CSDamagers__data_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__CSDamagers__data_expired[this]=false
   set s__CSDamagers__data_end[this]=false
   set s__CSDamagers__data_trees[this]=false
   set s__CSDamagers__data_selfdestruct[this]=false
   set s__CSDamagers__data_damagers[this]=0
   set s__CSDamagers__data_lifespan[this]=null
    set si__CSDamagers__data_V[this]=-1
 return this
endfunction

//Generated destructor of CSDamagers__data
function s__CSDamagers__data_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CSDamagers__data_V[this]!=-1) then
        return
    endif
    set si__CSDamagers__data_V[this]=si__CSDamagers__data_F
    set si__CSDamagers__data_F=this
endfunction

//Generated allocator of CasterSystem___itemholder
function s__CasterSystem___itemholder__allocate takes nothing returns integer
 local integer this=si__CasterSystem___itemholder_F
    if (this!=0) then
        set si__CasterSystem___itemholder_F=si__CasterSystem___itemholder_V[this]
    else
        set si__CasterSystem___itemholder_I=si__CasterSystem___itemholder_I+1
        set this=si__CasterSystem___itemholder_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CasterSystem___itemholder_V[this]=-1
 return this
endfunction

//Generated destructor of CasterSystem___itemholder
function s__CasterSystem___itemholder_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CasterSystem___itemholder_V[this]!=-1) then
        return
    endif
    set si__CasterSystem___itemholder_V[this]=si__CasterSystem___itemholder_F
    set si__CasterSystem___itemholder_F=this
endfunction

//Generated allocator of CasterSystem___cssabi
function s__CasterSystem___cssabi__allocate takes nothing returns integer
 local integer this=si__CasterSystem___cssabi_F
    if (this!=0) then
        set si__CasterSystem___cssabi_F=si__CasterSystem___cssabi_V[this]
    else
        set si__CasterSystem___cssabi_I=si__CasterSystem___cssabi_I+1
        set this=si__CasterSystem___cssabi_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CasterSystem___cssabi_V[this]=-1
 return this
endfunction

//Generated destructor of CasterSystem___cssabi
function s__CasterSystem___cssabi_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CasterSystem___cssabi_V[this]!=-1) then
        return
    endif
    set si__CasterSystem___cssabi_V[this]=si__CasterSystem___cssabi_F
    set si__CasterSystem___cssabi_F=this
endfunction

//Generated allocator of CasterSystem___dostruct
function s__CasterSystem___dostruct__allocate takes nothing returns integer
 local integer this=si__CasterSystem___dostruct_F
    if (this!=0) then
        set si__CasterSystem___dostruct_F=si__CasterSystem___dostruct_V[this]
    else
        set si__CasterSystem___dostruct_I=si__CasterSystem___dostruct_I+1
        set this=si__CasterSystem___dostruct_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CasterSystem___dostruct_V[this]=-1
 return this
endfunction

//Generated destructor of CasterSystem___dostruct
function s__CasterSystem___dostruct_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CasterSystem___dostruct_V[this]!=-1) then
        return
    endif
    set si__CasterSystem___dostruct_V[this]=si__CasterSystem___dostruct_F
    set si__CasterSystem___dostruct_F=this
endfunction
//Generated destructor of csmissile
function sc__csmissile_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__csmissile_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__csmissile_onDestroy[si__csmissile_type[this]])
    set si__csmissile_V[this]=si__csmissile_F
    set si__csmissile_F=this
endfunction

//Generated allocator of csprojectile
function s__csprojectile__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__csmissile_F
    if (this!=0) then
        set si__csmissile_F=si__csmissile_V[this]
    else
        set si__csmissile_I=si__csmissile_I+1
        set this=si__csmissile_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__csmissile_mtype[this]=0
    set si__csmissile_type[this]=6
    set kthis=this

   set s__csprojectile_done[this]=false
   set s__csprojectile_N[this]=0
    set si__csmissile_V[this]=-1
 return this
endfunction


//Generated allocator of cscollisionmissile
function s__cscollisionmissile__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__csmissile_F
    if (this!=0) then
        set si__csmissile_F=si__csmissile_V[this]
    else
        set si__csmissile_I=si__csmissile_I+1
        set this=si__csmissile_I
    endif
    if (this>8190) then
        return 0
    endif

   set s__csmissile_mtype[this]=0
    set si__csmissile_type[this]=5
    set kthis=this

   set s__cscollisionmissile_ttype[this]=0 //target type
   set s__cscollisionmissile_pfx[this]=false //periodic fx mode
   set s__cscollisionmissile_tag[this]=0 //custom tag for the user.
    set si__csmissile_V[this]=-1
 return this
endfunction


//library CSData:

    //****************************************************************************************************
    // CSData 16.0
    // 
    // CSDatas are like UserData in units and items, they now use a hashtable instead of big arrays,
    // should be faster and safer
    //
    // Notice that for public spells or systems to be distributed you should only use these
    // for private objects (those who the mapper would never have access to) If you are making something
    // for your map you can use them wherever you want.
    //
    // Best to be used in conjunction to CSArrays so you just specify an array id for a handle.
    //
    // DO NOT USE THIS ON THESE HANDLE TYPES: -lightning, -ubersplat, -image, -texttag,
    //                                        -any 'argument' handle (like playerstate, damagetype, etc)
    //
    //****************************************************************************************************

    //====================================================================================================

    //=================================================================================================
    // a.k.a H2I, changed name to CS_H2I to prevent conflicts with other systems, it then stayed that
    // instead of changing to a private or public function since many outside spells use it.
    //
    function CS_H2I takes handle h returns integer
        return GetHandleId(h) //
    endfunction                                    //

    //==================================================================================================

    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetCSData takes handle h,integer v returns nothing
        call SaveInteger(CSData__ht , 0 , GetHandleId(h) , v)
    endfunction

    function GetCSData takes handle h returns integer
        return LoadInteger(CSData__ht , 0 , GetHandleId(h))
    endfunction

    function CSData__init takes nothing returns nothing
        set CSData__ht = InitHashtable()
    endfunction


//library CSData ends
//library GroupUtils:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This library is a simple implementation of a stack for groups that need to
//* be in the user's control for greater than an instant of time. Additionally,
//* this library provides a single, global group variable for use with user-end
//* enumerations. It is important to note that users should not be calling
//* DestroyGroup() on the global group, since then it may not exist for when it
//* it is next needed.
//*
//* The group stack removes the need for destroying groups and replaces it with
//* a recycling method.
//*     function NewGroup takes nothing returns group
//*     function ReleaseGroup takes group g returns boolean
//*     function GroupRefresh takes group g returns nothing
//* 
//* NewGroup grabs a currently unused group from the stack or creates one if the
//* stack is empty. You can use this group however you'd like, but always
//* remember to call ReleaseGroup on it when you are done with it. If you don't
//* release it, it will 'leak' and your stack may eventually overflow if you
//* keep doing that.
//* 
//* GroupRefresh cleans a group of any shadow references which may be clogging
//* its hash table. If you remove a unit from the game who is a member of a unit
//* group, it will 'effectively' remove the unit from the group, but leave a
//* shadow in its place. Calling GroupRefresh on a group will clean up any
//* shadow references that may exist within it.
//* 

function GroupUtils___H2I takes handle h returns integer
    return GetHandleId(h)
endfunction

function GroupUtils___AddEx takes nothing returns nothing
    if GroupUtils___Flag then
        call GroupClear(GroupUtils___Refr)
        set GroupUtils___Flag = false
    endif
    call GroupAddUnit(GroupUtils___Refr , GetEnumUnit())
endfunction
    
function GroupRefresh takes group g returns nothing
    set GroupUtils___Flag = true
    set GroupUtils___Refr = g
    call ForGroup(GroupUtils___Refr , function GroupUtils___AddEx)
    if GroupUtils___Flag then
        call GroupClear(g)
    endif
endfunction

function NewGroup takes nothing returns group
    if GroupUtils___Count == 0 then
        set GroupUtils___Groups[0]=CreateGroup()
    else
        set GroupUtils___Count = GroupUtils___Count - 1
    endif
    call sg__GroupUtils___Status_set((GetHandleId((GroupUtils___Groups[GroupUtils___Count]))) - GroupUtils___MIN_HANDLE_ID,1) // INLINED!!
    return GroupUtils___Groups[GroupUtils___Count]
endfunction

function ReleaseGroup takes group g returns boolean
    local integer stat= sg__GroupUtils___Status_get((GetHandleId((g))) - GroupUtils___MIN_HANDLE_ID) // INLINED!!
    if g == null then
        return false
    elseif stat == 0 then
        return false
    elseif stat == 2 then
        return false
    elseif GroupUtils___Count == 8191 then
        call DestroyGroup(g)
        return false
    else
        call GroupClear(g)
        set GroupUtils___Groups[GroupUtils___Count]=g
        set GroupUtils___Count = GroupUtils___Count + 1
        call sg__GroupUtils___Status_set((GetHandleId((g))) - GroupUtils___MIN_HANDLE_ID,2) // INLINED!!
    endif
    return true
endfunction

//library GroupUtils ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (Blue flavor for 1.23b or later) 
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: htt://www.wc3campaigns.net
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Blue Flavor: Slower than the red flavor, it got a 408000 handle id
//*             limit, which means that if more than 408000 handle ids
//*             are used in your map, TimerUtils might fail, this
//*             value is quite big and it is much bigger than the 
//*             timer limit in Red flavor.
//*
//********************************************************************

    //==================================================================================================

    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t,integer value returns nothing
        call SaveInteger(TimerUtils___hasht , 0 , GetHandleId(t) , value)
    endfunction

    function GetTimerData takes timer t returns integer
        return LoadInteger(TimerUtils___hasht , 0 , GetHandleId(t))
    endfunction

    //==========================================================================================

    //==========================================================================================
    function NewTimer takes nothing returns timer
        if ( TimerUtils___tN == 0 ) then
            set TimerUtils___tT[0]=CreateTimer()
        else
            set TimerUtils___tN = TimerUtils___tN - 1
        endif
        call SaveInteger(TimerUtils___hasht , 0 , GetHandleId((TimerUtils___tT[TimerUtils___tN] )) , ( 0)) // INLINED!!
     return TimerUtils___tT[TimerUtils___tN]
    endfunction

    //==========================================================================================
    function ReleaseTimer takes timer t returns nothing
        if ( t == null ) then
            return 
        endif
        if ( TimerUtils___tN == 8191 ) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if ( (LoadInteger(TimerUtils___hasht , 0 , GetHandleId((t)))) == TimerUtils___HELD ) then // INLINED!!
                return 
            endif
            call SaveInteger(TimerUtils___hasht , 0 , GetHandleId((t )) , ( TimerUtils___HELD)) // INLINED!!
            set TimerUtils___tT[TimerUtils___tN]=t
            set TimerUtils___tN = TimerUtils___tN + 1
        endif
    endfunction

    function TimerUtils___init takes nothing returns nothing
        set TimerUtils___hasht = InitHashtable()
    endfunction


//library TimerUtils ends
//library CSSafeCache:
    //*************************************************************************************************
    //*                                                                                               *
    //* CSSafeCache 15.3                       http://wc3campaigns.net/vexorian                       *
    //*                                                                                        *
    //*    CSCache is evil now, use just CSSafeCache when possible as it now contains all functions   *
    //* that do not use I2H or similar functions that are considered to cause unstability in the map  *
    //*                                                                                               *
    //*    CSCache has been deprecated, and is now unusuable since it can't be ported to patch 1.23b  *
    //* Migration from CSCache to CSSafeCache+structs should be easy                                  *
    //*                                                                                               *
    //* However, for old compatibility, CSSafeCache needs to stick to using gamecache, which is not   *
    //* as good as hashtable (it is slower and may be vulnerable to Sync attacks) I recommend         *
    //* switching from CSSafeCache to hashtable or Table                                              *
    //*                                                                                               *
    //*************************************************************************************************

    //=================================================================================================
    // CSSafeCache globals:
    //

    function CSSafeCache__init takes nothing returns nothing
    // CSSafeCache initializer :
        call FlushGameCache(InitGameCache("cscache"))
        set cs_cache = InitGameCache("cscache")
        call ExecuteFunc("InitArrayIndexes")
        call ExecuteFunc("Pool_SetupCharMap")
    endfunction


    //=================================================================================================================
    // CS Pairs
    // 
    // This is a sub system to assist csarrays, you can use them but CSArrays of size 2 have the same functionality
    // although cspairs are be faster their space is limited and will start using gamecache if abused
    //
    function NewPair takes integer x,integer y returns integer
     local integer i
     
       if ( CSSafeCache__cs_freepairs[0] == 0 ) then
           set CSSafeCache__cs_freepairs[8190]=CSSafeCache__cs_freepairs[8190] + 1
           set i = CSSafeCache__cs_freepairs[8190]
       else
           set i = CSSafeCache__cs_freepairs[CSSafeCache__cs_freepairs[0]]
           set CSSafeCache__cs_freepairs[0]=CSSafeCache__cs_freepairs[0] - 1
       endif
       if ( i >= 8189 ) then //because we can only recycle up to 8189 (free pairs array uses indexes 0 and 8190 for other purposes)
           call StoreInteger(cs_cache , "pairx" , I2S(i) , x)
           call StoreInteger(cs_cache , "pairy" , I2S(i) , y)
       else
           set CSSafeCache__cs_pairx[i]=x
           set CSSafeCache__cs_pairy[i]=y

       endif
     return i
    endfunction

    function DestroyPair takes integer id returns nothing
        if ( id >= 8189 ) then
            call FlushStoredInteger(cs_cache , "pairx" , I2S(id))
            call FlushStoredInteger(cs_cache , "pairy" , I2S(id))
        else
            set CSSafeCache__cs_freepairs[0]=CSSafeCache__cs_freepairs[0] + 1
            set CSSafeCache__cs_freepairs[CSSafeCache__cs_freepairs[0]]=id
        endif
    endfunction

    function SetPairXY takes integer id,integer x,integer y returns nothing
        if ( id >= 8189 ) then
            call StoreInteger(cs_cache , "pairx" , I2S(id) , x)
            call StoreInteger(cs_cache , "pairy" , I2S(id) , y)

        else
            set CSSafeCache__cs_pairx[id]=x
            set CSSafeCache__cs_pairy[id]=y
        endif
    endfunction

    function SetPairX takes integer id,integer x returns nothing
        if ( id >= 8189 ) then
            call StoreInteger(cs_cache , "pairx" , I2S(id) , x)
        else
            set CSSafeCache__cs_pairx[id]=x
        endif
    endfunction

    function SetPairY takes integer id,integer y returns nothing
        if ( id >= 8189 ) then
            call StoreInteger(cs_cache , "pairy" , I2S(id) , y)
        else
            set CSSafeCache__cs_pairy[id]=y
        endif
    endfunction

    function GetPairX takes integer id returns integer
        if ( id >= 8189 ) then
            return GetStoredInteger(cs_cache , "pairy" , I2S(id))
        endif
     return CSSafeCache__cs_pairx[id]
    endfunction
    function GetPairY takes integer id returns integer
        if ( id >= 8189 ) then
            return GetStoredInteger(cs_cache , "pairx" , I2S(id))
        endif
     return CSSafeCache__cs_pairy[id]
    endfunction





    //=================================================================================================================
    // CS Dynamic Arrays
    // 
    // Thanks: Pipedream, Peppar
    //
    // We can now create arrays in game! , also pass them as arguments or return values!
    // a 1 length array is a pointer!
    //
    function Array_TryFree takes nothing returns nothing
     local integer i
     local integer N=cs_array1[0]
     local integer k
     local boolean cleaned=false

     local integer loc

     local integer q
     local integer r
        


            set i = cs_array1[146]
            if ( i > 144 ) then
                call TimerStart(GetExpiredTimer() , 60. , false , function Array_TryFree)
                return 
            endif

            set loc = CSSafeCache__cs_freeindexes[i]
            set q = 0
            loop
                exitwhen ( loc == 0 )
    	    // we could just have used:
                    //set k=GetPairX(loc)
                    //set r=GetPairY(loc) But it is slower than direct usage:

                if ( loc >= 8192 ) then
    	        set k = GetStoredInteger(cs_cache , "pairx" , I2S(loc))
    		set r = GetStoredInteger(cs_cache , "pairy" , I2S(loc))
    	    else
    	        set k = CSSafeCache__cs_pairx[loc]
    		set r = CSSafeCache__cs_pairy[loc]
    	    endif

                if ( k + i - 1 == N ) then


                    //we found one we can remove from the list

                    set cleaned = true
                    //decrement N
                    
                    set N = k - 2

                    //Remove from the list:
                    if ( q == null ) then
                        //That was the first, update the array as well
                        set CSSafeCache__cs_freeindexes[i]=r
                    else
                        //Update the next of the previous one
                        //We could use : call SetPairY(q,,r) but it is slower
    		    if ( q >= 8189 ) then
    		        call StoreInteger(cs_cache , "pairy" , I2S(q) , r)
                        else
    			set CSSafeCache__cs_pairy[q]=r
    		    endif


                    endif
                    if ( r == null ) then
                        //This was the last one, update it in the array as well
                        set CSSafeCache__cs_freeindexes[i + 4096]=q
                    endif
                    
                    call DestroyPair(loc)
                    set loc = q
                endif
                set q = loc
                set loc = r
            endloop
           
            if ( cleaned ) then
                set cs_array1[0]=N
                set cs_array1[146]=1
            else
                set cs_array1[146]=cs_array1[i + 1]
            endif
     call TimerStart(GetExpiredTimer() , 0.2 , false , function Array_TryFree)

    endfunction

    function InitArrayIndexes2 takes nothing returns nothing
     local integer i=0
        loop
            exitwhen ( i == 8191 )
            set CSSafeCache__cs_pairx[i]=777
            set CSSafeCache__cs_pairy[i]=777
            set i = i + 1
        endloop
     
    endfunction


    function InitArrayIndexes takes nothing returns nothing
     local integer i=0
     local integer a=1
     local integer b=1
     local integer c


        //By placing 777 there instead of 0 it is easier to recognize non correctly initialized bugs
        loop
            exitwhen ( i == 8191 )
            set cs_array1[i]=777
            set cs_array2[i]=777
            set cs_array3[i]=777
            //set cs_pairx[i]=777
            //set cs_pairy[i]=777
            set i = i + 1
        endloop
        call ExecuteFunc("InitArrayIndexes2")


        set CSSafeCache__cs_freeindexes[0]=0 //The stack for the table indexes.
        set CSSafeCache__cs_freepairs[0]=0
        set CSSafeCache__cs_freepairs[8190]=0
        set i = 1
        loop
            set c = a + b
            set a = b
            set b = c
            exitwhen ( b > 144 ) //max size is 144
            set CSSafeCache__cs_freeindexes[b]=0 //the first of the list
            set CSSafeCache__cs_freeindexes[b + 4096]=0 //the last of the list
            loop
                exitwhen ( i > b )
                set cs_array1[i]=b
                set i = i + 1
            endloop
            
        endloop
        set cs_array1[i]=b //i is 145
        set cs_array1[146]=1
        set cs_array1[147]=101 //initial table index is 101
        set cs_array1[0]=147
        //index 0: Last used index
        // 1 to 145 : Fibonacci sequence
        // 146 : last check
        // 147 : Table indexes check
       
        //This has a good chance to compress the thing when necesary
        call TimerStart(CreateTimer() , 60. , false , function Array_TryFree)

    endfunction

    //=============================================================================================
    // Create an array of size, max size is 144, if doinit is true it will put a bunch of zeros
    // in the indexes
    //
    function NewArray takes integer size,boolean doinit returns integer
     local integer i
     local integer rsize=cs_array1[size]
     local integer loc

        set loc = CSSafeCache__cs_freeindexes[rsize]
        if ( loc != 0 ) then

            set CSSafeCache__cs_freeindexes[rsize]=GetPairY(loc)
            if ( CSSafeCache__cs_freeindexes[rsize] == 0 ) then
                set CSSafeCache__cs_freeindexes[4096 + rsize]=0
            endif
            set i = GetPairX(loc)
            call DestroyPair(loc)

            if ( i == 0 ) then
                //this code was probably a good idea when we used locations for the free indexes list, now we use pairs which should not ever
                //do this unless someone modiffied the pair array incorrectly
            
                call BJDebugMsg("Caster System: Unexpected error (5): corrupt stack, attempt to recover " + I2S(rsize))
                // recovering involves forgetting about the stack which got corrupted and start again from zero, it will leak
                // and probably get slow due to usage of gamecache but it is better than the problems that a corrupt stack might cause
                set CSSafeCache__cs_freeindexes[rsize]=0
                set CSSafeCache__cs_freeindexes[4096 + rsize]=0
                
                
                return NewArray(size , doinit)
            endif

        else
            
            //sz  i   i+1   i+2
            //[ ][   ][    ][   ]
        
            set i = cs_array1[0] + 2
            set cs_array1[0]=i + rsize - 1

        endif

        //It used to store size in the index equal to the array's id
        // but that required the get/set functions to increment 1 in every index
        // calculation. Instead, making size the previous index to the array works
        if ( i <= 8191 ) then
            set cs_array1[i - 1]=size
        elseif ( i <= 16382 ) then
            set cs_array2[i - 8192]=size
        else
            call StoreInteger(cs_cache , I2S(- i) , "size" , size)
        endif

       
        if ( not doinit ) then
            return i
        endif
        
        //    3
        //[i][i+1][i+2]

        set size = i + size - 1
        if ( size >= 16382 ) then
            set size = 16381
        endif
        loop
            exitwhen ( size < i ) or ( size < 8191 )
            set cs_array2[size - 8191]=0
            set size = size - 1
        endloop
        loop
            exitwhen ( size < i )
            set cs_array1[size]=0
            set size = size - 1
        endloop
        
        //call DisplayTextToPlayer(GetLocalPlayer(),0,0,I2S(i))

     return i
    endfunction


    //===============================================================================================================
    // Remember to destroy arrays when you no longer need them, else new arrays will get slower after a bunch of 
    // arrays are active
    //
    function DestroyArray takes integer id returns nothing
     local integer L
     local integer loc
    // local string k=I2S(-id)
     local integer lstpace

        if ( id <= 8191 ) then
            set L = cs_array1[cs_array1[id - 1]]
        elseif ( id <= 16382 ) then
            set L = cs_array1[cs_array2[id - 8191]]
        else
            set L = cs_array1[GetStoredInteger(cs_cache , I2S(- id) , "size")]
            //No way you are gonna call DestroyArray without calling
           //NewArray first, so we can use the gamecache variable directly instead

        endif
        set lstpace = id + L - 1
       call FlushStoredMission(cs_cache , I2S(- id))
      
       if ( lstpace > 16382 ) then
       
           if ( lstpace == cs_array1[0] ) then
               //We just destroyed the array that happens to be at the end of the heap.
               //Just get it back
               set cs_array1[0]=id - 2
               set cs_array1[146]=1
           else
               //Add to the last
               set loc = CSSafeCache__cs_freeindexes[L + 4096]
               if ( loc == 0 ) then
                   set loc = NewPair(id , 0)
                   set CSSafeCache__cs_freeindexes[L]=loc
                   set CSSafeCache__cs_freeindexes[L + 4096]=loc
               else
                   set CSSafeCache__cs_freeindexes[L + 4096]=NewPair(id , 0)
                   //we could just use: call SetPairY(loc, cs_freeindexes[L+4096] ) //but that's slower
                   if ( loc >= 8189 ) then
    	           call StoreInteger(cs_cache , "pairy" , I2S(loc) , CSSafeCache__cs_freeindexes[L + 4096])
                   else
                       set CSSafeCache__cs_pairy[loc]=CSSafeCache__cs_freeindexes[L + 4096]
                   endif

               endif


           endif

       elseif ( lstpace == cs_array1[0] ) then
               //We just destroyed the array that happens to be at the end of the heap.
               //Just get it back
               set cs_array1[0]=id - 2
               set cs_array1[146]=1
       else
           set loc = CSSafeCache__cs_freeindexes[L]
           set CSSafeCache__cs_freeindexes[L]=NewPair(id , loc)

           if ( loc == 0 ) then
               set CSSafeCache__cs_freeindexes[L + 4096]=CSSafeCache__cs_freeindexes[L]
           endif

       endif

    endfunction

    //================================================================================================================
    // Int Set/Get array usage prototypes.
    //
    // These are the actual functions, the rest are just the result of copy paste, if these functions are updated
    // the other ones should be updated as well (They are just return bugged variations)
    //
    function SetArrayInt takes integer id,integer index,integer val returns nothing
        set index = id + index
        if ( index < 8191 ) then
            set cs_array1[index]=val
        elseif ( index < 16382 ) then
            set cs_array2[index - 8191]=val
        else
            call StoreInteger(cs_cache , I2S(- id) , I2S(index) , val)
        endif
    endfunction
    function GetArrayInt takes integer id,integer index returns integer
        set index = id + index
        if ( index < 8191 ) then
            return cs_array1[index]
        elseif ( index < 16382 ) then
            return cs_array2[index - 8191]
        endif
     return GetStoredInteger(cs_cache , I2S(- id) , I2S(index))
    endfunction


    //================================================================================================================
    // String Set/Get array
    //
    // Due String related return bug issues, these are forced to use gamecache
    //
    function SetArrayString takes integer id,integer index,string val returns nothing
        call StoreString(cs_cache , I2S(- id) , I2S(index) , val)
    endfunction
    function GetArrayString takes integer id,integer index returns string
     return GetStoredString(cs_cache , I2S(- id) , I2S(index))
    endfunction

    //(Boolean is not needed)

    //==========================================================================================================================
    // Returns the size of an array (the specified by player one, not the actual size of it) should be useful.
    //
    function GetArraySize takes integer id returns integer
        if ( id <= 8191 ) then
            return cs_array1[id - 1]
        elseif ( id <= 16382 ) then
            return cs_array2[id - 8192]
        endif
     return GetStoredInteger(cs_cache , I2S(- id) , "size")
    endfunction


    //===========================================================================================================================
    // Returns an array that is an exact copy of the given array
    //
    function CloneArray takes integer id returns integer
     local integer sz
     local integer i
     local integer sz2
     local integer x
     local integer y

        if ( id <= 8191 ) then
            set sz = cs_array1[id - 1]
        elseif ( id <= 16382 ) then
            set sz = cs_array2[id - 8192]
        else
            set sz = GetStoredInteger(cs_cache , I2S(- id) , "size")
            //No way you are gonna call DestroyArray without calling
           //NewArray first, so we can use the gamecache variable directly instead

        endif

        set i = NewArray(sz , false)
       
        set sz2 = i + sz - 1
        set sz = id + sz - 1
        set x = i
        set y = id
        loop
            exitwhen ( ( y > sz ) or ( y >= 8191 ) or ( x >= 8191 ) )
            set cs_array1[x]=cs_array1[y]
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( ( y > sz ) or ( y >= 8191 ) or ( x >= 16382 ) )
            set cs_array2[x - 8191]=cs_array1[y]
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( ( y > sz ) or ( y >= 8191 ) )
            call StoreInteger(cs_cache , I2S(- i) , I2S(x - i) , cs_array1[y])
            set x = y + 1
            set y = y + 1
        endloop
        //...
        loop
            exitwhen ( ( y > sz ) or ( y >= 16382 ) or ( x >= 8191 ) )
            set cs_array1[x]=cs_array2[y - 8191]
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( ( y > sz ) or ( y >= 16382 ) or ( x >= 16382 ) )
            set cs_array2[x - 8191]=cs_array2[y - 8191]
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( ( y > sz ) or ( y >= 16382 ) )
            call StoreInteger(cs_cache , I2S(- i) , I2S(x - i) , cs_array2[y - 8191])
            set y = y + 1
            set x = x + 1
        endloop
        //...
        loop
            exitwhen ( ( y > sz ) or ( x >= 8191 ) )
            set cs_array1[x]=GetStoredInteger(cs_cache , I2S(- id) , I2S(y - id))
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( ( y > sz ) or ( x >= 16382 ) )
            set cs_array2[x - 8191]=GetStoredInteger(cs_cache , I2S(- id) , I2S(y - id))
            set y = y + 1
            set x = x + 1
        endloop
        loop
            exitwhen ( y > sz )
            call StoreInteger(cs_cache , I2S(- i) , I2S(x - i) , GetStoredInteger(cs_cache , I2S(- id) , I2S(y - id)))
            set y = y + 1
            set x = x + 1
        endloop
        
     return i
    endfunction

    //==================================================================================================
    // Attachable vars : Attacheable variables are what most other people call Handle Variables, they
    // allow to relate data with any handle, using a label, and its value, the stuff auto flushes if
    // the value is 0, false, "", or null .
    //
    // Differences between Attacheable variables and "Local Handle Variables" :
    // - The names of the functions
    // - The name of the function group does not cause confusion, it is difficult to say: 
    //   "you should set local handle variables to null at the end of a function" since
    //   it sounds as if you were talking about the "Local Handle Variables"
    // - And can work together with Tables.
    // 
    // Gamecache stuff are NOT Case Sensitive, don't ever use "" for label (Crashes game!)
    //
    //
    // Although locations and dynamic arrays are faster than gamecache, gamecache still keeps the flexibility
    // Best thing to do in my opinion is to combine these options. By combining you can acquire gamecache
    // flexibility and arrays/locs speed to solve a problem
    //

    //============================================================================================================
    // For integers
    //
    function AttachInt takes handle h,string label,integer x returns nothing
        if x == 0 then
            call FlushStoredInteger(cs_cache , I2S(GetHandleId(h)) , label)
        else
            call StoreInteger(cs_cache , I2S(GetHandleId(h)) , label , x)
        endif
    endfunction
    function GetAttachedInt takes handle h,string label returns integer
        return GetStoredInteger(cs_cache , I2S(GetHandleId(h)) , label)
    endfunction

    //=============================================================================================================
    function AttachReal takes handle h,string label,real x returns nothing
         if x == 0 then
            call FlushStoredReal(cs_cache , I2S(GetHandleId(h)) , label)
        else
            call StoreReal(cs_cache , I2S(GetHandleId(h)) , label , x)
        endif
    endfunction
    function GetAttachedReal takes handle h,string label returns real
        return GetStoredReal(cs_cache , I2S(GetHandleId(h)) , label)
    endfunction

    //=============================================================================================================
    function AttachBoolean takes handle h,string label,boolean x returns nothing
        if not x then
            call FlushStoredBoolean(cs_cache , I2S(GetHandleId(h)) , label)
        else
            call StoreBoolean(cs_cache , I2S(GetHandleId(h)) , label , x)
        endif
    endfunction
    function GetAttachedBoolean takes handle h,string label returns boolean
        return GetStoredBoolean(cs_cache , I2S(GetHandleId(h)) , label)
    endfunction

    //=============================================================================================================
    function AttachString takes handle h,string label,string x returns nothing
        if ( ( x == "" ) or ( x == null ) ) then
            call FlushStoredString(cs_cache , I2S(GetHandleId(h)) , label)
        else
            call StoreString(cs_cache , I2S(GetHandleId(h)) , label , x)
        endif
    endfunction
    function GetAttachedString takes handle h,string label returns string
        return GetStoredString(cs_cache , I2S(GetHandleId(h)) , label)
    endfunction

    //============================================================================================================
    function CleanAttachedVars takes handle h returns nothing
        call FlushStoredMission(cs_cache , I2S(GetHandleId(h)))
        call FlushChildHashtable(rdg_cstable, GetHandleId(h))
    endfunction

    //============================================================================================================
    // Left for compat
    function CleanAttachedVars_NoSets takes handle h returns nothing
        call FlushStoredMission(cs_cache , I2S(GetHandleId(h)))
    endfunction


    //=============================================================================================
    // Tables
    //
    // Tables are lame, the real name would be hash tables, they are just abbreviated usage
    // of gamecache natives with the addition that you can also Copy the values of a table to
    // another one, but don't expect it to be automatic, it must use a FieldData object to know
    // which fields and of wich types to copy, Copying a table to another, with a lot of Fields,
    // should surelly be lag friendly.
    //
    // The other thing about tables is that I can say that the Attached variables of a handle work
    // inside a table and GetAttachmentTable which is just return bug and I2S , works to allow you
    // to manipulate a handle's attached variables through a table.
    //
    // NewTable and DestroyTable were created to allow to create tables in the fly, but you can
    // simply use strings for tables, but place the table names should be between "("")" for example
    // "(mytable)" to avoid conflicts with other caster system stuff.
    //
    function NewTableIndex takes nothing returns integer
     local integer loc=CSSafeCache__cs_freeindexes[0]
     local integer i
        if ( loc != 0 ) then
            set i = GetPairX(loc)
            set CSSafeCache__cs_freeindexes[0]=GetPairY(loc)
            call DestroyPair(loc)

            return i
        endif
        set i = cs_array1[147] + 1
        set cs_array1[147]=i

     return i
    endfunction
    function NewTable takes nothing returns string
     local integer loc=CSSafeCache__cs_freeindexes[0]
     local integer i
        if ( loc != 0 ) then
            set i = GetPairX(loc)
            set CSSafeCache__cs_freeindexes[0]=GetPairY(loc)
            call DestroyPair(loc)

            return I2S(i)
        endif
        set i = cs_array1[147] + 1
        set cs_array1[147]=i

     return I2S(i)
    endfunction
    function GetAttachmentTable takes handle h returns string
        return I2S(GetHandleId(h))
    endfunction

    //============================================================================================================
    function DestroyTable takes string table returns nothing
     local integer i=S2I(table)
     local integer n
         call FlushStoredMission(cs_cache , table)
         if ( ( i > 100 ) and ( i < 1000000 ) ) then //All right, more than 1000000 tables is just wrong.
             if ( i == cs_array1[147] ) then
                 set cs_array1[147]=cs_array1[147] - 1
             else
                 set CSSafeCache__cs_freeindexes[0]=NewPair(i , CSSafeCache__cs_freeindexes[0])
             endif
         endif

    endfunction

    //============================================================================================================
    function ClearTable takes string table returns nothing
         call FlushStoredMission(cs_cache , table)
    endfunction


    //============================================================================================================
    function SetTableInt takes string table,string field,integer val returns nothing
        if ( val == 0 ) then
            call FlushStoredInteger(cs_cache , table , field)
        else
            call StoreInteger(cs_cache , table , field , val)
        endif
    endfunction
    function GetTableInt takes string table,string field returns integer
        return GetStoredInteger(cs_cache , table , field)
    endfunction

    //============================================================================================================
    function SetTableReal takes string table,string field,real val returns nothing
        if ( val == 0 ) then
            call FlushStoredReal(cs_cache , table , field)
        else
            call StoreReal(cs_cache , table , field , val)
        endif
    endfunction
    function GetTableReal takes string table,string field returns real
        return GetStoredReal(cs_cache , table , field)
    endfunction

    //============================================================================================================
    function SetTableBoolean takes string table,string field,boolean val returns nothing
        if ( not ( val ) ) then
            call FlushStoredBoolean(cs_cache , table , field)
        else
            call StoreBoolean(cs_cache , table , field , val)
        endif
    endfunction
    function GetTableBoolean takes string table,string field returns boolean
        return GetStoredBoolean(cs_cache , table , field)
    endfunction

    //============================================================================================================
    function SetTableString takes string table,string field,string val returns nothing
        if ( val == "" ) or ( val == null ) then
            call FlushStoredString(cs_cache , table , field)
        else
            call StoreString(cs_cache , table , field , val)
        endif
    endfunction
    function GetTableString takes string table,string field returns string
        return GetStoredString(cs_cache , table , field)
    endfunction

    //============================================================================================================
    // Returns true if the fiel contains a value different from 0, false,  null, or "" (depending on the type)
    // it is worthless to use this with boolean, since it would be the same as reading the boolean value
    //
    function HaveSetField takes string table,string field,integer fieldType returns boolean
        if ( fieldType == bj_GAMECACHE_BOOLEAN ) then
            return HaveStoredBoolean(cs_cache , table , field)
        elseif ( fieldType == bj_GAMECACHE_INTEGER ) then
            return HaveStoredInteger(cs_cache , table , field)
        elseif ( fieldType == bj_GAMECACHE_REAL ) then
            return HaveStoredReal(cs_cache , table , field)
        elseif ( fieldType == bj_GAMECACHE_STRING ) then
            return HaveStoredString(cs_cache , table , field)
        endif
     return false
    endfunction

    //============================================================================================================
    // Allows to copy a table to another one, but it needs a FieldData object to know which fields of which type
    // it is supposed to copy.
    //
    function CopyTable takes integer FieldData,string sourceTable,string destTable returns nothing
     local integer i=1
     local string k=I2S(FieldData)
     local string k2
     local string k3
     local integer n=GetStoredInteger(cs_cache , k , "N")
     local integer t
        loop
            exitwhen ( i > n )
            set k2 = I2S(i)
            set t = GetStoredInteger(cs_cache , k , k2)
            set k3 = GetStoredString(cs_cache , k , k2)
            if ( t == bj_GAMECACHE_BOOLEAN ) then
                if ( HaveStoredBoolean(cs_cache , sourceTable , k3) ) then
                    call StoreBoolean(cs_cache , destTable , k3 , GetStoredBoolean(cs_cache , sourceTable , k3))
                else
                    call FlushStoredBoolean(cs_cache , destTable , k3)
                endif
            elseif ( t == bj_GAMECACHE_INTEGER ) then
                if ( HaveStoredInteger(cs_cache , sourceTable , k3) ) then
                    call StoreInteger(cs_cache , destTable , k3 , GetStoredInteger(cs_cache , sourceTable , k3))
                else
                    call FlushStoredInteger(cs_cache , destTable , k3)
                endif
            elseif ( t == bj_GAMECACHE_REAL ) then
                if ( HaveStoredReal(cs_cache , sourceTable , k3) ) then
                    call StoreReal(cs_cache , destTable , k3 , GetStoredReal(cs_cache , sourceTable , k3))
                else
                    call FlushStoredReal(cs_cache , destTable , k3)
                endif
            elseif ( t == bj_GAMECACHE_STRING ) then
                if ( HaveStoredString(cs_cache , sourceTable , k3) ) then
                    call StoreString(cs_cache , destTable , k3 , GetStoredString(cs_cache , sourceTable , k3))
                else
                    call FlushStoredString(cs_cache , destTable , k3)
                endif
            endif
            set i = i + 1
        endloop


    endfunction

    //=============================================================================================
    // FieldData inherits from Table, was just designed to be used by CopyTable.
    //
    function FieldData_Create takes nothing returns integer
        return NewTableIndex()
    endfunction


    //============================================================================================================
    // valueType uses the same integer variables from blizzard.j :
    // bj_GAMECACHE_BOOLEAN, bj_GAMECACHE_INTEGER, bj_GAMECACHE_REAL and bj_GAMECACHE_STRING
    //
    function FieldData_AddField takes integer fielddata,string field,integer valueType returns nothing
     local string k=I2S(fielddata)
     local integer n=GetStoredInteger(cs_cache , k , "N") + 1
     local string k2=I2S(n)

        call StoreString(cs_cache , k , k2 , field)
        call StoreInteger(cs_cache , k , k2 , valueType)
        call StoreInteger(cs_cache , k , "N" , n)

    endfunction

    //=============================================================================================
    // Destroys Field Data
    function FieldData_Destroy takes integer fielddata returns nothing
        call DestroyTable(I2S(fielddata))
    endfunction

    //=============================================================================================
    // Pools
    //
    // A better name for pools would be sets, but by the time I made them I couldn't think of that
    // name, besides the word set is already a JASS syntax word so it would have been problematic.
    //
    // Another naming failure is that values of a pool are called "items" but that conflicts with
    // the word item that points to wc3 items, Pools can only store integer values, but if you want
    // you can go and use the return bug on them.
    //

    function CreatePool takes nothing returns integer
     local integer i=NewArray(34 , false)
        call SetArrayInt(i , 0 , 0)
     return i
    endfunction

    function ClearPool takes integer poolid returns nothing
        call SetArrayInt(poolid , 0 , 0) //[0:integer:n]
        call FlushStoredMission(cs_cache , I2S(- poolid))
    endfunction

    function DestroyPool takes integer poolid returns nothing
        call DestroyArray(poolid)
    endfunction


    function PoolAddItem takes integer poolid,integer value returns nothing
     local integer n
     local string k=I2S(- poolid)
     local string vk="#" + I2S(value)
        if not HaveStoredInteger(cs_cache , k , vk) then
            set n = GetArrayInt(poolid , 0) + 1 //[0:integer:N] 
            call StoreInteger(cs_cache , k , vk , n)
            if ( n > 33 ) then
                call StoreInteger(cs_cache , k , I2S(n) , value)
            else
                call SetArrayInt(poolid , n , value)
            endif
            call SetArrayInt(poolid , 0 , n) //[0:integer:N]
        endif
    endfunction



    function PoolRemoveItem takes integer poolid,integer value returns nothing
     local string k=I2S(- poolid)
     local string vk="#" + I2S(value)

     local integer p=GetStoredInteger(cs_cache , k , vk)
     local integer n

        if ( p != 0 ) then
            set n = GetArrayInt(poolid , 0) //[0:integer:N]
            call FlushStoredInteger(cs_cache , k , vk)
            
            if ( n > p ) then
            
                if ( n > 33 ) then
                    set vk = I2S(n)
                    set value = GetStoredInteger(cs_cache , k , vk)
                    call FlushStoredInteger(cs_cache , k , vk)
                else
                    set value = GetArrayInt(poolid , n)
                endif
                call StoreInteger(cs_cache , k , "#" + I2S(value) , p)
                if ( p > 33 ) then
                    call StoreInteger(cs_cache , k , I2S(p) , value)
                else
                    call SetArrayInt(poolid , p , value)
                endif
            elseif ( p > 33 ) then
                call FlushStoredInteger(cs_cache , k , I2S(p))
            endif
            call SetArrayInt(poolid , 0 , n - 1) //[0:integer:N]
        endif
    endfunction

    //===================================================================================
    function PoolGetItem takes integer poolid,integer itemn returns integer
        if ( itemn > 33 ) then
            return GetStoredInteger(cs_cache , I2S(- poolid) , I2S(itemn))
        endif
     return GetArrayInt(poolid , itemn)
    endfunction

    //===================================================================================
    function CountItemsInPool takes integer poolid returns integer
     return GetArrayInt(poolid , 0) //[0:integer:N]
    endfunction


    //===================================================================================
    // Removed : GetEnumPoolItem , ForPool and ForPool2 they are much worse than just
    // using CountItemsInPool and PoolGetItem to iterate the pool
    //

    //===================================================================================
    function GetFirstOfPool takes integer poolid returns integer
        return GetArrayInt(poolid , 1) //[1 is just the first of the pool]
    endfunction


    //===================================================================================
    function PoolPickRandomItem takes integer poolid returns integer
     local integer p=GetRandomInt(1 , GetArrayInt(poolid , 0))
        if ( p > 33 ) then
            return GetStoredInteger(cs_cache , I2S(- poolid) , I2S(p))
        endif
     return GetArrayInt(poolid , p)
    endfunction

    //===================================================================================
    function GetItemPositionInPool takes integer poolid,integer it returns integer
        return GetStoredInteger(cs_cache , I2S(- poolid) , "#" + I2S(it))
    endfunction

    //===================================================================================
    function IsItemInPool takes integer poolid,integer it returns boolean
        return ( HaveStoredInteger(cs_cache , I2S(- poolid) , "#" + I2S(it)) )
    endfunction

    //===================================================================================
    // This had to be optimized for speed, if it was just a loop using the above functions 
    // that would have been too slow to be worth keeping. That's a bad thing about JASS
    // it is such an slow language that code reusability always has the cost of speed
    //
    function PoolAddPool takes integer sourcepoolid,integer destpoolid returns nothing
     local integer a=1
     local integer n=GetArrayInt(sourcepoolid , 0) //[0:integer:N]
     local integer dn=GetArrayInt(destpoolid , 0) //[0:integer:N]
     local string sk=I2S(- sourcepoolid)

     local string k=I2S(- destpoolid)
     local integer v
     local string vk

        loop
            exitwhen ( a > n )
            if ( a > 33 ) then
                set v = GetStoredInteger(cs_cache , sk , I2S(a))
            else
                set v = GetArrayInt(sourcepoolid , a)
            endif
            set vk = "#" + I2S(v)
            if not HaveStoredInteger(cs_cache , k , vk) then
                set dn = dn + 1
                call StoreInteger(cs_cache , k , vk , dn)
                if ( dn > 33 ) then
                    call StoreInteger(cs_cache , k , I2S(dn) , v)
                else
                    call SetArrayInt(destpoolid , dn , v)
                endif
            endif
            set a = a + 1
        endloop
        call SetArrayInt(destpoolid , 0 , dn) //[0:integer:N]
    endfunction

    //=============================================================================================
    // Oh darn, After making PoolAddPool I don't feel like writting this one
    // All right I am at least make the get code
    //
    function PoolRemovePool takes integer sourcepoolid,integer destpoolid returns nothing
     local integer a=1
     local integer n=GetArrayInt(sourcepoolid , 0) //[0:integer:N]
     local integer v
     local string sk=I2S(- sourcepoolid)
        loop
            exitwhen a > n
            if ( a > 33 ) then
                set v = GetStoredInteger(cs_cache , sk , I2S(a))
            else
                set v = GetArrayInt(sourcepoolid , a)
            endif
            call PoolRemoveItem(destpoolid , v)
            set a = a + 1
        endloop
    endfunction

    //===================================================================================
    // Adds a tokenized string to a pool,
    //  Example: PoolAddS(udg_p, "1;2;3;4") will add to the udg_p pool : 1,2,3 and 4
    //
    function PoolAddS takes integer poolid,string s returns nothing
     local integer i=0
     local integer st
     local string c
        set s = s + ";"
        set st = 0
        loop
            set c = SubString(s , i , i + 1)
            exitwhen ( c == "" ) or ( c == null )
            if ( c == ";" ) then
                call PoolAddItem(poolid , S2I(SubString(s , st , i)))
                set st = i + 1
            endif
            set i = i + 1
        endloop
    endfunction

    //===================================================================================
    // Converts a tokenized string into a pool,
    //  Example: S2Pool( "1;2;3;4") will return a pool that has 1,2,3 and 4 inside
    //
    function S2Pool takes string s returns integer
     local integer spool= CreatePool()
        call PoolAddS(spool , s)
     return spool
    endfunction

    //===================================================================================
    // Does the opposite of S2Pool, debugging is a good use for this function.
    //
    function Pool2S takes integer P returns string
     local integer N=(GetArrayInt((P) , 0)) // INLINED!!
     local integer i
     local string s
        if ( N >= 1 ) then
            set s = I2S(PoolGetItem(P , 1))
            set i = 2
        else
            return ""
        endif
        loop
            exitwhen ( i > N )
            set s = s + ";" + I2S(PoolGetItem(P , i))
            set i = i + 1
        endloop
    return s
    endfunction

    //=============================================================================================================
    // Fixes a lame bug by blizzard related to the custom script section (The condition of the if statement might
    // actually be true.
    //
    function Pool_Percent takes nothing returns string
       if ( "%" == "" ) then
           return "%%"
       endif
     return "%"
    endfunction

    function Pool_SetupCharMap takes nothing returns nothing
     local string cm=".................................!.#$" + Pool_Percent() + "&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
     local integer i=0
     local string c
        if HaveStoredInteger(cs_cache , "charmap_upper" , "A") then
            return 
        endif
        loop
            set c = SubString(cm , i , i + 1)
            exitwhen ( c == null ) or ( c == "" )
            if ( c != "." ) then
                if c == StringCase(c , true) then
                    call StoreInteger(cs_cache , "charmap_upper" , c , i)
                else
                    call StoreInteger(cs_cache , "charmap_lower" , c , i)
                endif
                
            endif
            set i = i + 1
        endloop

    endfunction


    function Pool_Rawcode2Int takes string s returns integer
     local string c
     local integer i=0
     local integer r=0
        loop
            exitwhen i > 3
            set c = SubString(s , i , i + 1)
            set r = r * 256
            if c == StringCase(c , true) then
                set r = r + GetStoredInteger(cs_cache , "charmap_upper" , c)
            else
                set r = r + GetStoredInteger(cs_cache , "charmap_lower" , c)
            endif
            
            set i = i + 1
        endloop
     return r
    endfunction

    function PoolAddRawcodes_thread takes nothing returns nothing
    //Threaded because I don't want it to halt execution for no reason
    //
     local string s=bj_lastPlayedMusic
     local integer poolid=bj_groupEnumTypeId
     local string c
     local integer i=0
     local integer st=0
        set s = s + ";"
        loop
            set c = SubString(s , i , i + 1)
            exitwhen ( c == "" ) or ( c == null )
            if c == ";" then
                call PoolAddItem(poolid , Pool_Rawcode2Int(SubString(s , st , i)))
                set st = i + 1
            endif
            set i = i + 1
        endloop

    endfunction

    //=====================================================================================================================
    // Adds a string of tokenized rawcodes to a pool
    //  Example: PoolAddRawcodes(udg_p,"A000;A001")  will add 'A000' and 'A001' to the pool
    //
    // (Saves some lines, but is not as good efficiency wise)
    //
    function PoolAddRawcodes takes integer poolid,string s returns nothing
     local string b=bj_lastPlayedMusic
        set bj_groupEnumTypeId = poolid
        set bj_lastPlayedMusic = s
        call ExecuteFunc("PoolAddRawcodes_thread")
        set bj_lastPlayedMusic = b
    endfunction

    //===================================================================================================================
    // Converts a tokenized string of rawcodes into a pool,
    //  Example: Rawcodes2Pool( "A000;A001;AHbz;S000") will return a pool that has 'A000,'A001','AHbx' and 'S000' inside
    //
    // (Saves some lines, but is not as good efficiency wise)
    //
    function Rawcodes2Pool takes string s returns integer
     local integer spool= CreatePool()
        call PoolAddRawcodes(spool , s)
     return spool
    endfunction

    //===================================================================================================================
    // A subproduct of the Pool's Rawcode support is that we can easily have this function so I am including it even if
    // it has nothing to do with data storage.
    //
    // takes "Aloc" and converts it into 'Aloc'
    // it is different to the Pool_Rawcode2Int function in that it is safe to use it when it is the first CSCache
    // function ever used. But it is a little slower (wc3mapoptimizer should make it as fast though)
    //
    function CS_Rawcode2Int takes string s returns integer
     local string c
     local integer i=0
     local integer r=0
        loop
            exitwhen i > 3
            set c = SubString(s , i , i + 1)
            set r = r * 256
            if c == StringCase(c , true) then
                set r = r + GetStoredInteger(cs_cache , "charmap_upper" , c)
            else
                set r = r + GetStoredInteger(cs_cache , "charmap_lower" , c)
            endif
            
            set i = i + 1
        endloop
     return r
    endfunction



//library CSSafeCache ends
//library CSSafety:

//library CSSafety ends
//library CasterSystem:

    //***************************************************************************
    //*                                                                         *
    //* Caster System 16.0                                                      *
    //*                http://wc3campaigns.net/vexorian       *
    //* Requires:                                                               *
    //*                                                                *
    //* - Jasshelper / Newgen pack                                              *
    //*                                                                         *
    //* - The CSSafeCache Module                                                *
    //* - The CSData Module                                                     *
    //* - The CSSafety Module                                                   *
    //*                                                                         *
    //* - The caster unit from this map Can be found in this map's unit editor  *
    //*   ( Custom Units\Neutral Passive\Units\Caster )                         *
    //*                                                                         *
    //*   ( Update the cs_CasterUnitId constant next:)                          *
    //*                                                                         *
    //* - the war3mapImported\dummy.mdx imported file (find it in this map)     * 
    //*                                                                         *
    //***************************************************************************

    //====================================================================================================================================================================
    //  Caster System Configuration constants : 
    //
    // 


    //=================================================================================================
    // Caster System script:
    // 

    //=================================================================================================
    // main Caster System global variables:
    //

    //=================================================================================================
    function CS_CopyGroup takes group g returns group
        set bj_groupAddGroupDest = NewGroup()
        call ForGroup(g , function GroupAddGroupEnum)
     return bj_groupAddGroupDest
    endfunction


    function CS_SafeXY_Init takes nothing returns nothing
        set cs_game_maxx = GetRectMaxX(bj_mapInitialPlayableArea) - cs_RectLimitOffSet
        set cs_game_maxy = GetRectMaxY(bj_mapInitialPlayableArea) - cs_RectLimitOffSet
        set cs_game_miny = GetRectMinY(bj_mapInitialPlayableArea) + cs_RectLimitOffSet
        set cs_game_minx = GetRectMinX(bj_mapInitialPlayableArea) + cs_RectLimitOffSet
    endfunction

    function CS_SafeX takes real x returns real
        if ( x < cs_game_minx ) then
            return cs_game_minx
        elseif ( x > cs_game_maxx ) then
                return cs_game_maxx
        endif
     return ( x )
    endfunction

    function CS_SafeY takes real y returns real
        if ( y < cs_game_miny ) then
            return cs_game_minx
        elseif ( y > cs_game_maxy ) then
                return cs_game_maxy
        endif
     return ( y )
    endfunction

    //Deprecated, since patch 1.21 there is no crash anymore, it is possibly
    // still mildly useful since it does bound checking.
    function CS_MoveUnit takes unit u,real x,real y returns boolean
     local boolean b=true
        if ( x < cs_game_minx ) then
            set b = false
        elseif ( x > cs_game_maxx ) then
            set b = false
        elseif ( y > cs_game_maxy ) then
            set b = false
        elseif ( y < cs_game_miny ) then
            set b = false
        endif

        if ( b ) then
            call SetUnitX(u , x)
            call SetUnitY(u , y)
        endif
     return b
    endfunction
    function CS_MoveUnitLoc takes unit u,location loc returns boolean
        return CS_MoveUnit(u , GetLocationX(loc) , GetLocationY(loc))
    endfunction

    //==================================================================================================
    function CS_EnumUnitsInAOE_Filter takes nothing returns boolean
        return IsUnitInRangeLoc(GetFilterUnit() , bj_enumDestructableCenter , bj_enumDestructableRadius)
    endfunction

    //==================================================================================================
    // Use this version when you only have coordinates of the point.
    //
    function CS_EnumUnitsInAOE takes group g,real x,real y,real area,boolexpr bx returns nothing
     local boolexpr cond
     local boolexpr aux=Condition(function CS_EnumUnitsInAOE_Filter)

        if ( bx == null ) then
            set cond = aux
        else
            set cond = And(aux , bx)
        endif
        set bj_enumDestructableCenter = Location(x , y)
        set bj_enumDestructableRadius = area
        call GroupEnumUnitsInRange(g , x , y , cs_MaxUnitCollisionSize + area , cond)
        if ( bx != null ) then
            call DestroyBoolExpr(cond)
        endif
        call RemoveLocation(bj_enumDestructableCenter)
     set aux = null
     set cond = null
    endfunction

    //==================================================================================================
    // Use this version whenever you already have a location for that point, to save some steps
    //
    function CS_EnumUnitsInAOELoc takes group g,location loc,real area,boolexpr bx returns nothing
     local boolexpr cond
     local boolexpr aux=Condition(function CS_EnumUnitsInAOE_Filter)

        if ( bx == null ) then
            set cond = aux
        else
            set cond = And(aux , bx)
        endif
        set bj_enumDestructableCenter = loc
        set bj_enumDestructableRadius = area
        call GroupEnumUnitsInRangeOfLoc(g , loc , cs_MaxUnitCollisionSize + area , cond)
        call DestroyBoolExpr(cond)
        if ( bx != null ) then
            call DestroyBoolExpr(aux)
        endif
     set aux = null
     set cond = null
    endfunction




    //==================================================================================================
    // Angle Calculations
    //
    // I decided to add them to the caster system, because I found myself using them everytime, I am
    // trying to convert the caster system into a Spell Development Framework (hehe)
    //
    //=================================================================================================
    // Returns the angle distance between angles a1 and a2 (For example: a1=30 , a2=60 , return= 30 )
    //
    function Angles_GetAngleDifference takes real a1,real a2 returns real
     local real x
        set a1 = ModuloReal(a1 , 360)
        set a2 = ModuloReal(a2 , 360)
        if a1 > a2 then
            set x = a1
            set a1 = a2
            set a2 = x
        endif
        set x = a2 - 360
        if a2 - a1 > a1 - x then
            set a2 = x
        endif
        set x = a1 - a2
        if ( x < 0 ) then
            return - x
        endif
     return x
    endfunction

    //=================================================================================================
    // Returns the mid angle between a1 and a2 (For example: a1=30 , a2=60 , return= 45 )
    //
    function Angles_GetMidAngle takes real a1,real a2 returns real
     local real x
        set a1 = ModuloReal(a1 , 360)
        set a2 = ModuloReal(a2 , 360)
        if a1 > a2 then
            set x = a1
            set a1 = a2
            set a2 = x
        endif
        set x = a2 - 360
        if a2 - a1 > a1 - x then
            set a2 = x
        endif
     return ( a1 + a2 ) / 2
    endfunction

    //=================================================================================================
    // Makes angle a1 advance i units towards angle a2 (For Example: a1=30, a2=60, i=10, return=40 )
    //
    function Angles_MoveAngleTowardsAngle takes real a1,real a2,real i returns real
     local real x
        set a1 = ModuloReal(a1 , 360)
        set a2 = ModuloReal(a2 , 360)
        if a1 > a2 then
            set x = a1 - 360
            if a1 - a2 > a2 - x then
                set a1 = x
            endif
        else
            set x = a2 - 360
            if a2 - a1 > a1 - x then
                set a2 = x
            endif
        endif
        if a1 > a2 then
            set x = a1 - i
            if x <= a2 then
                return a2
            endif
           return x
        endif
        set x = a1 + i
        if x >= a2 then
            return a2
        endif
     return x
    endfunction

    //=================================================================================================
    // Returns true if the angle 'angle' is between 'angle1' and 'angle2'
    //
    function Angles_IsAngleBetweenAngles takes real angle,real angle1,real angle2 returns boolean
     local real x
        set angle = ModuloReal(angle , 360)
        set angle1 = ModuloReal(angle1 , 360)
        set angle2 = ModuloReal(angle2 , 360)
        if ( angle1 > angle2 ) then
            set x = angle1
            set angle1 = angle2
            set angle2 = x
        endif
        if ( angle2 - angle1 ) > ( angle1 - ( angle2 - 360 ) ) then
            set angle2 = angle2 - 360
            if angle > 180 then
                set angle = angle - 360
            endif
            return angle >= angle2 and angle <= angle1
        endif
     return ( angle >= angle1 ) and ( angle <= angle2 )
    endfunction

    //====================================================================================================================================================================
    function CreateCaster takes real fac,real x,real y returns unit
     local unit m
        if ( x != 0 ) then
            set x = CS_SafeX(x)
        endif
        if ( y != 0 ) then
            set y = CS_SafeY(y)
        endif
        set m = CreateUnit(Player(15) , cs_CasterUnitId , x , y , fac)

        
        call UnitAddAbility(m , 'Aloc')
        call UnitAddAbility(m , cs_FlyingHeightHack)
        call UnitRemoveAbility(m , cs_FlyingHeightHack)
     set udg_currentcaster = m
     set m = null
     return udg_currentcaster
    endfunction



    function AddCasterFacing takes real fac returns unit
        return CreateCaster(fac , 0 , 0)
    endfunction

    function AddCaster takes nothing returns unit
        return CreateCaster(0 , 0 , 0)
    endfunction


    //====================================================================================================================================================================
    function CreateCasters takes integer n returns nothing
     local integer a=0
     local unit c
        loop
            exitwhen a >= n
            set c = CreateCaster(0 , 0 , 0)
            call GroupAddUnit(udg_casters , c)
            set a = a + 1
        endloop
     set c = null
    endfunction

    function CasterSystem___InitCasterSystem takes nothing returns nothing
        set udg_casters = NewGroup()
        call CS_SafeXY_Init()
        call CreateCasters(cs_InitialCastersNumber)
        set udg_castervars[100]=- 1
        set udg_castervars[101]=- 1
        set udg_castervars[102]=- 1
        set udg_castervars[103]=- 1
        set udg_castervars[104]=- 1

        set cs_dmg_caster = CreateCaster(0. , 0. , 0.)
        call UnitRemoveAbility(cs_dmg_caster , 'Aloc') //Otherwise the units would flee like crazy

    endfunction



    //====================================================================================================================================================================
    function GetACaster takes nothing returns unit
        set udg_currentcaster = FirstOfGroup(udg_casters)
        if udg_currentcaster == null then
            set udg_currentcaster = CreateCaster(0 , 0 , 0)
        endif
        call GroupRemoveUnit(udg_casters , udg_currentcaster)
        call SetUnitState(udg_currentcaster , UNIT_STATE_MANA , 1000)
     return udg_currentcaster
    endfunction

    //====================================================================================================================================================================
    function Caster_SetZAngle takes unit caster,real ang returns nothing
     local real a=( ModuloReal(GetUnitFacing(caster) , 360) * bj_DEGTORAD )
     local real x
        set ang = ModuloReal(ang , 360)
        if ( ang == 90 ) then
            set ang = 89
        endif
        if ( ang == 270 ) then
            set ang = 271
        endif
        if ( ang > 90 ) and ( ang < 270 ) then
            set x = - 1
        else
            set x = 1
        endif
        set ang = ang * bj_DEGTORAD
        call SetUnitLookAt(caster , "Bone_Chest" , caster , 10000.0 * Cos(a) * Cos(ang) , 10000.0 * Sin(a) * Cos(ang) , x * ( 10000.0 * Tan(ang) + 90.0 ))
    endfunction

    //====================================================================================================================================================================
    function Caster_SetZAngle2 takes unit caster,integer ang returns nothing
        call SetUnitAnimationByIndex(caster , ang + 90) //Thanks infrane!
    endfunction

    //====================================================================================================================================================================
    function RecycleCaster takes unit caster returns nothing
        if GetWidgetLife(caster) >= 0.405 then
            call ResetUnitLookAt(caster)
            call SetUnitOwner(caster , Player(15) , true)
            call SetUnitVertexColor(caster , 255 , 255 , 255 , 255)
            call SetUnitScale(caster , 1 , 1 , 1)
            call SetUnitTimeScale(caster , 1)
            call SetUnitMoveSpeed(caster , 522)
            call SetUnitFlyHeight(caster , 0 , 0)
            call UnitAddAbility(caster , 'Aloc')
            call SetUnitTurnSpeed(caster , 0.6)
            call GroupAddUnit(udg_casters , caster)
        endif
    endfunction

    function RecycleCaster_Light takes unit caster returns nothing
        if GetWidgetLife(caster) >= 0.405 then
            call SetUnitOwner(caster , Player(15) , true)
            call GroupAddUnit(udg_casters , caster)
        endif
    endfunction
    function RecicleCaster takes unit caster returns nothing
        call RecycleCaster(caster)
    endfunction
    function RecicleCaster_Light takes unit caster returns nothing
        call RecycleCaster_Light(caster)
    endfunction


    function CasterRecycleTimed_X takes nothing returns nothing
     local timer t=GetExpiredTimer()
     local integer k=(LoadInteger(CSData__ht , 0 , GetHandleId((t)))) // INLINED!!
        if ( s__CasterSystem___csrecy_abil[k] != 0 ) then
            call UnitRemoveAbility(s__CasterSystem___csrecy_caster[k] , s__CasterSystem___csrecy_abil[k])
        endif
        call RecycleCaster(s__CasterSystem___csrecy_caster[k])
        call s__CasterSystem___csrecy_destroy(k)
        call ReleaseTimer(t)
    endfunction

    function CasterRecycleTimed takes unit caster,integer abi,real delay returns nothing
     local timer t=NewTimer()
     local integer k= s__CasterSystem___csrecy__allocate()
        set s__CasterSystem___csrecy_caster[k]=caster
        set s__CasterSystem___csrecy_abil[k]=abi
        call SaveInteger(CSData__ht , 0 , GetHandleId((t )) , ( k)) // INLINED!!

        call TimerStart(t , delay , false , function CasterRecycleTimed_X)
    endfunction

    function CasterWaitForEndCast takes nothing returns nothing
     local unit caster=udg_currentcaster
     local integer abilid=udg_currentabi
     local real delay=udg_castervars[0]
     local boolean activeability=( udg_castervars[1] > 0 )
        loop
            exitwhen GetUnitCurrentOrder(caster) == 0
            call TriggerSleepAction(0)
        endloop
        if ( delay > 0 ) then
            if activeability then
                call CasterRecycleTimed(caster , abilid , delay)
            else
                call UnitRemoveAbility(caster , abilid)
                call CasterRecycleTimed(caster , 0 , delay)
            endif
        else
            call UnitRemoveAbility(caster , abilid)
            call RecycleCaster(caster)
        endif
     set caster = null
    endfunction

    function RecycleCasterAfterCastEx takes unit caster,real delaytime,integer abilid,boolean activeability returns nothing
        set udg_castervars[0]=delaytime
        set udg_castervars[1]=IntegerTertiaryOp(activeability , 1 , 0)
        set udg_currentabi = abilid
        set udg_currentcaster = caster
        call ExecuteFunc("CasterWaitForEndCast")
    endfunction
    function RecicleCasterAfterCastEx takes unit caster,real delaytime,integer abilid,boolean activeability returns nothing
        call RecycleCasterAfterCastEx(caster , delaytime , abilid , activeability)
    endfunction

    function CasterWaitForEndCast_Light takes nothing returns nothing
     local unit caster=udg_currentcaster
     local integer abilid=udg_currentabi
     local real delay=udg_castervars[0]
     local boolean activeability=( udg_castervars[1] > 0 )
        loop
            exitwhen GetUnitCurrentOrder(caster) == 0
            call TriggerSleepAction(0)
        endloop
        if ( delay > 0 ) then
            if activeability then
                call CasterRecycleTimed(caster , abilid , delay)
            else
                call UnitRemoveAbility(caster , abilid)
                call CasterRecycleTimed(caster , 0 , delay)
            endif
        else
            call UnitRemoveAbility(caster , abilid)
            call RecycleCaster_Light(caster)
        endif
     set caster = null
    endfunction

    function RecycleCasterAfterCastEx_Light takes unit caster,real delaytime,integer abilid,boolean activeability returns nothing
        set udg_castervars[0]=delaytime
        set udg_castervars[1]=IntegerTertiaryOp(activeability , 1 , 0)
        set udg_currentabi = abilid
        set udg_currentcaster = caster
        call ExecuteFunc("CasterWaitForEndCast_Light")
    endfunction


    function RecicleCasterAfterCastEx_Light takes unit caster,real delaytime,integer abilid,boolean activeability returns nothing
        call RecycleCasterAfterCastEx_Light(caster , delaytime , abilid , activeability)
    endfunction
    function RecicleCasterAfterCast takes unit caster,integer abilid returns nothing
        call RecycleCasterAfterCastEx(caster , udg_delayhack , abilid , false)
    endfunction
    function RecycleCasterAfterCast takes unit caster,integer abilid returns nothing
        call RecycleCasterAfterCastEx(caster , udg_delayhack , abilid , false)
    endfunction


    //====================================================================================================================================================================
    function PreloadAbility takes integer abilid returns integer
     local unit u=FirstOfGroup(udg_casters)
        if u == null then
            set u = GetACaster()
            call UnitAddAbility(u , abilid)
            call UnitRemoveAbility(u , abilid)
            call RecycleCaster_Light(u)
        else
            call UnitAddAbility(u , abilid)
            call UnitRemoveAbility(u , abilid)
        endif
     set u = null
     return abilid
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityEx takes player owner,real x,real y,real z,integer abilid,integer level,string order,widget target,real delay returns unit
     local unit caster=GetACaster()
     local boolean done=false
        call SetUnitOwner(caster , owner , false)
        call UnitAddAbility(caster , abilid)
        call SetUnitAbilityLevel(caster , abilid , level)
        call SetUnitX(caster , x)
        call SetUnitY(caster , y)
        call SetUnitFlyHeight(caster , z , 0)
        if S2I(order) != 0 then
            set done = IssueTargetOrderById(caster , S2I(order) , target)
        else
            set done = IssueTargetOrder(caster , order , target)
        endif
        if ( delay <= 0 ) or not ( done ) then
            call UnitRemoveAbility(caster , abilid)
            call RecycleCaster_Light(caster)
        else
            call RecycleCasterAfterCastEx_Light(caster , delay , abilid , true)
        endif
     set udg_currentcaster = caster
     set caster = null
     return udg_currentcaster
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityExLoc takes player owner,location loc,real z,integer abilid,integer level,string order,widget target,real delay returns unit
        return CasterCastAbilityEx(owner , GetLocationX(loc) , GetLocationY(loc) , z , abilid , level , order , target , delay)
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityLevel takes player owner,integer abilid,integer level,string order,widget target,boolean instant returns unit
     local real x
     local real y
     local real d
        if udg_sourcehack != null then
            set x = GetLocationX(udg_sourcehack)
            set y = GetLocationY(udg_sourcehack)
        else
            set x = GetWidgetX(target)
            set y = GetWidgetY(target)
        endif
        if not ( instant ) then
            set d = udg_delayhack + 0.01
        else
            set d = 0
        endif
     return CasterCastAbilityEx(owner , x , y , 0 , abilid , level , order , target , d)
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbility takes player owner,integer abilid,string order,widget target,boolean instant returns unit
        return CasterCastAbilityLevel(owner , abilid , 1 , order , target , instant)
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityPointEx takes player owner,real x1,real y1,real z1,integer abilid,integer level,string order,real x2,real y2,real delay returns unit
     local unit caster=GetACaster()
        call SetUnitOwner(caster , owner , false)
        call UnitAddAbility(caster , abilid)
        call SetUnitAbilityLevel(caster , abilid , level)
        call SetUnitX(caster , x1)
        call SetUnitY(caster , y1)
        call SetUnitFlyHeight(caster , z1 , 0)
        if S2I(order) != 0 then
            if not IssuePointOrderById(caster , S2I(order) , x2 , y2) then
                call IssueImmediateOrderById(caster , S2I(order))
            endif
        else
            if not IssuePointOrder(caster , order , x2 , y2) then
                call IssueImmediateOrder(caster , order)
            endif
        endif
        if ( delay <= 0 ) then
            call UnitRemoveAbility(caster , abilid)
            call RecycleCaster_Light(caster)
        else
            call RecycleCasterAfterCastEx_Light((caster ) , (( delay )*1.0) , ( abilid ) , ( true)) // INLINED!!
        endif
     set udg_currentcaster = caster
     set caster = null
     return udg_currentcaster
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityPointExLoc takes player owner,location loc1,real z1,integer abilid,integer level,string order,location loc2,real delay returns unit
        return CasterCastAbilityPointEx(owner , GetLocationX(loc1) , GetLocationY(loc1) , z1 , abilid , level , order , GetLocationX(loc2) , GetLocationY(loc2) , delay)
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityLevelPoint takes player owner,integer abilid,integer level,string order,real x,real y,boolean instant returns unit
     local real sx
     local real sy
     local real d
        if udg_sourcehack != null then
            set sx = GetLocationX(udg_sourcehack)
            set sy = GetLocationY(udg_sourcehack)
        else
            set sx = x
            set sy = y
        endif
        if instant then
            set d = 0
        else
            set d = udg_delayhack + 0.01
        endif
     return CasterCastAbilityPointEx(owner , sx , sy , 0 , abilid , level , order , x , y , d)
    endfunction

    function CasterCastAbilityPoint takes player owner,integer abilid,string order,real x,real y,boolean instant returns unit
        return CasterCastAbilityLevelPoint(owner , abilid , 1 , order , x , y , instant)
    endfunction

    function CasterCastAbilityPointLoc takes player owner,integer abilid,string order,location loc,boolean instant returns unit
        return CasterCastAbilityLevelPoint(owner , abilid , 1 , order , GetLocationX(loc) , GetLocationY(loc) , instant)
    endfunction

    function CasterCastAbilityLevelPointLoc takes player owner,integer abilid,integer level,string order,location loc,boolean instant returns unit
        return CasterCastAbilityLevelPoint(owner , abilid , level , order , GetLocationX(loc) , GetLocationY(loc) , instant)
    endfunction

    //====================================================================================================================================================================

    function CasterUseAbilityLevelStatic_Rec takes nothing returns nothing
     local timer t=GetExpiredTimer()
     local integer k=(LoadInteger(CSData__ht , 0 , GetHandleId((t)))) // INLINED!!
        call RecycleCaster(s__CasterSystem___cssabi_caster[k])
        call s__CasterSystem___cssabi_destroy(k)
        call ReleaseTimer(t)
    endfunction

    function CasterUseAbilityLevelStatic_X takes nothing returns nothing
     local timer t=GetExpiredTimer()
     local integer k=(LoadInteger(CSData__ht , 0 , GetHandleId((t)))) // INLINED!!

        call DestroyEffect(s__CasterSystem___cssabi_fx[k])
        call UnitRemoveAbility(s__CasterSystem___cssabi_caster[k] , s__CasterSystem___cssabi_abil[k])
        call TimerStart(t , 2 , false , function CasterUseAbilityLevelStatic_Rec)
    endfunction

    function CasterUseAbilityLevelStatic takes player owner,string modelpath,integer abilityid,integer level,real duration,real x,real y returns unit
     local timer t=NewTimer()
     local unit c=GetACaster()
     local integer k= s__CasterSystem___cssabi__allocate()


        call SetUnitPosition(c , x , y)
        set s__CasterSystem___cssabi_fx[k]=AddSpecialEffectTarget(modelpath , c , "origin")
        set s__CasterSystem___cssabi_caster[k]=c
        set s__CasterSystem___cssabi_abil[k]=abilityid

        call SetUnitOwner(c , owner , true)
        call UnitAddAbility(c , abilityid)
        call SetUnitAbilityLevel(c , abilityid , level)

        call SaveInteger(CSData__ht , 0 , GetHandleId((t )) , ( k)) // INLINED!!
        call TimerStart(t , duration , false , function CasterUseAbilityLevelStatic_X)


        set udg_currentcaster = c
     set c = null
     return udg_currentcaster
    endfunction

    function CasterUseAbilityStatic takes player owner,string modelpath,integer abilityid,real duration,real x,real y returns unit
        return CasterUseAbilityLevelStatic(owner , modelpath , abilityid , 1 , duration , x , y)
    endfunction

    function CasterUseAbilityStaticLoc takes player owner,string modelpath,integer abilityid,real duration,location loc returns unit
        return CasterUseAbilityLevelStatic(owner , modelpath , abilityid , 1 , duration , GetLocationX(loc) , GetLocationY(loc))
    endfunction

    function CasterUseAbilityLevelStaticLoc takes player owner,string modelpath,integer abilityid,integer level,real duration,location loc returns unit
        return CasterUseAbilityLevelStatic(owner , modelpath , abilityid , level , duration , GetLocationX(loc) , GetLocationY(loc))
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityLevelGroup takes player owner,integer abilid,integer level,string order,group targetgroup,boolean instant returns nothing
     local group affected
     local unit tempunit
     local unit caster=null
        if bj_wantDestroyGroup then
            set bj_wantDestroyGroup = false
            set affected = targetgroup
        else
            set affected = NewGroup()
            call GroupAddGroup(targetgroup , affected)
        endif
        loop
           set tempunit = FirstOfGroup(affected)
           exitwhen tempunit == null
           if instant then
               if caster == null then
                   set caster = GetACaster()
                   call SetUnitOwner(caster , owner , false)
                   call UnitAddAbility(caster , abilid)
                   call SetUnitAbilityLevel(caster , abilid , level)
               endif
               if udg_sourcehack != null then
                   call SetUnitX(caster , GetLocationX(udg_sourcehack))
                   call SetUnitY(caster , GetLocationY(udg_sourcehack))

               else
                   call SetUnitX(caster , GetUnitX(tempunit))
                   call SetUnitY(caster , GetUnitY(tempunit))
               endif

               if S2I(order) != 0 then
                   call IssueTargetOrderById(caster , S2I(order) , tempunit)
               else
                   call IssueTargetOrder(caster , order , tempunit)
               endif
           else
               call CasterCastAbilityLevel(owner , abilid , level , order , tempunit , false)
           endif
           call GroupRemoveUnit(affected , tempunit)
        endloop
        if caster != null then
            call UnitRemoveAbility(caster , abilid)
            call RecycleCaster(caster)
        endif
     call ReleaseGroup(affected)
     set affected = null
     set tempunit = null
     set caster = null
    endfunction

    function CasterCastAbilityGroup takes player owner,integer abilid,string order,group targetgroup,boolean instant returns nothing
        call CasterCastAbilityLevelGroup(owner , abilid , 1 , order , targetgroup , instant)
    endfunction

    //====================================================================================================================================================================
    function CasterAOE_IsFilterEnemy takes nothing returns boolean
        return IsUnitEnemy(GetFilterUnit() , bj_groupEnumOwningPlayer) and ( GetWidgetLife(GetFilterUnit()) > 0.405 )
    endfunction

    function CasterAOE_IsFilterAlly takes nothing returns boolean
        return IsUnitAlly(GetFilterUnit() , bj_groupEnumOwningPlayer) and ( GetWidgetLife(GetFilterUnit()) > 0.405 )
    endfunction

    //====================================================================================================================================================================
    function CasterCastAbilityLevelAOE takes player owner,integer abilid,integer level,string order,real x,real y,real radius,boolean goodeffect,boolean instant returns nothing
     local boolexpr b
     local group aoe=NewGroup()
        set bj_groupEnumOwningPlayer = owner
        if goodeffect then
            set b = Condition(function CasterAOE_IsFilterAlly)
        else
            set b = Condition(function CasterAOE_IsFilterEnemy)
        endif
        call CS_EnumUnitsInAOE(aoe , x , y , radius , b)
        set bj_wantDestroyGroup = true
        call CasterCastAbilityLevelGroup(owner , abilid , level , order , aoe , instant)
     call DestroyBoolExpr(b)
     set b = null
     set aoe = null
    endfunction

    function CasterCastAbilityAOE takes player owner,integer abilid,string order,real x,real y,real radius,boolean goodeffect,boolean instant returns nothing
        call CasterCastAbilityLevelAOE(owner , abilid , 1 , order , x , y , radius , goodeffect , instant)
    endfunction

    function CasterCastAbilityAOELoc takes player owner,integer abilid,string order,location center,real radius,boolean goodeffect,boolean instant returns nothing
        call CasterCastAbilityLevelAOE(owner , abilid , 1 , order , GetLocationX(center) , GetLocationY(center) , radius , goodeffect , instant)
    endfunction

    function CasterCastAbilityLevelAOELoc takes player owner,integer abilid,integer level,string order,location center,real radius,boolean goodeffect,boolean instant returns nothing
        call CasterCastAbilityLevelAOE(owner , abilid , level , order , GetLocationX(center) , GetLocationY(center) , radius , goodeffect , instant)
    endfunction

    //====================================================================================================================================================================

    function ResetSourceHack takes nothing returns nothing
        if ( udg_sourcehack != null ) then
            call RemoveLocation(udg_sourcehack)
            set udg_sourcehack = null
        endif
    endfunction

    function CasterSetCastSource takes real x,real y returns nothing
        if ( udg_sourcehack == null ) then
            set udg_sourcehack = Location(x , y)
        else
            call MoveLocation(udg_sourcehack , x , y)
        endif
        call TimerStart(cs_sourcehacktimer , 0. , false , function ResetSourceHack)
    endfunction

    function CasterSetCastSourceLoc takes location loc returns nothing
        call CasterSetCastSource(GetLocationX(loc) , GetLocationY(loc))
    endfunction

    function ResetDelayHack takes nothing returns nothing
        set udg_delayhack = 0.
    endfunction

    function CasterSetRecycleDelay takes real Delay returns nothing
        set udg_delayhack = Delay
        call TimerStart(cs_delayhacktimer , 0. , false , function ResetDelayHack)
    endfunction

    //====================================================================================================================================================================


    //Super DamageOptions structure!


    function DamageTypes takes attacktype attT,damagetype dmgT returns integer
    //    set udg_castervars[100] = CS_H2I(attT)
    //    set udg_castervars[101] = CS_H2I(dmgT)
        set cs_dopt_Atype = attT
        set cs_dopt_Dtype = dmgT
     return 1
    endfunction

    function DamageException takes unittype Exception,real ExceptionFactor returns integer
        set cs_dopt_ExceptionUtype = Exception
        set cs_dopt_ExceptionFct = ExceptionFactor
    //    set udg_castervars[102] = CS_H2I(Exception)
    //    set udg_castervars[103] = ExceptionFactor
     return 2
    endfunction

    function DamageOnlyTo takes unittype ThisUnitType returns integer
        set cs_dopt_OnlyUtype = ThisUnitType
    //    set udg_castervars[104] = CS_H2I(ThisUnitType)
     return 4
    endfunction

    constant function DontDamageSelf takes nothing returns integer
     return 8
    endfunction

    constant function DamageTrees takes nothing returns integer
     return 16
    endfunction

    constant function DamageOnlyVisibles takes nothing returns integer
     return 32
    endfunction

    function DamageOnlyEnemies takes nothing returns integer
        set cs_dopt_EnemyAlly = 0
    // ouch, forgot what it was
     return 64
    endfunction

    function ForceDamageAllies takes nothing returns integer
        set cs_dopt_EnemyAlly = 1
     return 64
    endfunction

    function DamageOnlyAllies takes nothing returns integer
        set cs_dopt_EnemyAlly = 2
     return 64
    endfunction

    function DamageFactorAbility1 takes integer spellid,real factor returns integer
        set cs_dopt_dfab1 = spellid
        set cs_dopt_dfab1_fc = factor
     return 128
    endfunction

    function DamageFactorAbility2 takes integer spellid,real factor returns integer
        set cs_dopt_dfab2 = spellid
        set cs_dopt_dfab2_fc = factor

     return 256
    endfunction

    function DamageFactorAbility3 takes integer spellid,real factor returns integer
        set cs_dopt_dfab3 = spellid
        set cs_dopt_dfab3_fc = factor

     return 512
    endfunction

    function DamageIgnore takes unittype ThisUnitType returns integer
        set cs_dopt_IgnoreUtype = ThisUnitType
    //    set udg_castervars[112] = CS_H2I(ThisUnitType)
     return 1024
    endfunction

    function DamageAlliedFactor takes real fct returns integer
          set cs_dopt_Ally_fc = fct
    //    set udg_castervars[113] = fct
     return 2048
    endfunction

    constant function ConsiderOnlyDeadUnits takes nothing returns integer
     return 4096
    endfunction

    constant function IgnoreDeadState takes nothing returns integer
     return 8192
    endfunction


    //===============================================================================================
    function IsDamageOptionIncluded takes integer DamageOptions,integer whichDamageOption returns boolean
     local integer i=8192
        if ( DamageOptions == 0 ) then
            return false
        endif
        loop
            exitwhen ( i <= whichDamageOption )
            if ( DamageOptions >= i ) then
                set DamageOptions = DamageOptions - i
            endif
            set i = i / 2
        endloop
     return ( DamageOptions >= whichDamageOption )
    endfunction


    //=================================================================================================

    function GetDamageFactor takes unit u,attacktype a,damagetype d returns real
     local real hp=GetWidgetLife(u)
     local real mana=GetUnitState(u , UNIT_STATE_MANA)
     local real r

        //Since a unit is in that point, we don't need checks.
        call SetUnitX(cs_dmg_caster , GetUnitX(u))
        call SetUnitY(cs_dmg_caster , GetUnitY(u))

        call SetUnitOwner(cs_dmg_caster , GetOwningPlayer(u) , false)
        set r = hp
        if ( hp < 1 ) then
            call SetWidgetLife(u , 1)
            set r = 1
        endif
        call UnitDamageTarget(cs_dmg_caster , u , 0.01 , true , false , a , d , null)
        call SetUnitOwner(cs_dmg_caster , Player(15) , false)
        if ( mana > GetUnitState(u , UNIT_STATE_MANA) ) then
            //Unit had mana shield, return 1 and restore mana too.
            call SetUnitState(u , UNIT_STATE_MANA , mana)
            set r = 1
        else
            set r = ( r - GetWidgetLife(u) ) * 100
        endif
        call SetWidgetLife(u , hp)

     return r
    endfunction

    //======================================================================================================
    // Fix for the unit type bugs from blizzard, amphibious units aren't considered ground for some reason
    // so this considers any non flying unit as ground.
    //
    // Also heroes are resistant too, so in case UNIT_TYPE_RESISTANT is used it will return true in case the
    // unit is a hero too.
    //
    function CS_IsUnitType takes unit u,unittype ut returns boolean
        if ( ut == UNIT_TYPE_GROUND ) then
            return not ( IsUnitType(u , UNIT_TYPE_FLYING) )
        elseif ( ut == UNIT_TYPE_RESISTANT ) then
            return IsUnitType(u , ut) or IsUnitType(u , UNIT_TYPE_HERO)
        endif
     return IsUnitType(u , ut)
    endfunction

    function GetDamageFactorByOptions takes unit hurter,unit target,integer d returns real
     local real r=1
     
        if ( d >= 8192 ) then
    	    set d = d - 8192
    	elseif ( d >= 4096 ) then
    	    if ( GetWidgetLife(target) > 0.405 ) then
    		    return 0.0
    		endif
    		set d = d - 4096
    	elseif ( GetWidgetLife(target) <= 0.405 ) then
            return 0.0
        endif

        if d >= 2048 then
            if IsUnitAlly(target , GetOwningPlayer(hurter)) then
                set r = r * cs_dopt_Ally_fc
            endif
            set d = d - 2048
        endif
        if d >= 1024 then
            if CS_IsUnitType(target , cs_dopt_IgnoreUtype) then
                return 0.0
            endif
            set d = d - 1024
        endif
        if d >= 512 then
            if GetUnitAbilityLevel(target , cs_dopt_dfab1) > 0 then
                set r = r * cs_dopt_dfab1_fc
            endif
            set d = d - 512
        endif
        if d >= 256 then
            if GetUnitAbilityLevel(target , cs_dopt_dfab2) > 0 then
                set r = r * cs_dopt_dfab2_fc
            endif
            set d = d - 256
        endif
        if d >= 128 then
            if GetUnitAbilityLevel(target , cs_dopt_dfab3) > 0 then
                set r = r * cs_dopt_dfab3_fc
            endif
            set d = d - 128
        endif
        if d >= 64 then
            if ( cs_dopt_EnemyAlly == 0 ) and IsUnitAlly(target , GetOwningPlayer(hurter)) then
                return 0.0
            elseif ( cs_dopt_EnemyAlly == 2 ) and IsUnitEnemy(target , GetOwningPlayer(hurter)) then
                return 0.0
            endif
            set d = d - 64
        endif
        if d >= 32 then
            set d = d - 32
            if not IsUnitVisible(target , GetOwningPlayer(hurter)) then
                return 0.0
            endif
        endif
        if d >= 16 then
            set d = d - 16
        endif
        if d >= 8 then
            set d = d - 8
            if hurter == target then
                return 0.0
            endif
        endif
        if d >= 4 then
            set d = d - 4
            if not CS_IsUnitType(target , cs_dopt_OnlyUtype) then
                return 0.0
            endif
        endif
        if d >= 2 then
            set d = d - 2
            if CS_IsUnitType(target , cs_dopt_ExceptionUtype) then
                set r = r * cs_dopt_ExceptionFct
            endif
        endif
        if d >= 1 then
            set d = d - 1
            set r = r * GetDamageFactor(target , cs_dopt_Atype , cs_dopt_Dtype)
        endif
     return r
    endfunction

    //======================================================================================================================
    // This used to be needed because in 1.17 UnitDamageTarget didn't consider the damagetype argument, this bug
    // was fixed in 1.18, and we no longer need this function, left for compatibility.
    //
    function DamageUnitByTypes takes unit hurter,unit target,real dmg,attacktype attT,damagetype dmgT returns boolean
        return UnitDamageTarget(hurter , target , dmg , true , false , attT , dmgT , null)
    endfunction

    //=============================================================================================================================
    function DamageUnitByOptions takes unit hurter,unit target,real dmg,integer DamageOptions returns boolean
     local real f=GetDamageFactorByOptions(hurter , target , DamageOptions)
        if ( f == 0 ) then
            return false
        endif
     return UnitDamageTarget(hurter , target , dmg * f , true , false , null , null , null)
    endfunction

    //=============================================================================================================================
    function DamageUnit takes player hurter,real damage,unit victim returns boolean
        call SetUnitX(cs_dmg_caster , GetUnitX(victim))
        call SetUnitY(cs_dmg_caster , GetUnitY(victim))

        call SetUnitOwner(cs_dmg_caster , hurter , false)
call UnitDamageTarget((cs_dmg_caster ) , ( victim ) , (( damage )*1.0) , true , false , ( cs_DefaultAttackType ) , ( cs_DefaultDamageType) , null) // INLINED!!
        call SetUnitOwner(cs_dmg_caster , Player(15) , false)

     return GetWidgetLife(victim) <= 0 // I thought UnitDamageTarget returned true when it killed the unit, but nope, it returns true when it was able to do the damage.
    endfunction

    //====================================================================================================================================================================
    function UnitDamageUnitTimed_Child takes nothing returns nothing
     local real damage= udg_castervars[0]
     local real damageperiod= udg_castervars[2]
     local effect fx=bj_lastCreatedEffect
     local timer t=NewTimer()
     local unit hurter=udg_currenthurter
     local real next=0
     local integer i=0
     local real c
     local unit target=udg_currentcaster
     local damagetype dmgT=ConvertDamageType(R2I(udg_castervars[4]))
     local attacktype attT=ConvertAttackType(R2I(udg_castervars[3]))

        call TimerStart(t , udg_castervars[1] - 0.01 , false , null)
        loop
            if TimerGetElapsed(t) >= next then
                exitwhen not UnitDamageTarget(hurter , target , damage , true , false , attT , dmgT , null)
                exitwhen GetWidgetLife(target) <= 0.405
                set i = i + 1
                set next = i * damageperiod
            endif
            exitwhen ( TimerGetRemaining(t) <= 0 ) or GetWidgetLife(target) <= 0.405
            call TriggerSleepAction(0)
        endloop
     call DestroyEffect(fx)
     call ReleaseTimer(t)
     set fx = null
     set dmgT = null
     set attT = null
    endfunction

    function UnitDamageUnitTimed takes unit hurter,real damageps,real damageperiod,real duration,unit target,string modelpath,string attachPointName,attacktype attT,damagetype dmgT returns nothing
     local unit c=udg_currentcaster
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , target , attachPointName)
        set udg_currentcaster = target
        set udg_castervars[0]=damageps
        set udg_castervars[1]=duration
        set udg_castervars[2]=damageperiod
        set udg_castervars[3]=(GetHandleId((attT))) // INLINED!!
        set udg_castervars[4]=(GetHandleId((dmgT))) // INLINED!!
        set udg_currenthurter = hurter
        call ExecuteFunc("UnitDamageUnitTimed_Child")
        set udg_currentcaster = c
     set c = null
    endfunction

    //=============================================================================================================
    // Left for compatibility
    //
    function DamageUnitTimedEx_Child takes nothing returns nothing
     local real damage= udg_castervars[0]
     local real damageperiod= udg_castervars[2]
     local effect fx=bj_lastCreatedEffect
     local timer t=NewTimer()
     local integer id=udg_currentabi
     local real next=0
     local integer i=0
     local real c
     local unit target=udg_currentcaster
        call TimerStart(t , udg_castervars[1] - 0.01 , false , null)
        loop
            if TimerGetElapsed(t) >= next then
                exitwhen DamageUnit(Player(id) , damage , target)
                set i = i + 1
                set next = i * damageperiod
            endif
            exitwhen ( TimerGetRemaining(t) <= 0 ) or GetWidgetLife(target) <= 0.405
            call TriggerSleepAction(0)
        endloop
     call DestroyEffect(fx)
     call ReleaseTimer(t)
     set fx = null
    endfunction

    function DamageUnitTimedEx takes player owner,real damageps,real damageperiod,real duration,unit target,string modelpath,string attachPointName returns nothing
     local unit c=udg_currentcaster
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , target , attachPointName)
        set udg_currentcaster = target
        set udg_castervars[0]=damageps
        set udg_castervars[1]=duration
        set udg_castervars[2]=damageperiod
        set udg_currentabi = GetPlayerId(owner)
        call ExecuteFunc("DamageUnitTimedEx_Child")
        set udg_currentcaster = c
     set c = null
    endfunction

    function DamageUnitTimed takes player owner,real damageps,real duration,unit target,string modelpath,string attachPointName returns nothing
        call DamageUnitTimedEx(owner , damageps , 1 , duration , target , modelpath , attachPointName)
    endfunction

    //[

    // integer k used to point to a table in gamecache, this is the reason I am not using dostruct directly
    // the evil backwards compatibility... You shall find out why OOP guys like encapsullation so much...
    //
    // It's fun, it was first an integer pointing to a mission in gamecache, then it was a dynamic array
    // and now it is a struct... so much history.
    function SetDamageOptions_i takes integer k,integer DamageOptions returns nothing
     local integer d=DamageOptions
        set s__CasterSystem___dostruct_value[(k)]=d
    	if ( d >= 8192 ) then
            set d = d - 8192
    	endif
    	if ( d >= 4096 ) then
            set d = d - 4096
    	endif
    	
        if d >= 2048 then
            set s__CasterSystem___dostruct_ally_fc[(k)]=cs_dopt_Ally_fc
            set d = d - 2048
        endif
        if d >= 1024 then
            set s__CasterSystem___dostruct_ign[(k)]=cs_dopt_IgnoreUtype
            set d = d - 1024
        endif
        if d >= 512 then
            set s__CasterSystem___dostruct_dfab3[(k)]=cs_dopt_dfab3
            set s__CasterSystem___dostruct_dfab3_fc[(k)]=cs_dopt_dfab3_fc
            set d = d - 512
        endif
        if d >= 256 then
            set s__CasterSystem___dostruct_dfab2[(k)]=cs_dopt_dfab2
            set s__CasterSystem___dostruct_dfab2_fc[(k)]=cs_dopt_dfab2_fc
            set d = d - 256
        endif
        if d >= 128 then
            set s__CasterSystem___dostruct_dfab1[(k)]=cs_dopt_dfab1
            set s__CasterSystem___dostruct_dfab1_fc[(k)]=cs_dopt_dfab1_fc
            set d = d - 128
        endif
    //[0 integer value][1 integer attT][2 integer dmgT][3 integer excp][4 real excf][5 integer only]
    //[6 integer allied][7 integer ab1][8 real fc1][9 integer ab2][10 real fc2][11 integer ab3][12 real fc3]
    //[13 integer ign][14 real allf]

        if d >= 64 then
            set d = d - 64
            set s__CasterSystem___dostruct_allied[(k)]=cs_dopt_EnemyAlly //[6=allied]
        endif
        if d >= 32 then
            set d = d - 32
        endif
        if d >= 16 then
            set d = d - 16
        endif
        if d >= 8 then
            set d = d - 8
        endif
        if d >= 4 then
            set s__CasterSystem___dostruct_only[(k)]=cs_dopt_OnlyUtype
            set d = d - 4
        endif
        if d >= 2 then
            set s__CasterSystem___dostruct_excp[(k)]=cs_dopt_ExceptionUtype
            set s__CasterSystem___dostruct_excf[(k)]=cs_dopt_ExceptionFct
            set d = d - 2
        endif
        if d >= 1 then
            set s__CasterSystem___dostruct_attt[(k)]=cs_dopt_Atype
            set s__CasterSystem___dostruct_dmgt[(k)]=cs_dopt_Dtype
        endif
    endfunction


    // inline friendly:)
    function SetDamageOptions takes integer id,integer DamageOptions returns nothing
        call SetDamageOptions_i(id , DamageOptions)
    endfunction

    function CreateDamageOptions takes integer DamageOptions returns integer
     local integer n=(s__CasterSystem___dostruct__allocate())

        call SetDamageOptions_i(n , DamageOptions)

     return n
    endfunction

    function DestroyDamageOptions takes integer id returns nothing
        call s__CasterSystem___dostruct_destroy((id))
    endfunction

    function LoadDamageOptions takes integer id returns integer
     local integer opt=s__CasterSystem___dostruct_value[(id)]
     local integer v=opt

        if v >= 8192 then
    	    set v = v - 8192
    	endif
        if v >= 4096 then
    	    set v = v - 4096
    	endif
        if v >= 2048 then
            set cs_dopt_Ally_fc = s__CasterSystem___dostruct_ally_fc[(id)]
            set v = v - 2028
        endif
        if v >= 1024 then
            set cs_dopt_IgnoreUtype = s__CasterSystem___dostruct_ign[(id)]
            set v = v - 1024
        endif
        if v >= 512 then
            set cs_dopt_dfab3 = s__CasterSystem___dostruct_dfab3[(id)]
            set cs_dopt_dfab3_fc = s__CasterSystem___dostruct_dfab3_fc[(id)]
            set v = v - 512
        endif
        if v >= 256 then
            set cs_dopt_dfab2 = s__CasterSystem___dostruct_dfab2[(id)]
            set cs_dopt_dfab2_fc = s__CasterSystem___dostruct_dfab2_fc[(id)]
            set v = v - 256
        endif
        if v >= 128 then
            set cs_dopt_dfab1 = s__CasterSystem___dostruct_dfab1[(id)]
            set cs_dopt_dfab1_fc = s__CasterSystem___dostruct_dfab1_fc[(id)]
            set v = v - 128
        endif
        if v >= 64 then
            set v = v - 64
            set cs_dopt_EnemyAlly = s__CasterSystem___dostruct_allied[(id)]
        endif
        if v >= 32 then
            set v = v - 32
        endif
        if v >= 16 then
            set v = v - 16
        endif
        if v >= 8 then
            set v = v - 8
        endif
        if v >= 4 then
            set cs_dopt_OnlyUtype = s__CasterSystem___dostruct_only[(id)]
            set v = v - 4
        endif
        if v >= 2 then
            set cs_dopt_ExceptionUtype = s__CasterSystem___dostruct_excp[(id)]
            set cs_dopt_ExceptionFct = s__CasterSystem___dostruct_excf[(id)]
            set v = v - 2
        endif
        if v >= 1 then
            set cs_dopt_Atype = s__CasterSystem___dostruct_attt[(id)]
            set cs_dopt_Dtype = s__CasterSystem___dostruct_dmgt[(id)]
        endif

     return opt
    endfunction

    //==================================================================================================
    function IsDestructableTree_withcs takes destructable d returns boolean

     local boolean b
     local boolean i=IsDestructableInvulnerable(d)

        call SetUnitX(cs_dmg_caster , GetWidgetX(d))
        call SetUnitY(cs_dmg_caster , GetWidgetY(d))

        if i then
            call SetDestructableInvulnerable(d , false)
        endif
        call UnitAddAbility(cs_dmg_caster , cs_DamageTreeDetectorId)

        set b = ( IssueTargetOrder(cs_dmg_caster , "eattree" , d) )
        call UnitRemoveAbility(cs_dmg_caster , cs_DamageTreeDetectorId)

        if i then
            call SetDestructableInvulnerable(d , true)
        endif
     return b
    endfunction

    function IsDestructableTree takes destructable d returns boolean
     local string k=I2S(GetDestructableTypeId(d))
     local boolean b

        if HaveStoredBoolean(cs_cache , "trees" , k) then
            set b = GetStoredBoolean(cs_cache , "trees" , k)
            return b
        else
            set b = IsDestructableTree_withcs(d)
            call StoreBoolean(cs_cache , "trees" , k , b)
        endif
     return b
    endfunction

    //===============================================================================================
    function DamageDestructablesInCircleEnum takes nothing returns nothing
     local destructable d=GetEnumDestructable()
     local unit u=udg_currentcaster
        if ( GetWidgetLife(d) > 0 ) and not ( IsDestructableInvulnerable(d) ) and ( ( Pow(GetDestructableX(d) - udg_castervars[200] , 2) + Pow(GetDestructableY(d) - udg_castervars[201] , 2) ) <= udg_castervars[202] ) then
            call SetWidgetLife(d , GetWidgetLife(d) - udg_castervars[203])
        endif
     set udg_currentcaster = u
     set u = null
     set d = null
    endfunction

    function DamageDestructablesInCircle takes real x,real y,real radius,real dmg returns nothing
     local rect r=Rect(x - radius , y - radius , x + radius , y + radius)
        set udg_castervars[200]=x
        set udg_castervars[201]=y
        set udg_castervars[202]=radius * radius
        set udg_castervars[203]=dmg
        call EnumDestructablesInRect(r , null , function DamageDestructablesInCircleEnum)
     call RemoveRect(r)
     set r = null
    endfunction

    function DamageDestructablesInCircleLoc takes location loc,real radius,real dmg returns nothing
        call DamageDestructablesInCircle(GetLocationX(loc) , GetLocationY(loc) , radius , dmg)
    endfunction

    function DamageTreesInCircleEnum takes nothing returns nothing
     local destructable d=GetEnumDestructable()
        if ( GetWidgetLife(d) > 0 ) and not ( IsDestructableInvulnerable(d) ) and ( ( Pow(GetDestructableX(d) - udg_castervars[200] , 2) + Pow(GetDestructableY(d) - udg_castervars[201] , 2) ) <= udg_castervars[202] ) and ( IsDestructableTree(d) ) then
            call KillDestructable(d)
        endif
     set d = null
    endfunction

    function DamageTreesInCircle takes real x,real y,real radius returns nothing
     local rect r=Rect(x - radius , y - radius , x + radius , y + radius)
        set udg_castervars[200]=x
        set udg_castervars[201]=y
        set udg_castervars[202]=radius * radius
        call EnumDestructablesInRect(r , null , function DamageTreesInCircleEnum)
     call RemoveRect(r)
     set r = null
    endfunction

    function DamageTreesInCircleLoc takes location loc,real radius returns nothing
        call DamageTreesInCircle(GetLocationX(loc) , GetLocationY(loc) , radius)
    endfunction

    function DamageUnitGroupEx takes unit hurter,real damage,group targetgroup,integer DamageOptions returns nothing
     local group affected
     local unit p
        if bj_wantDestroyGroup then
            set bj_wantDestroyGroup = false
            set affected = targetgroup
        else
            set affected = NewGroup()
            call GroupAddGroup(targetgroup , affected)
        endif
        loop
            set p = FirstOfGroup(affected)
            exitwhen p == null
            call DamageUnitByOptions(hurter , p , damage , DamageOptions)
            call GroupRemoveUnit(affected , p)
        endloop
     call ReleaseGroup(affected)
     set affected = null
     set p = null
    endfunction

    function DamageUnitsInAOEEx takes unit hurter,real damage,real x,real y,real radius,boolean affectallied,integer DamageOptions returns nothing
     local boolexpr b=null
     local group aoe=NewGroup()
     local integer d=DamageOptions
        set bj_groupEnumOwningPlayer = GetOwningPlayer(hurter)
        if d >= 8192 then
            set d = d - 8192
        endif
        if d >= 4096 then
            set d = d - 4096
        endif

        if d >= 2048 then
            set d = d - 2048
        endif
        if d >= 1024 then
            set d = d - 1024
        endif
        if d >= 512 then
            set d = d - 512
        endif
        if d >= 256 then
            set d = d - 256
        endif
        if d >= 128 then
            set d = d - 128
        endif
        if d >= 64 then
            if ( cs_dopt_EnemyAlly == 2 ) then
                set b = Condition(function CasterAOE_IsFilterAlly)
            elseif ( cs_dopt_EnemyAlly == 1 ) then
            else
                set b = Condition(function CasterAOE_IsFilterEnemy)
            endif
            set d = d - 64
        elseif not ( affectallied ) then
            set b = Condition(function CasterAOE_IsFilterEnemy)
        endif
        if d >= 32 then
            set d = d - 32
        endif
        if d >= 16 then
            call DamageTreesInCircle(x , y , radius)
        endif
        call CS_EnumUnitsInAOE(aoe , x , y , radius , b)
        set bj_wantDestroyGroup = true
        call DamageUnitGroupEx(hurter , damage , aoe , DamageOptions)
        //call DestroyBoolExpr(b)
     set b = null
     set aoe = null
    endfunction

    function DamageUnitsInAOEExLoc takes unit hurter,real damage,location loc,real radius,boolean affectallied,integer DamageOptions returns nothing
        call DamageUnitsInAOEEx(hurter , damage , GetLocationX(loc) , GetLocationY(loc) , radius , affectallied , DamageOptions)
    endfunction

    function DamageUnitGroup takes player hurter,real damage,group targetgroup returns nothing
        call SetUnitOwner(cs_dmg_caster , hurter , false)
        call DamageUnitGroupEx(cs_dmg_caster , damage , targetgroup , 0)
        call SetUnitOwner(cs_dmg_caster , Player(15) , false)
    endfunction

    //====================================================================================================================================================================
    function DamageUnitsInAOE takes player hurter,real damage,real x,real y,real radius,boolean affectallied returns nothing
        call SetUnitOwner(cs_dmg_caster , hurter , false)
        call DamageUnitsInAOEEx(cs_dmg_caster , damage , x , y , radius , affectallied , 0)
        call SetUnitOwner(cs_dmg_caster , Player(15) , false)
    endfunction

    function DamageUnitsInAOELoc takes player hurter,real damage,location loc,real radius,boolean affectallied returns nothing
        call DamageUnitsInAOE(hurter , damage , GetLocationX(loc) , GetLocationY(loc) , radius , affectallied)
    endfunction

    //====================================================================================================================================================================
    function AddAreaDamagerForUnit_Child takes nothing returns nothing
     local real D
     local real damageps= udg_castervars[0]
     local real area= udg_castervars[2]
     local real damageperiod= udg_castervars[3]
     local real excd=udg_castervars[8]
     local boolean affectallies= ( udg_castervars[4] >= 1 )
     local boolean onlyallies= ( udg_castervars[4] == 2 )
     local boolean self= ( udg_castervars[5] == 1 )
     local unit hurter=udg_currenthurter
     local unit fire= udg_currentcaster
     local player owner= GetOwningPlayer(fire)
     local timer t= NewTimer()
     local real next= 0
     local integer a= 0
     local group inrange= NewGroup()
     local string c
     local string art=bj_lastPlayedMusic
     local string attach=""
     local unit picked
     local boolean recicled=false
     local unittype only=null
     local unittype ign=null
     local unittype exce=null
     local attacktype attT
     local damagetype dmgT
     local boolean trees=( udg_castervars[11] == 1 )
     local boolean inv=( udg_castervars[12] == 1 )
     local integer a1=0
     local integer a2=0
     local integer a3=0
     local real f1=cs_dopt_dfab1_fc
     local real f2=cs_dopt_dfab2_fc
     local real f3=cs_dopt_dfab3_fc
     local real allf=udg_castervars[113]
     local effect array fx
     local integer deadcond=R2I(udg_castervars[114])
     local boolean deadeval=false
     local integer fxn=0
        set fx[0]=bj_lastCreatedEffect

        if f1 != 1 then
            set a1 = cs_dopt_dfab1
        endif
        if f2 != 1 then
            set a2 = cs_dopt_dfab2
        endif
        if f3 != 1 then
            set a3 = cs_dopt_dfab3
        endif
        if udg_castervars[112] != - 1 then
            set ign = ConvertUnitType(R2I(udg_castervars[112]))
        endif
        if udg_castervars[6] != - 1 then
            set only = ConvertUnitType(R2I(udg_castervars[6]))
        endif
        if udg_castervars[7] != - 1 then
            set exce = ConvertUnitType(R2I(udg_castervars[7]))
        endif
        if udg_castervars[9] != - 1 then
            set attT = ConvertAttackType(R2I(udg_castervars[9]))
        else
            set attT = cs_DefaultAttackType
        endif
        if udg_castervars[10] != - 1 then
            set dmgT = ConvertDamageType(R2I(udg_castervars[10]))
        else
            set dmgT = cs_DefaultDamageType
        endif
        loop
            set c = SubString(art , a , a + 1)
            exitwhen c == "!" or c == ""
            set attach = attach + c
            set a = a + 1
        endloop
        set art = SubString(art , a + 1 , 10000)
        call TimerStart(t , udg_castervars[1] - 0.01 , false , null)
        set a = 0
        loop
            loop
                exitwhen fxn <= 0
                call DestroyEffect(fx[fxn])
                set fx[fxn]=null
                set fxn = fxn - 1
            endloop
            if IsUnitInGroup(fire , udg_casters) then
                set recicled = true
                call GroupRemoveUnit(udg_casters , fire)
            endif
            exitwhen recicled
            if TimerGetElapsed(t) >= next then
                set a = a + 1
                set next = a * damageperiod
                call CS_EnumUnitsInAOE(inrange , GetUnitX(fire) , GetUnitY(fire) , area , null)
                if trees then
                    call DamageTreesInCircle(GetUnitX(fire) , GetUnitY(fire) , area)
                endif
                loop
                    set picked = FirstOfGroup(inrange)
                    exitwhen picked == null
    				if ( deadcond == 0 ) then
    				    set deadeval = ( GetWidgetLife(picked) > 0.405 )
    				elseif ( deadcond == 1 ) then
    				    set deadeval = ( GetWidgetLife(picked) <= 0.405 )
    				else
    				    set deadeval = true
    				endif
                    if ( self or picked != hurter ) and not ( GetWidgetLife(picked) <= 0.405 ) and ( ( ( affectallies or onlyallies ) and IsUnitAlly(picked , owner) ) or ( not ( onlyallies ) and IsUnitEnemy(picked , owner) ) ) and ( only == null or CS_IsUnitType(picked , only) ) and ( ign == null or not ( CS_IsUnitType(picked , ign) ) ) then
                        set D = damageps
                        if ( allf != 1 ) and IsUnitAlly(picked , owner) then
                            set D = D * allf
                        endif
                        if ( exce != null ) and CS_IsUnitType(picked , exce) then
                            set D = D * excd
                        endif
                        if inv and not ( IsUnitVisible(picked , owner) ) then
                            set D = 0
                        endif
                        if ( a1 != 0 ) and ( GetUnitAbilityLevel(picked , a1) > 0 ) then
                            set D = D * f1
                        endif
                        if ( a2 != 0 ) and ( GetUnitAbilityLevel(picked , a2) > 0 ) then
                            set D = D * f2
                        endif
                        if ( a3 != 0 ) and ( GetUnitAbilityLevel(picked , a3) > 0 ) then
                            set D = D * f3
                        endif
                        if D != 0 then
call UnitDamageTarget((hurter ) , ( picked ) , (( D )*1.0) , true , false , ( attT ) , ( dmgT) , null) // INLINED!!
                            if ( art != "" ) and ( art != null ) then
                                set fxn = fxn + 1
                                set fx[fxn]=AddSpecialEffectTarget(art , picked , attach)
                            endif
                        endif
                    endif
                    call GroupRemoveUnit(inrange , picked)
                endloop
            endif
            exitwhen TimerGetRemaining(t) <= 0
            call TriggerSleepAction(0)
        endloop
     call ReleaseGroup(inrange)
     call DestroyEffect(fx[0])
     call TriggerSleepAction(2)
     call RecycleCaster((fire)) // INLINED!!
     call ReleaseTimer(t)
     set inrange = null
     set fire = null
     set owner = null
     set fx[0]=null
     set picked = null
     set hurter = null
     set only = null
     set ign = null
     set exce = null
     set attT = null
     set dmgT = null
    endfunction

    function AddAreaDamagerForUnit takes unit hurter,string modelpath,string targetart,string targetattach,real x,real y,real damage,real damageperiod,real duration,real area,boolean affectallies,integer DamageOptions returns unit
     local string s=bj_lastPlayedMusic
     local integer v=DamageOptions
        set bj_lastPlayedMusic = targetattach + "!" + targetart
        set udg_currentcaster = GetACaster()
        call SetUnitPosition(udg_currentcaster , x , y)
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , udg_currentcaster , "origin")
        set udg_castervars[0]=damage
        set udg_castervars[1]=duration
        set udg_castervars[2]=area
        set udg_castervars[3]=damageperiod
    	
    	if ( v >= 8192 ) then
    	    set udg_castervars[114]=2
    		set v = v - 8192
    	elseif ( v >= 4096 ) then
    	    set udg_castervars[114]=1
    		set v = v - 4096
    	else
    	    set udg_castervars[114]=0
    	endif

        if v >= 2048 then
            set v = v - 2048
        else
            set udg_castervars[113]=1
        endif
        if v >= 1024 then
            set v = v - 1024
        else
            set udg_castervars[112]=- 1
        endif
        if v >= 512 then
            set v = v - 512
        else
            set udg_castervars[111]=0
        endif
        if v >= 256 then
            set v = v - 256
        else
            set udg_castervars[109]=0
        endif
        if v >= 128 then
            set v = v - 128
        else
            set udg_castervars[107]=0
        endif
        if v >= 64 then
            set v = v - 64
            set udg_castervars[4]=cs_dopt_EnemyAlly
        else
            set udg_castervars[4]=IntegerTertiaryOp(affectallies , 1 , 0)
        endif
        if v >= 32 then
            set udg_castervars[12]=1
            set v = v - 32
        else
            set udg_castervars[12]=0
        endif
        if v >= 16 then
            set udg_castervars[11]=1
            set v = v - 16
        else
            set udg_castervars[11]=0
        endif
        if v >= 8 then
            set udg_castervars[5]=0
            set v = v - 8
        else
            set udg_castervars[5]=1
        endif
        if v >= 4 then
            set udg_castervars[6]=(GetHandleId((cs_dopt_OnlyUtype))) // INLINED!!
            set v = v - 4
        else
            set udg_castervars[6]=- 1
        endif
        if v >= 2 then
            set udg_castervars[7]=(GetHandleId((cs_dopt_ExceptionUtype))) // INLINED!!
            set udg_castervars[8]=damage * cs_dopt_ExceptionFct
            set v = v - 2
        else
            set udg_castervars[7]=- 1
            set udg_castervars[8]=- 1
        endif
        if v >= 1 then
            set udg_castervars[9]=(GetHandleId((cs_dopt_Atype))) // INLINED!!
            set udg_castervars[10]=(GetHandleId((cs_dopt_Dtype))) // INLINED!!
        else
            set udg_castervars[9]=- 1
            set udg_castervars[10]=- 1
        endif
        set udg_currenthurter = hurter
        call SetUnitOwner(udg_currentcaster , GetOwningPlayer(hurter) , true)
        call ExecuteFunc("AddAreaDamagerForUnit_Child")
        set bj_lastPlayedMusic = s
     return udg_currentcaster
    endfunction

    function AddAreaDamagerForUnitLoc takes unit hurter,string modelpath,string targetart,string targetattach,location loc,real damage,real damageperiod,real duration,real area,boolean affectallies,integer DamageOptions returns unit
     return AddAreaDamagerForUnit(hurter , modelpath , targetart , targetattach , GetLocationX(loc) , GetLocationY(loc) , damage , damageperiod , duration , area , affectallies , DamageOptions)
    endfunction

    function AddDamagingEffectEx takes player owner,string modelpath,string targetart,string targetattach,real x,real y,real damage,real damageperiod,real duration,real area,boolean affectallies returns unit
     local string s=bj_lastPlayedMusic
        set bj_lastPlayedMusic = targetattach + "!" + targetart
        set udg_currentcaster = GetACaster()
        call SetUnitPosition(udg_currentcaster , x , y)
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , udg_currentcaster , "origin")
        set udg_castervars[0]=damage
        set udg_castervars[1]=duration
        set udg_castervars[2]=area
        set udg_castervars[3]=damageperiod
        set udg_castervars[4]=IntegerTertiaryOp(affectallies , 1 , 0)
        set udg_castervars[5]=1
        set udg_castervars[6]=- 1
        set udg_castervars[7]=- 1
        set udg_castervars[8]=- 1
        set udg_castervars[9]=- 1
        set udg_castervars[10]=- 1
        set udg_castervars[107]=0
        set udg_castervars[109]=0
        set udg_castervars[111]=0
        set udg_castervars[112]=- 1
        set udg_castervars[113]=1
        set udg_currenthurter = udg_currentcaster
        call SetUnitOwner(udg_currentcaster , owner , true)
        call ExecuteFunc("AddAreaDamagerForUnit_Child")
        set bj_lastPlayedMusic = s
     return udg_currentcaster
    endfunction

    function AddDamagingEffectExLoc takes player owner,string modelpath,string targetart,string targetattach,location loc,real damage,real damageperiod,real duration,real area,boolean affectallies returns unit
        return AddDamagingEffectEx(owner , modelpath , targetart , targetattach , GetLocationX(loc) , GetLocationY(loc) , damage , damageperiod , duration , area , affectallies)
    endfunction

    function AddDamagingEffect takes player owner,string modelpath,real x,real y,real damageps,real duration,real area,boolean affectallies returns unit
        return AddDamagingEffectEx(owner , modelpath , "" , "" , x , y , damageps , 1 , duration , area , affectallies)
    endfunction

    function AddDamagingEffectLoc takes player owner,string modelpath,location loc,real damageps,real duration,real area,boolean affectallies returns unit
        return AddDamagingEffectEx(owner , modelpath , "" , "" , GetLocationX(loc) , GetLocationY(loc) , damageps , 1 , duration , area , affectallies)
    endfunction

    //============================================================================================================
    function UnitMoveToAsProjectileAnySpeed_Move takes unit m,integer k returns boolean
     local boolean tounit= s__csprojectile_tounit[k]
     local unit tg
     local real x2
     local real y2
     local real z2
     local real x1=GetUnitX(m)
     local real y1=GetUnitY(m)
     local real z1=GetUnitFlyHeight(m)
     local real g
     local real d
     local real od
     local real v
     local real time
     local integer n
     local boolean done=false
     local effect fx

        if tounit then
            set tg = s__csprojectile_target[k]
            if ( GetWidgetLife(tg) <= 0.405 ) then
                set tounit = false
                set s__csprojectile_tounit[k]=false
            else
                set x2 = GetUnitX(tg)
                set y2 = GetUnitY(tg)
                set z2 = GetUnitFlyHeight(tg) + s__csprojectile_z2o[k]
                set n = s__csprojectile_N[k]
                if ( n == 0 ) then
                    //Using the counter prevents us to save z2,x2,y2 too much times and saves speed
                    set s__csprojectile_z2[k]=z2
                    set s__csprojectile_x2[k]=x2 // Backup stuff just in case
                    set s__csprojectile_y2[k]=y2
                elseif ( n == 25 ) then
                    set n = 0
                else
                    set n = n + 1
                endif
                set s__csprojectile_N[k]=n
            endif
            set tg = null
        endif

        if not ( tounit ) then
            set z2 = s__csprojectile_z2[k]
            set x2 = s__csprojectile_x2[k]
            set y2 = s__csprojectile_y2[k]
        endif

        set g = Atan2(y2 - y1 , x2 - x1)
        call SetUnitFacing(m , g * bj_RADTODEG)


        set v = s__csprojectile_speed[k]
        set d = v * cs_TIMER_CYCLE
        
        set od = SquareRoot(Pow(x1 - x2 , 2) + Pow(y1 - y2 , 2))
        if ( od <= d ) then
            call SetUnitX(m , x2)
            call SetUnitY(m , y2)
            set done = true
        else
            call SetUnitX(m , x1 + d * Cos(g))
            call SetUnitY(m , y1 + d * Sin(g))
        endif



        set g = s__csprojectile_acel[k]
        set time = od / v
        set d = v
        set v = ( z2 - z1 + 0.5 * g * time * time ) / time //z speed
        if ( GetUnitTypeId(m) == cs_CasterUnitId ) then
            call SetUnitAnimationByIndex(m , R2I(Atan2(v , d) * bj_RADTODEG) + 90) //Thanks infrane!
        endif
        call SetUnitFlyHeight(m , z1 + v * cs_TIMER_CYCLE , 0)
        set d = ( Pow(GetUnitX(m) - x2 , 2) + Pow(GetUnitY(m) - y2 , 2) )
        if ( done or ( d <= 400 ) ) then //So the actual distance is less than or equal to 20
            set done = true
            set s__csprojectile_done[k]=true
            set fx = s__csprojectile_fx[k]
            if ( fx != null ) then
                call SetUnitAnimationByIndex(m , 91)
                call DestroyEffect(fx)
                set fx = null
            endif
        endif
     return done
    endfunction










    function CollisionMissile_Destroyer takes unit m,integer k,trigger T returns nothing
     local trigger tr= T
     local triggeraction ta= s__cscollisionmissile_ac[k]

        if ( s__cscollisionmissile_fx[k] != null ) then
            call DestroyEffect(s__cscollisionmissile_fx[k])
        endif
        

        if ( s__cscollisionmissile_new[k] ) then
            call ExplodeUnitBJ(m)
        else
            call RecycleCasterAfterCastEx((m ) , (( 4 )*1.0) , ( 0 ) , ( true)) // INLINED!!
        endif
        
        call TriggerRemoveAction(tr , ta)
        //call TriggerRemoveAction(T,GetArrayTriggerAction(k,18)) //[18=triggeraction]
        
        call sc__csmissile_destroy(k)
        
        //call Hostage(CS_H2I(tr))
       
        call DestroyTrigger(tr)
        //call CleanAttachedVars(T)
        //call DestroyTrigger(T)

     set tr = null
     set ta = null

    endfunction



    function GetTriggerCollisionMissile takes nothing returns unit
        return s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))] // INLINED!!
    endfunction



    function CollisionMissile_Move takes unit m,integer k returns boolean
     local integer state= s__cscollisionmissile_state[k]
     local boolean done
     local real d
     local real F
     local real asp
     local real x
     local real nx
     local real y
     local real ny
     local integer tt
     local widget wd
     
     local trigger TTT

     
        if ( state == 2 ) then
            set TTT = s__cscollisionmissile_t[k]
            call TriggerExecute(TTT)
            set TTT = null
            set s__cscollisionmissile_state[k]=3
            return false
        elseif ( state == 3 ) then
             call CollisionMissile_Destroyer(m , k , s__cscollisionmissile_t[k])
             return true
        else
            if ( state == 1 ) then
                call TriggerRegisterUnitInRange(s__cscollisionmissile_t[k] , m , s__cscollisionmissile_collision[k] , null)
                set s__cscollisionmissile_state[k]=0
            endif
            set d = s__cscollisionmissile_speed[k] * cs_TIMER_CYCLE
            set F = s__cscollisionmissile_f[k]
            set asp = s__cscollisionmissile_aspeed[k]
            set x = GetUnitX(m)
            set y = GetUnitY(m)
            if ( asp != 0 ) then
                set tt = s__cscollisionmissile_ttype[k]
                if ( tt == s__cscollisionmissile_ttype_point ) or ( tt == s__cscollisionmissile_ttype_widget ) then
                    if ( tt == s__cscollisionmissile_ttype_point ) then
                        set nx = s__cscollisionmissile_tx[k]
                        set ny = s__cscollisionmissile_ty[k]
                        set F = Angles_MoveAngleTowardsAngle(F , Atan2(ny - y , nx - x) * bj_RADTODEG , asp * cs_TIMER_CYCLE)
                    else
                        set wd = s__cscollisionmissile_tw[k]
                        if ( GetWidgetLife(wd) <= 0.405 ) then
                            set s__cscollisionmissile_ttype[k]=s__cscollisionmissile_ttype_none
                            set nx = x + 0.001
                            set ny = y + 0.001
                            set F = F + asp * cs_TIMER_CYCLE
                        else
                            set nx = GetWidgetX(wd)
                            set ny = GetWidgetY(wd)
                            set F = Angles_MoveAngleTowardsAngle(F , Atan2(ny - y , nx - x) * bj_RADTODEG , asp * cs_TIMER_CYCLE)
                        endif
                       set wd = null
                    endif
                else
                    set F = F + asp * cs_TIMER_CYCLE
                endif
                set s__cscollisionmissile_f[k]=F
                call SetUnitFacing(m , F)
            endif
            set F = F * bj_DEGTORAD
            set nx = x + d * Cos(F)
            set ny = y + d * Sin(F)
            set d = s__cscollisionmissile_maxd[k] - d
            set s__cscollisionmissile_maxd[k]=d
            set done = ( d <= 0 )
            if ( not done ) then
                if not ( CS_MoveUnit(m , nx , ny) ) then
                    set done = true
                elseif ( s__cscollisionmissile_pfx[k] ) then
                    set F = s__cscollisionmissile_pfx_current[k] + cs_TIMER_CYCLE
                    if ( F >= s__cscollisionmissile_pfx_dur[k] ) then
                        call DestroyEffect(AddSpecialEffectTarget(s__cscollisionmissile_pfx_path[k] , m , "origin"))
                        set s__cscollisionmissile_pfx_current[k]=0.
                    else
                        set s__cscollisionmissile_pfx_current[k]=F
                    endif
                endif
            endif
        endif
        if done then
            call DisableTrigger(s__cscollisionmissile_t[k])
            call DestroyEffect(s__cscollisionmissile_fx[k])
            set s__cscollisionmissile_fx[k]=null
            set s__cscollisionmissile_state[k]=2
            return false
        endif
     return false
    endfunction

    function CasterSystemMovementTimer takes nothing returns nothing
     local timer ti
     local integer n=cs_missilecount
     local integer i=1
     local unit p

     local integer k


        loop
            exitwhen ( i > n )
            set k = cs_missiles[i]

                if ( s__csmissile_mtype[k] == cs_TYPE_COLLISIONMISSILE ) then
                
                    set p = s__csmissile_m[k]

                    if not ( CollisionMissile_Move(p , k) ) then
                        set i = i + 1
                    else
                        set cs_missiles[i]=cs_missiles[n]
                        set n = n - 1
                    endif
                elseif ( s__csmissile_mtype[k] == cs_TYPE_PROJECTILE ) then
                    set p = s__csmissile_m[k]
                    if not ( UnitMoveToAsProjectileAnySpeed_Move(p , k) ) then
                        set i = i + 1
                    else
                        set cs_missiles[i]=cs_missiles[n]
                        set n = n - 1
                    endif
                else
                    set i = i + 1
                    call BJDebugMsg("Caster System: Unexpected Error (1) Wrong Array:" + I2S(k) + " ; " + I2S(s__csmissile_mtype[k]))
                endif

        endloop

        if ( n == 0 ) then
            call PauseTimer(cs_movementtimer)
            set cs_movementtimer_active = false
        endif
        set cs_missilecount = n
        
     set p = null
    endfunction
    





    function UnitMoveToAsProjectileAnySpeed_Effect takes unit m,effect fx,real speed,real arc,real x2,real y2,unit target,real z2 returns nothing
    //
    //   The internal projectile system used by all the projectile functions
    //
     local timer t


     local string km
     local integer k

        set km = I2S((GetHandleId((m)))) // INLINED!!
        set k = (GetStoredInteger(cs_cache , ("MOVEMENT_TABLES" ) , ( km))) // INLINED!!
        if ( k > 0 ) then
            set s__csprojectile_done[k]=true
        endif
        set k = s__csprojectile__allocate()
        set s__csmissile_m[k]=m

        call StoreInteger(cs_cache , "MOVEMENT_TABLES" , km , k)
     

        set cs_missilecount = cs_missilecount + 1
        set cs_missiles[cs_missilecount]=k
        
        if ( not cs_movementtimer_active ) then
            call TimerStart(cs_movementtimer , cs_TIMER_CYCLE , true , function CasterSystemMovementTimer)
            set cs_movementtimer_active = true
        endif

        set s__csmissile_mtype[k]=cs_TYPE_PROJECTILE

        if ( target != null ) then
            set s__csprojectile_tounit[k]=true
            set s__csprojectile_target[k]=target
            set s__csprojectile_x2[k]=GetUnitX(target)
            set s__csprojectile_y2[k]=GetUnitY(target)
            set s__csprojectile_z2o[k]=z2
        else
            set s__csprojectile_tounit[k]=false
            set s__csprojectile_x2[k]=x2
            set s__csprojectile_y2[k]=y2
        endif

        set s__csprojectile_z2[k]=z2
        set s__csprojectile_speed[k]=speed

        set s__csprojectile_acel[k]=arc * 8000
        if ( fx != null ) then
            set s__csprojectile_fx[k]=fx
           set fx = null
        endif
        loop
            exitwhen s__csprojectile_done[k]
            call TriggerSleepAction(0)
        endloop
        call FlushStoredInteger(cs_cache , "MOVEMENT_TABLES" , km)
        call sc__csmissile_destroy(k)

    endfunction

    function UnitMoveToAsProjectileAnySpeed takes unit m,real speed,real arc,real x2,real y2,unit target,real z2 returns nothing
    //Left for compat
        call UnitMoveToAsProjectileAnySpeed_Effect(m , null , speed , arc , x2 , y2 , target , z2)
    endfunction


    //========================================================================================================================
    function UnitMoveToAsProjectileGen takes unit m,real arc,real x2,real y2,unit target,real z2 returns nothing
    //
    //   The internal projectile system used by all the projectile functions
    //
     local real x1=GetUnitX(m)
     local real y1=GetUnitY(m)
     local real acel=arc * 1600
     local real speed=GetUnitMoveSpeed(m)
     local real z1=GetUnitFlyHeight(m)
     local real d
     local real d1
     local real d2
     local real t
     local real vel
     local real dif=0
     local boolean tounit= ( target != null )
     local boolean b=false
     local boolean mode=false
        if tounit then
            set x2 = GetUnitX(target)
            set y2 = GetUnitY(target)
            set z2 = GetUnitFlyHeight(target) + z2
        endif
        set mode = ( z2 > z1 )
        set d = SquareRoot(Pow(x2 - x1 , 2) + Pow(y2 - y1 , 2))
        set d1 = 1000000
        set d2 = 0
        set t = d / speed
        if t == 0 then
            set t = 0.001
        endif
        set vel = ( z2 - z1 + 0.5 * acel * t * t ) / t
        call SetUnitFacing(m , Atan2BJ(y2 - y1 , x2 - x2))
        call IssuePointOrder(m , "move" , x2 , y2)
        set t = 0
        loop
            set d2 = d1
            if tounit then
                if ( GetWidgetLife(target) <= 0.405 ) then
                    set tounit = false
                else
                    set x2 = GetUnitX(target)
                    set y2 = GetUnitY(target)
                endif
            endif
            set d1 = SquareRoot(Pow(x2 - GetUnitX(m) , 2) + Pow(y2 - GetUnitY(m) , 2))
            exitwhen b or d1 == 0
            set b = ( d1 <= speed * ( t - dif ) )
            exitwhen ( mode and b ) or ( GetUnitCurrentOrder(m) != OrderId("move") )
            if tounit then
                call IssuePointOrder(m , "move" , x2 , y2)
            endif
            set dif = t
            if dif == 0.001 then
               set t = 0.1
            else
                set t = ( d - d1 ) / speed
            endif
            set t = 2 * t - dif
            call SetUnitFlyHeight(m , z1 + ( vel * t - 0.5 * acel * t * t ) , RAbsBJ(vel - acel * ( t + dif ) / 2))
            set t = ( t + dif ) / 2
            call TriggerSleepAction(0)
        endloop
        if tounit then
            set x2 = GetUnitX(target)
            set y2 = GetUnitY(target)
        endif
        call SetUnitFlyHeight(m , z2 , 0)
        call SetUnitX(m , x2)
        call SetUnitY(m , y2)
    endfunction

    function UnitMoveToAsProjectile takes unit m,real arc,real x2,real y2,real z2 returns nothing
        call UnitMoveToAsProjectileGen(m , arc , x2 , y2 , null , z2)
    endfunction

    //============================================================================================================
    function ProjectileLaunchEx takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns nothing
     local unit m=CreateCaster(Atan2BJ(y2 - y1 , x2 - x1) , x1 , y1)
     local effect fx=null

        call SetUnitScale(m , scale , scale , scale)
        call SetUnitVertexColor(m , red , green , blue , alpha)

        call SetUnitFlyHeight(m , z1 , 0)
        set fx = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , owner , true)

        if ( speed <= 522 ) then
            call SetUnitMoveSpeed(m , speed)
            call UnitMoveToAsProjectileGen((m ) , (( arc )*1.0) , (( x2 )*1.0) , (( y2 )*1.0) , null , (( z2)*1.0)) // INLINED!!
            call DestroyEffect(fx)
        else
            call UnitMoveToAsProjectileAnySpeed_Effect(m , fx , speed , arc , x2 , y2 , null , z2)
        endif
        call ExplodeUnitBJ(m)
     set owner = null
     set fx = null
     set m = null
    endfunction

    function ProjectileLaunchExLoc takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,location loc1,real z1,location loc2,real z2 returns nothing
        call ProjectileLaunchEx(owner , modelpath , scale , red , green , blue , alpha , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , GetLocationX(loc2) , GetLocationY(loc2) , z2)
    endfunction

    //============================================================================================================
    function ProjectileLaunch takes string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns nothing
        call ProjectileLaunchEx(Player(15) , modelpath , 1 , 255 , 255 , 255 , 255 , speed , arc , x1 , y1 , z1 , x2 , y2 , z2)
    endfunction

    function ProjectileLaunchLoc takes string modelpath,real speed,real arc,location loc1,real z1,location loc2,real z2 returns nothing
        call ProjectileLaunchExLoc(Player(15) , modelpath , 1 , 255 , 255 , 255 , 255 , speed , arc , loc1 , z1 , loc2 , z2)
    endfunction

    //============================================================================================================
    function DamagingProjectileLaunchAOE_Child takes nothing returns nothing
     local unit m=udg_currentcaster
     local effect fx=bj_lastCreatedEffect
     local real x2=udg_castervars[0]
     local real y2=udg_castervars[1]
     local real aoeradius=udg_castervars[3]
     local real damage=udg_castervars[4]
     local boolean affectallied=bj_isUnitGroupInRectResult
     local integer V=CreateDamageOptions(R2I(udg_castervars[5]))
     local unit hurter=udg_currenthurter
     local real speed=udg_castervars[6]
        if ( speed <= 522 ) then
            call SetUnitMoveSpeed(m , speed)
            call UnitMoveToAsProjectileGen((m ) , (( bj_meleeNearestMineDist )*1.0) , (( udg_castervars[0] )*1.0) , (( udg_castervars[1] )*1.0) , null , (( udg_castervars[2])*1.0)) // INLINED!!
            call DestroyEffect(fx)
        else
            call UnitMoveToAsProjectileAnySpeed_Effect(m , fx , speed , bj_meleeNearestMineDist , udg_castervars[0] , udg_castervars[1] , null , udg_castervars[2])
        endif

        call DamageUnitsInAOEEx(hurter , damage , x2 , y2 , aoeradius , affectallied , LoadDamageOptions(V))
        call s__CasterSystem___dostruct_destroy(((V))) // INLINED!!
        call ExplodeUnitBJ(m)
     set m = null
     set fx = null
    endfunction

    function DamagingProjectileLaunchAOE takes unit hurter,string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2,real aoeradius,real damage,boolean affectallied,integer DamageOptions returns unit
     local unit m=CreateCaster(Atan2BJ(y2 - y1 , x2 - x1) , x1 , y1)

        call SetUnitFlyHeight(m , z1 , 0)
        set udg_currentcaster = m
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , GetOwningPlayer(hurter) , true)
        set bj_meleeNearestMineDist = arc
        set udg_castervars[0]=x2
        set udg_castervars[1]=y2
        set udg_castervars[2]=z2
        set udg_castervars[3]=aoeradius
        set udg_castervars[4]=damage
        set udg_castervars[5]=DamageOptions
        set udg_castervars[6]=speed
        set udg_currenthurter = hurter
        set bj_isUnitGroupInRectResult = affectallied
        call ExecuteFunc("DamagingProjectileLaunchAOE_Child")
     set m = null
     return udg_currentcaster
    endfunction

    function DamagingProjectileLaunchAOELoc takes unit hurter,string modelpath,real speed,real arc,location loc1,real z1,location loc2,real z2,real aoeradius,real damage,boolean affectallied,integer DamageOptions returns unit
        return DamagingProjectileLaunchAOE(hurter , modelpath , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , GetLocationX(loc2) , GetLocationY(loc2) , z2 , aoeradius , damage , affectallied , DamageOptions)
    endfunction

    function ProjectileLaunchDamage takes player owner,string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2,real aoeradius,real damage,boolean affectallied returns unit
     local unit m=CreateCaster(Atan2BJ(y2 - y1 , x2 - x1) , x1 , y1)

        call SetUnitFlyHeight(m , z1 , 0)
        set udg_currentcaster = m
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , owner , true)
        set bj_meleeNearestMineDist = arc
        set udg_castervars[0]=x2
        set udg_castervars[1]=y2
        set udg_castervars[2]=z2
        set udg_castervars[3]=aoeradius
        set udg_castervars[4]=damage
        set udg_castervars[5]=0
        set udg_castervars[6]=speed

        set bj_isUnitGroupInRectResult = affectallied
        set udg_currenthurter = m
        call ExecuteFunc("DamagingProjectileLaunchAOE_Child")
     set m = null
     return udg_currentcaster
    endfunction

    function ProjectileLaunchDamageLoc takes player owner,string modelpath,real speed,real arc,location loc1,real z1,location loc2,real z2,real aoeradius,real damage,boolean affectallied returns unit
        return ProjectileLaunchDamage(owner , modelpath , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , GetLocationX(loc2) , GetLocationY(loc2) , z2 , aoeradius , damage , affectallied)
    endfunction

    //============================================================================================================
    function ProjectileLaunchKill_Child takes nothing returns nothing
     local unit m=udg_currentcaster
     local effect fx=bj_lastCreatedEffect
     local real x2=udg_castervars[0]
     local real y2=udg_castervars[1]
     local real speed=udg_castervars[3]

        if ( speed <= 522 ) then
            call SetUnitMoveSpeed(m , speed)
            call UnitMoveToAsProjectileGen((m ) , (( bj_meleeNearestMineDist )*1.0) , (( udg_castervars[0] )*1.0) , (( udg_castervars[1] )*1.0) , null , (( udg_castervars[2])*1.0)) // INLINED!!
            call DestroyEffect(fx)
        else
            call UnitMoveToAsProjectileAnySpeed_Effect(m , fx , speed , bj_meleeNearestMineDist , udg_castervars[0] , udg_castervars[1] , null , udg_castervars[2])
        endif

        call ExplodeUnitBJ(m)

     set m = null
     set fx = null
    endfunction

    function ProjectileLaunchKill takes player owner,string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns unit
     local unit m=CreateCaster(Atan2BJ(y2 - y1 , x2 - x1) , x1 , y1)


        call SetUnitFlyHeight(m , z1 , 0)
        set udg_currentcaster = m
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , owner , true)
        set bj_meleeNearestMineDist = arc
        set udg_castervars[0]=x2
        set udg_castervars[1]=y2
        set udg_castervars[2]=z2
        set udg_castervars[3]=speed
        call ExecuteFunc("ProjectileLaunchKill_Child")
     set m = null
     return udg_currentcaster
    endfunction

    function ProjectileLaunchKillLoc takes player owner,string modelpath,real speed,real arc,location loc1,real z1,location loc2,real z2 returns unit
        return ProjectileLaunchKill(owner , modelpath , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , GetLocationX(loc2) , GetLocationY(loc2) , z2)
    endfunction

    //====================================================================================================================================================================
    function UnitMoveToUnitAsProjectile takes unit m,real arc,unit target,real zoffset returns nothing
        call UnitMoveToAsProjectileGen(m , arc , 0 , 0 , target , zoffset)
    endfunction

    //====================================================================================================================================================================
    function ProjectileLaunchToUnitEx takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,real x1,real y1,real z1,unit target,real zoffset returns nothing
     local unit m=CreateCaster(Atan2BJ(GetUnitY(target) - y1 , GetUnitX(target) - x1) , x1 , y1)
     local effect fx=null

        call SetUnitFlyHeight(m , z1 , 0)
        call SetUnitScale(m , scale , scale , scale)
        call SetUnitVertexColor(m , red , green , blue , alpha)
        set fx = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , owner , true)

        if ( speed <= 522 ) then
            call SetUnitMoveSpeed(m , speed)
            call UnitMoveToAsProjectileGen((m ) , (( arc )*1.0) , 0 , 0 , ( target ) , (( zoffset)*1.0)) // INLINED!!
            call DestroyEffect(fx)
        else
            call UnitMoveToAsProjectileAnySpeed_Effect(m , fx , speed , arc , 0 , 0 , target , zoffset)
        endif

        call ExplodeUnitBJ(m)
     set m = null
     set fx = null
    endfunction

    function ProjectileLaunchToUnitExLoc takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,location loc1,real z1,unit target,real zoffset returns nothing
        call ProjectileLaunchToUnitEx(owner , modelpath , scale , red , green , blue , alpha , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , target , zoffset)
    endfunction

    function ProjectileLaunchToUnit takes string modelpath,real speed,real arc,real x1,real y1,real z1,unit target,real zoffset returns nothing
        call ProjectileLaunchToUnitEx(Player(15) , modelpath , 1 , 255 , 255 , 255 , 255 , speed , arc , x1 , y1 , z1 , target , zoffset)
    endfunction

    function ProjectileLaunchToUnitLoc takes string modelpath,real speed,real arc,location loc1,real z1,unit target,real zoffset returns nothing
        call ProjectileLaunchToUnitExLoc(Player(15) , modelpath , 1 , 255 , 255 , 255 , 255 , speed , arc , loc1 , z1 , target , zoffset)
    endfunction

    //====================================================================================================================================================================
    function DamagingProjectileLaunchTarget_Child takes nothing returns nothing
     local unit m=udg_currentcaster
     local unit target=bj_meleeNearestMine
     local effect fx=bj_lastCreatedEffect
     local real damage=udg_castervars[4]
     local damagetype dmgT=ConvertDamageType(R2I(udg_castervars[6]))
     local attacktype attT=ConvertAttackType(R2I(udg_castervars[5]))
     local unit hurter=udg_currenthurter
     local real speed=udg_castervars[7]
        if ( speed <= 522 ) then
            call SetUnitMoveSpeed(m , speed)
            call UnitMoveToAsProjectileGen((m ) , (( bj_meleeNearestMineDist )*1.0) , 0 , 0 , ( target ) , (( udg_castervars[2])*1.0)) // INLINED!!
            call DestroyEffect(fx)
        else
            call UnitMoveToAsProjectileAnySpeed_Effect(m , fx , speed , bj_meleeNearestMineDist , 0 , 0 , target , udg_castervars[2])
        endif

call UnitDamageTarget((hurter ) , ( target ) , (( damage )*1.0) , true , false , ( attT ) , ( dmgT) , null) // INLINED!!
        call ExplodeUnitBJ(m)
     set m = null
     set hurter = null
     set target = null
     set fx = null
     set dmgT = null
     set attT = null
    endfunction

    function DamagingProjectileLaunchTarget takes unit hurter,string modelpath,real speed,real arc,real x1,real y1,real z1,unit target,real zoffset,real damage,attacktype attT,damagetype dmgT returns unit
     local unit m=CreateCaster(Atan2BJ(GetUnitY(target) - y1 , GetUnitX(target) - x1) , x1 , y1)

        set udg_castervars[7]=speed
        call SetUnitFlyHeight(m , z1 , 0)
        set udg_currentcaster = m
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , GetOwningPlayer(hurter) , true)
        set bj_meleeNearestMineDist = arc
        set udg_castervars[2]=zoffset
        set bj_meleeNearestMine = target
        set udg_castervars[4]=damage
        set udg_castervars[5]=(GetHandleId((attT))) // INLINED!!
        set udg_castervars[6]=(GetHandleId((dmgT))) // INLINED!!
        set udg_currenthurter = hurter
        call ExecuteFunc("DamagingProjectileLaunchTarget_Child")
     set m = null
     return udg_currentcaster
    endfunction

    function DamagingProjectileLaunchTargetLoc takes unit hurter,string modelpath,real speed,real arc,location loc,real z1,unit target,real zoffset,real damage,attacktype attT,damagetype dmgT returns unit
        return DamagingProjectileLaunchTarget(hurter , modelpath , speed , arc , GetLocationX(loc) , GetLocationY(loc) , z1 , target , zoffset , damage , attT , dmgT)
    endfunction

    function ProjectileLaunchToUnitDamage takes player owner,string modelpath,real speed,real arc,real x1,real y1,real z1,unit target,real zoffset,real damage returns unit
     local unit m=CreateCaster(Atan2BJ(GetUnitY(target) - y1 , GetUnitX(target) - x1) , x1 , y1)

        set udg_castervars[7]=speed
        call SetUnitFlyHeight(m , z1 , 0)
        set udg_currentcaster = m
        set bj_lastCreatedEffect = AddSpecialEffectTarget(modelpath , m , "origin")
        call SetUnitOwner(m , owner , true)
        set bj_meleeNearestMineDist = arc
        set udg_castervars[2]=zoffset
        set bj_meleeNearestMine = target
        set udg_castervars[4]=damage
        set udg_castervars[5]=(GetHandleId((cs_DefaultAttackType))) // INLINED!!
        set udg_castervars[6]=(GetHandleId((cs_DefaultDamageType))) // INLINED!!
        set udg_currenthurter = m
        call ExecuteFunc("DamagingProjectileLaunchTarget_Child")
     set m = null
     return udg_currentcaster
    endfunction

    function ProjectileLaunchToUnitDamageLoc takes player owner,string modelpath,real speed,real arc,location loc1,real z1,unit target,real zoffset,real damage returns unit
        return ProjectileLaunchToUnitDamage(owner , modelpath , speed , arc , GetLocationX(loc1) , GetLocationY(loc1) , z1 , target , zoffset , damage)
    endfunction

    //==============================================================================================================================================================================
    // Caster System Class: CollisionMissile
    //
    function CollisionMissile_Destroy takes unit m returns nothing
     local integer k=GetUnitUserData(m)
     

        if ( s__cscollisionmissile_fx[k] != null ) then
            call DestroyEffect(s__cscollisionmissile_fx[k])
            set s__cscollisionmissile_fx[k]=null
        endif

        //For convenience, always wait for next tic to destroy the thing. But destroy the effect so
        //players don't ever notice it.
        set s__cscollisionmissile_state[k]=2
        call DisableTrigger(s__cscollisionmissile_t[k])

    endfunction

    function CollisionMissile_Create takes string MissileModelPath,real x,real y,real dirangle,real speed,real AngleSpeed,real MaxDist,real height,boolean UseNewCaster,real Collision,code OnImpact returns unit
     local timer t
     local integer k
     local trigger R

     local unit m


        set k = s__cscollisionmissile__allocate()
     
        if UseNewCaster then
            set m = CreateCaster(dirangle , x , y)
            set s__cscollisionmissile_new[k]=true
        else
            set m = GetACaster()
            call SetUnitFacing(m , dirangle)
            call SetUnitPosition(m , CS_SafeX(x) , CS_SafeY(y))
            set s__cscollisionmissile_new[k]=false
        endif
        set cs_missilecount = cs_missilecount + 1
        set cs_missiles[cs_missilecount]=k
        
        if ( not cs_movementtimer_active ) then
            call TimerStart(cs_movementtimer , cs_TIMER_CYCLE , true , function CasterSystemMovementTimer)
            set cs_movementtimer_active = true
        endif

        call SetUnitUserData(m , k)

        set s__csmissile_mtype[k]=cs_TYPE_COLLISIONMISSILE
       
        set s__cscollisionmissile_speed[k]=speed
        set s__cscollisionmissile_aspeed[k]=AngleSpeed

        set s__cscollisionmissile_f[k]=dirangle

        set s__cscollisionmissile_maxd[k]=MaxDist

        call SetUnitFlyHeight(m , height , 0)



        set R = CreateTrigger()

        set s__cscollisionmissile_collision[k]=Collision

        set s__cscollisionmissile_state[k]=1
        set s__cscollisionmissile_t[k]=R
        call SaveInteger(CSData__ht , 0 , GetHandleId((R )) , ( k)) // INLINED!!
        
        set s__cscollisionmissile_fx[k]=AddSpecialEffectTarget(MissileModelPath , m , "origin")
        set s__csmissile_m[k]=m
        set s__cscollisionmissile_ac[k]=TriggerAddAction(R , OnImpact)

     set R = null
     set udg_currentcaster = m
     set m = null

     return udg_currentcaster
    endfunction

    function CollisionMissile_CreateLoc takes string MissileModelPath,location loc,real dirangle,real speed,real AngleSpeed,real MaxDist,real height,boolean UseNewCaster,real Collision,code OnImpact returns unit
        return CollisionMissile_Create(MissileModelPath , GetLocationX(loc) , GetLocationY(loc) , dirangle , speed , AngleSpeed , MaxDist , height , UseNewCaster , Collision , OnImpact)
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_SetAngleSpeed takes unit m,real newAspeed returns nothing
     local integer k=GetUnitUserData(m)
        set s__cscollisionmissile_aspeed[k]=newAspeed
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_SetSpeed takes unit m,real newspeed returns nothing
     local integer k=GetUnitUserData(m)
        set s__cscollisionmissile_speed[k]=newspeed
    endfunction


    //=========================================================================================================================================================
    function CollisionMissile_SetTargetPoint takes unit m,real tx,real ty returns nothing
     local integer k= GetUnitUserData(m)
        set s__cscollisionmissile_tx[k]=tx
        set s__cscollisionmissile_ty[k]=ty
        set s__cscollisionmissile_ttype[k]=s__cscollisionmissile_ttype_point
    endfunction
    function CollisionMissile_SetTargetPointLoc takes unit m,location tloc returns nothing
        call CollisionMissile_SetTargetPoint(m , GetLocationX(tloc) , GetLocationY(tloc))
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_SetTarget takes unit m,widget Target returns nothing
     local integer k= GetUnitUserData(m)
        set s__cscollisionmissile_tw[k]=Target
        set s__cscollisionmissile_ttype[k]=s__cscollisionmissile_ttype_widget
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_ForgetTarget takes unit m returns nothing
        set s__cscollisionmissile_ttype[(GetUnitUserData(m))]=s__cscollisionmissile_ttype_none
    endfunction
    


    //=========================================================================================================================================================
    function CollisionMissile_SetDirAngle takes unit m,real f returns nothing
        set s__cscollisionmissile_f[(GetUnitUserData(m))]=f
        call SetUnitFacing(m , f)
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_ResetMaxDist takes unit m,real maxdist returns nothing
        set s__cscollisionmissile_maxd[(GetUnitUserData(m))]=maxdist
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_PeriodicFX takes unit m,string fx,real dur returns nothing
    // [1 integer state][2 trigger T][3 real collision][4 real speed][5 real F][6 real aspeed][7 integer TType]
    // [8 real Tx][9 real Ty][10 widget Tw][11 real F][12 real maxd][13 boolean pfx][14 real pfx_current][15 real pfx_dur][16 pfx_path]
    // [17 fx][18 ac][19 boolean new][20 m]

     local integer k= (GetUnitUserData(m))
        set s__cscollisionmissile_pfx[k]=true
        set s__cscollisionmissile_pfx_path[k]=fx
        set s__cscollisionmissile_pfx_dur[k]=dur
        set s__cscollisionmissile_pfx_current[k]=0.
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_SetTag takes unit m,integer tag returns nothing
        set s__cscollisionmissile_tag[(GetUnitUserData(m))]=tag
    endfunction

    //=========================================================================================================================================================
    function CollisionMissile_GetTag takes unit m returns integer
        return s__cscollisionmissile_tag[(GetUnitUserData(m))]
    endfunction


    //**************************************************************************************************
    //*
    //* Caster System Special Events:
    //*
    //*
    //**************************************************************************************************




    //==================================================================================================
    // Event: OnAbilityLearn
    //
    function Event_OnLearn1 takes nothing returns nothing

     local integer s=GetLearnedSkill()
     local string k=I2S(s)
       if HaveStoredString(cs_cache , "events_onlearn" , k) then
           call ExecuteFunc(GetStoredString(cs_cache , "events_onlearn" , k))
       endif

    endfunction

    function Event_OnLearn2 takes nothing returns nothing

     local integer s=GetLearnedSkill()
     local string k=I2S(s)
       if HaveStoredString(cs_cache , "events_onlearn" , k) then
           call StoreInteger(cs_cache , "events_variables" , "unit" , (GetHandleId((GetTriggerUnit())))) // INLINED!!
           set CasterSystem___acquiringunit = GetTriggerUnit()
           call StoreInteger(cs_cache , "events_variables" , "current" , s)
           set CasterSystem___acquiredabil = s
           call ExecuteFunc(GetStoredString(cs_cache , "events_onlearn" , k))
       endif

    endfunction

    function InitLearnEvent takes gamecache g,integer i returns nothing
     local trigger t=CreateTrigger()
     local integer j=0
        loop
            call TriggerRegisterPlayerUnitEvent(t , Player(j) , EVENT_PLAYER_HERO_SKILL , null)
            set j = j + 1
            exitwhen j == bj_MAX_PLAYER_SLOTS
        endloop
        if ( i == 1 ) then
            set CasterSystem___events_probablytemp_learntrig = t
            set CasterSystem___events_probablytemp_learntriga = TriggerAddAction(t , function Event_OnLearn1)
        else
            call TriggerAddAction(t , function Event_OnLearn2)
        endif
        call StoreInteger(g , "eventhandlers" , "learn" , i)
         
     set t = null
    endfunction

    function OnAbilityLearn takes integer abilid,string funcname returns nothing


        if ( not HaveStoredInteger(cs_cache , "eventhandlers" , "learn") ) then
            call InitLearnEvent(cs_cache , 1)
        endif

        call StoreString(cs_cache , "events_onlearn" , I2S(abilid) , funcname)


    endfunction

    //==================================================================================================
    // Event: OnAbilityGet
    //
    function GetAbilityAcquiringUnit takes nothing returns unit
        return CasterSystem___acquiringunit
    endfunction

    function SetAbilityAcquiringUnit takes unit u returns nothing
        set CasterSystem___acquiringunit = u
    endfunction
    
    function GetAcquiredAbilityId takes nothing returns integer
        return CasterSystem___acquiredabil
    endfunction

    function SetAcquiredAbilityId takes integer i returns nothing
        set CasterSystem___acquiredabil = i
    endfunction

    function UnitAddAbility_ConsiderEvent takes unit whichUnit,integer abilid,integer level returns nothing
     local string k=I2S(abilid)
        call UnitAddAbility(whichUnit , abilid)
        call SetUnitAbilityLevel(whichUnit , abilid , level)
        if ( HaveStoredString(cs_cache , "events_onlearn" , k) ) then
            set CasterSystem___acquiringunit = whichUnit
            set CasterSystem___acquiredabil = abilid
            call ExecuteFunc(GetStoredString(cs_cache , "events_onlearn" , k))
        endif
    endfunction
    


    function Event_OnPassive_Browse takes unit u,string k returns nothing
     local integer n=GetStoredInteger(cs_cache , "events_passives" , "n")
     local integer un=0
     local integer i=1
     local integer s

        loop
            exitwhen ( i > n )
            set s = GetStoredInteger(cs_cache , "events_passives" , I2S(i))
            if ( GetUnitAbilityLevel(u , s) > 0 ) then
                if ( un == 0 ) then
                    set un = 1
                    call StoreInteger(cs_cache , "events_variables" , "unit" , (GetHandleId((u)))) // INLINED!!
                    set CasterSystem___acquiringunit = u
                else
                    set un = un + 1
                endif
                call StoreInteger(cs_cache , "events_unit_passive" + I2S(un) , k , s)
                call StoreInteger(cs_cache , "events_variables" , "current" , s)
                set CasterSystem___acquiredabil = s
                call ExecuteFunc(GetStoredString(cs_cache , "events_onlearn" , I2S(s)))
            endif
            set i = i + 1
        endloop
        if ( un == 0 ) then
            set un = - 1
        endif
        call StoreInteger(cs_cache , "events_unit_passives" , k , un)
    endfunction

    function Event_OnPassive_Do takes unit u,string k,integer n returns nothing
     local integer i=1
     local integer s
        call StoreInteger(cs_cache , "events_variables" , "unit" , (GetHandleId((u)))) // INLINED!!
        set CasterSystem___acquiringunit = u
        loop
            exitwhen ( i > n )
            set s = GetStoredInteger(cs_cache , "events_unit_passive" + I2S(i) , k)
            if ( GetUnitAbilityLevel(u , s) > 0 ) then
                call StoreInteger(cs_cache , "events_variables" , "current" , s)
                set CasterSystem___acquiredabil = s
                call ExecuteFunc(GetStoredString(cs_cache , "events_onlearn" , I2S(s)))
            endif
            set i = i + 1
        endloop
    endfunction


    function Event_OnPassive_EnterRect takes nothing returns nothing

     local unit u=GetTriggerUnit()
     local string k=I2S(GetUnitTypeId(u))
     local integer n=GetStoredInteger(cs_cache , "events_unit_passives" , k)
        if ( n > 0 ) then
            call Event_OnPassive_Do(u , k , n)
        elseif ( n == 0 ) then
		    //call BJDebugMsg(GetObjectName(GetUnitTypeId(u)) + " has no listed passive abilities.")
            call Event_OnPassive_Browse(u , k)
        endif

     set u = null
    endfunction

    function Event_OnPassive_NoCasters takes nothing returns boolean
        return ( GetUnitTypeId(GetTriggerUnit()) != cs_CasterUnitId )
    endfunction
    function Event_OnPassive_InitEnum takes nothing returns nothing
     local trigger t
     local integer n=GetStoredInteger(cs_cache , "events_passives" , "n")
     local integer i=1
     local integer array p
     local string array s
     local unit u
     local group a=NewGroup()
     local boolean saved
	 
		//call BJDebugMsg("SCreating yo trigger")
        call ReleaseTimer(GetExpiredTimer())
        loop
            exitwhen ( i > n )
            set p[i]=GetStoredInteger(cs_cache , "events_passives" , I2S(i))
            set s[i]=GetStoredString(cs_cache , "events_onlearn" , I2S(p[i]))
			//call BJDebugMsg(s[i])
            set i = i + 1
        endloop
        call GroupEnumUnitsInRect(a , bj_mapInitialPlayableArea , null)
        loop
            set u = FirstOfGroup(a)
            exitwhen ( u == null )
            set i = 1
            set saved = false
			//call BJDebugMsg(GetUnitName(u))

            loop
                exitwhen ( i > n )
                if ( GetUnitAbilityLevel(u , p[i]) > 0 ) then
                    if ( not saved ) then
                        set saved = true
                        call StoreInteger(cs_cache , "events_variables" , "unit" , (GetHandleId((u)))) // INLINED!!
                        set CasterSystem___acquiringunit = u
                    endif
                    call StoreInteger(cs_cache , "events_variables" , "current" , p[i])
                    set CasterSystem___acquiredabil = p[i]
                    call ExecuteFunc(s[i])
                endif
                set i = i + 1
            endloop
            call GroupRemoveUnit(a , u)
        endloop
		//call BJDebugMsg("Creating yo trigger")
        set t = CreateTrigger()
        call TriggerRegisterEnterRectSimple(t , bj_mapInitialPlayableArea)
        call TriggerAddAction(t , function Event_OnPassive_EnterRect)
        call TriggerAddCondition(t , Condition(function Event_OnPassive_NoCasters))
        call ReleaseGroup(a)

     set t = null
     set a = null
    endfunction


    function InitPassiveEvent takes nothing returns nothing
     local trigger t
        call TimerStart(NewTimer() , 0 , false , function Event_OnPassive_InitEnum)
        set CasterSystem___eventhandlers_passives = true

        if ( not HaveStoredInteger(cs_cache , "eventhandlers" , "learn") ) then
            call InitLearnEvent(cs_cache , 2)
        else
            set t = CasterSystem___events_probablytemp_learntrig
            call TriggerRemoveAction(t , CasterSystem___events_probablytemp_learntriga)
            call TriggerAddAction(t , function Event_OnLearn2)
            call StoreInteger(cs_cache , "eventhandlers" , "learn" , 2)
           set t = null
        endif
    endfunction


    function OnAbilityGet takes integer abilid,string funcname returns nothing
     local integer n=GetStoredInteger(cs_cache , "events_passives" , "n") + 1

        if ( not CasterSystem___eventhandlers_passives ) then
            call InitPassiveEvent()
        endif

        call StoreString(cs_cache , "events_onlearn" , I2S(abilid) , funcname)
        call StoreInteger(cs_cache , "events_passives" , "n" , n)
        call StoreInteger(cs_cache , "events_passives" , I2S(n) , abilid)
    endfunction

    //==================================================================================================
    // Event: OnAbilityEffect
    //
    function Event_OnEffect takes nothing returns nothing
     local string k=I2S(GetSpellAbilityId())
     
        if HaveStoredString(cs_cache , "events_oneffect" , k) then
            call ExecuteFunc(GetStoredString(cs_cache , "events_oneffect" , k))
        endif
    endfunction

    function InitEffectEvent takes gamecache g returns nothing
     local trigger t=CreateTrigger()
     local integer i= 0
        loop
            call TriggerRegisterPlayerUnitEvent(t , Player(i) , EVENT_PLAYER_UNIT_SPELL_EFFECT , null)
            set i = i + 1
            exitwhen i == bj_MAX_PLAYER_SLOTS
        endloop
        call TriggerAddAction(t , function Event_OnEffect)
        call StoreInteger(g , "eventhandlers" , "effect" , 1)
     set t = null
    endfunction

    function OnAbilityEffect takes integer abilid,string funcname returns nothing

        if ( not HaveStoredInteger(cs_cache , "eventhandlers" , "effect") ) then
            call InitEffectEvent(cs_cache)
        endif
        call StoreString(cs_cache , "events_oneffect" , I2S(abilid) , funcname)
    endfunction

    //==================================================================================================
    // Event: OnAbilityCast
    //
    function Event_OnCast takes nothing returns nothing
     local string k=I2S(GetSpellAbilityId())
        if HaveStoredString(cs_cache , "events_oncast" , k) then
            call ExecuteFunc(GetStoredString(cs_cache , "events_oncast" , k))
        endif

    endfunction

    function InitCastEvent takes nothing returns nothing
     local trigger t=CreateTrigger()
     local integer i= 0
        loop
            call TriggerRegisterPlayerUnitEvent(t , Player(i) , EVENT_PLAYER_UNIT_SPELL_CAST , null)
            set i = i + 1
            exitwhen i == bj_MAX_PLAYER_SLOTS
        endloop
        call TriggerAddAction(t , function Event_OnCast)
        call StoreInteger(cs_cache , "eventhandlers" , "cast" , 1)
     set t = null
    endfunction

    function OnAbilityPreCast takes integer abilid,string funcname returns nothing
        if ( not HaveStoredInteger(cs_cache , "eventhandlers" , "cast") ) then
            call InitCastEvent()
        endif
        call StoreString(cs_cache , "events_oncast" , I2S(abilid) , funcname)
    endfunction

    //==================================================================================================
    // Event: OnAbilityEndCast
    //
    function Event_OnEndCast takes nothing returns nothing
     local string k=I2S(GetSpellAbilityId())

        if HaveStoredString(cs_cache , "events_onendcast" , k) then
            call ExecuteFunc(GetStoredString(cs_cache , "events_onendcast" , k))
        endif

    endfunction

    function InitEndCastEvent takes nothing returns nothing
     local trigger t=CreateTrigger()
     local integer i= 0
        loop
            call TriggerRegisterPlayerUnitEvent(t , Player(i) , EVENT_PLAYER_UNIT_SPELL_ENDCAST , null)
            set i = i + 1
            exitwhen i == bj_MAX_PLAYER_SLOTS
        endloop
        call TriggerAddAction(t , function Event_OnEndCast)
        call StoreInteger(cs_cache , "eventhandlers" , "endcast" , 1)
     set t = null
    endfunction

    function OnAbilityEndCast takes integer abilid,string funcname returns nothing

        if ( not HaveStoredInteger(cs_cache , "eventhandlers" , "endcast") ) then
            call InitEndCastEvent()
        endif
        call StoreString(cs_cache , "events_onendcast" , I2S(abilid) , funcname)

    endfunction


    //==================================================================================================
    // Spell Helpers
    //
    function IsPointWater takes real x,real y returns boolean
        return IsTerrainPathable(x , y , PATHING_TYPE_WALKABILITY) and not ( IsTerrainPathable(x , y , PATHING_TYPE_AMPHIBIOUSPATHING) )
    endfunction

    function IsPointWaterLoc takes location loc returns boolean
        return IsPointWater(GetLocationX(loc) , GetLocationY(loc))
    endfunction

    //==================================================================================================
    function IsUnitSpellImmune takes unit u returns boolean
        return IsUnitType(u , UNIT_TYPE_MAGIC_IMMUNE)
    endfunction

    function IsUnitImmuneToPhisical takes unit u returns boolean
        return ( GetDamageFactor(u , ATTACK_TYPE_CHAOS , DAMAGE_TYPE_DEMOLITION) == 0 )
    endfunction

    function IsUnitInvulnerableBJ takes unit u returns boolean
        return ( GetDamageFactor(u , ATTACK_TYPE_CHAOS , DAMAGE_TYPE_UNIVERSAL) == 0 )
    endfunction

    //## Utility functions ##
    //====================================================================================================
    // Mimic an interface error message
    //     ForPlayer : The player to show the error
    //     msg       : The error
    //
    function CS_Error takes player ForPlayer,string msg returns nothing
     local sound error=CreateSoundFromLabel("InterfaceError" , false , false , false , 10 , 10)
        if ( GetLocalPlayer() == ForPlayer ) then
            if ( msg != "" ) and ( msg != null ) then
                call ClearTextMessages()
                call DisplayTimedTextToPlayer(ForPlayer , 0.52 , - 1.00 , 2.00 , "|cffffcc00" + msg + "|r")
            endif
            call StartSound(error)
        endif
     call KillSoundWhenDone(error)
     set error = null
    endfunction

    //## Safe item hiding system ##
    //===============================
    // Hides an item, it keeps it safe while leaving other units unable to use it
    // (unless an (attached) variable / table field points to it and user does
    // something with it) - THIS IS HIGHLY DISCOURAGED
    //
    // * Don't use it with tomes that increase hero stats
    // * Make triggers with item acquire/lose events ignore when a
    //   Caster is triggering unit.
    //

    //If your map got more than 8191 items, you are crazy.

    function CS_HideItem takes item i returns integer
     local unit s
     local group gr=CasterSystem___CSItemStorage_gr
     local integer r

        if ( gr == null ) then
            set gr = NewGroup()
            set CasterSystem___CSItemStorage_gr = gr
        endif
        set s = FirstOfGroup(gr)
        if ( s == null ) then
            set s = CreateCaster(0 , 0 , 0)
            call UnitAddAbility(s , cs_DummyInventory_Id)
            if ( UnitInventorySize(s) < bj_MAX_INVENTORY ) then
                call BJDebugMsg("CASTER SYSTEM ERROR: Please use a correct ability for cs_DummyInventory_Id ")
                loop //crash the thread
                endloop
            endif

            call GroupAddUnit(gr , s)
        endif
        call UnitAddItem(s , i)
        set r = s__CasterSystem___itemholder__allocate()
        set s__CasterSystem___itemholder_it[r]=i
        set s__CasterSystem___itemholder_s[r]=s

        if ( UnitInventorySize(s) == UnitInventoryCount(s) ) then
            call GroupRemoveUnit(gr , s)
        endif
     set s = null
     set gr = null
     return (r)
    endfunction


    //===============================
    // Restores an item
    //
    function CS_RestoreItem takes integer hiddenindex,real x,real y returns item
     local group gr=CasterSystem___CSItemStorage_gr
     local integer r=(hiddenindex)
     local unit s=s__CasterSystem___itemholder_s[r]
     local item i=s__CasterSystem___itemholder_it[r]
     local integer c
        call s__CasterSystem___itemholder_destroy(r)
     
        call UnitRemoveItem(s , i)
        set c = UnitInventoryCount(s)
        if ( c == 0 ) then
            call UnitRemoveAbility(s , cs_DummyInventory_Id)
            call GroupRemoveUnit(gr , s)
            call ExplodeUnitBJ(s)
        else
            call GroupAddUnit(gr , s)
        endif
        call SetItemPosition(i , x , y)
        set CasterSystem___returnitem = i
     set i = null
     set s = null
     return CasterSystem___returnitem
    endfunction

    function CS_RestoreItemLoc takes integer hiddenindex,location loc returns item
        return CS_RestoreItem(hiddenindex , GetLocationX(loc) , GetLocationY(loc))
    endfunction


    //=============================================================================================================
    // More convenient than CS_HideItem not compatible with CS_HideItem / CS_RestoreItem(loc)
    //
    function CS_SetItemVisible takes item it,boolean flag returns nothing
     local integer r
     local unit s
     local string k=I2S((GetHandleId((it)))) // INLINED!!
     local group gr
     local integer x
        if ( flag ) then
            if ( HaveStoredInteger(cs_cache , "CSItemStorage" , k) ) then
                //DO SHOW:
                set r = (GetStoredInteger(cs_cache , "CSItemStorage" , k))
                set s = s__CasterSystem___itemholder_s[r]
                set gr = CasterSystem___CSItemStorage_gr
                if ( gr == null ) then
                    set gr = NewGroup()
                    set CasterSystem___CSItemStorage_gr = gr
                endif
                call FlushStoredInteger(cs_cache , "CSItemStorage" , k)
                call UnitRemoveItem(s , it)
                call SetItemVisible(it , true) //Just in case
                set x = GetUnitUserData(s) - 1
                if ( x == 0 ) then
                    call UnitRemoveAbility(s , cs_DummyInventory_Id)
                    call GroupRemoveUnit(gr , s)
                    call ExplodeUnitBJ(s)
                else
                    call SetUnitUserData(s , x)
                    call GroupAddUnit(gr , s)
                endif
                call s__CasterSystem___itemholder_destroy(r)
               set s = null
               set gr = null
            else //What? Trying to show an item that was not hidden using this method?
            endif
            

        elseif ( HaveStoredInteger(cs_cache , "CSItemStorage" , k) ) then
            //What? Trying to hide an item that was already hidden by this method?

        else //DO HIDE:
            set gr = CasterSystem___CSItemStorage_gr
            if ( gr == null ) then
                set gr = NewGroup()
                set CasterSystem___CSItemStorage_gr = gr
            endif
            set s = FirstOfGroup(gr)
            
            if ( s == null ) then
                set s = CreateCaster(0 , 0 , 0)
                call UnitAddAbility(s , cs_DummyInventory_Id)
                if ( UnitInventorySize(s) < bj_MAX_INVENTORY ) then
                    call BJDebugMsg("CASTER SYSTEM ERROR: Please use a correct ability for cs_DummyInventory_Id ")
                    set x = x
                endif
                call SetUnitUserData(s , 0) //UserData will now hold total items
                call GroupAddUnit(gr , s)
            endif
            call UnitAddItem(s , it)
            set r = s__CasterSystem___itemholder__allocate()
            set s__CasterSystem___itemholder_s[r]=s
            set s__CasterSystem___itemholder_it[r]=it
            call StoreInteger(cs_cache , "CSItemStorage" , k , (r))
            set x = GetUnitUserData(s) + 1
            call SetUnitUserData(s , x)
            if ( x == bj_MAX_INVENTORY ) then
                call GroupRemoveUnit(gr , s)
            endif
         set s = null
         set gr = null
        endif
    endfunction

    function CS_IsItemVisible takes item it returns boolean
       return not HaveStoredInteger(cs_cache , "CSItemStorage" , I2S((GetHandleId((it))))) // INLINED!!
    endfunction


    //=============================================================================================================
    // Obsolette functions: (Left for compatibility)
    //
    constant function WaterDetectorId takes nothing returns integer
    return 'Asb2'
    endfunction
    function SpellEffectModelPath takes integer abilityid,effecttype t returns string
    return GetAbilityEffectById(abilityid , t , 0)
    endfunction
    constant function Caster_DefaultAttackType takes nothing returns attacktype
    return cs_DefaultAttackType
    endfunction
    constant function Caster_DefaultDamageType takes nothing returns damagetype
    return cs_DefaultDamageType
    endfunction
    constant function Caster_UnitId takes nothing returns integer
    return cs_CasterUnitId
    endfunction
    constant function DamageTreeDetectorId takes nothing returns integer
    return cs_DamageTreeDetectorId
    endfunction
    constant function ChangeableFlyingHeightAllowerId takes nothing returns integer
    return cs_FlyingHeightHack
    endfunction
    constant function CS_MaxCollisionSize takes nothing returns real
    return cs_MaxUnitCollisionSize
    endfunction
    constant function CS_Cycle takes nothing returns real
    return cs_TIMER_CYCLE
    endfunction
    constant function CS_InventoryId takes nothing returns integer
    return cs_DummyInventory_Id
    endfunction
    constant function CS_RectLimitOffSet takes nothing returns real
    return cs_RectLimitOffSet
    endfunction
    function CS_IsUnitVisible takes unit u,player p returns boolean
         return IsUnitVisible(u , p)
    endfunction


//library CasterSystem ends
//library CSDamagers:

//*************************************************************************************
//* CSDamagers 15.3
//* ---------------
//*    Rebuilt from scratch since 15.1, now they use CSData instead of CSCache
//*
//* A DamagerGroup is a bunch of 'damagers', only that it does not matter how many
//*  'damagers' are in range of the target unit, it is only affected by the damage once.
//*
//* A damager is a single special effect that every once in a while causes damage to
//*  nearby units, these things are MUI, dynamic and can have expiration times.
//*
//*
//**************************************************************************************

//======================================================================================





        function s__CSDamagers__damagerdata_onDestroy takes integer this returns nothing
           call GroupRemoveUnit(CSDamagers__damagerflag , s__CSDamagers__damagerdata_u[this])
           if ( s__CSDamagers__damagerdata_prev[this] == this ) then
               set s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]]=0
           else
               if ( s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]] == this ) then
                   set s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]]=s__CSDamagers__damagerdata_prev[this]
               endif
               set s__CSDamagers__damagerdata_next[s__CSDamagers__damagerdata_prev[this]]=s__CSDamagers__damagerdata_next[this]
               set s__CSDamagers__damagerdata_prev[s__CSDamagers__damagerdata_next[this]]=s__CSDamagers__damagerdata_prev[this]
           endif
           call ReleaseTimer(s__CSDamagers__damagerdata_lifespan[this])
           if ( s__CSDamagers__damagerdata_abil[this] != 0 ) then
               call UnitRemoveAbility(s__CSDamagers__damagerdata_u[this] , s__CSDamagers__damagerdata_abil[this])
           endif
           call RecycleCasterAfterCastEx((s__CSDamagers__damagerdata_u[this] ) , (( 4 )*1.0) , ( 0 ) , ( false)) // INLINED!!
           call DestroyEffect(s__CSDamagers__damagerdata_fx[this])
        endfunction

//Generated destructor of CSDamagers__damagerdata
function s__CSDamagers__damagerdata_destroy takes integer this returns nothing
    if this==null then
        return
    elseif (si__CSDamagers__damagerdata_V[this]!=-1) then
        return
    endif
    call s__CSDamagers__damagerdata_onDestroy(this)
    set si__CSDamagers__damagerdata_V[this]=si__CSDamagers__damagerdata_F
    set si__CSDamagers__damagerdata_F=this
endfunction

    //============================================================================================================

    function CSDamagers__processUnitsInRange takes nothing returns boolean
     local unit e=GetFilterUnit()

        if ( IsUnitInRangeXY(e , CSDamagers__centerx , CSDamagers__centery , CSDamagers__radius) and not IsUnitInGroup(e , CSDamagers__loggroup) ) then
            call GroupAddUnit(CSDamagers__loggroup , e)
            set CSDamagers__inrange[CSDamagers__an]=e
            set CSDamagers__an = CSDamagers__an + 1
        endif

     set e = null
     return false
    endfunction

    function CSDamagers__expire takes nothing returns nothing
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((GetExpiredTimer()))))) // INLINED!!
     local integer p=s__CSDamagers__data_damagers[d]
     local integer q
     local integer do
     local real x

        set s__CSDamagers__data_expired[d]=true

        set CSDamagers__an = 0
        if ( p != 0 ) then
            set q = p
            loop
                set CSDamagers__centerx = GetUnitX(s__CSDamagers__damagerdata_u[q])
                set CSDamagers__centery = GetUnitY(s__CSDamagers__damagerdata_u[q])
                set CSDamagers__radius = s__CSDamagers__data_area[d]
                if s__CSDamagers__data_trees[d] then
                    call DamageTreesInCircle(CSDamagers__centerx , CSDamagers__centery , CSDamagers__radius)
                endif
                call GroupEnumUnitsInRange(CSDamagers__enumgroup , CSDamagers__centerx , CSDamagers__centery , CSDamagers__radius + cs_MaxUnitCollisionSize , CSDamagers__procfilter)
                exitwhen ( s__CSDamagers__damagerdata_next[q] == p )
                set q = s__CSDamagers__damagerdata_next[q]
            endloop
        endif
        if ( CSDamagers__an != 0 ) then
            set do = LoadDamageOptions(s__CSDamagers__data_DamageOptions[d])
            loop
                exitwhen ( CSDamagers__an == 0 )
                set CSDamagers__an = CSDamagers__an - 1
                set x = GetDamageFactorByOptions(s__CSDamagers__data_hurter[d] , CSDamagers__inrange[CSDamagers__an] , do)
                if ( x >= CSDamagers__EPSILON ) or ( x <= - CSDamagers__EPSILON ) then
                    call UnitDamageTarget(s__CSDamagers__data_hurter[d] , CSDamagers__inrange[CSDamagers__an] , s__CSDamagers__data_damage[d] * x , true , false , null , null , null)
                endif
            endloop
        endif
        call GroupClear(CSDamagers__loggroup)

        set s__CSDamagers__data_expired[d]=false
        if ( s__CSDamagers__data_end[d] or ( s__CSDamagers__data_selfdestruct[d] and ( p == 0 ) ) ) then
            call sc___prototype10_evaluate(1,GetExpiredTimer())
        endif
    endfunction

    function CSDamagers__damagerExpires takes nothing returns nothing
        call s__CSDamagers__damagerdata_destroy(((LoadInteger(CSData__ht , 0 , GetHandleId((GetExpiredTimer())))))) // INLINED!!
    endfunction


    function CSDamagers__endOfDamagerGroup takes nothing returns nothing
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((GetExpiredTimer()))))) // INLINED!!
        call sc___prototype10_evaluate(1,s__CSDamagers__data_thetimer[d])
    endfunction
    //================================================================================================================================
    //
    // 
    function DamagerGroup_Create takes unit hurter,real damage,real damageperiod,real area,integer DamageOptions returns timer
     local timer t=NewTimer()
     local integer d=s__CSDamagers__data__allocate()

        if IsDamageOptionIncluded(DamageOptions , (16)) then // INLINED!!
            set s__CSDamagers__data_trees[d]=true
        endif
        set s__CSDamagers__data_DamageOptions[d]=CreateDamageOptions(DamageOptions)
        set s__CSDamagers__data_thetimer[d]=t
        set s__CSDamagers__data_hurter[d]=hurter
        set s__CSDamagers__data_damage[d]=damage
        set s__CSDamagers__data_area[d]=area
        call SaveInteger(CSData__ht , 0 , GetHandleId((t )) , ( (d))) // INLINED!!
        call TimerStart(t , damageperiod , true , function CSDamagers__expire)


      
     //since we use CSSafety, no need to null the timer...
     return t
    endfunction

    function DamagerGroup_Destroy takes timer DamagerGroup returns nothing
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((DamagerGroup))))) // INLINED!!
        if ( s__CSDamagers__data_expired[d] ) then
            set s__CSDamagers__data_end[d]=true
            return 
        endif
        loop
            exitwhen ( s__CSDamagers__data_damagers[d] == 0 )
            call s__CSDamagers__damagerdata_destroy(s__CSDamagers__data_damagers[d])
        endloop
        call ReleaseTimer(DamagerGroup)
        call s__CasterSystem___dostruct_destroy(((s__CSDamagers__data_DamageOptions[d]))) // INLINED!!
        if ( s__CSDamagers__data_lifespan[d] != null ) then
            call ReleaseTimer(s__CSDamagers__data_lifespan[d])
        endif
        call s__CSDamagers__data_destroy(d)
    endfunction

    //at least it is inlineable...
    function DamagerGroup_AutoDestruct takes timer DamagerGroup,boolean auto returns nothing
        set s__CSDamagers__data_selfdestruct[((LoadInteger(CSData__ht , 0 , GetHandleId((DamagerGroup)))))]=auto // INLINED!!
    endfunction
   
    function DamagerGroup_SetLifeSpan takes timer DamagerGroup,real LifeSpan returns nothing
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((DamagerGroup))))) // INLINED!!
        if ( s__CSDamagers__data_lifespan[d] == null ) then
            set s__CSDamagers__data_lifespan[d]=NewTimer()
            call SaveInteger(CSData__ht , 0 , GetHandleId((s__CSDamagers__data_lifespan[d] )) , ( (d))) // INLINED!!
        endif
        call TimerStart(s__CSDamagers__data_lifespan[d] , LifeSpan , false , function CSDamagers__endOfDamagerGroup)

    endfunction

    //
    function DamagerGroup_Update takes timer DamagerGroup,unit hurter,real damage,real damageperiod,real area,integer DamageOptions returns nothing
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((DamagerGroup))))) // INLINED!!
        set s__CSDamagers__data_hurter[d]=hurter
        set s__CSDamagers__data_damage[d]=damage
        call TimerStart(DamagerGroup , damageperiod , true , function CSDamagers__expire)
        call SetDamageOptions_i((s__CSDamagers__data_DamageOptions[d] ) , ( DamageOptions)) // INLINED!!
    endfunction

    function DamagerGroup_AddDamager takes timer DamagerGroup,string modelpath,real x,real y,real LifeSpan returns unit
     local unit c=GetACaster()
     local timer t=NewTimer()
     local integer dt=s__CSDamagers__damagerdata__allocate()
     local integer d=((LoadInteger(CSData__ht , 0 , GetHandleId((DamagerGroup))))) // INLINED!!

        set s__CSDamagers__damagerdata_u[dt]=c
        call SetUnitUserData(c , (dt))
        set s__CSDamagers__damagerdata_lifespan[dt]=t
        set s__CSDamagers__damagerdata_fx[dt]=AddSpecialEffectTarget(modelpath , c , "origin")
        set s__CSDamagers__damagerdata_parent[dt]=d
        if ( s__CSDamagers__data_damagers[d] == 0 ) then
            set s__CSDamagers__data_damagers[d]=dt
            set s__CSDamagers__damagerdata_next[dt]=dt
            set s__CSDamagers__damagerdata_prev[dt]=dt
        else
            //brain hurts.
            set s__CSDamagers__damagerdata_next[dt]=s__CSDamagers__data_damagers[d]
            set s__CSDamagers__damagerdata_prev[dt]=s__CSDamagers__damagerdata_prev[s__CSDamagers__data_damagers[d]]
            set s__CSDamagers__damagerdata_next[s__CSDamagers__damagerdata_prev[s__CSDamagers__data_damagers[d]]]=dt
            set s__CSDamagers__damagerdata_prev[s__CSDamagers__data_damagers[d]]=dt
            set s__CSDamagers__data_damagers[d]=dt
        endif
        
        call SetUnitX(c , x)
        call SetUnitY(c , y)
        call SaveInteger(CSData__ht , 0 , GetHandleId((t )) , ( (dt))) // INLINED!!
        if ( LifeSpan >= CSDamagers__EPSILON ) then
            call TimerStart(t , LifeSpan , false , function CSDamagers__damagerExpires)
        endif
        call SetUnitOwner(c , GetOwningPlayer(s__CSDamagers__data_hurter[d]) , true)
        call GroupAddUnit(CSDamagers__damagerflag , c)

     set c = null
     return s__CSDamagers__damagerdata_u[dt]
    endfunction
    function DamagerGroup_AddDamagerLoc takes timer DamagerGroup,string modelpath,location loc,real LifeSpan returns unit
        return DamagerGroup_AddDamager(DamagerGroup , modelpath , GetLocationX(loc) , GetLocationY(loc) , LifeSpan)
    endfunction

 //*************************************************
 //* Damager functions
 //*
 //*************************************************
     function Damager_SetLifeSpan takes unit Damager,real lifespan returns nothing
      local integer dt
         if ( not IsUnitInGroup(Damager , CSDamagers__damagerflag) ) then
             return 
         endif
         set dt = (GetUnitUserData(Damager))
         if ( lifespan < CSDamagers__EPSILON ) then
             call PauseTimer(s__CSDamagers__damagerdata_lifespan[dt])
         else
             call TimerStart(s__CSDamagers__damagerdata_lifespan[dt] , lifespan , false , function CSDamagers__damagerExpires)
         endif
    endfunction

    function Damager_Remove takes unit Damager returns nothing
         if ( not IsUnitInGroup(Damager , CSDamagers__damagerflag) ) then
             return 
         endif
         call s__CSDamagers__damagerdata_destroy((GetUnitUserData(Damager)))
    endfunction

    function Damager_SetAbility takes unit Damager,integer abilid,integer l returns nothing
      local integer dt
         if ( not IsUnitInGroup(Damager , CSDamagers__damagerflag) ) then
             return 
         endif
         set dt = (GetUnitUserData(Damager))
         if ( s__CSDamagers__damagerdata_abil[dt] != abilid ) then
             if ( s__CSDamagers__damagerdata_abil[dt] != 0 ) then
                 call UnitRemoveAbility(Damager , s__CSDamagers__damagerdata_abil[dt])
             endif
             call UnitAddAbility(Damager , abilid)
             set s__CSDamagers__damagerdata_abil[dt]=abilid
         endif
         call SetUnitAbilityLevel(Damager , abilid , l)
    endfunction

 //========================================================================================
    function CSDamagers__init takes nothing returns nothing
        set CSDamagers__loggroup = CreateGroup()
        set CSDamagers__enumgroup = CreateGroup()
        set CSDamagers__damagerflag = CreateGroup()
        set CSDamagers__procfilter = Condition(function CSDamagers__processUnitsInRange)
    endfunction


//library CSDamagers ends




//===========================================================================
// Starting Units for Final Alliance Players
//   - 1 Town Hall, placed at start location
//   - 5 Peasants, placed between start location and nearest gold mine
//
function MeleeStartingUnitsFinalHumans takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
        call Preloader("scripts\\HumanMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h030' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peasants near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h030' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peasants directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h02Z' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'H035' , 'H036' , 'H037' , 'H038' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Orc Players
//   - 1 Great Hall, placed at start location
//   - 5 Peons, placed between start location and nearest gold mine
//
function MeleeStartingUnitsOrcDrae takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
        call Preloader("scripts\\OrcMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Great Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'lhav' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peons near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'llab' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Great Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'ogre' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peons directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'llab' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'llab' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( townHall != null ) then
        call UnitAddAbilityBJ('ALeh' , townHall)
        call UnitMakeAbilityPermanentBJ(true , 'ALeh' , townHall)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'Lwar' , 'Lsha' , 'Leds' , 'Ltob' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peons.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
	set townHall = null
endfunction

//===========================================================================
// Starting Units for Undead Players
//   - 1 Necropolis, placed at start location
//   - 1 Haunted Gold Mine, placed on nearest gold mine
//   - 3 Acolytes, placed between start location and nearest gold mine
//   - 1 Ghoul, placed between start location and nearest gold mine
//   - Blight, centered on nearest gold mine, spread across a "large area"
//
function MeleeStartingUnitsUndeadRis takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location nearTownLoc
    local location heroLoc
    local real peonX
    local real peonY
    local real ghoulX
    local real ghoulY

    if ( doPreload ) then
        call Preloader("scripts\\UndeadMelee.pld")
    endif
	
    call SetPlayerAbilityAvailable( whichPlayer,'A0UZ',true )

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer , 'uZZQ' , startLoc , bj_UNIT_FACING)
        
        // Replace the nearest gold mine with a blighted version.
        //set nearestMine = BlightGoldMineForPlayerBJ(nearestMine , whichPlayer)

        // Spawn Ghoul near the Necropolis.
        set nearTownLoc = MeleeGetProjectedLoc(startLoc , GetUnitLoc(nearestMine) , 288 , 0)
        set ghoulX = GetLocationX(nearTownLoc)
        set ghoulY = GetLocationY(nearTownLoc)
        set bj_ghoul[GetPlayerId(whichPlayer)]=CreateUnit(whichPlayer , 'uZZH' , ghoulX + 0.00 * unitSpacing , ghoulY + 0.00 * unitSpacing , bj_UNIT_FACING)

        set bj_ghoul[GetPlayerId(whichPlayer)]=CreateUnit(whichPlayer , 'uZZA' , ghoulX + 0.00 * unitSpacing , ghoulY + 0.00 * unitSpacing , bj_UNIT_FACING)

        set bj_ghoul[GetPlayerId(whichPlayer)]=CreateUnit(whichPlayer , 'u02O' , GetUnitX(nearestMine) , GetUnitY(nearestMine) , bj_UNIT_FACING)

        call IssueTargetOrder(bj_ghoul[GetPlayerId(whichPlayer)] , "entangleinstant" , nearestMine)
		
		
        // Spawn Acolytes near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'uZZF' , peonX + 0.00 * unitSpacing , peonY + 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZF' , peonX + 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZH' , peonX - 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)

        // Create a patch of blight around the gold mine.
        //call SetBlightLoc(whichPlayer , nearMineLoc , 768 , true)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer , 'uZZQ' , startLoc , bj_UNIT_FACING)
        
        // Spawn Acolytes and Ghoul directly south of the Necropolis.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'uZZF' , peonX - 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZF' , peonX - 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZH' , peonX + 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZH' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'uZZA' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u02O' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Create a patch of blight around the start location.
        //call SetBlightLoc(whichPlayer , startLoc , 768 , true)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'Udea' , 'Udre' , 'Ulic' , 'Ucrl' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Acolytes.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Night Elf Players
//   - 1 Tree of Life, placed by nearest gold mine, already entangled
//   - 5 Wisps, placed between Tree of Life and nearest gold mine
//
function MeleeStartingUnitsNightElfTide takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local real minTreeDist= 3.50 * bj_CELLWIDTH
    local real minWispDist= 1.75 * bj_CELLWIDTH
    local unit nearestMine
    local location nearMineLoc
    local location wispLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit tree

    if ( doPreload ) then
        call Preloader("scripts\\NightElfMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Tree of Life near the mine and have it entangle the mine.
        // Project the Tree's coordinates from the gold mine, and then snap
        // the X and Y values to within minTreeDist of the Gold Mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 650 , 0)
        set nearMineLoc = MeleeGetLocWithinRect(nearMineLoc , GetRectFromCircleBJ(GetUnitLoc(nearestMine) , minTreeDist))
        set tree = CreateUnitAtLoc(whichPlayer , 'etol' , nearMineLoc , bj_UNIT_FACING)
        call IssueTargetOrder(tree , "entangleinstant" , nearestMine)

        // Spawn Wisps at the start location.
        set wispLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set wispLoc = MeleeGetLocWithinRect(wispLoc , GetRectFromCircleBJ(GetUnitLoc(nearestMine) , minWispDist))
        set peonX = GetLocationX(wispLoc)
        set peonY = GetLocationY(wispLoc)
        call CreateUnit(whichPlayer , 'wser' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX + 0.58 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX - 0.58 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Tree of Life at the start location.
        call CreateUnitAtLoc(whichPlayer , 'etol' , startLoc , bj_UNIT_FACING)

        // Spawn Wisps directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'wser' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'wser' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'Edem' , 'Ekee' , 'Emoo' , 'Ewar' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Wisps.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
//
//ZEAR STARTING UNITS USE THE CASTER SYSTEM. TO VIEW MELEESTARTINGUNITSZEAR FUNCTION 
//DO A SEARCH IN THIS DOCUMENT.
//
//===========================================================================
// Starting Units for Freezing Legion Players
//   - 1 Frozen Hall, placed at start location
//   - 5 Frost Spirits, placed between start location and nearest gold mine
//
function MeleeStartingUnitsFreezingLegion takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
//        call Preloader( "scripts\\HumanMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Frozen Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h01C' , startLoc , bj_UNIT_FACING)
        
        // Spawn Frost Spirits near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'e014' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Frozen Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h01C' , startLoc , bj_UNIT_FACING)
        
        // Spawn Frost Spirits directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'e014' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e014' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'E016' , 'N03F' , 'U017' , 'N01O' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Northpact Players
//   - 1 Frozen Hall, placed at start location
//   - 5 Frost Spirits, placed between start location and nearest gold mine
//
function MeleeStartingUnitsNorthpact takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
//        call Preloader( "scripts\\HumanMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Frozen Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'fhal' , startLoc , bj_UNIT_FACING)
        
        // Spawn Frost Spirits near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Frozen Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'fhal' , startLoc , bj_UNIT_FACING)
        
        // Spawn Frost Spirits directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'ffrs' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'FHTR' , 'FLGM' , 'FCMP' , 'FMTR' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Void Players
//   - 1 Shrine of the Aether, placed at start location
//   - 7 Voidspawn, placed between start location and nearest gold mine
//
function MeleeStartingUnitsVoid takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
//        call Preloader( "scripts\\HumanMelee.pld" )
    endif

    call SetPlayerStateBJ(whichPlayer , PLAYER_STATE_RESOURCE_FOOD_CAP , 45)
	set rj_foodMax[GetPlayerId(whichPlayer)]=45
    call SetPlayerAbilityAvailable( whichPlayer,'A0S9',true   )

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Shrine of the Aether at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h012' , startLoc , bj_UNIT_FACING)
        call UnitAddAbility(townHall , 'A0H9') //This is an ability with no art and no effect that declares a unit is completed building, because there's no native for that
        call UnitMakeAbilityPermanent(townHall , true , 'A0H9')
        call IssueTargetOrder(townHall , "entangleinstant" , nearestMine) //Void will instantly activate gold drain from this
        
        // Spawn Voidspawn near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 0.60 * unitSpacing, peonY + 0.60 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 0.60 * unitSpacing, peonY - 0.60 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 0.60 * unitSpacing, peonY + 0.60 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 0.60 * unitSpacing, peonY - 0.60 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 0.00 * unitSpacing, peonY + 1.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 0.00 * unitSpacing, peonY - 1.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 0.00 * unitSpacing, peonY - 0.00 * unitSpacing, bj_UNIT_FACING)
//Void no longer use workers

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Shrine of the Aether at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h012' , startLoc , bj_UNIT_FACING)
        call UnitAddAbility(townHall , 'A0H9') //This is an ability with no art and no effect that declares a unit is completed building, because there's no native for that
        call UnitMakeAbilityPermanent(townHall , true , 'A0H9')
        
        // Spawn Frost Spirits directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
//        call CreateUnit(whichPlayer, 'e00D', peonX + 3.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX + 0.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 1.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 2.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)
//        call CreateUnit(whichPlayer, 'e00D', peonX - 3.00 * unitSpacing, peonY + 0.00 * unitSpacing, bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'U01H' , 'U01M' , 'U01L' , 'O01U' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Kaldorei Players
//   - 1 Tree of Life, placed at start location
//   - 5 wisps, placed between start location and nearest gold mine
//
function MeleeStartingUnitsKaldorei takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local real minTreeDist= 3.50 * bj_CELLWIDTH
    local real minWispDist= 1.75 * bj_CELLWIDTH
    local unit nearestMine
    local location nearMineLoc
    local location wispLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit tree

    if ( doPreload ) then
        call Preloader("scripts\\NightElfMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Tree of Life near the mine and have it entangle the mine.
        // Project the Tree's coordinates from the gold mine, and then snap
        // the X and Y values to within minTreeDist of the Gold Mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 650 , 0)
        set nearMineLoc = MeleeGetLocWithinRect(nearMineLoc , GetRectFromCircleBJ(GetUnitLoc(nearestMine) , minTreeDist))
        set tree = CreateUnitAtLoc(whichPlayer , 'e00M' , nearMineLoc , bj_UNIT_FACING)
        call IssueTargetOrder(tree , "entangleinstant" , nearestMine)

        // Spawn Wisps at the start location.
        set wispLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set wispLoc = MeleeGetLocWithinRect(wispLoc , GetRectFromCircleBJ(GetUnitLoc(nearestMine) , minWispDist))
        set peonX = GetLocationX(wispLoc)
        set peonY = GetLocationY(wispLoc)
        call CreateUnit(whichPlayer , 'e000' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX + 0.58 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX - 0.58 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Tree of Life at the start location.
        call CreateUnitAtLoc(whichPlayer , 'e00M' , startLoc , bj_UNIT_FACING)

        // Spawn Wisps directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'e000' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'e000' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'E00Z' , 'E010' , 'E011' , 'E012' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Wisps.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Undead Players
//   - 1 Necropolis, placed at start location
//   - 1 Haunted Gold Mine, placed on nearest gold mine
//   - 3 Acolytes, placed between start location and nearest gold mine
//   - 1 Ghoul, placed between start location and nearest gold mine
//   - Blight, centered on nearest gold mine, spread across a "large area"
//
function MeleeStartingUnitsScourge takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location nearTownLoc
    local location heroLoc
    local real peonX
    local real peonY
    local real ghoulX
    local real ghoulY

    if ( doPreload ) then
        call Preloader("scripts\\UndeadMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer , 'u00C' , startLoc , bj_UNIT_FACING)
        
        // Replace the nearest gold mine with a blighted version.
        set nearestMine = BlightGoldMineForPlayerBJ(nearestMine , whichPlayer) //I so love the editability of this function -- Retera 
																		     //                                              :|

        // Spawn Ghoul near the Necropolis.
        set nearTownLoc = MeleeGetProjectedLoc(startLoc , GetUnitLoc(nearestMine) , 288 , 0)
        set ghoulX = GetLocationX(nearTownLoc)
        set ghoulY = GetLocationY(nearTownLoc)
        set bj_ghoul[GetPlayerId(whichPlayer)]=CreateUnit(whichPlayer , 'u003' , ghoulX + 0.00 * unitSpacing , ghoulY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Spawn Acolytes near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'u001' , peonX + 0.00 * unitSpacing , peonY + 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u001' , peonX + 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u001' , peonX - 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)

        // Create a patch of blight around the gold mine.
        call SetBlightLoc(whichPlayer , nearMineLoc , 768 , true)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Necropolis at the start location.
        call CreateUnitAtLoc(whichPlayer , 'u00C' , startLoc , bj_UNIT_FACING)
        
        // Spawn Acolytes and Ghoul directly south of the Necropolis.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'u001' , peonX - 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u001' , peonX - 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u001' , peonX + 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'u003' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Create a patch of blight around the start location.
        call SetBlightLoc(whichPlayer , startLoc , 768 , true)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'U00Q' , 'U00R' , 'U00S' , 'U00T' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Acolytes.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Horde Players
//   - 1 Great Hall, placed at start location
//   - 5 Peons, placed between start location and nearest gold mine
//
function MeleeStartingUnitsHorde takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY

    if ( doPreload ) then
        call Preloader("scripts\\OrcMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Great Hall at the start location.
        call CreateUnitAtLoc(whichPlayer , 'o00C' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peons near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'o000' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Great Hall at the start location.
        call CreateUnitAtLoc(whichPlayer , 'o00C' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peons directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'o000' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'o000' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'O00O' , 'O00P' , 'O00Q' , 'O00R' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peons.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction

//===========================================================================
// Starting Units for Alliance Players
//   - 1 Town Hall, placed at start location
//   - 5 Peasants, placed between start location and nearest gold mine
//
function MeleeStartingUnitsAlliance takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local location nearMineLoc
    local location heroLoc
    local real peonX
    local real peonY
    local unit townHall= null

    if ( doPreload ) then
        call Preloader("scripts\\HumanMelee.pld")
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h000' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peasants near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'h001' , peonX + 0.00 * unitSpacing , peonY + 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX + 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX - 1.00 * unitSpacing , peonY + 0.15 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX + 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX - 0.60 * unitSpacing , peonY - 1.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Town Hall at the start location.
        set townHall = CreateUnitAtLoc(whichPlayer , 'h000' , startLoc , bj_UNIT_FACING)
        
        // Spawn Peasants directly south of the town hall.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'h001' , peonX + 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX + 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX + 0.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX - 1.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h001' , peonX - 2.00 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( townHall != null ) then
        call UnitAddAbilityBJ('Amic' , townHall)
        call UnitMakeAbilityPermanentBJ(true , 'Amic' , townHall)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'H00S' , 'H00T' , 'H00U' , 'H00V' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Peasants.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
endfunction


function MeleeInitVictoryDefeatB takes nothing returns nothing
    local trigger trig
    local integer index
    local player indexPlayer

    // Create a timer window for the "finish soon" timeout period, it has no timer
    // because it is driven by real time (outside of the game state to avoid desyncs)
    set bj_finishSoonTimerDialog = CreateTimerDialog(null)

    // Set a trigger to fire when we receive a "finish soon" game event
    set trig = CreateTrigger()
    call TriggerRegisterGameEvent(trig , EVENT_GAME_TOURNAMENT_FINISH_SOON)
    call TriggerAddAction(trig , function MeleeTriggerTournamentFinishSoon)

    // Set a trigger to fire when we receive a "finish now" game event
    set trig = CreateTrigger()
    call TriggerRegisterGameEvent(trig , EVENT_GAME_TOURNAMENT_FINISH_NOW)
    call TriggerAddAction(trig , function MeleeTriggerTournamentFinishNow)

    // Set up each player's mortality code.
    set index = 0
    loop
        set indexPlayer = Player(index)

        // Make sure this player slot is playing.
        if ( GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING ) then
            set bj_meleeDefeated[index]=false
            set bj_meleeVictoried[index]=false

            // Create a timer and timer window in case the player is crippled.
            set bj_playerIsCrippled[index]=false
            set bj_playerIsExposed[index]=false
            set bj_crippledTimer[index]=CreateTimer()
            set bj_crippledTimerWindows[index]=CreateTimerDialog(bj_crippledTimer[index])
            call TimerDialogSetTitle(bj_crippledTimerWindows[index] , MeleeGetCrippledTimerMessage(indexPlayer))

            // Set a trigger to fire whenever a building is cancelled for this player.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL , null)
            call TriggerAddAction(trig , function MeleeTriggerActionConstructCancel)

            // Set a trigger to fire whenever a unit dies for this player.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_DEATH , null)
            call TriggerAddAction(trig , function MeleeTriggerActionUnitDeath)

            // Set a trigger to fire whenever a unit begins construction for this player
            set trig = CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(trig , indexPlayer , EVENT_PLAYER_UNIT_CONSTRUCT_START , null)
            call TriggerAddAction(trig , function MeleeTriggerActionUnitConstructionStart)

            // Set a trigger to fire whenever this player defeats-out
            set trig = CreateTrigger()
            call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_DEFEAT)
            call TriggerAddAction(trig , function MeleeTriggerActionPlayerDefeated)

            // Set a trigger to fire whenever this player leaves
            set trig = CreateTrigger()
            call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_LEAVE)
            call TriggerAddAction(trig , function MeleeTriggerActionPlayerLeft)

            // Set a trigger to fire whenever this player changes his/her alliances.
            set trig = CreateTrigger()
            call TriggerRegisterPlayerAllianceChange(trig , indexPlayer , ALLIANCE_PASSIVE)
            call TriggerRegisterPlayerStateEvent(trig , indexPlayer , PLAYER_STATE_ALLIED_VICTORY , EQUAL , 1)
            call TriggerAddAction(trig , function MeleeTriggerActionAllianceChange)
        else
            set bj_meleeDefeated[index]=true
            set bj_meleeVictoried[index]=false

            // Handle leave events for observers
            if ( IsPlayerObserver(indexPlayer) ) then
                // Set a trigger to fire whenever this player leaves
                set trig = CreateTrigger()
                call TriggerRegisterPlayerEvent(trig , indexPlayer , EVENT_PLAYER_LEAVE)
                call TriggerAddAction(trig , function MeleeTriggerActionPlayerLeft)
            endif
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop

    // Test for victory / defeat at startup, in case the user has already won / lost.
    // Allow for a short time to pass first, so that the map can finish loading.
    call TimerStart(CreateTimer() , 2.0 , false , function MeleeTriggerActionAllianceChange)
endfunction






//*******************************************************
//****************************************************************************************
//Retera's Functions
//*****************************************************************************


// Old CSCache has been killed by the latest patch. It is unfortunately simply possible to port CSCache to
// the new hashtable functions.
//
// maps using CSCache will have to migrate, manually to something else, it should be easy to migrate to CSSafeCache + structs, yet not that easy.


function InitTrig_CSCache takes nothing returns nothing

endfunction

//*****************************************************
//* As of 15.3, CS does not need CSSafety, it will 
//* instead need TimerUtils and GroupUtils, this proxy
//* library is included if you still have stuff requiring
//* CSSafety in your map, so you can make it compatible
//* with Timer/GroupUtils
//*



//Deprecated functions appended to the caster system to make old spells work:

//CSCache for patch 1.24 and higher, modified without permission by Retera
//  to make old spells work without modification (and for personal use)
// AttachInt/String/Boolean/other basics removed because of their presence in CSSafeCache

//***************************************************************************
//*                                                                         *
//* CSCache 13.7                                                            *
//*                                                             *
//* Requires:                                                               *
//*                                                                *
//* - Required Variables (Make sure to have them)                           *
//*                                                                         *
//*     gamecache          udg_cscache                                      *
//*     integer  array     udg_csarray1                                     *
//*     integer  array     udg_csarray2                                     *
//*     location array     rdg_csfreeindexes                                *
//*                                                                         *
//* - The functions                                                         *
//*    Select all the text from //##Begin to engine##                      *
//*    Copy it to clipboard                                                *
//*    Go to your map and open its custom script section, and paste        *
//*                                                                         *
//* Note: The "Needed Variable CSCache" Trigger allows you to instantly     *
//*       copy the variable to your map instantly                           *
//*                                                                         *
//***************************************************************************


//##Begin of CS Gamecache engine 13.6 http://wc3campaigns.net/vexorian ##
//=================================================================================================
// GameCache - Return bug module : Without gamecache or return bug, JASS would be a
// retarded-limited scripting language.
//
//=================================================================================================
// a.k.a H2I, changed name to CS_H2I to prevent conflicts with other systems (I intended this
// system to be easy to copy
//

function CSTable takes nothing returns hashtable
    if rdg_cstable == null then
        set rdg_cstable = InitHashtable()
    endif
 return rdg_cstable
endfunction

function CSTableX takes nothing returns hashtable
    if rdg_cstablex == null then
        set rdg_cstablex = InitHashtable()
    endif
 return rdg_cstablex
endfunction

function CSCache takes nothing returns gamecache
    //if rdg_cscache==null then
        //This might be heavy and cause first-time cast lag. Try to create an array or store
        //to a table or something during map init so this does not happen during the game.
    //    call FlushGameCache(InitGameCache("cscacheXXX"))
        set rdg_cscache = InitGameCache("cscacheXXX")
    //endif
 return cs_cache
endfunction



//=============================================================================================================
function AttachObject takes handle h,string label,agent x returns nothing
    if ( x == null ) then
        call RemoveSavedHandle(CSTable() , GetHandleId(h) , StringHash(label))
    else
        call SaveAgentHandle(CSTable() , GetHandleId(h) , StringHash(label) , x)
    endif
endfunction
function GetAttachedObject takes handle h,string label returns agent
//    return LoadAgentHandle(CSTable(), GetHandleId(h), StringHash(label))
    return null
endfunction
function GetAttachedWidget takes handle h,string label returns widget
    return LoadWidgetHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedRect takes handle h,string label returns rect
    return LoadRectHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedRegion takes handle h,string label returns region
    return LoadRegionHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedTimerDialog takes handle h,string label returns timerdialog
    return LoadTimerDialogHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedUnit takes handle h,string label returns unit
    return LoadUnitHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedItem takes handle h,string label returns item
    return LoadItemHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedEffect takes handle h,string label returns effect
    return LoadEffectHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedDestructable takes handle h,string label returns destructable
    return LoadDestructableHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedTrigger takes handle h,string label returns trigger
    return LoadTriggerHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedTimer takes handle h,string label returns timer
    return LoadTimerHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedGroup takes handle h,string label returns group
    return LoadGroupHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function AttachTriggerAction takes handle h,string label,triggeraction x returns nothing
    if ( x == null ) then
        call RemoveSavedHandle(CSTable() , GetHandleId(h) , StringHash(label))
    else
        call SaveTriggerActionHandle(CSTable() , GetHandleId(h) , StringHash(label) , x)
    endif
endfunction
function GetAttachedTriggerAction takes handle h,string label returns triggeraction
    return LoadTriggerActionHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function AttachLightning takes handle h,string label,lightning x returns nothing
    if ( x == null ) then
        call RemoveSavedHandle(CSTable() , GetHandleId(h) , StringHash(label))
    else
        call SaveLightningHandle(CSTable() , GetHandleId(h) , StringHash(label) , x)
    endif
endfunction
function GetAttachedLightning takes handle h,string label returns lightning
    return LoadLightningHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function AttachTextTag takes handle h,string label,texttag x returns nothing
    if ( x == null ) then
        call RemoveSavedHandle(CSTable() , GetHandleId(h) , StringHash(label))
    else
        call SaveTextTagHandle(CSTable() , GetHandleId(h) , StringHash(label) , x)
    endif
endfunction
function GetAttachedTextTag takes handle h,string label returns texttag
    return LoadTextTagHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedFogModifier takes handle h,string label returns fogmodifier
    return LoadFogModifierHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedImage takes handle h,string label returns image
    return LoadImageHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedUbersplat takes handle h,string label returns ubersplat
    return LoadUbersplatHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedSound takes handle h,string label returns sound
    return LoadSoundHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedLoc takes handle h,string label returns location
    return LoadLocationHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction
function GetAttachedBoolExpr takes handle h,string label returns boolexpr
    return LoadBooleanExprHandle(CSTable() , GetHandleId(h) , StringHash(label))
    return null
endfunction


//============================================================================================================
// You may ask why am I using thousands of functions instead of multi-use return bug exploiters? Well,
// these make the thing much easier to read (in my opinion) and it is also better in performance since we
// have less function calls (H2U(GetTableObject("table","unit"))) would be worse than GetTableUnit that is
// quite direct.
//
function SetTableObject takes string table,string field,agent val returns nothing
        call SaveAgentHandle(CSTable() , StringHash(table) , StringHash(field) , val)
endfunction
function GetTableObject takes string table,string field returns handle
//    return GetStoredInteger(CSCache(),table,field)
    return null
endfunction
function GetTableWidget takes string table,string field returns widget
    return LoadWidgetHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableRect takes string table,string field returns rect
    return LoadRectHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableRegion takes string table,string field returns region
    return LoadRegionHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableTimerDialog takes string table,string field returns timerdialog
    return LoadTimerDialogHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableUnit takes string table,string field returns unit
    return LoadUnitHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableItem takes string table,string field returns item
    return LoadItemHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableEffect takes string table,string field returns effect
    return LoadEffectHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableDestructable takes string table,string field returns destructable
    return LoadDestructableHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableTrigger takes string table,string field returns trigger
    return LoadTriggerHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableTimer takes string table,string field returns timer
    return LoadTimerHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableGroup takes string table,string field returns group
    return LoadGroupHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableTriggerAction takes string table,string field returns triggeraction
    return LoadTriggerActionHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableLightning takes string table,string field returns lightning
    return LoadLightningHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableImage takes string table,string field returns image
    return LoadImageHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableUbersplat takes string table,string field returns ubersplat
    return LoadUbersplatHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableSound takes string table,string field returns sound
    return LoadSoundHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction
function GetTableLoc takes string table,string field returns location
    return LoadLocationHandle(CSTable() , StringHash(table) , StringHash(field))
    return null
endfunction

//====================================================================================================================================================================
function CS_KillTrigger takes trigger t returns nothing
    if ( t != null ) then
        call TriggerRemoveAction(t , GetAttachedTriggerAction(t , "ac"))
        call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
        call FlushChildHashtable(rdg_cstable, GetHandleId(t))
        call DestroyTrigger(t)
    endif
endfunction

function CS_KillTimer takes timer t returns nothing
    if ( t != null ) then
        call PauseTimer(t)
        call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
        call FlushChildHashtable(rdg_cstable, GetHandleId(t))
        call DestroyTimer(t)
    endif
endfunction




function RJ_CS_MoveUnit takes unit u,real x2,real y2 returns boolean
    if not IsTerrainPathable(GetUnitX(u) , GetUnitY(u) , ConvertPathingType(1)) then
    call CS_MoveUnit(u , x2 , y2)
    return false
    endif
    return true
endfunction




function RJ_Knockback takes unit victim,real angle,real distance,boolean doEffect returns nothing
 local location victimloc=GetUnitLoc(victim)
 local location resultloc=PolarProjectionBJ(victimloc , distance , angle)
 local real fh=(GetStoredReal(cs_cache , I2S(GetHandleId((victim ))) , ( "BaseFlyerHeightInt"))) // INLINED!!
 local real nfh=GetUnitFlyHeight(victim)
 local boolean sel=false
 local effect kbfx
if GetLocationX(victimloc) != GetLocationX(resultloc) then
if fh == 0 then
if nfh == 0 then
call AttachReal(victim , "BaseFlyerHeightInt" , - 999)
else
call AttachReal(victim , "BaseFlyerHeightInt" , nfh)
endif
elseif fh == - 999 then
set fh = 0
endif
    set sel = IsUnitSelected(victim , GetOwningPlayer(victim))
//    call SetUnitPositionLoc( GetAttackedUnitBJ(), PolarProjectionBJ(GetUnitLoc(GetAttackedUnitBJ()), 1000.00, AngleBetweenPoints(GetUnitLoc(GetAttacker()), GetUnitLoc(GetAttackedUnitBJ()))) )

       call UnitAddAbility(victim , (cs_FlyingHeightHack)) // INLINED!!
       call UnitRemoveAbility(victim , (cs_FlyingHeightHack)) // INLINED!!
//                                            call UnitMoveToAsProjectileAnySpeed(GetAttackedUnitBJ(),1000,0.25,GetLocationX(l),GetLocationY(l),null,GetUnitFlyHeight(GetAttackedUnitBJ()))
//        call ShowUnit(u,false)
        call PauseUnit(victim , true)
    if doEffect == true then
    set kbfx = AddSpecialEffectLoc("Abilities\\Weapons\\GlaiveMissile\\GlaiveMissileTarget.mdl" , victimloc)
    endif
        call UnitMoveToAsProjectileAnySpeed_Effect(victim , null , 1000 , 1 , GetLocationX(resultloc) , GetLocationY(resultloc) , null , fh)
        call SetUnitPosition(victim , GetLocationX(resultloc) , GetLocationY(resultloc))
        call SetUnitTimeScale(victim , 1)
        call PauseUnit(victim , false)
        call SetUnitFlyHeight(victim , fh , 1)
    if doEffect == true then
    call DestroyEffect(kbfx)
    endif
    if ( GetWidgetLife(victim) >= 1 ) then
        if sel then
            call SelectUnitAddForPlayer(victim , GetOwningPlayer(victim))
        endif
    endif
 endif //end the if for whether they're already there
 call RemoveLocation(victimloc)
 call RemoveLocation(resultloc)
 
 set victimloc = null
 set kbfx = null
 set resultloc = null
endfunction

function KS_AngleBetweenUnits takes unit unitA,unit unitB returns real
    return bj_RADTODEG * Atan2(GetUnitY(unitB) - GetUnitY(unitA) , GetUnitX(unitB) - GetUnitX(unitA))
endfunction

//function KS_DistanceBetweenUnits takes unit unitA, unit unitB returns real
 //   return SquareRoot(Pow(GetUnitX(unitB)-GetUnitX(unitA),2) + Pow(GetUnitY(unitB)-GetUnitY(unitA),2))
//endfunction

    //This is a function destined to replace PauseUnit
function KS_PauseUnit takes unit whichUnit,boolean flag returns nothing
    local integer pausenum= (GetStoredInteger(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_PauseNum"))) // INLINED!!
    local boolean waspaused= (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_WasPaused"))) // INLINED!!
    if ( waspaused and pausenum > 0 ) then //if the unit had waspaused and a pausenum,remove the pausenum
        set pausenum = 0 // (without this, if a unit entered a field paused, such as in a jump, then was unpaused,
    endif //     it could leave the field and re-enter, getting a waspaused of false and a pausenum of 2)
    if ( waspaused and not IsUnitPaused(whichUnit) ) then //if waspaused value was true, but the unit was unpaused, set waspaused to false
        call AttachBoolean(whichUnit , "KS_WasPaused" , false) //(if unit is unpaused by PauseUnit, this keeps track of it)
    endif
    if ( pausenum == 0 and IsUnitPaused(whichUnit) ) then //if unit was paused, but had no pausenum, the value is stored
        call AttachBoolean(whichUnit , "KS_WasPaused" , true) //(adds WasPaused when needed)
    endif
    if ( flag ) then
        set pausenum = pausenum + 1
    elseif ( pausenum > 0 ) then
        set pausenum = pausenum - 1
    endif
    call AttachInt(whichUnit , "KS_PauseNum" , pausenum)
    if ( pausenum == 0 and not (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_WasPaused"))) ) then // INLINED!!
        call PauseUnit(whichUnit , false)
    elseif ( pausenum > 0 ) then
        call PauseUnit(whichUnit , true)
    endif
endfunction

function KS_UnitAddAbilityStack takes unit whichUnit,integer abilitycode,boolean flag returns nothing
    local integer abilnum= (GetStoredInteger(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_AbilNum" + I2S(abilitycode)))) //use abilitycode so it works with multiple abilities // INLINED!!
    local boolean hadabil= (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) // INLINED!!
    if ( hadabil and abilnum > 0 ) then //as in KS_PauseUnit, avoids units with an ability before entering
        set abilnum = 0 //gaining a too high abilnum
    endif
    if ( hadabil and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then //checks if ability was removed by another function
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , false)
    endif
    if ( abilnum == 0 and ( GetUnitAbilityLevel(whichUnit , abilitycode) > 0 ) ) then //if unit had the ability, but had no abilnum,
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , true) //the value is stored
    endif
    if ( flag ) then
        set abilnum = abilnum + 1
    elseif ( abilnum > 0 ) then
        set abilnum = abilnum - 1
    endif
    call AttachInt(whichUnit , "KS_AbilNum" + I2S(abilitycode) , abilnum)
    if ( abilnum == 0 and not (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) ) then // INLINED!!
        call UnitRemoveAbility(whichUnit , abilitycode)
    elseif ( ( abilnum > 0 ) and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then
        call UnitAddAbility(whichUnit , abilitycode)
    endif
endfunction

function KS_UnitAddAbilityLevel takes unit whichUnit,integer abilitycode,boolean flag returns nothing
    local integer abilnum= (GetStoredInteger(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_AbilNum" + I2S(abilitycode)))) //use abilitycode so it works with multiple abilities // INLINED!!
    local boolean hadabil= (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) // INLINED!!
    if ( hadabil and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then //checks if ability was removed by another function
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , false)
    endif
    if ( abilnum == 0 and ( GetUnitAbilityLevel(whichUnit , abilitycode) > 0 ) ) then //if unit had the ability, but had no abilnum,
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , true) //the value is stored
        set abilnum = GetUnitAbilityLevel(whichUnit , abilitycode)
    endif
    if ( flag ) then
        set abilnum = abilnum + 1
    elseif ( abilnum > 0 ) then
        set abilnum = abilnum - 1
    endif
    call AttachInt(whichUnit , "KS_AbilNum" + I2S(abilitycode) , abilnum)
    if ( abilnum == 0 and not (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) ) then // INLINED!!
        call UnitRemoveAbility(whichUnit , abilitycode)
    elseif ( ( abilnum > 0 ) and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then
        call UnitAddAbility(whichUnit , abilitycode)
    elseif ( abilnum > 0 and GetUnitAbilityLevel(whichUnit , abilitycode) > 0 ) then
        call SetUnitAbilityLevel(whichUnit , abilitycode , abilnum)
    endif
endfunction

function KS_UnitAddAbilityStack2 takes unit whichUnit,integer abilitycode,boolean flag returns nothing
    local integer abilnum= (GetStoredInteger(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_AbilNum" + I2S(abilitycode)))) //use abilitycode so it works with multiple abilities // INLINED!!
    local boolean hadabil= (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) // INLINED!!
    if ( hadabil and abilnum > 0 ) then //as in KS_PauseUnit, avoids units with an ability before entering
        set abilnum = 0 //gaining a too high abilnum
    endif
    if ( hadabil and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then //checks if ability was removed by another function
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , false)
    endif
    if ( abilnum == 0 and ( GetUnitAbilityLevel(whichUnit , abilitycode) > 0 ) ) then //if unit had the ability, but had no abilnum,
        call AttachBoolean(whichUnit , "KS_HadAbil" + I2S(abilitycode) , true) //the value is stored
    endif
    if ( flag ) then
        set abilnum = abilnum + 1
    elseif ( abilnum > 0 ) then
        set abilnum = abilnum - 1
    endif
    call AttachInt(whichUnit , "KS_AbilNum" + I2S(abilitycode) , abilnum)
    if ( abilnum == 0 and not (GetStoredBoolean(cs_cache , I2S(GetHandleId((whichUnit ))) , ( "KS_HadAbil" + I2S(abilitycode)))) ) then // INLINED!!
        call UnitRemoveAbility(whichUnit , abilitycode)
    elseif ( ( abilnum > 0 ) and ( GetUnitAbilityLevel(whichUnit , abilitycode) == 0 ) ) then
        call UnitAddAbility_ConsiderEvent(whichUnit , abilitycode , 1)
    endif
endfunction


//*************************************************************************************************
//*
//*  Alternative Spell Templates System
//*
//* Requires:
//*          - Special Events Functions
//*          - udg_spelltemplates gamecache variable
//*
//*    To be able to use The spell Templates in your map, or to make your own spell templates,
//*  First make sure you have the udg_spelltemplates gamecache variable, Either use next
//* "Variable Copying Trigger" or create iot with your variable editor.
//*
//*    After that, you have to copy this to your map's custom script section!
//* (The Custom Script Section Is at the top of the list of the triggers and has the Map's name.)
//*
//* Note: Make sure you paste the functions bellow the Special Events functions.
//*
//*    Select the text from the //##Start## to the //##End## and copy it to the custom script
//* section that is at the top of the trigger list and has your map's name.
//*
//*    After copying them and saving in your map, you need to call SetupSpecialEvents() at map
//*  Initialization in order to allow the system to work. (check next trigger)
//*
//*    If you already have them in your map, Delete the ones in your map, then copy these ones,
//*  this is a new version that fixes some memory leaks that were blizzard's fault, also the
//*  Special Events functions have a new option.
//*
//*   In theory, you may just copy the trigger, making sure it is above any other trigger, then
//* Instantly save, this is easier, but may not work well.
//*
//*************************************************************************************************
//==================================================================================================
//
// For more JASS scripts, visit : http://www.wc3JASS.com
//
//==================================================================================================

//==================================================================================================
function AbiCache takes nothing returns gamecache
    if udg_spelltemplates == null then
        call FlushGameCache(InitGameCache("spells.vx"))
        set udg_spelltemplates = InitGameCache("spells.vx")
    endif
 return udg_spelltemplates
endfunction

//==================================================================================================
// Old version:
// Setups A template (function name) for an ability abid, if uselearnevent is true it will only
// Work for A hero learns a skill events.
//
function SetAbilityTemplate takes integer abid,string func,boolean uselearnevent returns nothing
    if uselearnevent then
        call OnAbilityLearn(abid , func)
    else
        call OnAbilityEffect(abid , func)
    endif
    call StoreString(AbiCache() , "funcs" , I2S(abid) , func)
endfunction

//==================================================================================================
// Setups A template (function name) for an ACTIVE ability abid
//
function SetSpellTemplate takes integer abid,string func returns integer
    call OnAbilityEffect(abid , func)
    call StoreString(AbiCache() , "funcs" , I2S(abid) , func)
 return abid
endfunction

//============================================================================================================
// Setups A template (function name) for a PASSIVE ability abid, the ability won't work if added by triggers
//
function SetPassiveTemplate takes integer abid,string func returns integer
    call OnAbilityGet(abid , func)
    call StoreString(AbiCache() , "funcs" , I2S(abid) , func)
 return abid
endfunction

//============================================================================================================
// Determine a Spell Template (function)'s default value for a datafield
// This is not a necessary step, just an useful step (integers and reals default as 0, strings as
// null, without this step)
//
function SetTemplateDefaultInt takes string func,string datafield,integer value returns nothing
    call StoreInteger(AbiCache() , func , datafield , value)
endfunction

function SetTemplateDefaultReal takes string func,string datafield,real value returns nothing
    call StoreReal(AbiCache() , func , datafield , value)
endfunction

function SetTemplateDefaultString takes string func,string datafield,string value returns nothing
    call StoreString(AbiCache() , func , datafield , value)
endfunction

//==================================================================================================
// Set the value of an spell's datafield for an specific level, if specified level is 0, it will be
// the new default for all the levels of the ability
//
function SetAbilityDataString takes integer abid,string datafield,integer l,string value returns nothing
    call StoreString(AbiCache() , I2S(abid) , datafield + I2S(l) , value)
endfunction

function SetAbilityDataInt takes integer abid,string datafield,integer l,integer value returns nothing
    call StoreInteger(AbiCache() , I2S(abid) , datafield + I2S(l) , value)
endfunction

function SetAbilityDataReal takes integer abid,string datafield,integer l,real value returns nothing
    call StoreReal(AbiCache() , I2S(abid) , datafield + I2S(l) , value)
endfunction

//==================================================================================================
// When spells have too much levels it is now possible to use formulae
// The resulting number is ( initial + [(current level of spell)^lpower]*lfactor
//
function SetAbilityFormulaInt takes integer abid,string datafield,integer initial,real lpower,real lfactor returns nothing
 local gamecache a=AbiCache()
 local string s=I2S(abid)

    call StoreInteger(a , s , datafield + "0" , initial)
    call StoreReal(a , s , datafield + "#fc" , lfactor)
    call StoreReal(a , s , datafield + "#pw" , lpower)

 set a = null
endfunction

function SetAbilityFormulaReal takes integer abid,string datafield,real initial,real lpower,real lfactor returns nothing
 local gamecache a=AbiCache()
 local string s=I2S(abid)

    call StoreReal(a , s , datafield + "0" , initial)
    call StoreReal(a , s , datafield + "#fc" , lfactor)
    call StoreReal(a , s , datafield + "#pw" , lpower)

 set a = null
endfunction

//==================================================================================================
// Read the value for a datafield of a spell's level, better keep some local level and spell
// variables to use these.
//
function GetAbilityDataInt takes integer s,integer l,string datafield returns integer
 local gamecache a=AbiCache()
 local integer r=0
 local string sk=I2S(s)
 local boolean b=false
 local string sl=datafield + I2S(l)

    if HaveStoredInteger(a , sk , sl) then
        set r = GetStoredInteger(a , sk , sl)

    elseif HaveStoredInteger(a , sk , datafield + "0") then
        set r = GetStoredInteger(a , sk , datafield + "0")

        if HaveStoredReal(a , sk , datafield + "#fc") then
            set r = r + R2I(0.5 + Pow(l , GetStoredReal(a , sk , datafield + "#pw")) * GetStoredReal(a , sk , datafield + "#fc"))
            //0.5 makes it round the value
        endif
        set b = true

    elseif HaveStoredString(a , "funcs" , sk) then
        set r = GetStoredInteger(a , GetStoredString(a , "funcs" , I2S(s)) , datafield)
        set b = true
    endif
    if ( b ) then
        // This will make it faster next time it is used on the same datafield and levels,
        // but slower the first time.
        call StoreInteger(a , sk , sl , r)
    endif
 set a = null
 return r
endfunction

//==================================================================================================
function GetAbilityDataReal takes integer s,integer l,string datafield returns real
 local gamecache a=AbiCache()
 local real r=0
 local string sk=I2S(s)
 local boolean b=false
 local string sl=datafield + I2S(l)
    if HaveStoredReal(a , sk , sl) then
        set r = GetStoredReal(a , sk , sl)
    elseif HaveStoredReal(a , sk , datafield + "0") then
        set r = GetStoredReal(a , sk , datafield + "0")
        if HaveStoredReal(a , sk , datafield + "#fc") then
            set r = r + Pow(l , GetStoredReal(a , sk , datafield + "#pw")) * GetStoredReal(a , sk , datafield + "#fc")
        endif
        set b = true
    elseif HaveStoredString(a , "funcs" , sk) then
        set r = GetStoredReal(a , GetStoredString(a , "funcs" , sk) , datafield)
        set b = true
    endif
    if ( b ) then
        // This will make it faster next time it is used on the same datafield and levels,
        // but slower the first time.
        call StoreReal(a , sk , sl , r)
    endif
 set a = null
 return r
endfunction

//==================================================================================================
function GetAbilityDataString takes integer s,integer l,string datafield returns string
 local gamecache a=AbiCache()
 local string r=""
 local string sk=I2S(s)
    if HaveStoredString(a , sk , datafield + I2S(l)) then
        set r = GetStoredString(a , sk , datafield + I2S(l))
    elseif HaveStoredString(a , sk , datafield + "0") then
        set r = GetStoredString(a , sk , datafield + "0")
    elseif HaveStoredString(a , "funcs" , sk) then
        set r = GetStoredString(a , GetStoredString(a , "funcs" , sk) , datafield)
    endif
 set a = null
 return r
endfunction
//##End##

//##Start##
//**************************************************************************************************
//*
//*  GrupAddUnitsInTriange (Polygonal madness)
//*
//*     To implement this function, you must select the contents of this trigger starting
//*   with the //##Start## and finishing with the //##End##, and copy that TO YOUR MAP's
//*   CUSTOM SCRIPT SECTION, (it is at the top of the trigger list in the trigger editor)
//*
//*     DON'T JUST COPY THE TRIGGER; copy this to the custom script section
//*
//*     (If you already have these functions in your map don't copy these ones)
//*
//**************************************************************************************************

//==================================================================================================
//
// For more JASS functions, visit : http://www.wc3JASS.com
//
//==================================================================================================

//==================================================================================================
function GroupAddUnitsInTriangle_AngleCheck takes real angle,real angle1,real angle2,real PI2 returns boolean
 local real x
    if ( angle1 > angle2 ) then
        set x = angle1
        set angle1 = angle2
        set angle2 = x
    endif
    if ( angle2 - angle1 > angle1 - ( angle2 - PI2 ) ) then
        set angle2 = angle2 - PI2
        if ( angle < bj_PI ) then
            set angle = angle - PI2
        endif
        return ( angle >= angle2 ) and ( angle <= angle1 )
    endif
 return ( angle >= angle1 ) and ( angle <= angle2 )
endfunction

function GetRectThatLimitsTriangle takes real x1,real y1,real x2,real y2,real x3,real y3 returns rect
 local real maxx
 local real minx
    if ( x1 > x2 ) then
        if ( x2 > x3 ) then //x1>x2>x3
            set maxx = x1
            set minx = x3
        elseif ( x3 > x1 ) then //x3>x1>x2
            set maxx = x3
            set minx = x2
        else //x3>x1>x2
            set maxx = x1
            set minx = x2
        endif
    elseif ( x1 > x3 ) then //x2>x1>x3
        set maxx = x2
        set minx = x3
    elseif ( x3 > x2 ) then //x3>x2>x1 
        set maxx = x3
        set minx = x1
    else //x2>x3>x1
        set maxx = x2
        set minx = x1
    endif

    if ( y1 > y2 ) then
        if ( y2 > y3 ) then //y1>y2>y3
            return Rect(minx , y3 , maxx , y1)
        elseif ( y3 > y1 ) then //y3>y1>y2
            return Rect(minx , y2 , maxx , y3)
        else //y3>y1>y2
            return Rect(minx , y2 , maxx , y1)
        endif
    elseif ( y1 > y3 ) then //y2>y1>y3
        return Rect(minx , y3 , maxx , y2)
    elseif ( y3 > y2 ) then //y3>y2>y1 
        return Rect(minx , y1 , maxx , y3)
    endif
 //y2>y3>y1
 return Rect(minx , y1 , maxx , y2)
endfunction



function GroupAddUnitsInTriangle takes group whichGroup,real x1,real y1,real x2,real y2,real x3,real y3 returns nothing
 local rect semi=GetRectThatLimitsTriangle(x1 , y1 , x2 , y2 , x3 , y3)
 local group inrect=CreateGroup()
 local unit picked
 local real x
 local real y
 local real alpha=Atan2(y2 - y1 , x2 - x1)
 local real beta=Atan2(y3 - y1 , x3 - x1)
 local real gama=Atan2(y1 - y2 , x1 - x2)
 local real delta=Atan2(y3 - y2 , x3 - x2)
 local real PI2=bj_PI + bj_PI

    call GroupEnumUnitsInRect(inrect , semi , null)
    loop
        set picked = FirstOfGroup(inrect)
        exitwhen picked == null
        set x = GetUnitX(picked)
        set y = GetUnitY(picked)
        if IsUnitInGroup(picked , whichGroup) then
        elseif ( GroupAddUnitsInTriangle_AngleCheck(Atan2(y - y1 , x - x1) , alpha , beta , PI2) and GroupAddUnitsInTriangle_AngleCheck(Atan2(y - y2 , x - x2) , gama , delta , PI2) ) then
            call GroupAddUnit(whichGroup , picked)
        endif
        call GroupRemoveUnit(inrect , picked)
    endloop
 call RemoveRect(semi)
 call DestroyGroup(inrect)
 set whichGroup = null
 set picked = null
 set semi = null
 set inrect = null
endfunction
//##end##


//***************************************************************************************************
//*
//*  Obsolete Functions for Aura Template
//*
//*
//***************************************************************************************************


//============================================================================================================
// Attached Sets: Attachable Sets are handy in some situations and are a part of attachable variables,
// you can add integers or objects to a set, order doesn't matter and adding the same object twice is
// meaningless. CleanAttachedVars is always ready to clean every set owned by the handle.
//
//============================================================================================================
function AttachedSetAddInt takes handle h,string setn,integer int returns nothing
 local gamecache g=cs_cache
 local string k=I2S((GetHandleId((h)))) // INLINED!!
 local integer n
 local integer x=GetStoredInteger(g , k , "#setnumberof;" + setn)
 local integer y
    if x == 0 then
        set y = GetStoredInteger(g , k , "#totalsets") + 1
        call StoreInteger(g , k , "#totalsets" , y)
        call StoreInteger(g , k , "#setnumberof;" + setn , y)
        call StoreString(g , k , "#setName;" + I2S(y) , setn)
    endif
    set k = k + ";" + setn
    if not HaveStoredInteger(g , k , "Pos" + I2S(int)) then
        set n = GetStoredInteger(g , k , "n") + 1
        call StoreInteger(g , k , "n" , n)
        call StoreInteger(g , k , I2S(n) , int)
        call StoreInteger(g , k , "Pos" + I2S(int) , n)
    endif
 set g = null
endfunction

//============================================================================================================
function AttachedSetHasInt takes handle h,string setn,integer int returns boolean
    return HaveStoredInteger(cs_cache , I2S((GetHandleId((h)))) + ";" + setn , "Pos" + I2S(int)) // INLINED!!
endfunction

//============================================================================================================
function AttachedSetRemInt takes handle h,string setn,integer int returns nothing
 local gamecache g=cs_cache
 local string k=I2S((GetHandleId((h)))) + ";" + setn // INLINED!!
 local integer n
 local integer x
 local integer y
    if HaveStoredInteger(g , k , "Pos" + I2S(int)) then
        set x = GetStoredInteger(g , k , "Pos" + I2S(int))
        set n = GetStoredInteger(g , k , "n")
        if x != n then
            set y = GetStoredInteger(g , k , I2S(n))
            call StoreInteger(g , k , I2S(x) , y)
            call StoreInteger(g , k , "Pos" + I2S(y) , x)
        endif
        call FlushStoredInteger(g , k , "Pos" + I2S(int))
        call FlushStoredInteger(g , k , I2S(n))
        call StoreInteger(g , k , "n" , n - 1)
    endif
 set g = null
endfunction

//===========================================================================
function InitTrig_SpellTemplateSystem takes nothing returns nothing
endfunction


























//===================================================================================================
// Nova template code:
//
function NovaTemplate_DoStuff takes unit u,unit t,integer s,integer l,real fc returns nothing
 local real dmg=GetAbilityDataReal(s , l , "dmg")
 local real dmgps=GetAbilityDataReal(s , l , "Pdmg")
 local integer ab=GetAbilityDataInt(s , l , "Spell")
 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0)
    if ( dmg != 0 ) then
        call UnitDamageTarget(u , t , dmg * fc , true , false , null , null , null)
    endif
    if ( dmgps != 0 ) then
        call UnitDamageUnitTimed(u , dmgps * fc , GetAbilityDataReal(s , l , "PdmgPeriod") , GetAbilityDataReal(s , l , "PdmgDur") , t , fx , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1) , null , null)
    elseif ( fx != "" ) and ( fx != null ) then
        call DestroyEffect(AddSpecialEffectTarget(fx , t , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)))
    endif
    if ( ab != 0 ) then
        call CasterCastAbilityEx(GetOwningPlayer(u) , GetUnitX(t) , GetUnitY(t) , 0 , ab , l , I2S(GetAbilityDataInt(s , l , "OrderId")) , t , GetAbilityDataReal(s , l , "RecDelay"))
    endif
endfunction

function NovaTemplate_Collision takes nothing returns nothing
 local trigger x=GetTriggeringTrigger()
 local unit t=GetTriggerUnit()
 local unit u=GetAttachedUnit(x , "u")
 local integer s=(GetStoredInteger(cs_cache , I2S(GetHandleId((x ))) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , I2S(GetHandleId((x ))) , ( "l"))) // INLINED!!

 local real fc=0

 local group g=GetAttachedGroup(x , "g")

    if ( ( g == null ) or not ( IsUnitInGroup(t , g) ) ) then
        set fc = GetDamageFactorByOptions(u , t , LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions")))
    endif

    if ( fc != 0 ) then
        if ( g != null ) then
            call GroupAddUnit(g , t)
        endif
        call NovaTemplate_DoStuff(u , t , s , l , fc)
    endif

 set g = null
 set u = null
 set x = null
 set t = null
endfunction

function NovaTemplate_AI takes nothing returns nothing
 local unit m=bj_lastCreatedUnit
 local unit u=bj_meleeNearestMine
 local integer l=R2I(rdg_castervars[9])
 local integer s=rdg_currentabi
 local integer abi=GetAbilityDataInt(s , l , "abil")
 local real inc=GetAbilityDataReal(s , l , "turninc")
 local real dir=GetAbilityDataReal(s , l , "scale")
 local real dirr

 local trigger t=CreateTrigger()
 local triggeraction ac=TriggerAddAction(t , function NovaTemplate_Collision)
 local group g=null
 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 0)

    set dirr = GetAbilityDataReal(s , l , "collision")
    if ( dirr != 0 ) then
        call AttachInt(t , "s" , s)
        call AttachInt(t , "l" , l)
        call AttachObject(t , "u" , u)
        if ( GetAbilityDataInt(s , l , "TargetLog") == 1 ) then
            set g = GetAttachedGroup(u , "Nova_" + I2S(s) + "_Group")
            if ( g == null ) then
                set g = CreateGroup()
                call AttachObject(u , "Nova_" + I2S(s) + "_Group" , g)
                call AttachObject(t , "g" , g)
            else
                call AttachObject(t , "g" , g)
                set g = null
            endif
        else
            call AttachObject(t , "g" , null)
        endif
        call TriggerRegisterUnitInRange(t , m , dirr , null)

    endif

    call SetUnitScale(m , dir , dir , dir)
    set dir = rdg_castervars[8]
    call SetUnitFlyHeight(m , 100 , 0)
    call SetUnitMoveSpeed(m , 300)
    loop
        set dirr = dir * bj_DEGTORAD
        call IssuePointOrder(m , "move" , GetUnitX(m) + 200 * Cos(dirr) , GetUnitY(m) + 200 * Sin(dirr))
        exitwhen ( ( GetUnitAbilityLevel(m , abi) == 0 ) or ( GetUnitCurrentOrder(m) != OrderId("move") ) )
        if ( ( fx != "" ) and ( fx != null ) ) then
            call DestroyEffect(AddSpecialEffectTarget(fx , m , "origin"))
        endif
        set dir = dir + inc
        call TriggerSleepAction(0)
    endloop
    call TriggerRemoveAction(t , ac)
    call DestroyTrigger(t)
    if ( g != null ) then
        call AttachObject(u , "Nova_" + I2S(s) + "_Group" , null)
        call DestroyGroup(g)
       set g = null
    endif

 set ac = null
 set t = null
 set m = null
 set u = null
endfunction

function NovaSpellTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)

 local real speed=GetAbilityDataReal(s , l , "speed")
 local real dur=GetAbilityDataReal(s , l , "dur")
 local integer abil=GetAbilityDataInt(s , l , "abil")
 local integer n=GetAbilityDataInt(s , l , "n")

    set rdg_castervars[8]=0
    set rdg_castervars[9]=l
    set bj_meleeNearestMine = u
    loop
        exitwhen rdg_castervars[8] >= 360
        set bj_lastCreatedUnit = CasterUseAbilityLevelStatic(GetOwningPlayer(u) , GetAbilityEffectById(s , EFFECT_TYPE_MISSILE , 0) , abil , l , dur , GetUnitX(u) , GetUnitY(u))
        call SetUnitMoveSpeed(bj_lastCreatedUnit , speed)
        set rdg_currentabi = s
        call ExecuteFunc("NovaTemplate_AI")
        set rdg_castervars[8]=rdg_castervars[8] + 360 / n
    endloop

 set u = null
endfunction




//===================================================================================================
// code:
//
function TimedBarrelTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local location loc=GetSpellTargetLoc()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer t=GetAbilityDataInt(s , l , "timeout")
 local unit barrel=GetACaster()
 local effect fx
 local texttag Float
 local real scale=GetAbilityDataReal(s , l , "scale")

    call SetUnitPositionLoc(barrel , loc)
    call SetUnitScale(barrel , scale , scale , scale)
    set fx = AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , barrel , "origin")
    call SetUnitOwner(barrel , GetOwningPlayer(u) , true)
    set Float = CreateTextTagUnitBJ("" , barrel , 50 , 15 , 100 , 0 , 0 , 0)
    loop
        exitwhen t == 0
        call SetTextTagText(Float , I2S(t) , TextTagSize2Height(15))
        call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , barrel , "chest"))
        call PolledWait(1)
        set t = t - 1
    endloop
    call DestroyTextTag(Float)
    call DestroyEffect(fx)
    //set rdg_delayhack = 4
    call CasterSetRecycleDelay(4.0)
    call RecycleCasterAfterCastEx((barrel ) , udg_delayhack , ( 0) , false) // INLINED!!
    call CasterSetRecycleDelay(GetAbilityDataReal(s , l , "delay"))
    set scale = GetAbilityDataReal(s , l , "damage")
    if scale != 0 then
        call DamageUnitsInAOEExLoc(u , scale , loc , GetAbilityDataReal(s , l , "area") , true , LoadDamageOptions(GetAbilityDataInt(s , l , "damageoptions")))
    endif
    call CasterCastAbilityLevelPointLoc(GetOwningPlayer(u) , GetAbilityDataInt(s , l , "abil") , l , I2S(GetAbilityDataInt(s , l , "orderid")) , loc , false)
 call RemoveLocation(loc)
 set rdg_delayhack = 0
 set Float = null
 set barrel = null
 set loc = null
 set u = null
endfunction





//===================================================================================================
// code:
//
function ChargeSpellTemplate takes nothing returns nothing
 local location target=GetSpellTargetLoc()
 local integer t=0
 local trigger end=CreateTrigger()
 local unit horseman=GetTriggerUnit()
 local location loc=GetUnitLoc(horseman)
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(horseman , s)
 local effect shock=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , horseman , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
 local real sp
 local timer dur=CreateTimer()
 local real next=0
 local unit da=null
 local unit db=null
 local integer h=GetTerrainCliffLevelBJ(loc)
 local boolean img= GetAbilityDataInt(s , l , "eyecandy") == 1
 local boolean cliffcheck= GetAbilityDataInt(s , l , "cliffcheck") == 1
 local integer n=GetAbilityDataInt(s , l , "abiln")
 local integer a=n
 local integer array abi

 local integer spell=GetAbilityDataInt(s , l , "spellid")
 local integer orderid=GetAbilityDataInt(s , l , "orderid")
 local real delay=GetAbilityDataReal(s , l , "delay")

 local real dmg=GetAbilityDataReal(s , l , "damage")
 local integer dmgid=GetAbilityDataInt(s , l , "damageoptions")
 local real area=GetAbilityDataReal(s , l , "area")
 local boolean all=GetAbilityDataInt(s , l , "hurtallies") == 1
 local boolean nopathing= GetAbilityDataInt(s , l , "nopathing") == 1

 local real acq
    loop
        exitwhen a == 0
        set abi[a]=GetAbilityDataInt(s , l , "abil" + I2S(a) + "id")
        call UnitAddAbility(horseman , abi[a])
        set a = a - 1
    endloop
    if nopathing then
        call SetUnitPathing(horseman , false)
    endif
    call TimerStart(dur , GetAbilityDataReal(s , l , "durlimit") , false , null)
    call UnitRemoveBuffs(horseman , true , true)
    set sp = GetUnitMoveSpeed(horseman)
    set acq = GetUnitAcquireRange(horseman)
    call SetUnitAcquireRange(horseman , 0.01)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_DEATH)
    loop
        if cliffcheck and GetTerrainCliffLevel(GetUnitX(horseman) , GetUnitY(horseman)) != h then
             call SetUnitPositionLoc(horseman , loc)
        endif
        call MoveLocation(loc , GetUnitX(horseman) , GetUnitY(horseman))
        exitwhen GetTriggerEvalCount(end) > t or TimerGetRemaining(dur) <= 0
        exitwhen DistanceBetweenPoints(loc , target) < 50.00
        call IssuePointOrderLoc(horseman , "move" , target)
        set t = t + 1
        if TimerGetElapsed(dur) >= next then
            set rdg_delayhack = delay
            call CasterSetRecycleDelay(delay)
            call CasterCastAbilityLevelPoint(GetOwningPlayer(horseman) , spell , l , I2S(orderid) , GetUnitX(horseman) , GetUnitY(horseman) , false)
            set rdg_delayhack = 0
            if dmg != 0 then
                call DamageUnitsInAOEEx(horseman , dmg , GetUnitX(horseman) , GetUnitY(horseman) , area , all , LoadDamageOptions(dmgid))
            endif
            set next = next + 0.25
            if img then
                call RemoveUnit(db)
                set db = da
                set da = CreateUnit(Player(15) , GetUnitTypeId(horseman) , 0 , 0 , GetUnitFacing(horseman))
                call UnitAddAbility(da , 'Aloc')
                call SetUnitColor(da , GetPlayerColor(GetOwningPlayer(horseman)))
                call SetUnitPosition(da , GetUnitX(horseman) , GetUnitY(horseman))
                call SetUnitVertexColor(da , 255 , 255 , 255 , 127)
                call SetUnitVertexColor(db , 255 , 255 , 255 , 63)
                call SetUnitTimeScale(da , 0)
            endif
        endif
        call TriggerSleepAction(0)
    endloop
    if nopathing then
        call SetUnitPathing(horseman , true)
    endif
    call RemoveLocation(loc)
    call TriggerSleepAction(0)
    call SetUnitPathing(horseman , true)
    call SetUnitAcquireRange(horseman , acq)
    set a = n
    loop
        exitwhen a == 0
        call UnitRemoveAbility(horseman , abi[a])
        set a = a - 1
    endloop
    call RemoveUnit(db)
    call TriggerSleepAction(0)
    call RemoveUnit(da)
 call DestroyTimer(dur)
 call DestroyEffect(shock)
 call RemoveLocation(target)
 call DestroyTrigger(end)
 set shock = null
 set target = null
 set loc = null
 set horseman = null
 set end = null
 set dur = null
 set da = null
 set db = null
endfunction





//===================================================================================================
// code:
//
function FireSpawnerTemplate takes nothing returns nothing

 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local real dur=GetAbilityDataReal(s , l , "duration")
 local real per=GetAbilityDataReal(s , l , "period")
 local real dmg=GetAbilityDataReal(s , l , "damage")
 local real rad=GetAbilityDataReal(s , l , "area")
 local boolean bol=GetAbilityDataInt(s , l , "affectallied") == 1
 local real x=rad / 2
 local location loc=GetSpellTargetLoc()
 local integer i= GetAbilityDataInt(s , l , "n")
 local integer dopt=LoadDamageOptions(GetAbilityDataInt(s , l , "damageoptions"))


    loop
        exitwhen i == 0
        call AddAreaDamagerForUnit(u , GetAbilityEffectById(s , EFFECT_TYPE_AREA_EFFECT , 0) , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 0) , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 1) , GetLocationX(loc) + GetRandomReal(- x , x) , GetLocationY(loc) + GetRandomReal(- x , x) , dmg , per , dur , rad , bol , dopt)
        set i = i - 1
    endloop

 call RemoveLocation(loc)
 set u = null
 set loc = null
endfunction


//===================================================================================================
// code:
//
function ShieldTemplate_Going takes nothing returns nothing
 local unit u=rdg_currentcaster
 local unit t=bj_lastCreatedUnit
 local unit caster=bj_lastReplacedUnit
 local integer s=rdg_currentabi
 local integer l=R2I(rdg_castervars[10])
 local integer b=GetAbilityDataInt(s , l , "pasN")
 local effect fx=bj_lastCreatedEffect
 local group ignore=bj_groupRemoveGroupDest
 local integer abi=GetAbilityDataInt(s , l , "spell")
 local integer dopts=GetAbilityDataInt(s , l , "dmgoptions")
 //local gamecache g=CSCache()

    call UnitMoveToAsProjectileGen((u ) , (( 0.1 )*1.0) , 0 , 0 , ( t ) , (( 30)*1.0)) // INLINED!!
    call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , t , "origin"))
    //call BJDebugMsg("Removing an effect (minor) from the mortal realm")

    call DamageUnitByOptions(u , t , GetAbilityDataReal(s , l , "damage") , LoadDamageOptions(dopts))

    call GroupRemoveUnit(ignore , t)
    call DestroyEffect(fx)
  //  call BJDebugMsg("Removing an effect (major) from the mortal realm")
    if GetAbilityDataInt(s , l , "fromcaster") == 1 then
        call CS_MoveUnit(u , GetUnitX(caster) , GetUnitY(caster))
    endif
    if abi != 0 then
        call UnitAddAbility(u , abi)
        call SetUnitAbilityLevel(u , abi , l)
        call IssueTargetOrderById(u , GetAbilityDataInt(s , l , "orderid") , t)
      //  call BJDebugMsg("Casting "+GetObjectName(abi)+" with unit "+GetUnitName(u)+" and order "+OrderId2String(GetAbilityDataInt(s,l,"orderid")))
    endif
    loop
        exitwhen b == 0
        call UnitRemoveAbility(u , GetAbilityDataInt(s , l , "pas" + I2S(b) + "id"))
      //  call BJDebugMsg("Removing "+GetObjectName(GetAbilityDataInt(s,l,"pas"+I2S(b)+"id"))+" from unit "+GetUnitName(u))
        set b = b - 1
    endloop
    call PolledWait(RMaxBJ(GetAbilityDataReal(s , l , "delay") , 5))
    call UnitRemoveAbility(u , abi)
  //  call BJDebugMsg("Removing "+GetObjectName(abi)+" from unit "+GetUnitName(u))
    call RecycleCaster(u)
//    call BJDebugMsg("Reciclying "+GetUnitName(u))
 //set g=null
 set caster = null
 set u = null
 set t = null
 set fx = null
 set ignore = null
endfunction

function ShieldTemplate takes nothing returns nothing
 local unit caster=GetTriggerUnit()
 local unit target
 local unit array elec
 local effect array fx
 local timer t=CreateTimer()
 local real grad=0
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(caster , s)
 local integer a=0
 local integer b=0
 local integer n=GetAbilityDataInt(s , l , "n")
 local real waitt=0
 local group ignore=CreateGroup()
 local group tolight=CreateGroup()
 local unit picked
 local integer abiN=GetAbilityDataInt(s , l , "pasN")
 local integer array pass
 local boolean good=GetAbilityDataInt(s , l , "goodspell") == 1
 local real min=GetAbilityDataReal(s , l , "minpercent")
 local real max=GetAbilityDataReal(s , l , "maxpercent")
 local real area=GetAbilityDataReal(s , l , "area")
 local real height=GetAbilityDataReal(s , l , "height")
 local real x
 local real y
 local real dist=GetAbilityDataReal(s , l , "distance")
 local boolean opposite=GetAbilityDataInt(s , l , "opposite") == 1
 local boolean clockwise=GetAbilityDataInt(s , l , "clockwise") == 1
 local boolean fromfacing=GetAbilityDataInt(s , l , "fromfacing") == 1
 local real angle
 local integer dmgid=GetAbilityDataInt(s , l , "dmgoptions")
 local real dmgps=GetAbilityDataReal(s , l , "dmgps")

    if GetSpellTargetUnit() == null then
        set target = caster
    else
        set target = GetSpellTargetUnit()
        call PolledWait(SquareRoot(Pow(GetUnitX(target) - GetUnitX(caster) , 2) + Pow(GetUnitY(target) - GetUnitY(caster) , 2)) / GetAbilityDataReal(s , l , "mainspeed"))
    endif
    set b = abiN
    loop
        exitwhen b == 0
        set pass[b]=GetAbilityDataInt(s , l , "pas" + I2S(b) + "id")
        set b = b - 1
    endloop
    call TimerStart(t , GetAbilityDataReal(s , l , "dur") , false , null)
    set a = 0
    loop
        exitwhen a >= n
        set elec[a]=GetACaster()
        set fx[a]=AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , elec[a] , "origin")
        call SetUnitOwner(elec[a] , GetOwningPlayer(caster) , true)
        call SetUnitPosition(elec[a] , GetUnitX(target) , GetUnitY(target))
        call SetUnitMoveSpeed(elec[a] , GetAbilityDataReal(s , l , "speed"))
        call SetUnitFlyHeight(elec[a] , height , 0)
        set b = abiN
        loop
            exitwhen b == 0
            call UnitAddAbility(elec[a] , pass[a])
            call SetUnitAbilityLevel(elec[a] , pass[a] , l)
            set b = b - 1
        endloop
        set a = a + 1
    endloop
    loop
        exitwhen ( TimerGetRemaining(t) <= 0 ) or ( IsUnitDeadBJ(target) ) or n <= 0
        call TriggerSleepAction(0)
        set a = 0
        set bj_groupEnumOwningPlayer = GetOwningPlayer(caster)
        call GroupClear(tolight)
        call GroupEnumUnitsInRange(tolight , GetUnitX(target) , GetUnitY(target) , area , null)
        loop
            set picked = FirstOfGroup(tolight)
            exitwhen a >= n or picked == null or TimerGetElapsed(t) <= waitt
            if IsUnitDeadBJ(picked) then
            elseif good and not ( IsUnitAlly(picked , GetOwningPlayer(caster)) ) then
            elseif IsUnitType(picked , UNIT_TYPE_HERO) and GetAbilityDataInt(s , l , "nonhero") == 1 then
            elseif not ( good ) and not ( IsUnitEnemy(picked , GetOwningPlayer(caster)) ) then
            elseif IsUnitInGroup(picked , ignore) then
            elseif GetUnitLifePercent(picked) > max or GetUnitLifePercent(picked) < min then
            else
                set bj_lastCreatedEffect = fx[a]
                set bj_lastCreatedUnit = picked
                set bj_lastReplacedUnit = caster
                set rdg_currentcaster = elec[a]
                call GroupRemoveUnit(tolight , picked)
                call GroupAddUnit(ignore , picked)
                set rdg_currentabi = s
                set rdg_castervars[10]=l
                set bj_groupRemoveGroupDest = ignore
                call ExecuteFunc("ShieldTemplate_Going")
                set waitt = TimerGetElapsed(t) + GetAbilityDataReal(s , l , "cooldown")
                set elec[a]=elec[n - 1]
                set elec[n - 1]=null
                set fx[a]=fx[n - 1]
                set fx[n - 1]=null
                set n = n - 1
            endif
            call GroupRemoveUnit(tolight , picked)
        endloop
        loop
            exitwhen a >= n
            if opposite then
                if ModuloInteger(a , 2) == 1 then
                    set angle = - ( grad + ( a - 1 ) * 360 / n )
                else
                    set angle = grad + a * 360 / n
                endif
            else
                set angle = grad + a * 360 / n
            endif
            if clockwise then
                set angle = - angle
            endif
            if fromfacing then
                set angle = GetUnitFacing(target) + angle
            endif
            set x = GetUnitX(target) + dist * CosBJ(angle)
            set y = GetUnitY(target) + dist * SinBJ(angle)
            if GetAbilityDataInt(s , l , "directmove") == 1 or SquareRoot(Pow(x - GetUnitX(elec[a]) , 2) + Pow(y - GetUnitY(elec[a]) , 2)) >= 1000 then
                call SetUnitPosition(elec[a] , x , y)
            else
                call IssuePointOrder(elec[a] , "smart" , x , y)
            endif
            call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_EFFECT , GetUnitX(elec[a]) , GetUnitY(elec[a])))
   // call BJDebugMsg("Removing an effect (minor) from the mortal realm")
            if dmgps != 0 then
                call DamageUnitsInAOEEx(caster , dmgps , GetUnitX(elec[a]) , GetUnitY(elec[a]) , GetAbilityDataReal(s , l , "dmgpsarea") , false , LoadDamageOptions(dmgid))
            endif
            set a = a + 1
        endloop
        set grad = ModuloReal(grad + 30 , 360)
    endloop
 call DestroyTimer(t)
 call DestroyGroup(tolight)
 call DestroyGroup(ignore)
 set t = null
 set tolight = null
 set a = 0
 call CasterSetRecycleDelay(5)
 loop
     exitwhen a >= n
     call DestroyEffect(fx[a])
    //call BJDebugMsg("Removing an effect (major) from the mortal realm")
     set b = abiN
     loop
         exitwhen b == 0
         call UnitRemoveAbility(elec[a] , pass[b])
      //   call BJDebugMsg("Removing "+GetObjectName(pass[b])+" from unit "+GetUnitName(elec[a]))
         set b = b - 1
     endloop
     call RecycleCasterAfterCastEx(elec[a] , udg_delayhack , 0 , false)
     //    call BJDebugMsg("RecIclying "+GetUnitName(elec[a]))
     set fx[a]=null
     set elec[a]=null
     set a = a + 1
 endloop
 set rdg_delayhack = 0
 set ignore = null
 set caster = null
 set target = null
endfunction





//===================================================================================================
function AuraTemplate_Wait takes timer t returns nothing
    call TimerStart(t , 1 , false , null)
    loop
        exitwhen ( TimerGetRemaining(t) <= 0 )
        call TriggerSleepAction(0.1)
    endloop
endfunction

function AuraTemplate takes nothing returns nothing
 local timer t=CreateTimer()
 local unit u=(CasterSystem___acquiringunit) // INLINED!!
 local integer s=(CasterSystem___acquiredabil) // INLINED!!
 local integer l=GetUnitAbilityLevel(u , s)
 local integer nl=l
 local integer n=GetAbilityDataInt(s , l , "n")
 local integer array abis
 local integer array spb
 local integer a=n
 local group affected=null
 local group inrange=CreateGroup()
 local group aux=CreateGroup()
 local unit picked
 local real area=GetAbilityDataReal(s , l , "area")
 local integer bad=GetAbilityDataInt(s , l , "bad")
 local boolean notself=( GetAbilityDataInt(s , l , "notself") != 0 )
 local boolean halt=false
 local boolean nor=(HaveStoredInteger(cs_cache , I2S((GetHandleId(((u ))))) + ";" + ( "AuraTemplateSet" ) , "Pos" + I2S(( s)))) // INLINED!!
 local boolean enb
 local integer d
	//if rdg_isCheats then
   // call BJDebugMsg(GetUnitName(u)+" got the magical "+GetObjectName(s))
    //endif
    if IsUnitIllusion(u) or ( l == 0 ) or nor then
        set n = 0
        set halt = true
    else
        call AttachedSetAddInt(u , "AuraTemplateSet" , s)
    endif
    loop
        exitwhen ( a == 0 ) or halt
        set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
        set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
        set a = a - 1
    endloop
    loop
        exitwhen ( halt )
        set nl = GetUnitAbilityLevel(u , s)
        if ( nl != l ) then
            if ( nl == 0 ) then
                set halt = true
            else
                loop
                    set picked = FirstOfGroup(aux)
                    exitwhen ( picked == null )
                    set a = n
                    loop
                        exitwhen ( a == 0 )
                        call UnitRemoveAbility(picked , spb[a])
                        call UnitRemoveAbility(picked , abis[a])
                        set a = a - 1
                    endloop
                    call GroupRemoveUnit(aux , picked)
                endloop
                set l = nl
                set n = GetAbilityDataInt(s , l , "n")
                set a = n
                loop
                    exitwhen ( ( a == 0 ) or ( halt ) )
                    set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
                    set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
                    set a = a - 1
                endloop
                set area = GetAbilityDataReal(s , l , "area")
            endif
        endif
        exitwhen ( halt )
        if ( GetWidgetLife(u) > 0 ) then
            call CS_EnumUnitsInAOE(inrange , GetUnitX(u) , GetUnitY(u) , area , null)
        else
            set halt = halt or ( GetUnitState(u , UNIT_STATE_MAX_LIFE) <= 0 ) //If max life is 0, the unit was removed
            call GroupClear(inrange)
        endif
        if ( affected != null ) then
            call DestroyGroup(affected)
        endif
        set affected = aux
        set aux = CreateGroup()
        loop
            set picked = FirstOfGroup(affected)
            exitwhen picked == null
            if not IsUnitInGroup(picked , inrange) then
                set a = n
                loop
                    exitwhen a == 0
                    call UnitRemoveAbility(picked , spb[a])
                    call UnitRemoveAbility(picked , abis[a])
                    set a = a - 1
                endloop
            else
                call GroupRemoveUnit(inrange , picked)
                call GroupAddUnit(aux , picked)
            endif
            call GroupRemoveUnit(affected , picked)
        endloop
        set d = GetAbilityDataInt(s , l , "options")
        if ( d != 0 ) then
            set d = LoadDamageOptions(d)
        endif
        loop
            set picked = FirstOfGroup(inrange)
            exitwhen ( picked == null )
            set enb = ( bad == 1 and IsUnitEnemy(picked , GetOwningPlayer(u)) )
            set enb = enb or ( bad == 0 and IsUnitAlly(picked , GetOwningPlayer(u)) and IsUnitAlly(u , GetOwningPlayer(picked)) and ( not ( notself ) or u != picked ) ) or ( bad == 2 and ( not ( notself ) or u != picked ) )
            if ( d != 0 ) then
                set enb = enb and ( GetDamageFactorByOptions(u , picked , d) > 0 )
            endif
            if enb then
                set a = n
                loop
                    exitwhen ( a == 0 )
                    if ( spb[a] != 0 ) then
                        call SetPlayerAbilityAvailable(GetOwningPlayer(picked) , spb[a] , false)
                        call UnitAddAbility(picked , spb[a])
                    else
                        call UnitAddAbility(picked , abis[a])
                    endif
                    call SetUnitAbilityLevel(picked , abis[a] , l)
                    call GroupAddUnit(aux , picked)
                    set a = a - 1
                endloop
            endif
            call GroupRemoveUnit(inrange , picked)
        endloop
        call AuraTemplate_Wait(t)
    endloop
    
    if not ( nor ) then
        call AttachedSetRemInt(u , "AuraTemplateSet" , s)
    endif
    loop
        set picked = FirstOfGroup(aux)
        exitwhen picked == null
        set a = n
        loop
            exitwhen ( a <= 0 )
            call UnitRemoveAbility(picked , spb[a])
            call UnitRemoveAbility(picked , abis[a])
            set a = a - 1
        endloop
        call GroupRemoveUnit(aux , picked)
    endloop
 call DestroyGroup(aux)
 call DestroyGroup(affected)
 call DestroyGroup(inrange)
 call DestroyTimer(t)
 set t = null
 set affected = null
 set inrange = null
 set picked = null
 set u = null
 set aux = null
endfunction




//====================================================================================================
constant function SpiralTemplate_Timer takes nothing returns real
    return 0.04
endfunction

function SpiralBeamDamage takes nothing returns nothing
 local string k=(GetStoredString(cs_cache , I2S(GetHandleId((GetTriggeringTrigger() ))) , ( "table"))) // INLINED!!
 local unit u= GetTriggerUnit()
 local unit w= GetTableUnit(k , "u")
 local integer s=(GetStoredInteger(cs_cache , (k ) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , (k ) , ( "l"))) // INLINED!!
 local integer a
 local real x
 local real fct=GetDamageFactorByOptions(w , u , LoadDamageOptions(GetAbilityDataInt(s , l , "options")))

    if ( fct != 0 ) then
        call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , u , "origin"))
        set x = GetAbilityDataReal(s , l , "damage")
call UnitDamageTarget((w ) , ( u ) , (( x * fct )*1.0) , true , false , ( null ) , ( null) , null) // INLINED!!
        set x = GetAbilityDataReal(s , l , "dmgduration")
        if ( x != 0 ) then
            call UnitDamageUnitTimed(w , GetAbilityDataReal(s , l , "damageps") * fct , GetAbilityDataReal(s , l , "damageperiod") , x , u , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0) , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1) , null , null)
        endif
        set a = GetAbilityDataInt(s , l , "spell")
        if a != 0 then
            call CasterSetRecycleDelay(GetAbilityDataReal(s , l , "recycledelay"))
            call CasterCastAbilityLevel(GetOwningPlayer(w) , a , l , I2S(GetAbilityDataInt(s , l , "orderid")) , u , false)
            set rdg_delayhack = 0
        endif
    endif
 set u = null
 set w = null
endfunction

function SpiralBeam_Stop takes nothing returns nothing
 local trigger t=GetTriggeringTrigger()
 local string k=(GetStoredString(cs_cache , I2S(GetHandleId((t ))) , ( "table"))) // INLINED!!
 local timer ti=GetTableTimer(k , "t")
 local trigger range=GetTableTrigger(k , "range")
 local unit h=GetTableUnit(k , "h")
    call DisableTrigger(t)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call PauseTimer(ti)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((ti)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(ti))
    call DestroyTimer(ti)
    call CS_KillTrigger(range)
    call SetUnitOwner(h , Player(15) , true)
    call DestroyEffect(GetTableEffect(k , "fx"))
    call DestroyEffect(AddSpellEffectById((GetStoredInteger(cs_cache , (k ) , ( "s"))) , EFFECT_TYPE_AREA_EFFECT , GetUnitX(h) , GetUnitY(h))) // INLINED!!
 set t = null
 set ti = null
 set range = null
 set h = null
endfunction

function SpiralBeam_Movement takes nothing returns nothing
 local string k=(GetStoredString(cs_cache , I2S(GetHandleId((GetExpiredTimer() ))) , ( "table"))) // INLINED!!
 local integer s=(GetStoredInteger(cs_cache , (k ) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , (k ) , ( "l"))) // INLINED!!
 local unit u= GetTableUnit(k , "c")
 local unit h= GetTableUnit(k , "h")
 local integer time=(GetStoredInteger(cs_cache , (k ) , ( "times"))) + 100 // INLINED!!

 local real d=GetAbilityDataReal(s , l , "StartDistance") + time * (0.04) * GetAbilityDataReal(s , l , "DistanceSpeed") // INLINED!!
 local real tanspeed=GetAbilityDataReal(s , l , "TanSpeed")
 local real grad= (GetStoredReal(cs_cache , (k ) , ( "grad"))) + ( tanspeed / d ) * bj_RADTODEG * (0.04) // INLINED!!
     call SetTableReal(k , "grad" , grad)
     call CS_MoveUnit(h , GetUnitX(u) + d * CosBJ(grad) , GetUnitY(u) + d * SinBJ(grad))
     call SetUnitFacing(h , grad + 90 * RSignBJ(tanspeed))
     call SetTableInt(k , "times" , time)
     if ( (GetStoredInteger(cs_cache , (k ) , ( "next"))) <= time ) then // INLINED!!
         call SetTableInt(k , "next" , time + R2I(50 + ( GetAbilityDataReal(s , l , "fxperiod") * 100 ) / (0.04))) // INLINED!!
         call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_EFFECT , h , "origin"))
     endif
 set u = null
 set h = null
endfunction

function SpiralBeamTemplate_Color takes unit u,integer rgb returns nothing
 local integer Y=rgb + IntegerTertiaryOp(rgb < 0 , 0x80000000 , 0)
 local integer Z
 local integer r
 local integer g
 local integer b
    set Z = Y / 0x100
    set b = Y - ( Z * 0x100 )
    set Y = Z / 0x100
    set g = Z - ( Y * 0x100 )
    set Z = Y / 0x100
    set r = Y - ( Z * 0x100 )
    if ( rgb < 0 ) then
        set Z = Z + 128
    endif
    call SetUnitVertexColor(u , r , g , b , Z)
endfunction


function SpiralBeamTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local timer t=CreateTimer()
 local trigger range=CreateTrigger()
 local unit h=GetACaster()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local effect fx
 local real x=GetUnitX(u)
 local real y=GetUnitY(u)
 local real grad
 local real d
 local integer v
 local integer array abi
 local integer n=GetAbilityDataInt(s , l , "abilN")
 local integer a=0
 local location loc
 local unit center=null
 local trigger end=null
 local boolean ch=( GetAbilityDataInt(s , l , "channel") == 1 )
 local string k=NewTable()

    if GetAbilityDataInt(s , l , "dontfollow") == 1 then
        set loc = GetSpellTargetLoc()
        if GetLocationX(loc) == 0 and GetLocationY(loc) == 0 then
            call MoveLocation(loc , GetUnitX(u) , GetUnitY(u))
        endif
        set center = GetACaster()
        call SetUnitOwner(center , GetOwningPlayer(u) , false)
        call SetUnitPositionLoc(center , loc)
        set x = GetLocationX(loc)
        set y = GetLocationY(loc)
        call RemoveLocation(loc)
        set loc = null
    else
        set center = u
    endif
    call SetUnitPosition(h , x , y)
    call SetUnitFlyHeight(h , GetAbilityDataReal(s , l , "height") , 0)
    loop
        exitwhen a == n
        set abi[a]=GetAbilityDataInt(s , l , "abil" + I2S(a + 1) + "id")
        call UnitAddAbility(h , abi[a])
        set a = a + 1
    endloop
    set d = GetAbilityDataReal(s , l , "scale")
    call SetUnitScale(h , d , d , d)
    set fx = AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , h , "origin")
    call SpiralBeamTemplate_Color(h , GetAbilityDataInt(s , l , "color"))
    call SetUnitOwner(h , GetOwningPlayer(u) , true)
    call SetTableReal(k , "grad" , GetUnitFacing(u))
    call SetTableObject(k , "c" , center)
    call SetTableInt(k , "s" , s)
    call SetTableInt(k , "l" , l)
    call SetTableObject(k , "u" , u)

    call AttachString(range , "table" , k)
    call AttachString(t , "table" , k)

    call TriggerRegisterUnitInRange(range , h , GetAbilityDataReal(s , l , "area") , null)
    call AttachTriggerAction(range , "ac" , TriggerAddAction(range , function SpiralBeamDamage))

    call SetTableObject(k , "h" , h)
    call TimerStart(t , (0.04) , true , function SpiralBeam_Movement) // INLINED!!

    if ch then
        set end = CreateTrigger()
        call AttachString(end , "table" , k)
        call TriggerRegisterUnitEvent(end , u , EVENT_UNIT_SPELL_ENDCAST)
        call TriggerAddAction(end , function SpiralBeam_Stop)
        call SetTableObject(k , "t" , t)
        call SetTableObject(k , "range" , range)
        call SetTableObject(k , "fx" , fx)
    endif

    call PolledWait(GetAbilityDataReal(s , l , "duration"))
    if ch then
        if GetTriggerEvalCount(end) == 0 then
            set ch = false
            call FlushStoredMission(cs_cache , I2S(GetHandleId((end)))) // INLINED!!
            call FlushChildHashtable(rdg_cstable, GetHandleId(end))
            call DestroyTrigger(end)
            call PauseUnit(u , true)
            call IssueImmediateOrder(u , "stop")
            call PauseUnit(u , false)
        else
            call FlushStoredMission(cs_cache , I2S(GetHandleId((end)))) // INLINED!!
            call FlushChildHashtable(rdg_cstable, GetHandleId(end))
            call DestroyTrigger(end)
            call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_AREA_EFFECT , GetUnitX(h) , GetUnitY(h)))
        endif
        set end = null
    else
        call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_AREA_EFFECT , GetUnitX(h) , GetUnitY(h)))
    endif
    if center != u then
        call RecycleCaster((center)) // INLINED!!
    endif
    set a = 0
 loop
     exitwhen a == n
     call UnitRemoveAbility(h , abi[a])
     set a = a + 1
 endloop
 if not ( ch ) then
     call PauseTimer(t)
     call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
     call FlushChildHashtable(rdg_cstable, GetHandleId(t))
     call DestroyTimer(t)
     call CS_KillTrigger(range)
     call DestroyEffect(fx)
 endif

 call FlushStoredMission(cs_cache , I2S(GetHandleId((h)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(h))
 call RecycleCasterAfterCastEx((h ) , (( 4.0 )*1.0) , ( 0 ) , ( true)) // INLINED!!


 set t = null
 set u = null
 set range = null
 set h = null
 set fx = null
 set loc = null
 set center = null
 set end = null
endfunction





//==================================================================================================
constant function BeamSpellTemplate_Timer takes nothing returns real
    return 0.04
endfunction

function BeamTemplate_Color takes unit u,integer rgb returns nothing
 local integer Y=rgb + IntegerTertiaryOp(rgb < 0 , 0x80000000 , 0)
 local integer Z
 local integer r
 local integer g
 local integer b
    set Z = Y / 0x100
    set b = Y - ( Z * 0x100 )
    set Y = Z / 0x100
    set g = Z - ( Y * 0x100 )
    set Z = Y / 0x100
    set r = Y - ( Z * 0x100 )
    if ( rgb < 0 ) then
        set Z = Z + 128
    endif
    call SetUnitVertexColor(u , r , g , b , Z)
endfunction

function InRangeOfBeam takes nothing returns nothing
 local string k=(GetStoredString(cs_cache , I2S(GetHandleId((GetTriggeringTrigger() ))) , ( "table"))) // INLINED!!
 local unit bolt=GetTableUnit(k , "bolt")
 local unit o=GetTableUnit(k , "u")
 local integer s=(GetStoredInteger(cs_cache , (k ) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , (k ) , ( "l"))) // INLINED!!
 local group targetlog
 local unit u=GetTriggerUnit()
 local boolean b=false
 local real x
 local real f=GetDamageFactorByOptions(o , u , LoadDamageOptions(GetAbilityDataInt(s , l , "options")))

    set b = ( ( f != 0 ) )
    if b and ( u == o ) then
        if (GetStoredBoolean(cs_cache , (k ) , ( "ignoreself"))) then // INLINED!!
            call SetTableBoolean(k , "ignoreself" , false)
            set b = false
        endif
    endif
    if b and ( GetAbilityDataInt(s , l , "canrepeat") == 0 ) then
        set targetlog = GetTableGroup(k , "log")
        if not IsUnitInGroup(u , targetlog) then
            call GroupAddUnit(targetlog , u)
        else
            set b = false
        endif
        set targetlog = null
    endif
    if b then
        call CasterSetRecycleDelay(GetAbilityDataReal(s , l , "delay"))
        call CasterCastAbilityLevel(GetOwningPlayer(bolt) , GetAbilityDataInt(s , l , "spell") , l , I2S(GetAbilityDataInt(s , l , "orderid")) , u , false)
        set rdg_delayhack = 0
        call UnitDamageTarget(o , u , GetAbilityDataReal(s , l , "damage") * f , true , false , null , null , null)
        set x = GetAbilityDataReal(s , l , "duration")
        if x > 0 then
            call UnitDamageUnitTimed(o , GetAbilityDataReal(s , l , "damageps") * f , GetAbilityDataReal(s , l , "period") , x , u , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0) , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1) , null , null)
        endif
    endif
 set o = null
 set bolt = null
 set targetlog = null
 set u = null
endfunction


function BeamSpellTemplate_Movement takes string k,unit u returns nothing
 local real ux=GetUnitX(u)
 local real uy=GetUnitY(u)
 local real tx=(GetStoredReal(cs_cache , (k ) , ( "x"))) // INLINED!!
 local real ty=(GetStoredReal(cs_cache , (k ) , ( "y"))) // INLINED!!
 local real a=Atan2(ty - uy , tx - ux)
 local real d=(GetStoredReal(cs_cache , (k ) , ( "adv"))) // INLINED!!
 local real x=ux + d * Cos(a)
 local real y=uy + d * Sin(a)

    if not ( CS_MoveUnit(u , x , y) ) or ( ( Pow(GetUnitX(u) - x , 2) + Pow(GetUnitY(u) - y , 2) ) > 100 ) or ( ( Pow(x - tx , 2) + Pow(y - ty , 2) ) <= 100 ) then
         call SetTableBoolean(k , "done" , true)
    endif
endfunction

function BeamSpellTemplate_Tcheck takes nothing returns nothing
 local string k=(GetStoredString(cs_cache , I2S(GetHandleId((GetExpiredTimer() ))) , ( "table"))) // INLINED!!
    if not ( (GetStoredBoolean(cs_cache , (k ) , ( "done"))) ) then // INLINED!!
        call BeamSpellTemplate_Movement(k , GetTableUnit(k , "bolt"))
    endif
endfunction

function BeamSpellTemplate takes nothing returns nothing
 local location loc=GetSpellTargetLoc()
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local real ux=GetUnitX(u)
 local real uy=GetUnitY(u)
 local real angle=ModuloReal(Atan2BJ(GetLocationY(loc) - uy , GetLocationX(loc) - ux) , 360)
 local unit bolt=(CreateCaster(((angle)*1.0) , 0 , 0)) // INLINED!!
 local group targetlog=CreateGroup()
 local unit picked
 local effect fx
 local trigger dis=CreateTrigger()
 local real x=GetAbilityDataReal(s , l , "distance")
 local real y=GetAbilityDataReal(s , l , "offset")
 local string attch=GetAbilityDataString(s , l , "spc")
 local integer repeat=GetAbilityDataInt(s , l , "boomerang")
 local timer t=CreateTimer()
 local string k=NewTable()

    call AttachString(t , "table" , k)
    call AttachString(dis , "table" , k)

    call RemoveLocation(loc)
    call SetTableInt(k , "s" , s)
    call SetTableInt(k , "l" , l)
    call SetTableReal(k , "x" , ux + x * CosBJ(angle))
    call SetTableReal(k , "y" , uy + x * SinBJ(angle))
    call SetTableReal(k , "adv" , GetAbilityDataReal(s , l , "speed") * (0.04)) // INLINED!!

    set ux = ux + y * CosBJ(angle)
    set uy = uy + y * SinBJ(angle)
    call SetUnitPosition(bolt , ux , uy)
    set x = GetAbilityDataReal(s , l , "scale")
    call SetUnitScale(bolt , x , x , x)
    call SetUnitOwner(bolt , GetOwningPlayer(u) , true)
    call SetUnitFlyHeight(bolt , GetAbilityDataReal(s , l , "height") , 0)

    set fx = AddSpellEffectTargetById(s , EFFECT_TYPE_AREA_EFFECT , bolt , "origin")
    call BeamTemplate_Color(bolt , GetAbilityDataInt(s , l , "color"))
    call AttachTriggerAction(dis , "ac" , TriggerAddAction(dis , function InRangeOfBeam))
    call SetTableObject(k , "bolt" , bolt)
    call SetTableObject(k , "log" , targetlog)
    call SetTableObject(k , "u" , u)
    call SetTableBoolean(k , "ignoreself" , true)
    call TriggerRegisterUnitInRange(dis , bolt , GetAbilityDataReal(s , l , "area") , null)
    call TimerStart(t , (0.04) , true , function BeamSpellTemplate_Tcheck) // INLINED!!
    loop
        loop
            exitwhen (GetStoredBoolean(cs_cache , (k ) , ( "done"))) // INLINED!!
            call TriggerSleepAction(0)
            if attch == "point" then
                call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_SPECIAL , GetUnitX(bolt) , GetUnitY(bolt)))
            else
                call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , bolt , attch))
            endif
        endloop
        exitwhen repeat == 0
        call SetTableBoolean(k , "done" , false)
        set x = (GetStoredReal(cs_cache , (k ) , ( "x"))) // INLINED!!
        set y = (GetStoredReal(cs_cache , (k ) , ( "y"))) // INLINED!!
        call SetTableReal(k , "x" , ux)
        call SetTableReal(k , "y" , uy)
        set ux = x
        set uy = y
        set repeat = repeat - 1
    endloop
    call CS_KillTrigger(dis)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((bolt)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(bolt))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call PauseTimer(t)
    call DestroyTimer(t)
    call DestroyEffect(fx)
    call DestroyTable(k)
    call TriggerSleepAction(4)
    call ExplodeUnitBJ(bolt)
 call DestroyGroup(targetlog)
 set t = null
 set targetlog = null
 set u = null
 set bolt = null
 set picked = null
 set fx = null
 set dis = null
endfunction



//====================================================================================================
function ConeSpellTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local unit t=GetSpellTargetUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local location loc=GetSpellTargetLoc()
 local real x=GetUnitX(u)
 local real y=GetUnitY(u)
 local real alpha= Atan2(GetLocationY(loc) - GetUnitY(u) , GetLocationX(loc) - GetUnitX(u))
 local real beta= alpha + bj_PI / 2
 local real area=GetAbilityDataReal(s , l , "initialarea")
 local real dis=GetAbilityDataReal(s , l , "distance")
 local real fin=GetAbilityDataReal(s , l , "finalarea")
 local real x1=x + area * Cos(beta) / 2
 local real y1=y + area * Sin(beta) / 2
 local real x2
 local real y2
 local real x3=( x + dis * Cos(alpha) ) + fin * Cos(beta) / 2
 local real y3=( y + dis * Sin(alpha) ) + fin * Sin(beta) / 2
 local real x4
 local real y4
 local group inquad=CreateGroup()
 local unit picked
 local player P=GetOwningPlayer(u)
 local integer ab
 local integer o
 local string attach
 local real dmg
 local integer n=GetAbilityDataInt(s , l , "maxtargets")
 local integer D
 local real fct
    //call BJDebugMsg(GetObjectName(s)+" has registering as casting with the Cone template.")
    set beta = alpha - bj_PI / 2
    set x2 = x + area * Cos(beta) / 2
    set y2 = y + area * Sin(beta) / 2
    set x4 = ( x + dis * Cos(alpha) ) + fin * Cos(beta) / 2
    set y4 = ( y + dis * Sin(alpha) ) + fin * Sin(beta) / 2
    call GroupAddUnitsInTriangle(inquad , x1 , y1 , x2 , y2 , x3 , y3)
    call GroupAddUnitsInTriangle(inquad , x2 , y2 , x3 , y3 , x4 , y4)
    call GroupRemoveUnit(inquad , u)
    //call TriggerSleepAction(0)
    set ab = GetAbilityDataInt(s , l , "spell")
    set fin = GetAbilityDataReal(s , l , "dmgdur")
    if fin != 0 then
        set dis = GetAbilityDataReal(s , l , "dmgps")
        set area = GetAbilityDataReal(s , l , "dmgpsperiod")
    endif
    set attach = GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)
    if ab != 0 then
        if GetAbilityDataInt(s , l , "castfromcaster") == 1 then
            set udg_sourcehack = GetUnitLoc(u)
        else
            set udg_sourcehack = null
        endif
        call CasterSetRecycleDelay(GetAbilityDataReal(s , l , "recycledelay"))
        set o = GetAbilityDataInt(s , l , "orderid")
    endif
    set dmg = GetAbilityDataReal(s , l , "damage")
    set D = LoadDamageOptions(GetAbilityDataInt(s , l , "options"))
    loop
        if ( t != null ) then
            set picked = t
            set t = null
        else
            set picked = FirstOfGroup(inquad)
        endif
        exitwhen ( picked == null ) or ( n == 0 )
        call GroupRemoveUnit(inquad , picked)
        set fct = GetDamageFactorByOptions(u , picked , D)
        if ( fct != 0 ) then
            if ( ab != 0 ) then
                call CasterCastAbilityLevel(P , ab , l , I2S(o) , picked , udg_delayhack == 0)
            endif
            if ( fin != 0 ) then
                call UnitDamageUnitTimed(u , dis * fct , area , fin , picked , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0) , attach , null , null)
            else
                call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , picked , attach))
            endif
call UnitDamageTarget((u ) , ( picked ) , (( dmg * fct )*1.0) , true , false , ( null ) , ( null) , null) // INLINED!!
            set n = n - 1
        endif
    endloop
    if ab != 0 then
        call RemoveLocation(rdg_sourcehack)
        set udg_sourcehack = null
        set udg_delayhack = 0
    endif
 call DestroyGroup(inquad)
 call RemoveLocation(loc)
 set loc = null
 set inquad = null
 set P = null
endfunction



//===================================================================================================
// SpellCast template code:
//
function SpellCast_Missile takes player ow,integer s,integer l,real x1,real y1,real x2,real y2 returns nothing
 local integer rgb=GetAbilityDataInt(s , l , "MissileColor")
 local integer Y=rgb + IntegerTertiaryOp(rgb < 0 , 0x80000000 , 0)
 local integer Z
 local integer r
 local integer g
 local integer b
 local real sc=GetAbilityDataReal(s , l , "MissileScale")
    set Z = Y / 0x100
    set b = Y - ( Z * 0x100 )
    set Y = Z / 0x100
    set g = Z - ( Y * 0x100 )
    set Z = Y / 0x100
    set r = Y - ( Z * 0x100 )
    if ( rgb < 0 ) then
        set Z = Z + 128
    endif
    call ProjectileLaunchEx(ow , GetAbilityEffectById(s , EFFECT_TYPE_MISSILE , 0) , sc , r , g , b , Z , GetAbilityDataReal(s , l , "MissileSpeed") , GetAbilityDataReal(s , l , "MissileArc") , x1 , y1 , GetAbilityDataReal(s , l , "MissileLHeight") , x2 , y2 , GetAbilityDataReal(s , l , "MissileIHeight"))
endfunction

function SpellCast_Do takes unit u,integer s,integer l,real x,real y,real px,real py returns nothing
 local integer n=GetAbilityDataInt(s , l , "spellN")
 local integer array ts
 local real array tsr
 local boolean array tsfp
 local integer array tso
 local real array tsz
 local integer tn=0
 local integer i=1
 local integer t
 local string k
 local real dmg=GetAbilityDataReal(s , l , "dmg")
 local real dmgps=GetAbilityDataReal(s , l , "dmgps")
 local real period
 local real dur
 local real cx
 local real cy
 local real z
 local integer dop
 local player ow=GetOwningPlayer(u)
 local group g=CreateGroup()
 local unit p
 local string fx
 local string fxa=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)

    if ( dmgps != 0 ) then
        set period = GetAbilityDataReal(s , l , "dmgpsPeriod")
        set dur = GetAbilityDataReal(s , l , "dmgpsDur")
    endif

    if ( GetAbilityDataInt(s , l , "UseMissile") == 1 ) then
        call SpellCast_Missile(ow , s , l , px , py , x , y)
    endif
    set fx = GetAbilityEffectById(s , EFFECT_TYPE_AREA_EFFECT , 0)
    if ( ( fx != null ) and ( fx != "" ) ) then
        call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_AREA_EFFECT , x , y))
    endif
    set fx = GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0)
    loop
        exitwhen ( i > n )
        set k = "spell" + I2S(i)
        set t = GetAbilityDataInt(s , l , k + "type")
        if ( t == 0 ) then //Targetted Spell
            set tn = tn + 1
            set ts[tn]=GetAbilityDataInt(s , l , k + "id")
            set tsr[tn]=GetAbilityDataReal(s , l , k + "RecDelay")
            set tso[tn]=GetAbilityDataInt(s , l , k + "OrderId")
            set tsfp[tn]=( GetAbilityDataInt(s , l , k + "FromSource") == 1 )
            set tsz[tn]=GetAbilityDataReal(s , l , k + "CasterHeight")

        elseif ( t == 1 ) then

            if ( GetAbilityDataInt(s , l , k + "FromSource") == 1 ) then
                set cx = px
                set cy = py
            else
                set cx = x
                set cy = y
            endif
            set z = GetAbilityDataReal(s , l , k + "CasterHeight")
            call CasterCastAbilityPointEx(ow , cx , cy , z , GetAbilityDataInt(s , l , k + "id") , l , I2S(GetAbilityDataInt(s , l , k + "OrderId")) , x , y , GetAbilityDataReal(s , l , k + "RecDelay"))

        endif
        set i = i + 1
    endloop
    set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
    set n = GetAbilityDataInt(s , l , "maxtargets")
    call GroupEnumUnitsInRange(g , x , y , GetAbilityDataReal(s , l , "area") , null)
    if ( IsDamageOptionIncluded(dop , (16)) ) then // INLINED!!
        call DamageTreesInCircle(x , y , GetAbilityDataReal(s , l , "area"))
    endif
    loop
        set p = FirstOfGroup(g)
        exitwhen ( ( n <= 0 ) or ( p == null ) )
        call GroupRemoveUnit(g , p)
        set z = GetDamageFactorByOptions(u , p , dop)
        if ( z != 0 ) then
            set n = n - 1
            if ( dmg != 0 ) then
                call UnitDamageTarget(u , p , z * dmg , true , false , null , null , null)
            endif
            if ( dmgps != 0 ) then
                call UnitDamageUnitTimed(u , dmgps * z , period , dur , p , fx , fxa , null , null)
            else
                if ( ( fx != "" ) and ( fx != null ) ) then
                    call DestroyEffect(AddSpecialEffectTarget(fx , p , fxa))
                endif
            endif
            set i = 1
            loop
                exitwhen ( i > tn )
                if ( tsfp[i] ) then
                    set cx = px
                    set cy = py
                else
                    set cx = GetUnitX(p)
                    set cy = GetUnitY(p)
                endif
                call CasterCastAbilityEx(ow , cx , cy , tsz[i] , ts[i] , l , I2S(tso[i]) , p , tsr[i])
                set i = i + 1
            endloop

        endif
    endloop
    call DestroyGroup(g)


 set ow = null
 set g = null
 set p = null
endfunction

function SpellCast_Doer takes nothing returns nothing
 local trigger t=GetTriggeringTrigger()
 local string k=(I2S(GetHandleId((t)))) // INLINED!!
 local eventid e=GetTriggerEventId()
 local integer s=(GetStoredInteger(cs_cache , (k ) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , (k ) , ( "l"))) // INLINED!!
 local integer n
 local real px
 local real py
 local unit u

    if ( e == EVENT_UNIT_SPELL_FINISH ) then
        call SetTableBoolean(k , "ignoreEndCast" , true)
        set n = GetAbilityDataInt(s , l , "Times")
        if ( n <= 0 ) then
            set n = 0x0FFFFFFF
        endif
        call SetTableInt(k , "n" , n)
        call TriggerRegisterTimerEvent(t , GetAbilityDataReal(s , l , "Timer") , true)
    elseif ( ( e == EVENT_UNIT_SPELL_ENDCAST ) or ( e == EVENT_UNIT_DEATH ) ) then
        if ( not ( (GetStoredBoolean(cs_cache , (k ) , ( "ignoreEndCast"))) ) or ( e == EVENT_UNIT_DEATH ) ) then // INLINED!!
            call CS_KillTrigger(t)
        endif
    else
        set n = (GetStoredInteger(cs_cache , (k ) , ( "n"))) // INLINED!!
        if ( n <= 0 ) then
            call CS_KillTrigger(t)
        else
            call SetTableInt(k , "n" , n - 1)
            set u = GetTableUnit(k , "u")
            if ( (GetStoredBoolean(cs_cache , (k ) , ( "SourceIsUnit"))) ) then // INLINED!!
                set px = GetUnitX(u)
                set py = GetUnitY(u)
            else
                set px = (GetStoredReal(cs_cache , (k ) , ( "px"))) // INLINED!!
                set py = (GetStoredReal(cs_cache , (k ) , ( "py"))) // INLINED!!
            endif
            call SpellCast_Do(u , s , l , (GetStoredReal(cs_cache , (k ) , ( "x"))) , (GetStoredReal(cs_cache , (k ) , ( "y"))) , px , py) // INLINED!!
           set u = null
        endif
    endif

 set e = null
 set t = null
endfunction

function SpellCastTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local unit uu
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer n
 local trigger t= CreateTrigger()
 local string k=(I2S(GetHandleId((t)))) // INLINED!!
 local integer ty=GetAbilityDataInt(s , l , "ChannelType")
 local location loc=GetSpellTargetLoc() //Will always hate blizzard for not having GetSpellTargetX/Y and forcing me to use locations
 local real x=GetLocationX(loc)
 local real y=GetLocationY(loc)

    if ( ( x == 0 ) and ( y == 0 ) ) then
        set uu = GetSpellTargetUnit()
        if ( uu != null ) then
            set x = GetUnitX(uu)
            set y = GetUnitY(uu)
        endif
       set uu = null
    endif

    if ( ( GetAbilityDataInt(s , l , "SourceIsUnit") == 1 ) or ( GetAbilityDataInt(s , l , "UseMissile") == 1 ) ) then
        call SetTableBoolean(k , "SourceIsUnit" , true)
    else
        call SetTableReal(k , "px" , x)
        call SetTableReal(k , "py" , y)
    endif
    call SetTableReal(k , "x" , x)
    call SetTableReal(k , "y" , y)
    call SetTableInt(k , "s" , s)
    call SetTableInt(k , "l" , l)
    call SetTableObject(k , "u" , u)

    call TriggerAddAction(t , function SpellCast_Doer)

    call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_DEATH)
    if ( ty >= 1 ) then //do stuff till channel ends
        call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_SPELL_ENDCAST)
    endif
    if ( ty >= 2 ) then //Wait till channel ends succesfully then do stuff
        call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_SPELL_FINISH)
    else
        set n = GetAbilityDataInt(s , l , "Times")
        if ( n <= 0 ) then
            set n = 0x0FFFFFFF
        endif
        call SetTableInt(k , "n" , n)
        call TriggerRegisterTimerEvent(t , GetAbilityDataReal(s , l , "Timer") , true)
        if ( GetAbilityDataInt(s , l , "instantStart") == 1 ) then
            call TriggerExecute(t)
        endif
    endif

    call RemoveLocation(loc)
 set loc = null

 set u = null
 set t = null
endfunction


//===================================================================================================
// The code!
//
function WaveTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local unit p
 local real x=GetUnitX(u)
 local real y=GetUnitY(u)
 local location loc=GetSpellTargetLoc()
 local real fc=Atan2(GetLocationY(loc) - y , GetLocationX(loc) - x) //The angle between the hero and the target by any chance?
 local integer a=1

 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)

 local integer t=0
 local integer ab=GetAbilityDataInt(s , l , "Spell")
 local real rec
 local string ord
 local real z1

 local integer dop
 local integer n=GetAbilityDataInt(s , l , "WaveN")
 local group g=CreateGroup()
 local real area= GetAbilityDataReal(s , l , "AdvanceDist")
 local real cos= area * Cos(fc)
 local real sin= area * Sin(fc)
 local real nx
 local real ny

 local real dmg=GetAbilityDataReal(s , l , "dmg")
 local real dmgps=GetAbilityDataReal(s , l , "PDmg")
 local real period
 local real dur

 local integer i
 local integer mx=GetAbilityDataInt(s , l , "WaveMaxTargets")

 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_AREA_EFFECT , 0)
 local string fxt=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0)
 local string fxta=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)

 local player ow=GetOwningPlayer(u)
 local real vrt=GetAbilityDataReal(s , l , "Variation")
 local group tg=null
 local boolean scf=( GetAbilityDataInt(s , l , "FromWaveCenter") == 1 )

    if ( dmgps != 0 ) then
        set period = GetAbilityDataReal(s , l , "PDmgPeriod")
        set dur = GetAbilityDataReal(s , l , "PDmgDur")
    endif

    if ( ab != 0 ) then
         set t = GetAbilityDataInt(s , l , "SpellKind")
         set rec = GetAbilityDataReal(s , l , "RecDelay")
         set ord = I2S(GetAbilityDataInt(s , l , "OrderId"))
         set z1 = GetAbilityDataReal(s , l , "SpellHeight")
    endif



    if ( GetAbilityDataInt(s , l , "AvoidHitTwice") == 1 ) then
        set tg = CreateGroup()
    endif


    set area = GetAbilityDataReal(s , l , "WaveArea")

    call RemoveLocation(loc)

    loop
        exitwhen ( a >= n )
        set nx = x + a * cos + GetRandomReal(- vrt , vrt)
        set ny = y + a * sin + GetRandomReal(- vrt , vrt)

        if ( ( fx != "" ) and ( fx != null ) ) then
            call DestroyEffect(AddSpecialEffect(fx , nx , ny))
        endif

        set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        if ( ( ( t == 1 ) and ( ab != 0 ) ) or ( dmg != 0 ) or ( dmgps != 0 ) ) then
            call GroupClear(g)
            call GroupEnumUnitsInRange(g , nx , ny , area , null)
        endif

        if ( ( t == 0 ) and ( ab != 0 ) ) then
            call CasterCastAbilityPointEx(ow , nx , ny , z1 , ab , l , ord , nx , ny , rec)
        endif

        if ( IsDamageOptionIncluded(dop , (16)) ) then // INLINED!!
            call DamageTreesInCircle(nx , ny , area)
        endif

        set i = 0
        loop
            set p = FirstOfGroup(g)
            exitwhen ( ( p == null ) or ( i >= mx ) )
            call GroupRemoveUnit(g , p)
            if ( ( tg != null ) and IsUnitInGroup(p , tg) ) then
                set fc = 0
            else
                set fc = GetDamageFactorByOptions(u , p , dop)
            endif
            if ( fc != 0 ) then

                if ( dmg != 0 ) then
                    call UnitDamageTarget(u , p , dmg * fc , true , false , null , null , null)
                endif
                if ( dmgps != 0 ) then
                    call UnitDamageUnitTimed(u , dmgps * fc , period , dur , p , fxt , fxta , null , null)
                elseif ( ( fxt != "" ) and ( fxt != null ) ) then
                    call DestroyEffect(AddSpecialEffectTarget(fxt , p , fxta))
                endif
                if ( ( ab != 0 ) and ( t == 1 ) ) then
                    if not ( scf ) then
                        set nx = GetUnitX(p)
                        set ny = GetUnitY(p)
                    endif
                    call CasterCastAbilityEx(ow , nx , ny , z1 , ab , l , ord , p , rec)
                endif
                if ( tg != null ) then
                    call GroupAddUnit(tg , p)
                endif
                set i = i + 1
            endif
        endloop
        call TriggerSleepAction(0)
        set a = a + 1
    endloop
    if ( tg != null ) then
        call DestroyGroup(tg)
        set tg = null
    endif

 set ow = null
 set u = null
 set p = null
 set loc = null
endfunction

//===================================================================================================




//===================================================================================================
// The code!
//
function WaveKBTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local unit p
 local real x=GetUnitX(u)
 local real y=GetUnitY(u)
 local location loc=GetSpellTargetLoc()
 local real fc=Atan2(GetLocationY(loc) - y , GetLocationX(loc) - x) //The angle between the hero and the target by any chance?
 local integer a=1

 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)

 local integer t=0
 local integer ab=GetAbilityDataInt(s , l , "Spell")
 local real rec
 local string ord
 local real z1

 local integer dop
 local integer n=GetAbilityDataInt(s , l , "WaveN")
 local group g=CreateGroup()
 local real area= GetAbilityDataReal(s , l , "AdvanceDist")
 local real cos= area * Cos(fc)
 local real sin= area * Sin(fc)
 local real nx
 local real ny

 local real dmg=GetAbilityDataReal(s , l , "dmg")
 local real dmgps=GetAbilityDataReal(s , l , "PDmg")
 local real period
 local real dur

 local integer i
 local integer mx=GetAbilityDataInt(s , l , "WaveMaxTargets")

 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_AREA_EFFECT , 0)
 local string fxt=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0)
 local string fxta=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)

 local player ow=GetOwningPlayer(u)
 local real vrt=GetAbilityDataReal(s , l , "Variation")
 local group tg=null
 local boolean scf=( GetAbilityDataInt(s , l , "FromWaveCenter") == 1 )


    if ( dmgps != 0 ) then
        set period = GetAbilityDataReal(s , l , "PDmgPeriod")
        set dur = GetAbilityDataReal(s , l , "PDmgDur")
    endif

    if ( ab != 0 ) then
         set t = GetAbilityDataInt(s , l , "SpellKind")
         set rec = GetAbilityDataReal(s , l , "RecDelay")
         set ord = I2S(GetAbilityDataInt(s , l , "OrderId"))
         set z1 = GetAbilityDataReal(s , l , "SpellHeight")
    endif



    if ( GetAbilityDataInt(s , l , "AvoidHitTwice") == 1 ) then
        set tg = CreateGroup()
    endif


    set area = GetAbilityDataReal(s , l , "WaveArea")

    call RemoveLocation(loc)

    loop
        exitwhen ( a >= n )
        set nx = x + a * cos + GetRandomReal(- vrt , vrt)
        set ny = y + a * sin + GetRandomReal(- vrt , vrt)

        if ( ( fx != "" ) and ( fx != null ) ) then
            call DestroyEffect(AddSpecialEffect(fx , nx , ny))
        endif

        set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        if ( ( ( t == 1 ) and ( ab != 0 ) ) or ( dmg != 0 ) or ( dmgps != 0 ) ) then
            call GroupClear(g)
            call GroupEnumUnitsInRange(g , nx , ny , area , null)
        endif

        if ( ( t == 0 ) and ( ab != 0 ) ) then
            call CasterCastAbilityPointEx(ow , nx , ny , z1 , ab , l , ord , nx , ny , rec)
        endif

        if ( IsDamageOptionIncluded(dop , (16)) ) then // INLINED!!
            call DamageTreesInCircle(nx , ny , area)
        endif

        set i = 0
        loop
            set p = FirstOfGroup(g)
            exitwhen ( ( p == null ) or ( i >= mx ) )
            call GroupRemoveUnit(g , p)
            if ( ( tg != null ) and IsUnitInGroup(p , tg) ) then
                set fc = 0
            else
                set fc = GetDamageFactorByOptions(u , p , dop)
            endif
            if ( fc != 0 ) then

                if ( dmg != 0 ) then
                    call UnitDamageTarget(u , p , dmg * fc , true , false , null , null , null)
                    call RJ_Knockback(p , ( bj_RADTODEG * Atan2(GetUnitY(p) - GetUnitY(u) , GetUnitX(p) - GetUnitX(u)) ) , 250.00 , false)

                endif
                if ( dmgps != 0 ) then
                    call UnitDamageUnitTimed(u , dmgps * fc , period , dur , p , fxt , fxta , null , null)
                elseif ( ( fxt != "" ) and ( fxt != null ) ) then
                    call DestroyEffect(AddSpecialEffectTarget(fxt , p , fxta))
                endif
                if ( ( ab != 0 ) and ( t == 1 ) ) then
                    if not ( scf ) then
                        set nx = GetUnitX(p)
                        set ny = GetUnitY(p)
                    endif
                    call CasterCastAbilityEx(ow , nx , ny , z1 , ab , l , ord , p , rec)
                endif
                if ( tg != null ) then
                    call GroupAddUnit(tg , p)
                endif
                set i = i + 1
            endif
        endloop
        call TriggerSleepAction(0)
        set a = a + 1
    endloop
    if ( tg != null ) then
        call DestroyGroup(tg)
        set tg = null
    endif

 set ow = null
 set u = null
 set p = null
 set loc = null
endfunction

//===================================================================================================





//===================================================================================================
function ToggleableTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer x
 local integer a=0
 local integer array ab
 local integer array spb
 local integer array added
 local integer i=1
 local integer n=GetAbilityDataInt(s , l , "AbilN")
 local integer buf=GetAbilityDataInt(s , l , "BuffId")
 local integer efper=GetAbilityDataInt(s , l , "CasterEffectPeriods")

    loop
        exitwhen ( GetUnitAbilityLevel(u , buf) > 0 )

        //As unbelievable as it sounds, this is the best way to do this kind of spells, if you 
        //find something better tell me! , The Turn off order used to work so damn perfectly
        //Before but blizzard screwed everything with patch 1.18

        call TriggerSleepAction(0)
    endloop

    loop
        exitwhen ( i > n )
        set ab[i]=GetAbilityDataInt(s , l , "Abil" + I2S(i))
        set spb[i]=GetAbilityDataInt(s , l , "SPB" + I2S(i))

        set x = GetUnitAbilityLevel(u , ab[i])
        if ( x == 0 ) then
            if ( spb[i] != 0 ) then
                call UnitAddAbility(u , spb[i])
                call SetPlayerAbilityAvailable(GetOwningPlayer(u) , spb[i] , false)
            else
                call UnitAddAbility(u , ab[i])
            endif
        endif
        call SetUnitAbilityLevel(u , ab[i] , l + x)
        set added[i]=GetUnitAbilityLevel(u , ab[i]) - x
        set i = i + 1
    endloop
    loop
        exitwhen ( GetUnitAbilityLevel(u , buf) <= 0 )
        call TriggerSleepAction(0)
        if ( ModuloInteger(a , efper) == 0 ) then
            call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_CASTER , GetUnitX(u) , GetUnitY(u)))
        endif
        set a = a + 1
    endloop
    call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , u , "origin"))

    set i = 1
    loop
        exitwhen ( i > n )
        set x = GetUnitAbilityLevel(u , ab[i]) - added[i]
        if ( x <= 0 ) then
            if ( spb[i] != 0 ) then
                call UnitRemoveAbility(u , spb[i])
            endif
            call UnitRemoveAbility(u , ab[i])
        else
            call SetUnitAbilityLevel(u , ab[i] , x)
        endif
        set i = i + 1
    endloop
 

 set u = null
endfunction

//===================================================================================================



//===========================================================================



//===================================================================================================
function ToggleableUSTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local unit u2
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer x
 local integer a=0
 local integer array ab
 local integer array spb
 local integer array added
 local integer array uab
 local integer i=1
 local integer n=GetAbilityDataInt(s , l , "AbilN")
 local integer n2=GetAbilityDataInt(s , l , "UAbilN")
 local integer buf=GetAbilityDataInt(s , l , "BuffId")
 local integer efper=GetAbilityDataInt(s , l , "CasterEffectPeriods")
 local integer uidz=GetAbilityDataInt(s , l , "UnitId")

    loop
        exitwhen ( GetUnitAbilityLevel(u , buf) > 0 )

        //As unbelievable as it sounds, this is the best way to do this kind of spells, if you 
        //find something better tell me! , The Turn off order used to work so damn perfectly
        //Before but blizzard screwed everything with patch 1.18

        call TriggerSleepAction(0)
    endloop

    loop
        exitwhen ( i > n )
        set ab[i]=GetAbilityDataInt(s , l , "Abil" + I2S(i))
        set spb[i]=GetAbilityDataInt(s , l , "SPB" + I2S(i))
 //       set uab[i]=GetAbilityDataInt(s,l,"UAbil"+I2S(i))

        set x = GetUnitAbilityLevel(u , ab[i])
        if ( x == 0 ) then
            if ( spb[i] != 0 ) then
                call UnitAddAbility(u , spb[i])
                call SetPlayerAbilityAvailable(GetOwningPlayer(u) , spb[i] , false)
            else
                call UnitAddAbility(u , ab[i])
            endif
        endif
        call SetUnitAbilityLevel(u , ab[i] , l + x)
        set added[i]=GetUnitAbilityLevel(u , ab[i]) - x
        set i = i + 1
    endloop
    set i = 1
    loop
        exitwhen ( i > n2 )
        set uab[i]=GetAbilityDataInt(s , l , "UAbil" + I2S(i))
        set i = i + 1
    endloop


    loop
        exitwhen ( GetUnitAbilityLevel(u , buf) <= 0 )
        call TriggerSleepAction(0)
        if ( ModuloInteger(a , efper) == 0 ) then
            call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_CASTER , GetUnitX(u) , GetUnitY(u)))
            call CreateNUnitsAtLoc(1 , uidz , GetOwningPlayer(u) , GetUnitLoc(u) , bj_UNIT_FACING)
            set u2 = bj_lastCreatedUnit
            call UnitApplyTimedLifeBJ(( ( 20.00 ) * ( I2R(l) ) ) , 'BTLF' , u2)

            set i = 1
            loop
                exitwhen ( i > n )
                call UnitAddAbility(u2 , uab[i])
                call SetUnitAbilityLevel(u2 , uab[i] , l)
                set i = i + 1
            endloop

        endif
 //       call DisplayTextToPlayer(GetOwningPlayer(u), 0, 0, "test")
        set a = a + 1
    endloop
    call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , u , "origin"))

    set i = 1
    loop
        exitwhen ( i > n )
        set x = GetUnitAbilityLevel(u , ab[i]) - added[i]
        if ( x <= 0 ) then
            if ( spb[i] != 0 ) then
                call UnitRemoveAbility(u , spb[i])
            endif
            call UnitRemoveAbility(u , ab[i])
        else
            call SetUnitAbilityLevel(u , ab[i] , x)
        endif
        set i = i + 1
    endloop
 

 set u = null
 set u2 = null
endfunction

//===================================================================================================



//===================================================================================================
function SlashTemplate_DoSpell takes player ow,unit t,integer s,integer l returns nothing
 local integer ab=GetAbilityDataInt(s , l , "Spell")

    if ( ab != 0 ) then
        call CasterCastAbilityEx(ow , GetUnitX(t) , GetUnitY(t) , GetAbilityDataReal(s , l , "SpellHeight") , ab , l , I2S(GetAbilityDataInt(s , l , "OrderId")) , t , GetAbilityDataReal(s , l , "RecDelay"))
    endif
endfunction
    

function SlashTemplate_Colorize takes unit u,integer rgb returns nothing
 local integer Y=rgb + IntegerTertiaryOp(rgb < 0 , 0x80000000 , 0)
 local integer Z
 local integer r
 local integer g
 local integer b

    set Z = Y / 0x100
    set b = Y - ( Z * 0x100 )
    set Y = Z / 0x100
    set g = Z - ( Y * 0x100 )
    set Z = Y / 0x100
    set r = Y - ( Z * 0x100 )
    if ( rgb < 0 ) then
        set Z = Z + 128
    endif
    call SetUnitVertexColor(u , r , g , b , Z)
endfunction

function SlashTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local group targetlog=CreateGroup()
 local group inrange=CreateGroup()
 local integer i=GetAbilityDataInt(s , l , "totalhits")
 local unit target=GetSpellTargetUnit()
 local unit picked
 local unit other=GetSpellTargetUnit()
 local real grad=GetUnitX(u)
 local real damage=GetAbilityDataReal(s , l , "dmg")
 local effect fx1=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
 local effect fx2=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 2))

 local real x
 local real y
 local real tx
 local real ty
 local real d
 local integer dop
 local real fc

 local real dmgps=GetAbilityDataReal(s , l , "PDmg")
 local real period=GetAbilityDataReal(s , l , "PDmgPeriod")
 local real dur=GetAbilityDataReal(s , l , "PDmgDur")

 local integer ki=GetAbilityDataInt(s , l , "SlashKind")

 local boolean closest=( GetAbilityDataInt(s , l , "SelMethod") == 0 )
 local boolean color= ( GetAbilityDataInt(s , l , "colorize") == 1 )

    call PauseUnit(u , true)
    call SetUnitPathing(u , false)
    if ( color ) then
        call SlashTemplate_Colorize(u , GetAbilityDataInt(s , l , "SlashColor"))
    endif

    loop
        call GroupAddUnit(targetlog , target)
        set x = GetUnitX(u)
        set y = GetUnitY(u)
        set tx = GetUnitX(target)
        set ty = GetUnitY(target)

        call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_SPECIAL , x , y))

        call SetUnitAnimation(u , GetAbilityDataString(s , l , "animation"))
        call TriggerSleepAction(0)

        if ( ( ki == 0 ) or ( ( ki == 2 ) and ( GetRandomInt(0 , 1) == 0 ) ) ) then
            set grad = Atan2(ty - y , tx - x)
        else
            set grad = GetRandomReal(0 , 2 * bj_PI)
        endif
        set x = 100 * Cos(grad)
        set y = 100 * Sin(grad)
        if ( GetAbilityDataInt(s , l , "AngleKind") == 1 ) then
            set x = - x
            set y = - y
        endif
        set x = tx + x
        set y = ty + y
        
        call SetUnitFacing(u , grad * bj_RADTODEG)
        call SetUnitPosition(u , x , y)

        set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        set fc = GetDamageFactorByOptions(u , target , dop)

        if ( fc != 0 ) then
            call UnitDamageTarget(u , target , damage * fc , true , false , null , null , null)
            call SlashTemplate_DoSpell(GetOwningPlayer(u) , target , s , l)
            if ( dmgps != 0 ) then
                call UnitDamageUnitTimed(u , dmgps * fc , period , dur , target , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0) , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1) , null , null)
            else
                call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , target , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)))
            endif
        endif




        call TriggerSleepAction(0)

        set x = GetAbilityDataReal(s , l , "dmgfct")
        set damage = damage * x
        set dmgps = dmgps * x

        set x = GetUnitX(u)
        set y = GetUnitY(u)
        set tx = GetUnitX(target)
        set ty = GetUnitY(target)

        set i = i - 1
        exitwhen ( i == 0 ) or ( GetWidgetLife(u) < 1 )
        call GroupClear(inrange)
        call GroupEnumUnitsInRange(inrange , tx , ty , GetAbilityDataReal(s , l , "area") , null)
        set target = null
        set other = null
        if closest then
            set grad = 1000000
        else
            set grad = 0
        endif
        set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        loop
            set picked = FirstOfGroup(inrange)
            exitwhen ( picked == null )
            set fc = GetDamageFactorByOptions(u , picked , dop)
            if ( fc != 0 ) then
                if closest then
                    set d = SquareRoot(Pow(x - GetUnitX(picked) , 2) + Pow(y - GetUnitY(picked) , 2))
                else
                    set d = GetRandomInt(0 , R2I(grad + 1))
                endif
                if ( d <= grad ) then
                    if not ( IsUnitInGroup(picked , targetlog) ) then
                        if closest then
                            set grad = d
                        endif
                        set target = picked
                    endif
                    if not ( closest ) then
                        set grad = grad + 1
                    endif
                    set other = picked
                endif
            endif
            call GroupRemoveUnit(inrange , picked)
        endloop
        if ( target == null ) and ( GetAbilityDataInt(s , l , "canrepeat") == 1 ) then
            set target = other
        endif
        exitwhen ( target == null )
    endloop
    if ( color ) then
        call SlashTemplate_Colorize(u , GetAbilityDataInt(s , l , "EndColor"))
    endif
    call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , u , "origin"))
    call PauseUnit(u , false)
    call SetUnitPathing(u , true)
    call SetUnitPosition(u , GetUnitX(u) , GetUnitY(u))
 call DestroyEffect(fx1)
 call DestroyEffect(fx2)
 set fx1 = null
 set fx2 = null
 set u = null
 call DestroyGroup(targetlog)
 set targetlog = null
 call DestroyGroup(inrange)
 set inrange = null
 set target = null
 set other = null
endfunction




//===========================================================================
function JumpTemplate_OtherMissile takes player ow,string fx,integer s,integer l,location loc,location tar returns nothing
 local integer rgb=GetAbilityDataInt(s , l , "OModelColor")
 local integer Y=rgb + IntegerTertiaryOp(rgb < 0 , 0x80000000 , 0)
 local integer Z
 local integer r
 local integer g
 local integer b

    set Z = Y / 0x100
    set b = Y - ( Z * 0x100 )
    set Y = Z / 0x100
    set g = Z - ( Y * 0x100 )
    set Z = Y / 0x100
    set r = Y - ( Z * 0x100 )
    if ( rgb < 0 ) then
        set Z = Z + 128
    endif

   call ProjectileLaunchExLoc(ow , fx , GetAbilityDataReal(s , l , "OModelScale") , r , g , b , Z , GetAbilityDataReal(s , l , "speed") , GetAbilityDataReal(s , l , "arc") , loc , GetAbilityDataReal(s , l , "z1") , tar , GetAbilityDataReal(s , l , "z2"))

endfunction

function JumpTemplate_Impact takes integer s,integer l,unit uxx,location loc returns nothing
 local unit u=GetTriggerUnit()
 local player ow=GetOwningPlayer(u)
 local unit p
 local real fc
 local integer t=0
 local integer ab=GetAbilityDataInt(s , l , "Spell")
 local real rec
 local string ord
 local real z1
 local integer dop
 local group g=CreateGroup()
 local real nx=GetLocationX(loc)
 local real ny=GetLocationY(loc)
 local real dmg=GetAbilityDataReal(s , l , "Damage")
 local real dmgps=GetAbilityDataReal(s , l , "PDmg")
 local real period
 local real dur
 local integer i
 local integer mx=GetAbilityDataInt(s , l , "MaxTargets")
 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_EFFECT , 0)
 local string fxt=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0)
 local string fxta=GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)
 local boolean scf=( GetAbilityDataInt(s , l , "FromCenter") == 1 )
 local boolean useFac=( GetAbilityDataInt(s , l , "UseFacing") == 1 )
 local real area=GetAbilityDataReal(s , l , "area")
    if ( ab != 0 ) then
        set t = GetAbilityDataInt(s , l , "SpellKind")
        set rec = GetAbilityDataReal(s , l , "RecDelay")
        set ord = I2S(GetAbilityDataInt(s , l , "OrderId"))
        set z1 = GetAbilityDataReal(s , l , "SpellHeight")
    endif
    if ( dmgps != 0 ) then
        set period = GetAbilityDataReal(s , l , "PDmgPeriod")
        set dur = GetAbilityDataReal(s , l , "PDmgDur")
    endif
    if ( ( fx != "" ) and ( fx != null ) ) then
        call DestroyEffect(AddSpecialEffect(fx , nx , ny))
    endif
    set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
    if ( ( ( t == 1 ) and ( ab != 0 ) ) or ( dmg != 0 ) or ( dmgps != 0 ) ) then
        call GroupClear(g)
        call GroupEnumUnitsInRange(g , nx , ny , area , null)
    endif
    if ( ( t == 0 ) and ( ab != 0 ) ) then
		if( useFac ) then
			set fc = GetUnitFacing(u) * bj_DEGTORAD
			call CasterCastAbilityPointEx(ow , nx , ny , z1 , ab , l , ord , nx + 30 * Cos(fc) , ny + 30 * Sin(fc) , rec)
		else
			call CasterCastAbilityPointEx(ow , nx , ny , z1 , ab , l , ord , nx , ny , rec)
		endif
    endif
    if ( IsDamageOptionIncluded(dop , (16)) ) then // INLINED!!
        call DamageTreesInCircle(nx , ny , area)
    endif
    set i = 0
    loop
        set p = FirstOfGroup(g)
        exitwhen ( ( p == null ) or ( i >= mx ) )
        call GroupRemoveUnit(g , p)
        set fc = GetDamageFactorByOptions(u , p , dop)
        if ( fc != 0 ) then
            if ( dmg != 0 ) then
                call UnitDamageTarget(u , p , dmg * fc , true , false , null , null , null)
            endif
            if ( dmgps != 0 ) then
                call UnitDamageUnitTimed(u , dmgps * fc , period , dur , p , fxt , fxta , null , null)
            elseif ( ( fxt != "" ) and ( fxt != null ) ) then
                call DestroyEffect(AddSpecialEffectTarget(fxt , p , fxta))
            endif
            if ( ( ab != 0 ) and ( t == 1 ) ) then
                if not ( scf ) then
                    set nx = GetUnitX(p)
                    set ny = GetUnitY(p)
                endif
                call CasterCastAbilityEx(ow , nx , ny , z1 , ab , l , ord , p , rec)
            endif
            set i = i + 1
        endif
    endloop
 set ow = null
 set u = null
 set p = null
 set loc = null
endfunction


function JumpTemplate_AnimPlay takes unit u,string anim returns nothing
 local integer i=S2I(anim)
    if ( ( i > 0 ) or ( anim == "0" ) ) then
        call SetUnitAnimationByIndex(u , i)
    else
        call SetUnitAnimation(u , anim)
    endif
endfunction

function JumpTemplate_PrepareUnit_X takes nothing returns nothing
 local timer t=GetExpiredTimer()
 local string k=(I2S(GetHandleId((t)))) // INLINED!!
 local unit u=GetTableUnit(k , "u")
 local integer s=(GetStoredInteger(cs_cache , (k ) , ( "s"))) // INLINED!!
 local integer l=(GetStoredInteger(cs_cache , (k ) , ( "l"))) // INLINED!!
    call SetUnitTimeScale(u , GetAbilityDataReal(s , l , "AnimSpeed"))
    call JumpTemplate_AnimPlay(u , GetAbilityDataString(s , l , "JumpAnim"))
    call SetUnitPosition(u , (GetStoredReal(cs_cache , (k ) , ( "x"))) , (GetStoredReal(cs_cache , (k ) , ( "y")))) // INLINED!!
    call ShowUnit(u , true)
    call CS_KillTimer(t)
 set u = null
 set t = null
endfunction
function JumpTemplate_PrepareUnit takes unit u,real x,real y,integer s,integer l returns nothing
 local timer t=CreateTimer()
 local string k=(I2S(GetHandleId((t)))) // INLINED!!
    call SetTableObject(k , "u" , u)
    call SetTableReal(k , "x" , x)
    call SetTableReal(k , "y" , y)
    call SetTableInt(k , "s" , s)
    call SetTableInt(k , "l" , l)
    call TimerStart(t , 0 , false , function JumpTemplate_PrepareUnit_X)
 set t = null
endfunction


function JumpTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local location target=GetSpellTargetLoc()
 local location loc=GetUnitLoc(u)
 local boolean sel=false
 local boolean mode= ( GetAbilityDataInt(s , l , "UseOtherModel") == 1 )
 local string fx=GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 0)
 local real fh=GetUnitFlyHeight(u)
 local effect ffx

    set sel = IsUnitSelected(u , GetOwningPlayer(u))
    if mode then
        call ShowUnit(u , false)
        call JumpTemplate_OtherMissile(GetOwningPlayer(u) , fx , s , l , loc , target)
        call SetUnitPosition(u , GetLocationX(target) , GetLocationY(target))
        call ShowUnit(u , true)
    else
       set ffx = AddSpecialEffectTarget(fx , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
       call UnitAddAbility(u , (cs_FlyingHeightHack)) // INLINED!!
       call UnitRemoveAbility(u , (cs_FlyingHeightHack)) // INLINED!!

        call ShowUnit(u , false)
        call PauseUnit(u , true)
        call JumpTemplate_PrepareUnit(u , GetUnitX(u) , GetUnitY(u) , s , l) //Allows abilities like blink work with this correctly
        call UnitMoveToAsProjectileAnySpeed_Effect((u ) , null , (( GetAbilityDataReal(s , l , "speed") )*1.0) , (( GetAbilityDataReal(s , l , "arc") )*1.0) , (( GetLocationX(target) )*1.0) , (( GetLocationY(target) )*1.0) , ( null ) , (( fh)*1.0)) // INLINED!!
        call SetUnitPosition(u , GetLocationX(target) , GetLocationY(target))
        call SetUnitTimeScale(u , 1)
        call PauseUnit(u , false)
       call DestroyEffect(ffx)
       set ffx = null
    endif
    call SetUnitFlyHeight(u , fh , 0)
    if ( GetWidgetLife(u) >= 1 ) then
        call JumpTemplate_Impact(s , l , u , target)
        call JumpTemplate_AnimPlay(u , GetAbilityDataString(s , l , "EndAnim"))
        call QueueUnitAnimation(u , "stand")
        if sel then
            call SelectUnitAddForPlayer(u , GetOwningPlayer(u))
        endif
    endif
 call RemoveLocation(loc)
 call RemoveLocation(target)
 set u = null
 set loc = null
 set target = null
endfunction

function JumpTemplateNX takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local location target=GetSpellTargetLoc()
 local location loc=GetUnitLoc(u)
 local boolean sel=false
 local boolean mode= ( GetAbilityDataInt(s , l , "UseOtherModel") == 1 )
 local string fx=GetAbilityDataString(s , l , "OtherModel")
 local real fh=GetUnitFlyHeight(u)
 local effect ffx

    set sel = IsUnitSelected(u , GetOwningPlayer(u))
    if mode then
        call ShowUnit(u , false)
        call JumpTemplate_OtherMissile(GetOwningPlayer(u) , fx , s , l , loc , target)
        call SetUnitPosition(u , GetLocationX(target) , GetLocationY(target))
        call ShowUnit(u , true)
    else
       set ffx = AddSpecialEffectTarget(fx , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
       call UnitAddAbility(u , (cs_FlyingHeightHack)) // INLINED!!
       call UnitRemoveAbility(u , (cs_FlyingHeightHack)) // INLINED!!

        call ShowUnit(u , false)
        call PauseUnit(u , true)
        call JumpTemplate_PrepareUnit(u , GetUnitX(u) , GetUnitY(u) , s , l) //Allows abilities like blink work with this correctly
        call UnitMoveToAsProjectileAnySpeed_Effect((u ) , null , (( GetAbilityDataReal(s , l , "speed") )*1.0) , (( GetAbilityDataReal(s , l , "arc") )*1.0) , (( GetLocationX(target) )*1.0) , (( GetLocationY(target) )*1.0) , ( null ) , (( fh)*1.0)) // INLINED!!
        call SetUnitPosition(u , GetLocationX(target) , GetLocationY(target))
        call SetUnitTimeScale(u , 1)
        call PauseUnit(u , false)
       call DestroyEffect(ffx)
       set ffx = null
    endif
    call SetUnitFlyHeight(u , fh , 0)
    if ( GetWidgetLife(u) >= 1 ) then
        call JumpTemplate_Impact(s , l , u , target)
        call JumpTemplate_AnimPlay(u , GetAbilityDataString(s , l , "EndAnim"))
        call QueueUnitAnimation(u , "stand")
        if sel then
            call SelectUnitAddForPlayer(u , GetOwningPlayer(u))
        endif
    endif
 call RemoveLocation(loc)
 call RemoveLocation(target)
 set u = null
 set loc = null
 set target = null
endfunction


//===========================================================================




//===================================================================================================
// Channel Aura Code:
//
function ChannelAuraTemplate_Wait takes timer t returns nothing
    call TimerStart(t , 1 , false , null)
    loop
        exitwhen ( TimerGetRemaining(t) <= 0 )
        call TriggerSleepAction(0.1)
    endloop
endfunction

function ChannelAuraTemplate takes nothing returns nothing
 local timer t=CreateTimer()
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer nl=l
 local integer n=GetAbilityDataInt(s , l , "n")
 local integer array abis
 local integer array spb
 local integer a=n
 local group affected=null
 local group inrange=CreateGroup()
 local group aux=CreateGroup()
 local unit picked
 local real area=GetAbilityDataReal(s , l , "area")

 local boolean halt=false
 local integer d
 local trigger end=CreateTrigger()
 local effect fx=AddSpellEffectById(s , EFFECT_TYPE_AREA_EFFECT , GetUnitX(u) , GetUnitY(u))
 local integer weid=GetAbilityDataInt(s , l , "WeatherEffect")

 local rect efa
 local weathereffect snow


    if ( weid != 0 ) then
        set efa = Rect(GetUnitX(u) - area / 5 , GetUnitY(u) - area / 5 , GetUnitX(u) + area / 5 , GetUnitY(u) + area / 5)
        set snow = AddWeatherEffect(efa , weid)
        call EnableWeatherEffect(snow , true)
    endif

    call TriggerRegisterUnitEvent(end , u , EVENT_UNIT_SPELL_ENDCAST)

    loop
        exitwhen ( a == 0 )
        set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
        set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
        set a = a - 1
    endloop
    loop
        exitwhen halt
        set nl = GetUnitAbilityLevel(u , s)
        if ( nl != l ) then
            if ( nl == 0 ) then
                set halt = true
            else
                loop
                    set picked = FirstOfGroup(aux)
                    exitwhen picked == null
                    set a = n
                    loop
                        exitwhen a == 0
                        call UnitRemoveAbility(picked , spb[a])
                        call UnitRemoveAbility(picked , abis[a])
                        set a = a - 1
                    endloop
                    call GroupRemoveUnit(aux , picked)
                endloop
                set l = nl
                set n = GetAbilityDataInt(s , l , "n")
                set a = n
                loop
                    exitwhen a == 0 or halt
                    set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
                    set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
                    set a = a - 1
                endloop
                set area = GetAbilityDataReal(s , l , "area")
            endif
        endif
        set halt = halt or ( GetTriggerEvalCount(end) > 0 )
        exitwhen halt
        if ( GetWidgetLife(u) > 0 ) then
            call GroupEnumUnitsInRange(inrange , GetUnitX(u) , GetUnitY(u) , area , null)
        else
            set halt = halt or ( GetUnitState(u , UNIT_STATE_MAX_LIFE) <= 0 ) //If max life is 0, the unit was removed
            call GroupClear(inrange)
        endif
        if ( affected != null ) then
            call DestroyGroup(affected)
        endif
        set affected = aux
        set aux = CreateGroup()
        loop
            set picked = FirstOfGroup(affected)
            exitwhen picked == null
            if not IsUnitInGroup(picked , inrange) then
                set a = n
                loop
                    exitwhen ( a == 0 )
                    call UnitRemoveAbility(picked , spb[a])
                    call UnitRemoveAbility(picked , abis[a])
                    set a = a - 1
                endloop
            else
                call GroupRemoveUnit(inrange , picked)
                call GroupAddUnit(aux , picked)
            endif
            call GroupRemoveUnit(affected , picked)
        endloop
        set d = GetAbilityDataInt(s , l , "options")
        if ( d != 0 ) then
            set d = LoadDamageOptions(d)
        endif
        loop
            set picked = FirstOfGroup(inrange)
            exitwhen picked == null

            if ( GetDamageFactorByOptions(u , picked , d) > 0 ) then
                set a = n
                loop
                    exitwhen a == 0
                    if ( spb[a] != 0 ) then
                        call SetPlayerAbilityAvailable(GetOwningPlayer(picked) , spb[a] , false)
                        call UnitAddAbility(picked , spb[a])
                    else
                        call UnitAddAbility(picked , abis[a])
                    endif
                    call SetUnitAbilityLevel(picked , abis[a] , l)
                    call GroupAddUnit(aux , picked)
                    set a = a - 1
                endloop
            endif
            call GroupRemoveUnit(inrange , picked)
        endloop
        call ChannelAuraTemplate_Wait(t)
    endloop
    loop
        set picked = FirstOfGroup(aux)
        exitwhen picked == null
        set a = n
        loop
            exitwhen ( a <= 0 )
            call UnitRemoveAbility(picked , spb[a])
            call UnitRemoveAbility(picked , abis[a])
            set a = a - 1
        endloop
        call GroupRemoveUnit(aux , picked)
    endloop
    if ( weid != 0 ) then
        call RemoveRect(efa)
       set efa = null
        call RemoveWeatherEffect(snow)
       set snow = null
    endif

    call DestroyEffect(fx)
 call DestroyGroup(affected)
 call DestroyGroup(inrange)
 call DestroyGroup(aux)
 call DestroyTimer(t)
 call DestroyTrigger(end)
 set t = null
 set affected = null
 set inrange = null
 set picked = null
 set u = null
 set end = null
 set aux = null
endfunction




//===================================================================================================
constant function ChainTemplate_Timer takes nothing returns real
    return 0.04
endfunction

function ChainTemplate_OnTimer takes nothing returns nothing
 local timer c=GetExpiredTimer()
 local string k=(I2S(GetHandleId((c)))) // INLINED!!
 local unit m=GetAttachedUnit(c , "m")
 local unit t=GetAttachedUnit(c , "t")
 local real d=(0.04) * (GetStoredReal(cs_cache , (k ) , ( "s"))) // INLINED!!
 local real x=GetUnitX(m)
 local real y=GetUnitY(m)
 local real a=Atan2(GetUnitY(t) - y , GetUnitX(t) - x)

    if ( not (GetStoredBoolean(cs_cache , (k ) , ( "done"))) ) then // INLINED!!
        call CS_MoveUnit(m , x + d * Cos(a) , y + d * Sin(a))
        if ( IsUnitInRange(m , t , 20) ) then
            call SetTableBoolean(k , "done" , true)
        endif
    else
        call CS_MoveUnit(m , GetUnitX(t) , GetUnitY(t))
    endif

 set m = null
 set t = null
 set c = null
endfunction

function ChainTemplate_MoveTo takes unit m,unit t,real s,real zo returns nothing
 local timer x=CreateTimer()
 local real f=GetUnitFlyHeight(t) + zo
 local real dif=RAbsBJ(GetUnitFlyHeight(t) - f)
 local real mx=GetUnitX(m)
 local real my=GetUnitY(m)
 local real tx=GetUnitX(t)
 local real ty=GetUnitY(t)
 local real d=SquareRoot(Pow(mx - tx , 2) + Pow(my - ty , 2))

    call SetUnitFacing(m , Atan2BJ(ty - my , tx - mx))
    call SetUnitFlyHeight(m , f , dif / ( ( d + 0.001 ) / s ))
    call AttachObject(x , "m" , m)
    call AttachObject(x , "t" , t)
    call AttachReal(x , "s" , s)
    //call AttachReal(x,"z",zo)
    
    call TimerStart(x , (0.04) , true , function ChainTemplate_OnTimer) // INLINED!!
    loop
        exitwhen ( d <= 20 )
        call TriggerSleepAction(0)
        set d = SquareRoot(Pow(GetUnitX(m) - GetUnitX(t) , 2) + Pow(GetUnitY(m) - GetUnitY(t) , 2))
    endloop
    call SetUnitFlyHeight(m , f , 0)
 call FlushStoredMission(cs_cache , I2S(GetHandleId((x)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(x))
 call DestroyTimer(x)
 set x = null
endfunction

function ChainSpellTemplate takes nothing returns nothing
 local unit closest=GetSpellTargetUnit()
 local unit closer
 local unit u=GetTriggerUnit()
 local group victimlog=CreateGroup()
 local group area=CreateGroup()
 local unit picked
 local real dist
 local real x
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local integer a=GetAbilityDataInt(s , l , "bounces")
 local real fct=GetAbilityDataReal(s , l , "factor")
 local real dmg=GetAbilityDataReal(s , l , "damage") / fct
 local real dmgps=GetAbilityDataReal(s , l , "damageps") / fct
 local real dur=GetAbilityDataReal(s , l , "duration")
 local real period=GetAbilityDataReal(s , l , "period")
 local real aoe=GetAbilityDataReal(s , l , "area")
 local integer spell=GetAbilityDataInt(s , l , "spellid")
 local integer order=GetAbilityDataInt(s , l , "orderid")
 local real delay=GetAbilityDataReal(s , l , "delay")
 local boolean good= ( GetAbilityDataInt(s , l , "isgoodspell") == 1 )
 local boolean b
 local boolean fast=false
 local boolean first=true
 local effect fx
 local unit m=(CreateCaster(((Atan2BJ(GetUnitY(closest) - GetUnitY(u) , GetUnitX(closest) - GetUnitX(u)))*1.0) , 0 , 0)) // INLINED!!
 local integer dopt=GetAbilityDataInt(s , l , "options")
 local integer q
 local real dopfc
 local real spd

    call SetUnitPosition(m , GetUnitX(u) , GetUnitY(u))
    call SetUnitFlyHeight(m , GetAbilityDataReal(s , l , "height") , 0)
    set fx = AddSpellEffectTargetById(s , EFFECT_TYPE_AREA_EFFECT , m , "origin")
    set x = GetAbilityDataReal(s , l , "scale")
    call SetUnitScale(m , x , x , x)
    call SetUnitOwner(m , GetOwningPlayer(u) , true)
    set x = GetAbilityDataReal(s , l , "speed")
    if x == 0 then
        set fast = true
    else
        set spd = x
        //call SetUnitMoveSpeed(m,x)
    endif
    loop
        exitwhen a <= 0
        if not ( first ) then
            set q = LoadDamageOptions(dopt)
            call GroupEnumUnitsInRange(area , GetUnitX(closest) , GetUnitY(closest) , aoe , null)
            set dist = 1000000
            set closer = null
            loop
                set picked = FirstOfGroup(area)
                exitwhen picked == null
                set b = ( IsUnitEnemy(picked , GetOwningPlayer(u)) and not ( good ) ) or ( IsUnitAlly(picked , GetOwningPlayer(u)) and good ) and ( GetDamageFactorByOptions(u , picked , q) != 0 )
                if b and not ( IsUnitInGroup(picked , victimlog) ) and IsUnitAliveBJ(picked) then
                    set x = SquareRoot(Pow(GetUnitX(picked) - GetUnitX(closest) , 2) + Pow(GetUnitY(picked) - GetUnitY(closest) , 2))
                    if x < dist then
                        set closer = picked
                        set dist = x
                    endif
                endif
                call GroupRemoveUnit(area , picked)
            endloop
            exitwhen closer == null
        else
           set first = false
           set closer = GetSpellTargetUnit()
           set closest = u
        endif
        set x = GetAbilityDataReal(s , l , "height")
        if fast then
            call IssuePointOrder(m , "move" , GetUnitX(closer) , GetUnitY(closer))
            call TriggerSleepAction(0)
            call SetUnitPosition(m , GetUnitX(closer) , GetUnitY(closer))
        else
            call ChainTemplate_MoveTo(m , closer , spd , x)
            //call UnitMoveToUnitAsProjectile(m, 0, closer, x)
            call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_AREA_EFFECT , closer , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 1)))
        endif
        set dmg = dmg * fct
        set dmgps = dmgps * fct
        set dopfc = GetDamageFactorByOptions(u , closer , LoadDamageOptions(dopt))
        if dopfc != 0 then
            call UnitDamageTarget(u , closer , dmg * dopfc , true , false , null , null , null)
            if spell != 0 then
                set udg_delayhack = delay
                call CasterCastAbilityLevel(GetOwningPlayer(u) , spell , l , I2S(order) , closer , delay == 0)
                set udg_delayhack = 0
            endif
            if dmgps != 0 then
                call UnitDamageUnitTimed(u , dmgps * dopfc , period , dur , closer , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 0) , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 1) , null , null)
            else
                call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , closer , GetAbilityEffectById(s , EFFECT_TYPE_SPECIAL , 1)))
            endif
        endif
        set closest = closer
        call GroupAddUnit(victimlog , closest)
        set a = a - 1
    endloop
    if fast then
        call TriggerSleepAction(0)
    endif
    call DestroyEffect(fx)
    call SetUnitOwner(m , Player(15) , false)
    call UnitApplyTimedLife(m , 0 , 4)

 call DestroyGroup(victimlog)
 call DestroyGroup(area)
 set closest = null
 set closer = null
 set u = null
 set victimlog = null
 set area = null
 set picked = null
endfunction





    // this is to add several abilities set up with the template system
function KS_AddNAbil takes unit whichUnit,integer abilityId,string abilityprefix,integer lvl,boolean add,unit caster returns nothing
    local integer i= 1
    local integer n= GetAbilityDataInt(abilityId , lvl , abilityprefix + "N")
    local integer abil
    local integer d
    local player own= GetOwningPlayer(whichUnit)
    loop
        exitwhen ( i > n )
        set d = GetAbilityDataInt(abilityId , lvl , abilityprefix + "options" + I2S(i)) //check pause options
        if ( d != 0 ) then
            set d = LoadDamageOptions(d)
        endif
        if ( GetDamageFactorByOptions(caster , whichUnit , d) > 0 ) then
            set abil = GetAbilityDataInt(abilityId , lvl , abilityprefix + "spbk" + I2S(i))
            if ( abil != 0 ) then
                call SetPlayerAbilityAvailable(own , abil , false)
            else
                set abil = GetAbilityDataInt(abilityId , lvl , abilityprefix + "abil" + I2S(i))
            endif
            call KS_UnitAddAbilityStack(whichUnit , abil , add)
        endif
        set i = i + 1
    endloop
    set whichUnit = null
    set abilityprefix = null
    set caster = null
endfunction


    //this is an additional function for KS_FT_Timer
    //called for each unit in the unit group and unpauses/remove abilities
    //but only if they did not have those abilites before entering the field
function KS_FT_CleanGroup takes nothing returns nothing
    local group iter=bj_groupLastCreatedDest
    local unit enum= GetEnumUnit()
    local integer s= (GetStoredInteger(cs_cache , I2S(GetHandleId((iter ))) , ( I2S((GetHandleId((enum)))) + "s"))) // INLINED!!
    local integer lvl= (GetStoredInteger(cs_cache , I2S(GetHandleId((iter ))) , ( I2S((GetHandleId((enum)))) + "lvl"))) // INLINED!!
    local integer d=GetAbilityDataInt(s , lvl , "pauseoptions") //check pause options
    local unit caster= GetAttachedUnit(iter , I2S((GetHandleId((enum)))) + "caster") // INLINED!!
    local boolean pauseany=GetAbilityDataInt(s , lvl , "pauseany") != 0
    if ( d != 0 ) then
        set d = LoadDamageOptions(d)
    endif
    if ( pauseany and GetDamageFactorByOptions(caster , enum , d) > 0 ) then
        call KS_PauseUnit(enum , false)
        if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((enum ))) , ( "KS_PauseNum"))) == 0 ) then // INLINED!!
            call SetUnitTimeScalePercent(enum , 100.00)
        endif
    endif
    call KS_AddNAbil(enum , s , "unpaused" , lvl , false , caster)
    call KS_AddNAbil(enum , s , "all" , lvl , false , caster)
    set enum = null
    set caster = null
endfunction

function KS_CleanCasters takes nothing returns nothing
    local unit enum= GetEnumUnit()
    call IssueImmediateOrder(enum , "stop")
    call RecycleCaster((enum)) // INLINED!!
    set enum = null
endfunction
                             
    //this is the function run when the timer expires
    //it performs cleanup duties for the template
function KS_FT_Timer takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local trigger tgr= GetAttachedTrigger(t , "effect")
    local timer orders=GetAttachedTimer(t , "orders")
    local trigger channelstop=GetAttachedTrigger(t , "channelstop")
    local effect e= GetAttachedEffect(t , "art")
    local location l= GetAttachedLoc(orders , "l")
    set bj_wantDestroyGroup = true
    set bj_groupLastCreatedDest = GetAttachedGroup(tgr , "group")
    call ForGroupBJ(bj_groupLastCreatedDest , function KS_FT_CleanGroup) //begin cleanup functions
    set bj_wantDestroyGroup = true
    set bj_groupLastCreatedDest = GetAttachedGroup(tgr , "CSgroup")
    call ForGroupBJ(bj_groupLastCreatedDest , function KS_CleanCasters)
    call DestroyEffect(e)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((tgr)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(tgr))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((orders)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(orders))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((channelstop)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(channelstop))
    call DestroyTrigger(tgr)
    call DestroyTimer(orders)
    call DestroyTrigger(channelstop)
    call DestroyTimer(t)
    call RemoveLocation(l)
    set l = null
    set t = null
    set tgr = null
    set orders = null
    set e = null
    set channelstop = null
endfunction

    //this is the garbage cleaning for the channelstop
function KS_FT_NoTimerClean takes timer t returns nothing
    local trigger tgr= GetAttachedTrigger(t , "effect")
    local timer orders=GetAttachedTimer(t , "orders")
    local trigger channelstop=GetAttachedTrigger(t , "channelstop")
    local effect e= GetAttachedEffect(t , "art")
    local location l= GetAttachedLoc(orders , "l")
    set bj_wantDestroyGroup = true
    call ForGroupBJ(GetAttachedGroup(tgr , "group") , function KS_FT_CleanGroup) //begin cleanup functions
    set bj_wantDestroyGroup = true
    call ForGroupBJ(GetAttachedGroup(tgr , "CSgroup") , function KS_CleanCasters)
    call DestroyEffect(e)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((tgr)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(tgr))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((orders)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(orders))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((channelstop)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(channelstop))
    call DestroyTrigger(tgr)
    call DestroyTimer(orders)
    call DestroyTrigger(channelstop)
    call DestroyTimer(t)
    call RemoveLocation(l)
    set l = null
    set t = null
    set tgr = null
    set orders = null
    set e = null
    set channelstop = null
endfunction



    //this function is part of the checks on entering units:
    //  it sets several forbidden unit types                                                      
function KS_FT_Effects_Conditions takes nothing returns boolean
    local trigger this=GetTriggeringTrigger()
    local unit caster=GetAttachedUnit(this , "caster")
    local unit trigunit=GetTriggerUnit()
    local integer s=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "s"))) // INLINED!!
    local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "lvl"))) // INLINED!!
    local boolean self=GetAbilityDataInt(s , lvl , "notself") == 0 //affects self?
    local integer bad=GetAbilityDataInt(s , lvl , "bad") //0 for friend, 1 for enemy, 2 for both
    
    local boolean bool=true
    
    if ( not self ) then //check self and bad
        set bool = bool and IsUnit(trigunit , caster) == false
    endif
    if ( bad == 0 ) then
        set bool = bool and not IsUnitEnemy(trigunit , GetOwningPlayer(caster))
    elseif ( bad == 1 ) then
        set bool = bool and not IsUnitAlly(trigunit , GetOwningPlayer(caster))
    endif
    
    //cleanup
    set trigunit = null
    set caster = null
    set this = null
    return bool
endfunction



    //This function perfoms all actions on units that enter the field
function KS_FT_Effects_Actions takes nothing returns nothing
    local trigger this=GetTriggeringTrigger()
    local unit caster=GetAttachedUnit(this , "caster")
    local unit trigunit=GetTriggerUnit()
    local unit field=GetAttachedUnit(this , "CScast")
    local group pausedunits=GetAttachedGroup(this , "group")
    local integer d
    local integer s=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "s"))) // INLINED!!
    local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "lvl"))) // INLINED!!
    local integer i=1
    local integer n= GetAbilityDataInt(s , lvl , "enterN")
    local boolean stopany=GetAbilityDataInt(s , lvl , "pauseany") != 0 //pause any units in region?
    local player own=GetOwningPlayer(caster)
    
    if ( not IsUnitInGroup(trigunit , pausedunits) ) then //don't re-add effects to units in the field
        call GroupAddUnit(pausedunits , trigunit)
        call KS_AddNAbil(trigunit , s , "all" , lvl , true , caster)
        call AttachObject(pausedunits , I2S((GetHandleId((trigunit)))) + "caster" , caster) // INLINED!!
        call AttachInt(pausedunits , I2S((GetHandleId((trigunit)))) + "s" , s) // INLINED!!
        call AttachInt(pausedunits , I2S((GetHandleId((trigunit)))) + "lvl" , lvl) // INLINED!!
        loop
            exitwhen ( i > n )
            set d = GetAbilityDataInt(s , lvl , "enteroptions" + I2S(i)) //check pause options
            if ( d != 0 ) then
                set d = LoadDamageOptions(d)
            endif
            if ( GetDamageFactorByOptions(caster , trigunit , d) > 0 ) then
                call CasterCastAbilityEx(own , GetUnitX(field) , GetUnitY(field) , 0 , GetAbilityDataInt(s , lvl , "enterabil" + I2S(i)) , 1 , GetAbilityDataString(s , lvl , "enterorderId" + I2S(i)) , trigunit , .01)
            endif
            set i = i + 1
        endloop
    
        if ( KS_FT_Effects_Conditions() ) then //if Conditions are fulfilled, either pause or add stopAbility 
            set d = GetAbilityDataInt(s , lvl , "pauseoptions") //check pause options
            if ( d != 0 ) then
                set d = LoadDamageOptions(d)
            endif
            
            if ( stopany and ( GetDamageFactorByOptions(caster , trigunit , d) > 0 ) ) then
                call KS_PauseUnit(trigunit , true)
                call SetUnitTimeScalePercent(trigunit , 0.00)
            else
                call KS_AddNAbil(trigunit , s , "unpaused" , lvl , true , caster)
            endif
        endif
    endif
    
    //cleanup
    set caster = null
    set this = null
    set trigunit = null
    set pausedunits = null
    set own = null
endfunction

    //This function is the loop function for the leaving function
function KS_FT_Orders_Enum takes nothing returns nothing
    local timer this=GetExpiredTimer()
    local integer s=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "s"))) // INLINED!!
    local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "lvl"))) // INLINED!!
    local unit field= GetAttachedUnit(this , "field")
    local unit caster= GetAttachedUnit(this , "caster")
    local real range= (GetStoredReal(cs_cache , I2S(GetHandleId((this ))) , ( "range"))) // INLINED!!
    local boolean pauseany= GetAbilityDataInt(s , lvl , "pauseany") != 0
    local integer d
    local group stopped
    local boolean preventleave= (GetStoredBoolean(cs_cache , I2S(GetHandleId((this ))) , ( "preventleave"))) // INLINED!!
    local unit u= GetEnumUnit()
    local real ang= KS_AngleBetweenUnits(u , field) * bj_DEGTORAD
    local real move= GetUnitMoveSpeed(u) * (GetStoredReal(cs_cache , I2S(GetHandleId((this ))) , ( "timeout"))) // INLINED!!
    if ( not IsUnitInRange(u , field , range) ) then
        if ( preventleave ) then
            call CS_MoveUnit(u , GetUnitX(u) + move * Cos(ang) , GetUnitY(u) + move * Sin(ang))
        else
            set stopped = GetAttachedGroup(this , "group")
            call GroupRemoveUnit(stopped , u)
            set d = GetAbilityDataInt(s , lvl , "pauseoptions") //check pause options
            if ( d != 0 ) then
                set d = LoadDamageOptions(d)
            endif
            if ( pauseany and GetDamageFactorByOptions(caster , u , d) > 0 ) then
                call KS_PauseUnit(u , false)
                if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "KS_PauseNum"))) == 0 ) then // INLINED!!
                    call SetUnitTimeScalePercent(u , 100.00)
                endif
            endif
            call KS_AddNAbil(u , s , "unpaused" , lvl , false , caster)
            call KS_AddNAbil(u , s , "all" , lvl , false , caster)
        endif
    endif
    set this = null
    set field = null
    set stopped = null
    set u = null
    set caster = null
    set field = null
endfunction

    //this function checks when units leave the area
function KS_FT_Orders_Actions takes nothing returns nothing
    local timer this=GetExpiredTimer()
    local group stopped= GetAttachedGroup(this , "group")
    call ForGroup(stopped , function KS_FT_Orders_Enum)
    set stopped = null
    set this = null
endfunction

    //this function is the conditions for the channelstop trigger
function KS_FT_channelstop_Conditions takes nothing returns boolean
    local trigger this=GetTriggeringTrigger()
    local boolean bool= GetSpellAbilityId() == (GetStoredInteger(cs_cache , I2S(GetHandleId((this ))) , ( "s"))) // INLINED!!
    set this = null
    return bool
endfunction

    //this function stops the spell if the caster stops channeling
function KS_FT_channelstop_Actions takes nothing returns nothing
    local trigger this=GetTriggeringTrigger()
    local timer tmr= GetAttachedTimer(this , "tmr")
    call KS_FT_NoTimerClean(tmr)
    set this = null
    set tmr = null
endfunction

    //this is the main TimeStopTemplate function
    //it sets up all the other triggers and functions
function KS_FieldTemplate takes nothing returns nothing
    //required variables
    local unit caster=GetSpellAbilityUnit()
    local integer s=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , s)

    //user-defined variables
    local real dur=GetAbilityDataReal(s , lvl , "dur") //spell duration
    local real range=GetAbilityDataReal(s , lvl , "range") //radius of the field
    local string fieldart= GetAbilityDataString(s , lvl , "fieldart") //field art
    local boolean preventleave= GetAbilityDataInt(s , lvl , "preventleave") != 0 //prevent units from leaving the area
    local real artsize= GetAbilityDataReal(s , lvl , "artsize") //the size of the fieldart
    local boolean channeled= GetAbilityDataInt(s , lvl , "channeled") != 0
    
    //non-user-defined variables
    local integer n= GetAbilityDataInt(s , lvl , "areaN")
    local integer i= 1
    local integer a
    local timer tmr= CreateTimer()
    local location l=GetSpellTargetLoc()
    local trigger t=CreateTrigger()
    local timer orders=CreateTimer()
    local trigger channelstop=CreateTrigger()
    local group stopped=CreateGroup()
    local group CSgroup=CreateGroup()
    local unit CScast=GetACaster()
    local unit CScasters
    local player own
    local string temp
    local effect art= AddSpecialEffectTarget(fieldart , CScast , "origin")
    local real timeout=0.04
    call GroupAddUnit(CSgroup , CScast)
    
    
    call SetUnitScale(CScast , artsize , artsize , artsize)
    call CS_MoveUnit(CScast , GetLocationX(l) , GetLocationY(l))
    
    //use CS to cast castAbility
    loop
        exitwhen ( i > n )
        set a = GetAbilityDataInt(s , lvl , "areaabil" + I2S(i))
        set own = GetOwningPlayer(caster)
        set temp = GetAbilityDataString(s , lvl , "areaorderId" + I2S(i))
        set CScasters = (CasterCastAbilityLevelPoint((own ) , ( a ) , 1 , ( temp ) , (( GetLocationX(l) )*1.0) , (( GetLocationY(l) )*1.0) , ( false))) // INLINED!!
        
        call GroupAddUnit(CSgroup , CScasters)
        set i = i + 1
    endloop
    
    //set up the enter field trigger
    call AttachObject(t , "caster" , caster)
    call AttachObject(t , "group" , stopped)
    call AttachInt(t , "s" , s)
    call AttachInt(t , "lvl" , lvl)
    call AttachObject(t , "CSgroup" , CSgroup)
    call AttachObject(t , "CScast" , CScast)
    call AttachReal(t , "range" , range)
    call TriggerRegisterUnitInRangeSimple(t , range , CScast)
    call TriggerAddAction(t , function KS_FT_Effects_Actions)
    
    //set up the timer for leaving the area
    call AttachObject(orders , "field" , CScast)
    call AttachReal(orders , "range" , range)
    call AttachBoolean(orders , "preventleave" , preventleave)
    call AttachObject(orders , "group" , stopped)
    call AttachInt(orders , "s" , s)
    call AttachInt(orders , "lvl" , lvl)
    call AttachObject(orders , "caster" , caster)
    call AttachReal(orders , "timeout" , timeout)
    call TimerStart(orders , timeout , true , function KS_FT_Orders_Actions)

    
    //set up the channeling stop trigger
    if ( channeled ) then
        call AttachInt(channelstop , "s" , s)
        call AttachObject(channelstop , "tmr" , tmr)
        call AttachObject(channelstop , "caster" , caster)
        call TriggerRegisterUnitEvent(channelstop , caster , EVENT_UNIT_SPELL_ENDCAST)
        call TriggerAddCondition(channelstop , Condition(function KS_FT_channelstop_Conditions))
        call TriggerAddAction(channelstop , function KS_FT_channelstop_Actions)
    endif
    
    //set up the timer
    call AttachObject(tmr , "effect" , t)
    call AttachObject(tmr , "art" , art)
    call AttachObject(tmr , "orders" , orders)
    call AttachObject(tmr , "channelstop" , channelstop)
    call TimerStart(tmr , dur , false , function KS_FT_Timer)
    
    //cleanup
    set tmr = null
    set l = null
    set caster = null
    set t = null
    set stopped = null
    set orders = null
    set art = null
    set CScast = null
    set CScasters = null
    set CSgroup = null
    set channelstop = null
    set fieldart = null
endfunction
//===========================================================================


function LocustFollowerAction takes nothing returns nothing
local trigger trg=GetTriggeringTrigger()
local unit caster=GetAttachedUnit(trg , "trigunit")
local integer spellid=(GetStoredInteger(cs_cache , I2S(GetHandleId((trg ))) , ( "spellid"))) // INLINED!!
local integer spawnnum=(GetStoredInteger(cs_cache , I2S(GetHandleId((trg ))) , ( "spawnnum"))) // INLINED!!
local integer lvl=GetUnitAbilityLevel(caster , spellid)
local real leash=GetAbilityDataReal(spellid , lvl , "leash")
local real spawnspacing=GetAbilityDataReal(spellid , lvl , "unitspacing")
local unit spawn
local integer i=1
local real x
local real y
local real cx=GetUnitX(caster)
local real cy=GetUnitY(caster)
local real cf
local real ox=GetOrderPointX()
local real oy=GetOrderPointY()
local unit ou=GetOrderTargetUnit()
local integer order=GetIssuedOrderId()
//local location ol=GetOrderPointLoc()
if ou == null then
set ox = GetOrderPointX()
set oy = GetOrderPointY()
else
set ox = GetUnitX(ou)
set oy = GetUnitY(ou)
endif
set cf = bj_RADTODEG * Atan2(oy - cy , ox - cx)
loop
    exitwhen i > spawnnum
    set spawn = GetAttachedUnit(trg , I2S(spellid) + "unit" + I2S(i))
    set x = GetUnitX(caster) - GetUnitX(spawn)
    set y = GetUnitY(caster) - GetUnitY(spawn)
    if SquareRoot(x * x + y * y) > leash then
    if i == spawnnum and spawnnum - ( ( spawnnum / 2 ) * 2 ) > 0 then
        set y = ( cf + 180 ) * bj_DEGTORAD
        set x = cx + spawnspacing * Cos(y)
        set y = cy + spawnspacing * Sin(y)
    else
        set y = ( cf + 180 * i + 90 ) * bj_DEGTORAD
        set x = cx + spawnspacing * ( ( i + 1 ) / 2 ) * Cos(y)
        set y = cy + spawnspacing * ( ( i + 1 ) / 2 ) * Sin(y)
    endif
    call CS_MoveUnit(spawn , x , y)
    call SetUnitFacing(spawn , cf)
    endif

    if i == spawnnum and spawnnum - ( ( spawnnum / 2 ) * 2 ) > 0 then
        set y = ( cf + 180 ) * bj_DEGTORAD
        set x = ox + spawnspacing * Cos(y)
        set y = oy + spawnspacing * Sin(y)
    else
        set y = ( cf + 180 * i + 90 ) * bj_DEGTORAD
        set x = ox + spawnspacing * ( ( i + 1 ) / 2 ) * Cos(y)
        set y = oy + spawnspacing * ( ( i + 1 ) / 2 ) * Sin(y)
    endif
	if order != OrderId("move") and order != OrderId("smart") and not (IssuePointOrderById(spawn,order,x,y)) then
	    if not IssueTargetOrderById(spawn,order,ou) then
			call IssuePointOrder(spawn,"attack",x,y)//Allow casting of unified abilities
		endif
    elseif order == OrderId("move") or order == OrderId("smart") then
		call IssuePointOrder(spawn,"attack",x,y)//Movement and smart orders cause movement of helpers!
    endif
    if ox==0 and oy==0 then
    call IssueImmediateOrder(spawn,"stop")
    endif 
    set i = i + 1
endloop

set spawn = null
set caster = null
set ou = null
//call RemoveLocation(ol)
//set ol=null
endfunction

function LocustFollowerTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit u=GetAttachedUnit(t , "timerunit")
call RemoveUnit(u)
call DestroyTimer(t)
set u = null
set t = null
endfunction

function LocustFollowerTemplate takes nothing returns nothing
local unit caster= GetSpellAbilityUnit()
local integer spellid=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(caster , spellid)
local unit array spawn
local integer spawntype=GetAbilityDataInt(spellid , lvl , "unitid")
local integer spawnnum=GetAbilityDataInt(spellid , lvl , "unitcount")
local real spawnspacing=GetAbilityDataReal(spellid , lvl , "unitspacing")
local real dur=GetAbilityDataReal(spellid , lvl , "duration")
local real deathtime=GetAbilityDataReal(spellid , lvl , "deathduration")
local integer i=1
local player p=GetOwningPlayer(caster)
local real x
local real y
local real cx=GetUnitX(caster)
local real cy=GetUnitY(caster)
local real cf=GetUnitFacing(caster)
local timer t=CreateTimer()
local trigger trg=CreateTrigger()
loop
    exitwhen i > spawnnum
    if i == spawnnum and spawnnum - ( ( spawnnum / 2 ) * 2 ) > 0 then
        set y = ( cf + 180 ) * bj_DEGTORAD
        set x = cx + spawnspacing * Cos(y)
        set y = cy + spawnspacing * Sin(y)
    else
        set y = ( cf + 180 * i + 90 ) * bj_DEGTORAD
        set x = cx + spawnspacing * ( ( i + 1 ) / 2 ) * Cos(y)
        set y = cy + spawnspacing * ( ( i + 1 ) / 2 ) * Sin(y)
    endif

    set spawn[i]=CreateUnit(p , spawntype , x , y , cf)
    call UnitAddAbility(spawn[i] , 'Aloc')
    call AttachObject(trg , I2S(spellid) + "unit" + I2S(i) , spawn[i])
    set i = i + 1
endloop
call TimerStart(t , dur , false , null)
call AttachInt(trg , "spellid" , spellid)
call AttachInt(trg , "spawnnum" , spawnnum)
call AttachObject(trg , "trigunit" , caster)
call TriggerRegisterUnitEvent(trg , caster , EVENT_UNIT_ISSUED_ORDER)
call TriggerRegisterUnitEvent(trg , caster , EVENT_UNIT_ISSUED_POINT_ORDER)
call TriggerRegisterUnitEvent(trg , caster , EVENT_UNIT_ISSUED_TARGET_ORDER)
call TriggerAddAction(trg , function LocustFollowerAction)
loop
    set y = TimerGetRemaining(t)
    exitwhen TimerGetRemaining(t) <= 0 or GetUnitState(caster , UNIT_STATE_LIFE) <= 0
    call TriggerSleepAction(0)
endloop
set i = 1
call DestroyTimer(t)
loop
    exitwhen i > spawnnum
    call KillUnit(spawn[i])
    set t = CreateTimer()
    call TimerStart(t , deathtime , false , function LocustFollowerTimer)
    call AttachObject(t , "timerunit" , spawn[i])
    set i = i + 1
endloop
call FlushStoredMission(cs_cache , I2S(GetHandleId((trg)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(trg))
call DestroyTrigger(trg)
set trg = null
set t = null
set caster = null
endfunction


//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************



function RetTrig_Netherfield_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0H0' ) ) then
        return false
    endif
    return true
endfunction


function RJ_FilterOutStructures2 takes nothing returns boolean
    local unit auracaster=GetAttachedUnit(GetTriggeringTrigger() , "auracaster")
    local unit trigunit=GetTriggerUnit()
    local boolean bool=( IsUnitType(trigunit , UNIT_TYPE_STRUCTURE) != true ) and ( not ( IsPlayerAlly(GetOwningPlayer(trigunit) , GetOwningPlayer(auracaster)) == true ) )
    set trigunit = null
    set auracaster = null
    return bool
endfunction

//THE NETHER FIELD ABILITY
//Created by Retera/Shorka
//Many thanks to Vexorian for caster system
function RetTrig_UnitRangeNether_Actions takes nothing returns nothing
    local unit victim=GetTriggerUnit()
    local location targetloc=GetAttachedLoc(GetTriggeringTrigger() , "targetloc")
    call RJ_Knockback(victim , ( bj_RADTODEG * Atan2(GetUnitY(victim) - GetLocationY(targetloc) , GetUnitX(victim) - GetLocationX(targetloc)) ) , 600.00 , true)
    set victim = null
    set targetloc = null
endfunction


function RetTrig_Netherfield_Actions takes nothing returns nothing
    local location l=GetSpellTargetLoc()
    local unit caster=GetSpellAbilityUnit()
    local effect fxglow=AddSpecialEffectLoc("Abilities\\Spells\\Voidspawn\\Netherfield\\NetherfieldEffect.mdx" , l)
//    local unit auracaster=GetACaster()
    local unit auracaster=CreateUnitAtLoc(GetOwningPlayer(caster) , 'u01N' , l , 0)
    local trigger t=CreateTrigger()
    set bj_wantDestroyGroup = true
//    call ForGroupBJ( GetUnitsInRangeOfLocMatching(512, l, Condition(function RJ_FilterOutStructures)), function RJ_NetherGroupKnockback )
//    call UnitAddAbility(auracaster,'A0HG')
    //set owner and loc
//    call SetUnitOwner(auracaster,GetOwningPlayer(caster),true)
//    call SetUnitPositionLoc(auracaster,l)
    call AttachObject(t , "auracaster" , auracaster)
    call AttachObject(t , "targetloc" , l)
    call TriggerRegisterUnitInRangeSimple(t , 512.00 , auracaster)
    call TriggerAddCondition(t , Condition(function RJ_FilterOutStructures2))
    call TriggerAddAction(t , function RetTrig_UnitRangeNether_Actions)
    call AttachObject(caster , "rj_netherfxglow" , fxglow)
    call AttachObject(caster , "rj_nethertargetloc" , l)
    call AttachObject(caster , "rj_netherknockbacktrigger" , t)
    set l = null
    set caster = null
    set fxglow = null
    set t = null
endfunction

function RetTrig_StopCasting_Actions takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local location l=GetAttachedLoc(caster , "rj_nethertargetloc")
    local effect fxglow=GetAttachedEffect(caster , "rj_netherfxglow")
    local trigger t=GetAttachedTrigger(caster , "rj_netherknockbacktrigger")
    local unit auracaster=GetAttachedUnit(t , "auracaster")
    call RemoveLocation(l)
    call DestroyEffect(fxglow)
    call DestroyTrigger(t)
    call UnitRemoveAbility(auracaster , 'A0HG')
//    call RecicleCaster(auracaster)
    call RemoveUnit(auracaster)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((caster)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(caster))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    set caster = null
    set l = null
    set fxglow = null
    set t = null
    set auracaster = null
endfunction

//===========================================================================
function InitRetTrig_Netherfield takes nothing returns nothing
    local integer D
    local integer s
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(t , Condition(function RetTrig_Netherfield_Conditions))
    call TriggerAddAction(t , function RetTrig_Netherfield_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    call TriggerAddCondition(t , Condition(function RetTrig_Netherfield_Conditions))
    call TriggerAddAction(t , function RetTrig_StopCasting_Actions)
    set t = null
//===================================================================================================
 // Nether Aura 1 ('A0HG')
 //
 set s = SetPassiveTemplate('A0HG' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageOnlyAllies() //Ignores enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 512)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0HE') //A0HE, Apig for testing
    call SetAbilityDataInt(s , "spbk1" , 0 , 'A0HF')
    call SetAbilityDataInt(s , "n" , 0 , 1)

endfunction


//===========================================================================
// Trigger: Learn Soul Steal
//===========================================================================
function RetTrig_Learn_Soul_Steal_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A087' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Learn_Soul_Steal_Actions takes nothing returns nothing
//    call AttachInt(GetAbilityAcquiringUnit(),"SoulStealLevel",GetUnitAbilityLevelSwapped('A087', GetAbilityAcquiringUnit()))
//    call UnitRemoveAbilityBJ( 'A08E', GetAbilityAcquiringUnit() )
    call UnitMakeAbilityPermanent((CasterSystem___acquiringunit) , true , 'A087') // INLINED!!
    call UnitMakeAbilityPermanent((CasterSystem___acquiringunit) , true , 'A086') // INLINED!!
    call UnitMakeAbilityPermanent((CasterSystem___acquiringunit) , true , 'A088') // INLINED!!
    call UnitMakeAbilityPermanent((CasterSystem___acquiringunit) , true , 'A089') // INLINED!!
endfunction

//===========================================================================
function InitRetTrig_Learn_Soul_Steal takes nothing returns nothing
    set rj_trg_Learn_Soul_Steal = CreateTrigger()
    call OnAbilityGet('A087' , "RetTrig_Learn_Soul_Steal_Actions")
endfunction

//===========================================================================
// Trigger: Invincibility Initialize
//===========================================================================
function RetTrig_Invincibility_Initialize_Func001A takes nothing returns nothing


//    call SetPlayerAbilityAvailable( GetEnumPlayer(),false, 'A06Z'  )
//    call SetPlayerAbilityAvailable( GetEnumPlayer(),false, 'A091'  )
//    call SetPlayerAbilityAvailable( GetEnumPlayer(),false, 'A07G'  )
//    call SetPlayerAbilityAvailable( GetEnumPlayer(),false, 'A09C'  )
 //   call SetPlayerUnitAvailableBJ( 'e018', false, GetEnumPlayer() )
endfunction

function RetTrig_Invincibility_Initialize_Actions takes nothing returns nothing
//    call DisplayTextToForce( GetPlayersAll(), "B" )
    call ForForce(GetPlayersAll() , function RetTrig_Invincibility_Initialize_Func001A)
endfunction

//===========================================================================
function InitRetTrig_Invincibility_Initialize takes nothing returns nothing
//    call DisplayTextToForce( GetPlayersAll(), "A" )
    set rj_trg_Invincibility_Initialize = CreateTrigger()
    call TriggerAddAction(rj_trg_Invincibility_Initialize , function RetTrig_Invincibility_Initialize_Actions)
//    call ExecuteFunc("RetTrig_Invincibility_Initialize_Actions")
endfunction

//===========================================================================
// Trigger: Invincibility Initialize Copy
//===========================================================================
function RetTrig_Invincibility_Initialize_Copy_Actions takes nothing returns nothing
    set rdg_WallVars[1]='h01L'
    set rdg_WallVars[2]='h01K'
    set rdg_WallVars[3]='h01M'
    set rdg_WallVars[4]='h01N'
    set rdg_WallVars[5]='h01O'
    set rdg_WallVars[6]='h01P'
    set rdg_WallVars[7]='h01Q'
    set rdg_WallVars[8]='h01R'
    set rdg_WallVars[9]='h01S'
    set rdg_WallVars[10]='h01T'
	
	call DisplayTextToForce(GetPlayersAll() , "|cffffffaaWelcome to the Heaven's Fall Race Mod, Beta Version 1.1.0. For Credits information, go to the Credits menu, press F9, or view the HeavensFallReadme.rtf in your Warcraft III folder.|r")

    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_RETERA") , GetLocalizedString("CREDITS_TEXT_RETERA") , "ReplaceableTextures\\CommandButtons\\BTNHeroLich.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_NARESH") , GetLocalizedString("CREDITS_TEXT_NARESH") , "ReplaceableTextures\\CommandButtons\\BTNMedivh.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_MATT") , GetLocalizedString("CREDITS_TEXT_MATT") , "ReplaceableTextures\\CommandButtons\\BTNChaosGrom.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_BEN") , GetLocalizedString("CREDITS_TEXT_BEN") , "ReplaceableTextures\\CommandButtons\\BTNRifleman.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_DOLLER") , GetLocalizedString("CREDITS_TEXT_DOLLER") , "ReplaceableTextures\\CommandButtons\\BTNEvilIllidan.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_COOKIE") , GetLocalizedString("CREDITS_TEXT_COOKIE") , "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_KHAL") , GetLocalizedString("CREDITS_TEXT_KHAL") , "ReplaceableTextures\\CommandButtons\\BTNFootman.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_VEXORIAN") , GetLocalizedString("CREDITS_TEXT_VEXORIAN") , "ReplaceableTextures\\CommandButtons\\BTNSpellBreakerMagicDefend.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_SUPERVEXORIAN") , GetLocalizedString("CREDITS_TEXT_SUPERVEXORIAN") , "ReplaceableTextures\\CommandButtons\\BTNSpellBreakerMagicDefend.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_SPELLBOUND") , GetLocalizedString("CREDITS_TEXT_SPELLBOUND") , "ReplaceableTextures\\CommandButtons\\BTNSpellbound.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_LOADSCREENS") , GetLocalizedString("CREDITS_TEXT_LOADSCREENS") , "ReplaceableTextures\\CommandButtons\\BTNBladeThrower.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_MULTIRACE") , GetLocalizedString("CREDITS_TEXT_MULTIRACE") , "ReplaceableTextures\\CommandButtons\\BTNPandarenBrewmaster.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_MPQDRAFT") , GetLocalizedString("CREDITS_TEXT_MPQDRAFT") , "ReplaceableTextures\\CommandButtons\\BTNZergling.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , GetLocalizedString("CUSTOM_NAME_BLIZZ") , GetLocalizedString("CREDITS_TEXT_BLIZZ") , "UI\\Glues\\MainMenu\\WarCraftIIILogo\\Blizzard.blp")
    call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED , "Hayate" , "This guy made the really cool jump animation for the frostwolves that will appear in HFv2" , "ReplaceableTextures\\CommandButtons\\BTNLeapWolf.blp")

endfunction

//===========================================================================
function InitRetTrig_Invincibility_Initialize_Copy takes nothing returns nothing
    set rj_trg_Invincibility_Initialize_Copy = CreateTrigger()
    call TriggerAddAction(rj_trg_Invincibility_Initialize_Copy , function RetTrig_Invincibility_Initialize_Copy_Actions)
endfunction

//===========================================================================
// Trigger: Game Initialization
//
// Default melee game initialization for all players
//===========================================================================
function RetTrig_Game_Initialization_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitRetTrig_Game_Initialization takes nothing returns nothing
    set rj_trg_Game_Initialization = CreateTrigger()
    call TriggerAddAction(rj_trg_Game_Initialization , function RetTrig_Game_Initialization_Actions)
endfunction

//===========================================================================
// Trigger: Turtle Grow
//===========================================================================
function RetTrig_Unit_Func001Func001C takes nothing returns boolean
    if ( not ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) < 8 ) ) then // INLINED!!
        return false
    endif
    return true
endfunction

function RetTrig_Unit_Func001A takes nothing returns nothing
    if ( RetTrig_Unit_Func001Func001C() ) then
        call AttachInt(GetEnumUnit() , "SeaTurtleSize" , ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) + 1 )) // INLINED!!
        call SetUnitScalePercent(GetEnumUnit() , 40.00 + ( I2R((GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize")))) * 12.50 ) , 40.00 + ( I2R((GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize")))) * 12.50 ) , 40.00 + ( I2R((GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize")))) * 12.50 )) // INLINED!!
//    call DisplayTextToForce( GetPlayersAll(), I2S(GetAttachedInt(GetEnumUnit(),"SeaTurtleSize")) )

    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 1 ) then // INLINED!!
        call UnitAddAbilityBJ('A0BA' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BD' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 2 ) then // INLINED!!
        call UnitAddAbilityBJ('A0BB' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BG' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 3 ) then // INLINED!!
        call UnitAddAbilityBJ('A0BC' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BH' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 4 ) then // INLINED!!
        call UnitAddAbilityBJ('A0BE' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BI' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 5 ) then // INLINED!!
        call UnitAddAbilityBJ('A0BF' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BJ' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 6 ) then // INLINED!!
        call UnitAddAbilityBJ('A0B7' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BK' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 7 ) then // INLINED!!
        call UnitAddAbilityBJ('A0B8' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BL' , GetEnumUnit())
    else
    endif
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "SeaTurtleSize"))) == 8 ) then // INLINED!!
        call UnitAddAbilityBJ('A0B9' , GetEnumUnit())
        call UnitAddAbilityBJ('A0BM' , GetEnumUnit())
    else
    endif


    else
    endif
endfunction

function RetTrig_Unit_Actions takes nothing returns nothing
    call ForGroupBJ(GetUnitsOfTypeIdAll('n01Y') , function RetTrig_Unit_Func001A)
endfunction

//===========================================================================
function InitRetTrig_Turtle_Grow takes nothing returns nothing
    set rj_trg_Turtle_Grow = CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(rj_trg_Turtle_Grow , 120.00)
    call TriggerAddAction(rj_trg_Turtle_Grow , function RetTrig_Unit_Actions)
endfunction

//===========================================================================
// Trigger: FL Orb Knockback
//===========================================================================
function RetTrig_Hydra_Knockback_Conditions takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A0BO' , GetAttacker()) == 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(1 , 100) <= 30 ) ) then
        return false
    endif
    if ( not ( IsUnitType(GetAttackedUnitBJ() , UNIT_TYPE_STRUCTURE) != true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Hydra_Knockback_Actions takes nothing returns nothing
 local unit attacker=GetAttacker()
 local location attackerloc=GetUnitLoc(attacker)
 local location attackeeloc=GetUnitLoc(GetAttackedUnitBJ())
 call RJ_Knockback(GetTriggerUnit() , AngleBetweenPoints(attackerloc , attackeeloc) , 250.00 , true)
 call RemoveLocation(attackerloc)
 call RemoveLocation(attackeeloc)
 set attacker = null
 set attackerloc = null
 set attackeeloc = null
endfunction

//===========================================================================
function InitRetTrig_FL_Orb_Knockback takes nothing returns nothing
    set rj_trg_FL_Orb_Knockback = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_FL_Orb_Knockback , EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(rj_trg_FL_Orb_Knockback , Condition(function RetTrig_Hydra_Knockback_Conditions))
    call TriggerAddAction(rj_trg_FL_Orb_Knockback , function RetTrig_Hydra_Knockback_Actions)
endfunction

//===========================================================================
// Trigger: Untitled Trigger 020
//===========================================================================
function RetTrig_Untitled_Trigger_020_Actions takes nothing returns nothing
    call AddSpecialEffectLocBJ(GetUnitLoc(GetAttackedUnitBJ()) , "Abilities\\Weapons\\GlaiveMissile\\GlaiveMissileTarget.mdl")
    call TriggerSleepAction(2)
    call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction

//===========================================================================
function InitRetTrig_Untitled_Trigger_020 takes nothing returns nothing
    set rj_trg_Untitled_Trigger_020 = CreateTrigger()
    call TriggerAddAction(rj_trg_Untitled_Trigger_020 , function RetTrig_Untitled_Trigger_020_Actions)
endfunction

//===========================================================================
// Trigger: Tidal Pool Attack
//===========================================================================
function RetTrig_Tidal_Pool_Attack_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'n01V' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Tidal_Pool_Attack_Actions takes nothing returns nothing
 local location l=PolarProjectionBJ(GetUnitLoc(GetAttackedUnitBJ()) , 250.00 , AngleBetweenPoints(GetUnitLoc(GetAttacker()) , GetUnitLoc(GetAttackedUnitBJ())))
 local unit u=GetAttackedUnitBJ()
 local location target=l
 local location loc=GetUnitLoc(u)
 local real fh=GetUnitFlyHeight(u)
 local boolean sel=false


    set sel = IsUnitSelected(u , GetOwningPlayer(u))
//    call SetUnitPositionLoc( GetAttackedUnitBJ(), PolarProjectionBJ(GetUnitLoc(GetAttackedUnitBJ()), 1000.00, AngleBetweenPoints(GetUnitLoc(GetAttacker()), GetUnitLoc(GetAttackedUnitBJ()))) )

       call UnitAddAbility(GetAttackedUnitBJ() , (cs_FlyingHeightHack)) // INLINED!!
       call UnitRemoveAbility(GetAttackedUnitBJ() , (cs_FlyingHeightHack)) // INLINED!!
//                                            call UnitMoveToAsProjectileAnySpeed(GetAttackedUnitBJ(),1000,0.25,GetLocationX(l),GetLocationY(l),null,GetUnitFlyHeight(GetAttackedUnitBJ()))
//        call ShowUnit(u,false)
        call PauseUnit(u , true)
        call UnitMoveToAsProjectileAnySpeed_Effect((u ) , null , (( 1000 )*1.0) , (( 1 )*1.0) , (( GetLocationX(target) )*1.0) , (( GetLocationY(target) )*1.0) , ( null ) , (( fh)*1.0)) // INLINED!!
        call SetUnitPosition(u , GetLocationX(target) , GetLocationY(target))
        call SetUnitTimeScale(u , 1)
        call PauseUnit(u , false)
        call SetUnitFlyHeight(u , fh , 0)
    if ( GetWidgetLife(u) >= 1 ) then
        if sel then
            call SelectUnitAddForPlayer(u , GetOwningPlayer(u))
        endif
    endif
 call RemoveLocation(loc)
 call RemoveLocation(target)
 call RemoveLocation(l)
 set u = null
 set loc = null
 set target = null
 set l = null
endfunction

//===========================================================================
function InitRetTrig_Tidal_Pool_Attack takes nothing returns nothing
    set rj_trg_Tidal_Pool_Attack = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Tidal_Pool_Attack , EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(rj_trg_Tidal_Pool_Attack , Condition(function RetTrig_Tidal_Pool_Attack_Conditions))
    call TriggerAddAction(rj_trg_Tidal_Pool_Attack , function RetTrig_Tidal_Pool_Attack_Actions)
endfunction

//===========================================================================
// Trigger: Gold Mine Fix
//===========================================================================
function RetTrig_Gold_Mine_Fix_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnteringUnit()) == 'ngol' ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetEnteringUnit()) != Player(PLAYER_NEUTRAL_PASSIVE) ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Gold_Mine_Fix_Actions takes nothing returns nothing
    call SetUnitOwner(GetEnteringUnit() , Player(PLAYER_NEUTRAL_PASSIVE) , true)
endfunction

//===========================================================================
function InitRetTrig_Gold_Mine_Fix takes nothing returns nothing
    set rj_trg_Gold_Mine_Fix = CreateTrigger()
    call TriggerRegisterEnterRectSimple(rj_trg_Gold_Mine_Fix , GetEntireMapRect())
    call TriggerAddCondition(rj_trg_Gold_Mine_Fix , Condition(function RetTrig_Gold_Mine_Fix_Conditions))
    call TriggerAddAction(rj_trg_Gold_Mine_Fix , function RetTrig_Gold_Mine_Fix_Actions)
endfunction

//===========================================================================
// Trigger: Corruption
//===========================================================================
function RetTrig_Corruption_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0AM' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Corruption_Func001Func002Func001C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'ewsp' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Corruption_Func001Func002C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'edoc' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Corruption_Func001C takes nothing returns boolean
    if ( not ( IsPlayerAlly(GetOwningPlayer(GetSpellTargetUnit()) , GetOwningPlayer(GetSpellAbilityUnit())) == true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Corruption_Actions takes nothing returns nothing
    if ( RetTrig_Corruption_Func001C() ) then
        if ( RetTrig_Corruption_Func001Func002C() ) then
            call ReplaceUnitBJ(GetSpellTargetUnit() , 'e01B' , bj_UNIT_STATE_METHOD_RELATIVE)
        else
            if ( RetTrig_Corruption_Func001Func002Func001C() ) then
                call ReplaceUnitBJ(GetSpellTargetUnit() , 'h02A' , bj_UNIT_STATE_METHOD_RELATIVE)
            else
                call UnitAddAbilityBJ('A0AO' , GetSpellTargetUnit())
            endif
        endif
    else
        call UnitAddAbilityBJ('A0C9' , GetSpellTargetUnit())
    endif
endfunction

//===========================================================================
function InitRetTrig_Corruption takes nothing returns nothing
    set rj_trg_Corruption = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Corruption , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Corruption , Condition(function RetTrig_Corruption_Conditions))
    call TriggerAddAction(rj_trg_Corruption , function RetTrig_Corruption_Actions)
endfunction

//===========================================================================
// Trigger: Blood Frenzy
//===========================================================================
function RetTrig_Blood_Frenzy_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'Aroa' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Blood_Frenzy_Actions takes nothing returns nothing
    call UnitApplyTimedLifeBJ(35.00 , 'BTLF' , GetSpellAbilityUnit())
    call UnitAddAbility(GetSpellAbilityUnit() , 'A0II')
    call SetUnitScalePercent(GetSpellAbilityUnit() , 200.00 , 200.00 , 200.00)
endfunction

//===========================================================================
function InitRetTrig_Blood_Frenzy takes nothing returns nothing
    set rj_trg_Blood_Frenzy = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Blood_Frenzy , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Blood_Frenzy , Condition(function RetTrig_Blood_Frenzy_Conditions))
    call TriggerAddAction(rj_trg_Blood_Frenzy , function RetTrig_Blood_Frenzy_Actions)
endfunction

//===========================================================================
// Trigger: Untitled Trigger 001
//===========================================================================
function RetTrig_Untitled_Trigger_001_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitRetTrig_Untitled_Trigger_001 takes nothing returns nothing
    set rj_trg_Untitled_Trigger_001 = CreateTrigger()
    call TriggerAddAction(rj_trg_Untitled_Trigger_001 , function RetTrig_Untitled_Trigger_001_Actions)
endfunction

//===========================================================================
// Trigger: Morph Fix
//===========================================================================
function RetTrig_Morph_Fix_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A08A' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Morph_Fix_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call TriggerSleepAction(1.5)
    if (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "SoulStealLevel"))) >= 1 then // INLINED!!
    call UnitAddAbilityBJ('A08E' , u)
    endif
    call SetUnitAbilityLevelSwapped('A08E' , u , (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "SoulStealLevel")))) // INLINED!!
endfunction

//===========================================================================
function InitRetTrig_Morph_Fix takes nothing returns nothing
    set rj_trg_Morph_Fix = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Morph_Fix , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Morph_Fix , Condition(function RetTrig_Morph_Fix_Conditions))
    call TriggerAddAction(rj_trg_Morph_Fix , function RetTrig_Morph_Fix_Actions)
endfunction

//===========================================================================
// Trigger: Aid of Demonic Helpers
//===========================================================================
function RetTrig_Aid_of_Demonic_Helpers_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A085' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Aid_of_Demonic_Helpers_Func005C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A085' , GetSpellAbilityUnit()) >= 2 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Aid_of_Demonic_Helpers_Func006C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A085' , GetSpellAbilityUnit()) >= 3 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Aid_of_Demonic_Helpers_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call CreateNUnitsAtLoc(1 , 'E017' , GetOwningPlayer(u) , PolarProjectionBJ(GetUnitLoc(u) , 128.00 , ( GetUnitFacing(u) + 90.00 )) , ( GetUnitFacing(u) - 90.00 ))
        call AttachObject(GetSpellAbilityUnit() , "demonic1" , GetLastCreatedUnit())
    call CreateNUnitsAtLoc(1 , 'E017' , GetOwningPlayer(u) , PolarProjectionBJ(GetUnitLoc(u) , 128.00 , ( GetUnitFacing(u) - 90.00 )) , ( GetUnitFacing(u) + 90.00 ))
        call AttachObject(GetSpellAbilityUnit() , "demonic2" , GetLastCreatedUnit())
//    if ( RetTrig_Aid_of_Demonic_Helpers_Func005C() ) then
//        call CreateNUnitsAtLoc( 1, 'E017', GetOwningPlayer(GetSpellAbilityUnit()), PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()), 256.00, ( GetUnitFacing(GetSpellAbilityUnit()) + 90.00 )), ( GetUnitFacing(GetSpellAbilityUnit()) - 90.00 ) )
//            call AttachObject(GetSpellAbilityUnit(),"demonic3",GetLastCreatedUnit())
//        call CreateNUnitsAtLoc( 1, 'E017', GetOwningPlayer(GetSpellAbilityUnit()), PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()), 256.00, ( GetUnitFacing(GetSpellAbilityUnit()) - 90.00 )), ( GetUnitFacing(GetSpellAbilityUnit()) + 90.00 ) )
//            call AttachObject(GetSpellAbilityUnit(),"demonic4",GetLastCreatedUnit())
//    else
//    endif
    if ( RetTrig_Aid_of_Demonic_Helpers_Func006C() ) then
        call CreateNUnitsAtLoc(1 , 'E017' , GetOwningPlayer(u) , PolarProjectionBJ(GetUnitLoc(u) , 256.00 , ( GetUnitFacing(u) + 90.00 )) , ( GetUnitFacing(u) - 90.00 ))
            call AttachObject(u , "demonic3" , GetLastCreatedUnit())
        call CreateNUnitsAtLoc(1 , 'E017' , GetOwningPlayer(u) , PolarProjectionBJ(GetUnitLoc(u) , 256.00 , ( GetUnitFacing(u) - 90.00 )) , ( GetUnitFacing(u) + 90.00 ))
            call AttachObject(u , "demonic4" , GetLastCreatedUnit())
    else
    endif
        call AttachBoolean(GetSpellAbilityUnit() , "hashelpers" , true)

    call TriggerSleepAction(20 * I2R(GetUnitAbilityLevelSwapped('A085' , u)))

    call AttachBoolean(GetSpellAbilityUnit() , "hashelpers" , false)
    call KillUnit(GetAttachedUnit(u , "demonic1"))
    call KillUnit(GetAttachedUnit(u , "demonic2"))
    call KillUnit(GetAttachedUnit(u , "demonic3"))
    call KillUnit(GetAttachedUnit(u , "demonic4"))
    call KillUnit(GetAttachedUnit(u , "demonic5"))
    call KillUnit(GetAttachedUnit(u , "demonic6"))
    call TriggerSleepAction(3.00)
    call RemoveUnit(GetAttachedUnit(u , "demonic1"))
    call RemoveUnit(GetAttachedUnit(u , "demonic2"))
    call RemoveUnit(GetAttachedUnit(u , "demonic3"))
    call RemoveUnit(GetAttachedUnit(u , "demonic4"))
    call RemoveUnit(GetAttachedUnit(u , "demonic5"))
    call RemoveUnit(GetAttachedUnit(u , "demonic6"))


  set u = null
endfunction

//===========================================================================
function InitRetTrig_Aid_of_Demonic_Helpers takes nothing returns nothing
    set rj_trg_Aid_of_Demonic_Helpers = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Aid_of_Demonic_Helpers , EVENT_PLAYER_UNIT_SPELL_FINISH)
    call TriggerAddCondition(rj_trg_Aid_of_Demonic_Helpers , Condition(function RetTrig_Aid_of_Demonic_Helpers_Conditions))
    call TriggerAddAction(rj_trg_Aid_of_Demonic_Helpers , function RetTrig_Aid_of_Demonic_Helpers_Actions)
endfunction

//===========================================================================
// Trigger: Demonic Helper Movement
//===========================================================================
function RetTrig_Demonic_Helper_Movement_Conditions takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A085' , GetOrderedUnit()) >= 1 ) ) then
        return false
    endif
    if ( not ( (GetStoredBoolean(cs_cache , I2S(GetHandleId((GetOrderedUnit() ))) , ( "hashelpers"))) == true ) ) then // INLINED!!
        return false
    endif
    return true
endfunction

function RetTrig_Demonic_Helper_Movement_Actions takes nothing returns nothing


  local unit u=GetOrderedUnit()
  local unit u2
  local location l
  local location l1
  local location l2
  set l1 = GetUnitLoc(u)
  set l2 = GetOrderPointLoc()


    set u2 = GetAttachedUnit(u , "demonic1")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 128.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic2")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 128.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic3")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 256.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic4")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 256.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

//    set u2=GetAttachedUnit(u,"demonic5")
//    set l=GetUnitLoc(u2)
//    if ( IsUnitInGroup(u, GetUnitsInRangeOfLocAll(1000.00, l)) != true  ) then
//        call RemoveLocation(l)
//        set l=PolarProjectionBJ(l1, 384.00, ( AngleBetweenPoints(l1, l2) + 90.00 )) 
//        call SetUnitPositionLoc( u2, l )
//    endif
//    call RemoveLocation(l)
//    set l=PolarProjectionBJ(l2, 384.00, ( AngleBetweenPoints(l1,l2) + 90.00 )) 
//    call IssuePointOrderLocBJ( u2, "attack", l)
//    call RemoveLocation(l)

//    set u2=GetAttachedUnit(u,"demonic6")
//    set l=GetUnitLoc(u2)
//    if ( IsUnitInGroup(u, GetUnitsInRangeOfLocAll(1000.00, l)) != true  ) then
//        call RemoveLocation(l)
//        set l=PolarProjectionBJ(l1, 384.00, ( AngleBetweenPoints(l1, l2) - 90.00 )) 
//        call SetUnitPositionLoc( u2, l )
//    endif
//    call RemoveLocation(l)
//    set l=PolarProjectionBJ(l2, 384.00, ( AngleBetweenPoints(l1,l2) - 90.00 )) 
//    call IssuePointOrderLocBJ( u2, "attack", l)
//    call RemoveLocation(l)


    call RemoveLocation(l1)
    call RemoveLocation(l2)
    set u = null
    set u2 = null
    set l = null
    set l1 = null
    set l2 = null
endfunction

//===========================================================================
function InitRetTrig_Demonic_Helper_Movement takes nothing returns nothing
    set rj_trg_Demonic_Helper_Movement = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Demonic_Helper_Movement , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(rj_trg_Demonic_Helper_Movement , Condition(function RetTrig_Demonic_Helper_Movement_Conditions))
    call TriggerAddAction(rj_trg_Demonic_Helper_Movement , function RetTrig_Demonic_Helper_Movement_Actions)
endfunction

//===========================================================================
// Trigger: Demonic Helper Attack
//===========================================================================
function RetTrig_Demonic_Helper_Movement_Copy_Copy_Copy_Conditions takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A085' , GetOrderedUnit()) >= 1 ) ) then
        return false
    endif
    if ( not ( (GetStoredBoolean(cs_cache , I2S(GetHandleId((GetOrderedUnit() ))) , ( "hashelpers"))) == true ) ) then // INLINED!!
        return false
    endif
//    if ( not ( IsPlayerInForce(GetOwningPlayer(GetOrderTargetUnit()), GetPlayersAllies(GetOwningPlayer(GetOrderedUnit()))) != true ) ) then
//        return false
//    endif
    return true
endfunction

function RetTrig_Demonic_Helper_Movement_Copy_Copy_Copy_Actions takes nothing returns nothing
  local unit u=GetOrderedUnit()
  local unit u2
  local location l
  local location l1
  local location l2
  set l1 = GetUnitLoc(u)
  set l2 = GetUnitLoc(GetOrderTargetUnit())


    set u2 = GetAttachedUnit(u , "demonic1")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 128.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic2")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 128.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic3")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 256.00 , ( AngleBetweenPoints(l1 , l2) + 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

    set u2 = GetAttachedUnit(u , "demonic4")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    set l = PolarProjectionBJ(l2 , 256.00 , ( AngleBetweenPoints(l1 , l2) - 90.00 ))
    call IssuePointOrderLocBJ(u2 , "attack" , l)
    call RemoveLocation(l)

//    set u2=GetAttachedUnit(u,"demonic5")
//    set l=GetUnitLoc(u2)
//    if ( IsUnitInGroup(u, GetUnitsInRangeOfLocAll(1000.00, l)) != true  ) then
//        call RemoveLocation(l)
//        set l=PolarProjectionBJ(l1, 384.00, ( AngleBetweenPoints(l1, l2) + 90.00 )) 
//        call SetUnitPositionLoc( u2, l )
//    endif
//    call RemoveLocation(l)
//    set l=PolarProjectionBJ(l2, 384.00, ( AngleBetweenPoints(l1,12) + 90.00 )) 
//    call IssuePointOrderLocBJ( u2, "attack", l)
//    call RemoveLocation(l)

//    set u2=GetAttachedUnit(u,"demonic6")
//    set l=GetUnitLoc(u2)
//    if ( IsUnitInGroup(u, GetUnitsInRangeOfLocAll(1000.00, l)) != true  ) then
//        call RemoveLocation(l)
//        set l=PolarProjectionBJ(l1, 384.00, ( AngleBetweenPoints(l1, l2) - 90.00 )) 
//        call SetUnitPositionLoc( u2, l )
//    endif
//    call RemoveLocation(l)
//    set l=PolarProjectionBJ(l2, 384.00, ( AngleBetweenPoints(l1,12) - 90.00 )) 
//    call IssuePointOrderLocBJ( u2, "attack", l)
//    call RemoveLocation(l)


    call RemoveLocation(l1)
    call RemoveLocation(l2)
    set u = null
    set u2 = null
    set l = null
    set l1 = null
    set l2 = null
endfunction

//===========================================================================
function InitRetTrig_Demonic_Helper_Attack takes nothing returns nothing
    set rj_trg_Demonic_Helper_Attack = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Demonic_Helper_Attack , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerAddCondition(rj_trg_Demonic_Helper_Attack , Condition(function RetTrig_Demonic_Helper_Movement_Copy_Copy_Copy_Conditions))
    call TriggerAddAction(rj_trg_Demonic_Helper_Attack , function RetTrig_Demonic_Helper_Movement_Copy_Copy_Copy_Actions)
endfunction

//===========================================================================
// DEMONIC HELPER STOP FUNCTION, VERY MUCH NEEDED
//===========================================================================


function RetTrig_Demonic_Helper_Stop_Actions takes nothing returns nothing
  local unit u=GetOrderedUnit()
  local unit u2
  local location l
  local location l1
  local real r=GetUnitFacing(u)
  set l1 = GetUnitLoc(u)


    set u2 = GetAttachedUnit(u , "demonic1")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( r + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    call IssueImmediateOrderBJ(u2 , "stop")

    set u2 = GetAttachedUnit(u , "demonic2")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 128.00 , ( r - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    call IssueImmediateOrderBJ(u2 , "stop")

    set u2 = GetAttachedUnit(u , "demonic3")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( r + 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    call IssueImmediateOrderBJ(u2 , "stop")

    set u2 = GetAttachedUnit(u , "demonic4")
    set l = GetUnitLoc(u2)
    if ( IsUnitInGroup(u , GetUnitsInRangeOfLocAll(1000.00 , l)) != true ) then
        call RemoveLocation(l)
        set l = PolarProjectionBJ(l1 , 256.00 , ( r - 90.00 ))
        call SetUnitPositionLoc(u2 , l)
    endif
    call RemoveLocation(l)
    call IssueImmediateOrderBJ(u2 , "stop")


    call RemoveLocation(l1)
    set u = null
    set u2 = null
    set l = null
    set l1 = null
    set r = 0
endfunction

//===========================================================================
function InitRetTrig_Demonic_Helper_Stop takes nothing returns nothing
  local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Demonic_Helper_Movement_Copy_Copy_Copy_Conditions))
    call TriggerAddAction(t , function RetTrig_Demonic_Helper_Stop_Actions)
  set t = null
endfunction



//===========================================================================
// Trigger: Demonic Helper Death
//===========================================================================
function RetTrig_Demonic_Helper_Death_Conditions takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A085' , GetDyingUnit()) >= 1 ) ) then
        return false
    endif
    if ( not ( (GetStoredBoolean(cs_cache , I2S(GetHandleId((GetDyingUnit() ))) , ( "hashelpers"))) == true ) ) then // INLINED!!
        return false
    endif
    return true
endfunction

function RetTrig_Demonic_Helper_Death_Actions takes nothing returns nothing
  local unit u=GetDyingUnit()
  local unit u1=GetAttachedUnit(u , "demonic1")
  local unit u2=GetAttachedUnit(u , "demonic2")
  local unit u3=GetAttachedUnit(u , "demonic3")
  local unit u4=GetAttachedUnit(u , "demonic4")
  local unit u5=GetAttachedUnit(u , "demonic5")
  local unit u6=GetAttachedUnit(u , "demonic6")
    call KillUnit(u1)
    call KillUnit(u2)
    call KillUnit(u3)
    call KillUnit(u4)
    call KillUnit(u5)
    call KillUnit(u6)
    call TriggerSleepAction(3.00)
    call AttachBoolean(u , "hashelpers" , false)
    call RemoveUnit(u1)
    call RemoveUnit(u2)
    call RemoveUnit(u3)
    call RemoveUnit(u4)
    call RemoveUnit(u5)
    call RemoveUnit(u6)

  set u = null
  set u1 = null
  set u2 = null
  set u3 = null
  set u4 = null
  set u5 = null
  set u6 = null

endfunction

//===========================================================================
function InitRetTrig_Demonic_Helper_Death takes nothing returns nothing
    call InitRetTrig_Demonic_Helper_Stop()
    set rj_trg_Demonic_Helper_Death = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Demonic_Helper_Death , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(rj_trg_Demonic_Helper_Death , Condition(function RetTrig_Demonic_Helper_Death_Conditions))
    call TriggerAddAction(rj_trg_Demonic_Helper_Death , function RetTrig_Demonic_Helper_Death_Actions)
endfunction

//===========================================================================
// Trigger: Blizzard
//===========================================================================
function RetTrig_Blizzard_Func001C takes nothing returns boolean
    if ( ( GetSpellAbilityId() == 'A07F' ) ) then
        return true
    endif
    if ( ( GetSpellAbilityId() == 'A09G' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_Blizzard_Conditions takes nothing returns boolean
    if ( not RetTrig_Blizzard_Func001C() ) then
        return false
    endif
    return true
endfunction

function RetTrig_Blizzard_Actions takes nothing returns nothing
    call SetTerrainTypeBJ(GetSpellTargetLoc() , 'Nsnw' , - 1 , 10 , 0)
    call CreateNUnitsAtLoc(1 , 'u018' , GetOwningPlayer(GetSpellAbilityUnit()) , GetSpellTargetLoc() , bj_UNIT_FACING)
endfunction

//===========================================================================
function InitRetTrig_Blizzard takes nothing returns nothing
    set rj_trg_Blizzard = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Blizzard , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Blizzard , Condition(function RetTrig_Blizzard_Conditions))
    call TriggerAddAction(rj_trg_Blizzard , function RetTrig_Blizzard_Actions)
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A034' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003001 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE) == true )
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003002001 takes nothing returns boolean
    return ( IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()) , GetOwningPlayer(GetSpellAbilityUnit())) == true )
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003002002001 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) != true )
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003002002002 takes nothing returns boolean
    return ( GetFilterUnit() != rdg_Obelisk )
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003002002 takes nothing returns boolean
    return GetBooleanAnd((IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) != true) , (GetFilterUnit() != rdg_Obelisk)) // INLINED!!
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003002 takes nothing returns boolean
    return GetBooleanAnd((IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()) , GetOwningPlayer(GetSpellAbilityUnit())) == true) , (GetBooleanAnd((IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) != true) , (GetFilterUnit() != rdg_Obelisk)))) // INLINED!!
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003 takes nothing returns boolean
    return GetBooleanAnd((IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE) == true) , (GetBooleanAnd((IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()) , GetOwningPlayer(GetSpellAbilityUnit())) == true) , (GetBooleanAnd((IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) != true) , (GetFilterUnit() != rdg_Obelisk)))))) // INLINED!!
endfunction

function RetTrig_Snitch_Spell_Trigger_Copy_Actions takes nothing returns nothing
    call SetUnitPositionLoc(GroupPickRandomUnit(GetUnitsInRangeOfLocMatching(600.00 , GetUnitLoc(GetSpellAbilityUnit()) , Condition(function RetTrig_Snitch_Spell_Trigger_Copy_Func001001001003))) , GetSpellTargetLoc())
    call SetUnitPositionLoc(GetSpellAbilityUnit() , GetSpellTargetLoc())
endfunction

//===========================================================================
function InitRetTrig_Snitch_Spell_Trigger_Copy takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Snitch_Spell_Trigger_Copy_Conditions))
    call TriggerAddAction(t , function RetTrig_Snitch_Spell_Trigger_Copy_Actions)
  set t = null
endfunction

//****************Leap Spell Can Bug, This should fix it
function RetTrig_Leap_Fixer_Trigger_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A075' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Leap_Fixer_Trigger_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call TriggerSleepAction(5.00)
    call PauseUnit(u , false)
    call SetUnitFlyHeightBJ(u , 0.00 , 0.00)
  //  call KillUnit(u)
  //  call DisplayTextToForce(GetForceOfPlayer(GetOwningPlayer(u)), "|cff00ff00Shorka: Killing the guy who leaped just to prove I can...|r")
  set u = null
endfunction

//===========================================================================
function InitRetTrig_Leap_Fixer_Trigger takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Leap_Fixer_Trigger_Conditions))
    call TriggerAddAction(t , function RetTrig_Leap_Fixer_Trigger_Actions)
//    call TriggerSleepAction(0.8)
//    call DisplayTextToForce(GetForceOfPlayer(Player(0)), "|cff00ff00Shorka: Killing the guy who leaped just to prove I can...|r")
  set t = null
endfunction

//****************************************Super Crazy Spell Attack Draenei Catapult
//--------------------------------------------------------------------------------
function AG_RandomSpellCast takes location l,unit u returns nothing
//    call CasterCastAbilityEx(GetOwningPlayer(u),)
//function CasterCastAbilityEx takes player owner, real x, real y, real z, integer abilid, integer level, string order, widget target, real delay returns unit
//function CasterCastAbilityPointEx takes player owner, real x1, real y1, real z1, integer abilid, integer level, string order, real x2, real y2, real delay returns unit
    local integer i=GetRandomInt(1 , 150)
  if GetBooleanAnd(i >= 1 , i <= 3) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'S00K' , 1 , I2S(OrderId("earthquake")) , l , 0)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "animatedead")
  endif
  if GetBooleanAnd(i >= 4 , i <= 13) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0D9' , 1 , I2S(OrderId("stomp")) , l , 0)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "stomp")
  endif
  if GetBooleanAnd(i >= 14 , i <= 23) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DO' , 1 , I2S(OrderId("silence")) , l , 25)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "silence")
  endif
  if GetBooleanAnd(i >= 24 , i <= 33) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DP' , 1 , I2S(OrderId("blizzard")) , l , 10)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "blizzard")
  endif
  if GetBooleanAnd(i >= 34 , i <= 43) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DQ' , 1 , I2S(OrderId("flamestrike")) , l , 2)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "flamestrike")
  endif
  if GetBooleanAnd(i >= 44 , i <= 53) then
    call CasterCastAbilityPointExLoc(Player(PLAYER_NEUTRAL_AGGRESSIVE) , l , 0 , 'A0HA' , 1 , I2S(OrderId("ward")) , l , 0)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "Serpentward")
  endif
  if GetBooleanAnd(i >= 54 , i <= 63) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DS' , 1 , I2S(OrderId("creepthunderclap")) , l , 0)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "creepthunderclap")
  endif
  if GetBooleanAnd(i >= 64 , i <= 73) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DT' , 1 , I2S(OrderId("roar")) , l , 0)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "roar")
  endif
  if GetBooleanAnd(i >= 74 , i <= 83) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DU' , 1 , I2S(OrderId("monsoon")) , l , 15)
  //      call DisplayTextToPlayer(Player(0), 0, 0, "monsoon")
  endif
  if GetBooleanAnd(i >= 84 , i <= 93) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DV' , 1 , I2S(OrderId("rainoffire")) , l , 1)
  //      call DisplayTextToPlayer(Player(0), 0, 0, "rainoffire")
  endif
  if GetBooleanAnd(i >= 94 , i <= 94) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DW' , 1 , I2S(OrderId("deathanddecay")) , l , 20)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "deathanddecay")
  endif
  if GetBooleanAnd(i >= 95 , i <= 95) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'Arng' , 1 , I2S(OrderId("revenge")) , l , 0)
  //      call DisplayTextToPlayer(Player(0), 0, 0, "revenge")
  endif
  if GetBooleanAnd(i >= 96 , i <= 100) then
    call CasterCastAbilityPointExLoc(GetOwningPlayer(u) , l , 0 , 'A0DX' , 1 , I2S(OrderId("tranquility")) , l , 10)
 //       call DisplayTextToPlayer(Player(0), 0, 0, "tranquility")
  endif
  if GetBooleanAnd(i >= 101 , i <= 150) then
 //       call DisplayTextToPlayer(Player(0), 0, 0, "No ability was cast.")
  endif
endfunction


function AG_AttachLoc takes unit u,string key,location l returns nothing
    call AttachReal(u , key + "-x" , GetLocationX(l))
    call AttachReal(u , key + "-y" , GetLocationY(l))
endfunction

function AG_GetAttachedLoc takes unit u,string key returns location
    return Location((GetStoredReal(cs_cache , I2S(GetHandleId((u ))) , ( key + "-x"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((u ))) , ( key + "-y")))) // INLINED!!
endfunction






function CrystalThrowerDeath_Conditions takes nothing returns boolean
    return GetUnitTypeId(GetDyingUnit()) == 'lthr'
endfunction

function CrystalThrowerDeath_Actions takes nothing returns nothing
    local unit u=GetDyingUnit()
    local location l=GetAttachedLoc(u , "attackgroundloc")
    local timer t=GetAttachedTimer(u , "attackground_Timer")
    local timer t2=GetAttachedTimer(u , "attackground_projectileTimer")
    call RemoveLocation(l)
    set l = GetAttachedLoc(t2 , "attackgroundloc")
    call RemoveLocation(l)
    set l = null
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t2)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t2))
    call DestroyTimer(t)
    call DestroyTimer(t2)
    set t = null
    set t2 = null
    call FlushStoredMission(cs_cache , I2S(GetHandleId((u)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(u))

    set u = null
endfunction


function EnchantedCrystals_ProjectileTimerExpire takes nothing returns nothing
  local timer t2=GetExpiredTimer()
  local unit u=GetAttachedUnit(t2 , "timerunit")
  local location l=GetAttachedLoc(t2 , "attackgroundloc")

    if GetUnitAbilityLevelSwapped('A0DL' , u) >= 2 then
    call AG_RandomSpellCast(l , u)
    endif

  set u = null
  set l = null
  set t2 = null

endfunction

function EnchantedCrystals_CooldownTimerExpire takes nothing returns nothing
  local timer t=GetExpiredTimer()
  local unit u=GetAttachedUnit(t , "timerunit")
  local location l=GetAttachedLoc(u , "attackgroundloc")
  local location lu=GetUnitLoc(u)
  local timer t2

  if GetUnitCurrentOrder(u) != String2OrderIdBJ("attackground") then
  call AttachBoolean(u , "attackground_running" , false)
  call PauseTimer(t)
  else

  if GetAttachedTimer(u , "attackground_projectileTimer") == null then
    set t2 = CreateTimer()
    call AttachObject(u , "attackground_projectileTimer" , t2)
  else
    set t2 = GetAttachedTimer(u , "attackground_projectileTimer")
  endif

//  call TimerStart( t2, ( TimerGetRemaining(t)-(4.5-(DistanceBetweenPoints(l, GetUnitLoc(u)) / 900.00)) ), false, function EnchantedCrystals_ProjectileTimerExpire   )
  call TimerStart(t2 , ( DistanceBetweenPoints(l , GetUnitLoc(u)) / 900.00 ) + 0.1 , false , function EnchantedCrystals_ProjectileTimerExpire)
  call AttachObject(t2 , "timerunit" , u)
  call AttachObject(t2 , "attackgroundloc" , l)
  endif



  call RemoveLocation(lu)
  set lu = null
  set u = null
  set t = null
  set t2 = null
  set l = null
endfunction

function RetTrig_Enchanted_Crystals_Actions takes nothing returns nothing
  local unit u=GetOrderedUnit()
  local location l=GetOrderPointLoc()
  local location lu=GetUnitLoc(u)
  local timer t
  local timer t2
  if GetAttachedLoc(u , "attackgroundloc") != null then
  call RemoveLocation(GetAttachedLoc(u , "attackgroundloc"))
  endif
  call AttachObject(u , "attackgroundloc" , l)

if (GetStoredBoolean(cs_cache , I2S(GetHandleId((u ))) , ( "attackground_running"))) == false then // INLINED!!
  call AttachBoolean(u , "attackground_running" , true)
  if GetAttachedTimer(u , "attackground_projectileTimer") == null then
      set t2 = CreateTimer()
      call AttachObject(u , "attackground_projectileTimer" , t2)
    else
      set t2 = GetAttachedTimer(u , "attackground_projectileTimer")
  endif

  call TimerStart(t2 , ( DistanceBetweenPoints(l , lu) / 900.00 ) + 0.1 , false , function EnchantedCrystals_ProjectileTimerExpire)
  call AttachObject(t2 , "timerunit" , u)
  call AttachObject(t2 , "attackgroundloc" , l)
  if GetAttachedTimer(u , "attackground_Timer") == null then
    set t = CreateTimer()
    call AttachObject(u , "attackground_Timer" , t)
    call TimerStart(t , 4.50 , true , function EnchantedCrystals_CooldownTimerExpire)
    call AttachObject(t , "timerunit" , u)
  else
    set t = GetAttachedTimer(u , "attackground_Timer")
    call TimerStart(t , 4.50 , true , function EnchantedCrystals_CooldownTimerExpire)
  endif


endif

    call RemoveLocation(lu)
    set lu = null
    set t = null
    set t2 = null
    set u = null
    set l = null
endfunction

function RetTrig_Enchanted_Crystals_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetOrderedUnit()) == 'lthr' ) ) then
        return false
    endif
    if ( not ( GetIssuedOrderIdBJ() == String2OrderIdBJ("attackground") ) ) then
        return false
    endif
    return true
endfunction





function RetTrig_Enchanted_Crystals_2_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'lthr' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Enchanted_Crystals_2_Actions takes nothing returns nothing
  local unit u=GetAttacker()
  local location l=GetUnitLoc(GetAttackedUnitBJ())
  local location lu=GetUnitLoc(u)
  local timer t2
  local timer t
  if GetAttachedLoc(u , "attackgroundloc") != null then
  call RemoveLocation(GetAttachedLoc(u , "attackgroundloc"))
  endif
  call AttachObject(u , "attackgroundloc" , l)

  if GetAttachedTimer(u , "attackground_projectileTimer") == null then
      set t2 = CreateTimer()
      call AttachObject(u , "attackground_projectileTimer" , t2)
    else
      set t2 = GetAttachedTimer(u , "attackground_projectileTimer")
  endif

  call TimerStart(t2 , ( DistanceBetweenPoints(l , lu) / 900.00 ) + 0.1 , false , function EnchantedCrystals_ProjectileTimerExpire)
  call AttachObject(t2 , "timerunit" , u)
  call AttachObject(t2 , "attackgroundloc" , l)

if (GetStoredBoolean(cs_cache , I2S(GetHandleId((u ))) , ( "attackground_running"))) == false then // INLINED!!
  call AttachBoolean(u , "attackground_running" , true)

  if GetAttachedTimer(u , "attackground_Timer") == null then
    set t = CreateTimer()
    call AttachObject(u , "attackground_Timer" , t)
    call TimerStart(t , 4.50 , true , function EnchantedCrystals_CooldownTimerExpire)
    call AttachObject(t , "timerunit" , u)
  else
    set t = GetAttachedTimer(u , "attackground_Timer")
    call TimerStart(t , 4.50 , true , function EnchantedCrystals_CooldownTimerExpire)
  endif


endif

//    call TriggerSleepAction(DistanceBetweenPoints(l, GetUnitLoc(u)) / 900.00)
//    if GetUnitAbilityLevelSwapped('A0DL', u) >= 2 then
//    call AG_RandomSpellCast(l,u)
//    endif
//    call AddSpecialEffectLocBJ( l, "Abilities\\Spells\\Human\\ThunderClap\\ThunderClapCaster.mdl" )

//  call RemoveLocation(l)
  call RemoveLocation(lu)
  set l = null
  set lu = null
  set t2 = null
  set u = null
  set t = null
endfunction

//===========================================================================
function InitRetTrig_Enchanted_Crystals takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Enchanted_Crystals_Conditions))
    call TriggerAddAction(t , function RetTrig_Enchanted_Crystals_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(t , Condition(function RetTrig_Enchanted_Crystals_2_Conditions))
    call TriggerAddAction(t , function RetTrig_Enchanted_Crystals_2_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(t , Condition(function CrystalThrowerDeath_Conditions))
    call TriggerAddAction(t , function CrystalThrowerDeath_Actions)
    set t = null

endfunction








//===========================================================================
// Trigger: ForceWall
//===========================================================================
function RetTrig_ForceWall_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A07B' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'h01H' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_ForceWall_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
  local unit u2=GetSpellTargetUnit()
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) / 32 )
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , ( 32.00 * I2R(GetForLoopIndexA()) ) , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , PATHING_TYPE_WALKABILITY , false)
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) / 32 )
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , ( 32.00 * I2R(GetForLoopIndexA()) ) , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , PATHING_TYPE_BUILDABILITY , false)
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
    call AddLightningLoc("CLPB" , GetUnitLoc(u) , GetUnitLoc(u2))
    call AttachInt(u , "FW_numwalls" , (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "FW_numwalls"))) + 1) // INLINED!!
    call AttachInt(u2 , "FW_numwalls" , (GetStoredInteger(cs_cache , I2S(GetHandleId((u2 ))) , ( "FW_numwalls"))) + 1) // INLINED!!
    call AttachObject(u , "FW_generator" + I2S((GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "FW_numwalls")))) , u2) // INLINED!!
    call AttachObject(u2 , "FW_generator" + I2S((GetStoredInteger(cs_cache , I2S(GetHandleId((u2 ))) , ( "FW_numwalls")))) , u) // INLINED!!
    call AttachLightning(u , "FW_lightning" + I2S((GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "FW_numwalls")))) , GetLastCreatedLightningBJ()) // INLINED!!
    call AttachLightning(u2 , "FW_lightning" + I2S((GetStoredInteger(cs_cache , I2S(GetHandleId((u2 ))) , ( "FW_numwalls")))) , GetLastCreatedLightningBJ()) // INLINED!!


endfunction

//===========================================================================
function InitRetTrig_ForceWall takes nothing returns nothing
    set rj_trg_ForceWall = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_ForceWall , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_ForceWall , Condition(function RetTrig_ForceWall_Conditions))
    call TriggerAddAction(rj_trg_ForceWall , function RetTrig_ForceWall_Actions)
    call InitRetTrig_Enchanted_Crystals()
endfunction

//===========================================================================
// Trigger: Forcewall Death
//===========================================================================
function RetTrig_Forcewall_Death_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetDyingUnit()) == 'h01H' ) ) then
//'h01H'
        return false
    endif
    return true
endfunction

function RetTrig_Forcewall_Death_Actions takes nothing returns nothing


  local unit u=GetDyingUnit()
  local unit u2

    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "FW_numwalls"))) // INLINED!!
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call DestroyLightningBJ(GetAttachedLightning(u , "FW_lightning" + I2S(GetForLoopIndexA())))
//        call AttachObject(u,"FW_lightning"+I2S(GetForLoopIndexA()),null)

        set u2 = GetAttachedUnit(u , "FW_generator" + I2S(GetForLoopIndexA()))

        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = (GetStoredInteger(cs_cache , I2S(GetHandleId((u2 ))) , ( "FW_numwalls"))) // INLINED!!
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd

            if GetAttachedLightning(u2 , "FW_lightning" + I2S(GetForLoopIndexB())) == GetAttachedLightning(u , "FW_lightning" + I2S(GetForLoopIndexA())) then
            call AttachObject(u2 , "FW_lightning" + I2S(GetForLoopIndexB()) , null)
            endif

            if GetAttachedUnit(u2 , "FW_generator" + I2S(GetForLoopIndexB())) == GetAttachedUnit(u , "FW_generator" + I2S(GetForLoopIndexA())) then
            call AttachObject(u2 , "FW_generator" + I2S(GetForLoopIndexB()) , null)
            endif

            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop

        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) / 32 )
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd
            call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(u) , ( 32.00 * I2R(GetForLoopIndexB()) ) , AngleBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) , PATHING_TYPE_WALKABILITY , true)
            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop
        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) / 32 )
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd
            call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(u) , ( 32.00 * I2R(GetForLoopIndexB()) ) , AngleBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) , PATHING_TYPE_BUILDABILITY , true)
            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop

    call FlushStoredMission(cs_cache , I2S(GetHandleId((u)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(u))
//    call AttachInt(u,"FW_numwalls",0)

endfunction

//===========================================================================
function InitRetTrig_Forcewall_Death takes nothing returns nothing
    set rj_trg_Forcewall_Death = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Forcewall_Death , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(rj_trg_Forcewall_Death , Condition(function RetTrig_Forcewall_Death_Conditions))
    call TriggerAddAction(rj_trg_Forcewall_Death , function RetTrig_Forcewall_Death_Actions)
endfunction

//===========================================================================
// Trigger: Forcewall Unsummon
//===========================================================================
function RetTrig_Forcewall_Unsummon_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A07C' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Forcewall_Unsummon_Actions takes nothing returns nothing


  local unit u=GetSpellAbilityUnit()
  local unit u2

    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = (GetStoredInteger(cs_cache , I2S(GetHandleId((u ))) , ( "FW_numwalls"))) // INLINED!!
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call DestroyLightningBJ(GetAttachedLightning(u , "FW_lightning" + I2S(GetForLoopIndexA())))
//        call AttachObject(u,"FW_lightning"+I2S(GetForLoopIndexA()),null)

        set u2 = GetAttachedUnit(u , "FW_generator" + I2S(GetForLoopIndexA()))

        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = (GetStoredInteger(cs_cache , I2S(GetHandleId((u2 ))) , ( "FW_numwalls"))) // INLINED!!
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd

            if GetAttachedLightning(u2 , "FW_lightning" + I2S(GetForLoopIndexB())) == GetAttachedLightning(u , "FW_lightning" + I2S(GetForLoopIndexA())) then
            call AttachObject(u2 , "FW_lightning" + I2S(GetForLoopIndexB()) , null)
            endif

            if GetAttachedUnit(u2 , "FW_generator" + I2S(GetForLoopIndexB())) == GetAttachedUnit(u , "FW_generator" + I2S(GetForLoopIndexA())) then
            call AttachObject(u2 , "FW_generator" + I2S(GetForLoopIndexB()) , null)
            endif

            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop

        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) / 32 )
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd
            call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(u) , ( 32.00 * I2R(GetForLoopIndexB()) ) , AngleBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) , PATHING_TYPE_WALKABILITY , true)
            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop
        set bj_forLoopBIndex = 1
        set bj_forLoopBIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) / 32 )
        loop
            exitwhen bj_forLoopBIndex > bj_forLoopBIndexEnd
            call SetTerrainPathableBJ(PolarProjectionBJ(GetUnitLoc(u) , ( 32.00 * I2R(GetForLoopIndexB()) ) , AngleBetweenPoints(GetUnitLoc(u) , GetUnitLoc(u2))) , PATHING_TYPE_BUILDABILITY , true)
            set bj_forLoopBIndex = bj_forLoopBIndex + 1
        endloop
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop

    call FlushStoredMission(cs_cache , I2S(GetHandleId((u)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(u))
//    call AttachInt(u,"FW_numwalls",0)

endfunction

//===========================================================================
function InitRetTrig_Forcewall_Unsummon takes nothing returns nothing
    set rj_trg_Forcewall_Unsummon = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Forcewall_Unsummon , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Forcewall_Unsummon , Condition(function RetTrig_Forcewall_Unsummon_Conditions))
    call TriggerAddAction(rj_trg_Forcewall_Unsummon , function RetTrig_Forcewall_Unsummon_Actions)
endfunction

//===========================================================================
// Trigger: ForceWall Fix Bug
//===========================================================================
function RetTrig_ForceWall_Fix_Bug_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A07B' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) != 'h01H' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_ForceWall_Fix_Bug_Actions takes nothing returns nothing
    call UnitResetCooldown(GetSpellAbilityUnit())
endfunction

//===========================================================================
function InitRetTrig_ForceWall_Fix_Bug takes nothing returns nothing
    set rj_trg_ForceWall_Fix_Bug = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_ForceWall_Fix_Bug , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_ForceWall_Fix_Bug , Condition(function RetTrig_ForceWall_Fix_Bug_Conditions))
    call TriggerAddAction(rj_trg_ForceWall_Fix_Bug , function RetTrig_ForceWall_Fix_Bug_Actions)
endfunction

//===========================================================================
// Trigger: Summon Wall
//===========================================================================
function RetTrig_Summon_Wall_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A07R' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'h01J' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Summon_Wall_Func001Func003001001002 takes nothing returns boolean
    return ( GetUnitTypeId(GetFilterUnit()) == 'h01K' )
endfunction

function RetTrig_Summon_Wall_Func001C takes nothing returns boolean
    if ( not ( IsUnitGroupEmptyBJ(GetUnitsInRectAll(RectFromCenterSizeBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , 64.00 , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , 64.00 , 64.00))) == true ) ) then
        return false
    endif
    if ( not ( IsUnitGroupDeadBJ(GetUnitsInRectMatching(RectFromCenterSizeBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , 64.00 , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , 64.00 , 64.00) , Condition(function RetTrig_Summon_Wall_Func001Func003001001002))) == true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Summon_Wall_Actions takes nothing returns nothing
//    call DisplayTextToForce( GetPlayersAll(), "D" )
    if ( RetTrig_Summon_Wall_Func001C() ) then
        set bj_forLoopAIndex = 1
        set bj_forLoopAIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) / 64 )
        loop
            exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
            call CreateNUnitsAtLoc(1 , rdg_WallVars[GetRandomInt(1 , 10)] , GetOwningPlayer(GetSpellAbilityUnit()) , PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , ( I2R(GetForLoopIndexA()) * 64.00 ) , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , bj_UNIT_FACING)
            set bj_forLoopAIndex = bj_forLoopAIndex + 1
        endloop
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Summon_Wall takes nothing returns nothing
//    call DisplayTextToForce( GetPlayersAll(), "C" )
    set rj_trg_Summon_Wall = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Summon_Wall , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Summon_Wall , Condition(function RetTrig_Summon_Wall_Conditions))
    call TriggerAddAction(rj_trg_Summon_Wall , function RetTrig_Summon_Wall_Actions)
endfunction

//===========================================================================
// Trigger: ForceWall Copy Copy
//===========================================================================
function RetTrig_ForceWall_Copy_Copy_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A07D' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'h01H' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_ForceWall_Copy_Copy_Actions takes nothing returns nothing
    call AddLightningLoc("CLPB" , GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))
endfunction

//===========================================================================
function InitRetTrig_ForceWall_Copy_Copy takes nothing returns nothing
    set rj_trg_ForceWall_Copy_Copy = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_ForceWall_Copy_Copy , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_ForceWall_Copy_Copy , Condition(function RetTrig_ForceWall_Copy_Copy_Conditions))
    call TriggerAddAction(rj_trg_ForceWall_Copy_Copy , function RetTrig_ForceWall_Copy_Copy_Actions)
endfunction

//===========================================================================
// Trigger: Eat
//===========================================================================
function RetTrig_Eat_Func001Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06V' , GetLearningUnit()) == 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Eat_Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06W' , GetLearningUnit()) > 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Eat_Actions takes nothing returns nothing
    if ( RetTrig_Eat_Func001C() ) then
        if ( RetTrig_Eat_Func001Func001C() ) then
            call UnitAddAbilityBJ('A06V' , GetLearningUnit())
        else
            call SetUnitAbilityLevelSwapped('A06V' , GetLearningUnit() , GetUnitAbilityLevelSwapped('A06W' , GetLearningUnit()))
        endif
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Eat takes nothing returns nothing
    set rj_trg_Eat = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Eat , EVENT_PLAYER_HERO_SKILL)
    call TriggerAddAction(rj_trg_Eat , function RetTrig_Eat_Actions)
endfunction

//===========================================================================
// Trigger: Firey Attack
//===========================================================================
function RetTrig_Firey_Attack_Func001Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06X' , GetLearningUnit()) == 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A006' , GetLearningUnit()) > 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Actions takes nothing returns nothing
    if ( RetTrig_Firey_Attack_Func001C() ) then
        if ( RetTrig_Firey_Attack_Func001Func001C() ) then
            call UnitAddAbilityBJ('A06X' , GetLearningUnit())
        else
            call SetUnitAbilityLevelSwapped('A06X' , GetLearningUnit() , GetUnitAbilityLevelSwapped('A006' , GetLearningUnit()))
        endif
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Firey_Attack takes nothing returns nothing
    set rj_trg_Firey_Attack = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Firey_Attack , EVENT_PLAYER_HERO_SKILL)
    call TriggerAddAction(rj_trg_Firey_Attack , function RetTrig_Firey_Attack_Actions)
endfunction

//===========================================================================
// Trigger: Firey Attack Copy 2
//===========================================================================
function RetTrig_Firey_Attack_Copy_2_Func001Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A08S' , GetLearningUnit()) == 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Copy_2_Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06P' , GetLearningUnit()) > 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Copy_2_Actions takes nothing returns nothing
    if ( RetTrig_Firey_Attack_Copy_2_Func001C() ) then
        if ( RetTrig_Firey_Attack_Copy_2_Func001Func001C() ) then
            call UnitAddAbilityBJ('A08S' , GetLearningUnit())
        else
            call SetUnitAbilityLevelSwapped('A08S' , GetLearningUnit() , GetUnitAbilityLevelSwapped('A06P' , GetLearningUnit()))
        endif
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Firey_Attack_Copy_2 takes nothing returns nothing
    set rj_trg_Firey_Attack_Copy_2 = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Firey_Attack_Copy_2 , EVENT_PLAYER_HERO_SKILL)
    call TriggerAddAction(rj_trg_Firey_Attack_Copy_2 , function RetTrig_Firey_Attack_Copy_2_Actions)
endfunction

//===========================================================================
// Trigger: Firey Attack Copy
//===========================================================================
function RetTrig_Firey_Attack_Copy_Func001Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06X' , GetLearningUnit()) == 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Copy_Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A006' , GetLearningUnit()) > 0 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Firey_Attack_Copy_Actions takes nothing returns nothing
    if ( RetTrig_Firey_Attack_Copy_Func001C() ) then
        if ( RetTrig_Firey_Attack_Copy_Func001Func001C() ) then
            call UnitAddAbilityBJ('A06X' , GetLearningUnit())
        else
            call SetUnitAbilityLevelSwapped('A06X' , GetLearningUnit() , GetUnitAbilityLevelSwapped('A006' , GetLearningUnit()))
        endif
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Firey_Attack_Copy takes nothing returns nothing
    set rj_trg_Firey_Attack_Copy = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Firey_Attack_Copy , EVENT_PLAYER_HERO_SKILL)
    call TriggerAddAction(rj_trg_Firey_Attack_Copy , function RetTrig_Firey_Attack_Copy_Actions)
endfunction

//===========================================================================
// Trigger: Invincibility Cast
//===========================================================================
function RetTrig_Invincibility_Cast_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A06Y' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invincibility_Cast_Func003C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06Y' , GetSpellAbilityUnit()) == 1 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invincibility_Cast_Func004C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06Y' , GetSpellAbilityUnit()) == 2 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invincibility_Cast_Func005C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A06Y' , GetSpellAbilityUnit()) == 3 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invincibility_Cast_Actions takes nothing returns nothing

  local unit tu=GetSpellTargetUnit()

    call SetUnitInvulnerable(tu , true)
    call UnitAddAbilityBJ('A06Z' , tu)
    call SetUnitAbilityLevelSwapped('A070' , tu , GetUnitAbilityLevelSwapped('A070' , GetSpellAbilityUnit()))

    if ( RetTrig_Invincibility_Cast_Func003C() ) then
        call TriggerSleepAction(15.00)
    else
    endif
    if ( RetTrig_Invincibility_Cast_Func004C() ) then
        call TriggerSleepAction(30.00)
    else
    endif
    if ( RetTrig_Invincibility_Cast_Func005C() ) then
        call TriggerSleepAction(60.00)
    else
    endif
    call SetUnitInvulnerable(tu , false)
    call UnitRemoveAbilityBJ('A06Z' , tu)
endfunction

//===========================================================================
function InitRetTrig_Invincibility_Cast takes nothing returns nothing
    set rj_trg_Invincibility_Cast = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Invincibility_Cast , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Invincibility_Cast , Condition(function RetTrig_Invincibility_Cast_Conditions))
    call TriggerAddAction(rj_trg_Invincibility_Cast , function RetTrig_Invincibility_Cast_Actions)
endfunction

//===========================================================================
// Trigger: Invulnerablize
//===========================================================================
function RetTrig_Invulnerablize_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A015' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invulnerablize_Actions takes nothing returns nothing
    call SetUnitInvulnerable(GetSpellAbilityUnit() , true)
endfunction

//===========================================================================
function InitRetTrig_Invulnerablize takes nothing returns nothing
    set rj_trg_Invulnerablize = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Invulnerablize , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(rj_trg_Invulnerablize , Condition(function RetTrig_Invulnerablize_Conditions))
    call TriggerAddAction(rj_trg_Invulnerablize , function RetTrig_Invulnerablize_Actions)
endfunction

//===========================================================================
// Trigger: Invulnerablize Turn Off
//===========================================================================
function RetTrig_Invulnerablize_Turn_Off_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A015' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Invulnerablize_Turn_Off_Actions takes nothing returns nothing
    call SetUnitInvulnerable(GetSpellAbilityUnit() , false)
endfunction

//===========================================================================
function InitRetTrig_Invulnerablize_Turn_Off takes nothing returns nothing
    set rj_trg_Invulnerablize_Turn_Off = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Invulnerablize_Turn_Off , EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    call TriggerAddCondition(rj_trg_Invulnerablize_Turn_Off , Condition(function RetTrig_Invulnerablize_Turn_Off_Conditions))
    call TriggerAddAction(rj_trg_Invulnerablize_Turn_Off , function RetTrig_Invulnerablize_Turn_Off_Actions)
endfunction



//  ABYSS CREATION

function RetTrig_Abyss_Creation_Conditions_New takes nothing returns boolean
    if ( not ( IsUnitType(GetEnteringUnit() , UNIT_TYPE_STRUCTURE) == true ) ) then
        return false
    endif
    if ( not ( GetUnitRace(GetEnteringUnit()) == RACE_DEMON ) ) then
        return false
    endif
  //  if ( not (  (GetUnitTypeId(GetEnteringUnit()) == 'n02R') or (GetUnitTypeId(GetEnteringUnit()) == 'h012')  ) ) then
  //      return false
  //  endif
    return true
endfunction

function CountNetherUnitsInGroupEnum takes nothing returns nothing
    local unit u=GetEnumUnit()
    if GetUnitTypeId(u) == 'n03A' and not IsUnitDeadBJ(u) then
    set bj_groupCountUnits = bj_groupCountUnits + 1
    endif
endfunction

function CountNetherUnitsInGroup takes group g returns integer
    set bj_groupCountUnits = 0
    call ForGroup(g , function CountNetherUnitsInGroupEnum)
    return bj_groupCountUnits
endfunction

function Abyss_Creation_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "timerunit")
    local unit spawn
    local group g=GetAttachedGroup(u , "netherchildgroup")
    local real dist
    local real ang
    if g == null then
    set g = CreateGroup()
    call AttachObject(u , "netherchildgroup" , g)
    endif
    if IsUnitDeadBJ(u) != true and GetUnitTypeId(u) != 'e01R' then
    if CountNetherUnitsInGroup(g) < 2 then
    set dist = GetRandomReal(0 , 750)
    set ang = GetRandomReal(0 , 360) * bj_DEGTORAD
    set spawn = CreateUnit(GetOwningPlayer(u) , 'n03A' , GetUnitX(u) + dist * Cos(ang) , GetUnitY(u) + dist * Sin(ang) , GetRandomReal(0 , 360))
    call GroupAddUnit(g , spawn)
    call SetUnitPosition(spawn, GetUnitX(spawn), GetUnitY(spawn))
    endif
    else
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!\
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call DestroyGroup(g)
    call DestroyTimer(t)
    endif
    set g = null
//    set spawn=null
    set u = null
    set t = null
    set spawn = null
endfunction

function RetTrig_Abyss_Creation_Actions_New takes nothing returns nothing
  local unit u=GetEnteringUnit()
  local location l=GetUnitLoc(u)
  local timer t
//    if GetUnitTypeId(u)=='h012' then
//    call SetTerrainTypeBJ( l, 'Void', -1, 12, 0 )
//    else
//    call SetTerrainTypeBJ( l, 'Void', -1, 7, 0 )
//    endif

 //   if GetUnitTypeId(GetEnteringUnit()) == 'n02R' or GetUnitTypeId(GetEnteringUnit()) == 'h012' then
    set t = CreateTimer()
    call AttachObject(t , "timerunit" , u)
    call TimerStart(t , 45.00 , true , function Abyss_Creation_Timer)
    set t = null
 //   endif

  call RemoveLocation(l)
  set l = null
  set u = null

endfunction

//===========================================================================
function InitRetTrig_Abyss_Creation takes nothing returns nothing
  local trigger t= CreateTrigger()

    call TriggerRegisterEnterRectSimple(t , GetEntireMapRect())
    call TriggerAddCondition(t , Condition(function RetTrig_Abyss_Creation_Conditions_New))
    call TriggerAddAction(t , function RetTrig_Abyss_Creation_Actions_New)

  set t = null
endfunction



function IsDestTree takes destructable d returns boolean
    local unit u=GetACaster()
    local boolean result
    call UnitAddAbilityBJ('Ahrl' , u)
    set result = IssueTargetOrderBJ(u , "harvest" , d)
    call UnitRemoveAbilityBJ('Ahrl' , u)
    call RecycleCaster((u)) // INLINED!!
    if GetDestructableTypeId(d) != 'B002' then
    return result
    endif
    return false
endfunction


function rj_FilteringDeadTrees takes nothing returns boolean
   return EnumDestructablesInCircleBJFilter() and IsDestructableDeadBJ(GetFilterDestructable()) != true and IsDestTree(GetFilterDestructable()) == true

endfunction










function EnumDestructablesInCircleRJ takes real radius,location loc,code actionFunc returns nothing
    local rect r

    if ( radius >= 0 ) then
        set bj_enumDestructableCenter = loc
        set bj_enumDestructableRadius = radius
        set r = GetRectFromCircleBJ(loc , radius)
        call EnumDestructablesInRect(r , Filter(function rj_FilteringDeadTrees) , actionFunc)
        call RemoveRect(r)
    endif
endfunction



function RandomDestructableInRange takes location loc,real rng returns destructable
    set bj_destRandomConsidered = 0
    set bj_destRandomCurrentPick = null
    call EnumDestructablesInCircleRJ(rng , loc , function RandomDestructableInRectBJEnum)
    return bj_destRandomCurrentPick
endfunction



function CountDestructablesInRange takes location loc,real rng returns integer

    set bj_groupCountUnits = 0
    call EnumDestructablesInCircleRJ(rng , loc , function CountUnitsInGroupEnum)
    return bj_groupCountUnits
endfunction

function SimResourceGet_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local texttag tt=GetAttachedTextTag(t , "tt")
    call DestroyTimer(t)
    call DestroyTextTag(tt)
    set t = null
    set tt = null
endfunction

function SimResourceGet takes player who,integer howMuch,location where,real red,real green,real blue,boolean cleanloc returns nothing
    local texttag tt
    local timer t=CreateTimer()
    set tt = CreateTextTagLocBJ("+" + I2S(howMuch) , where , 150.00 , 11.00 , red , green , blue , 0)
    call SetTextTagVelocityBJ(tt , 64 , 90)
    call SetTextTagPermanentBJ(tt , false)
    call SetTextTagAgeBJ(tt , 0)
    call SetTextTagFadepointBJ(tt , 1)
    call SetTextTagLifespan(tt , 2)
    if who == GetLocalPlayer() then
    call SetTextTagVisibility(tt , true)
	else
    call SetTextTagVisibility(tt , false)
    endif
//    call ShowTextTagForceBJ( true, tt, GetForceOfPlayer(who) )
    call AttachTextTag(t , "tt" , tt)
    call TimerStart(t , 2 , false , function SimResourceGet_Timer)
    set t = null
    set tt = null
    if cleanloc then
    call RemoveLocation(where)
    set where = null
    endif
endfunction



function RetTrig_Mine_Lasers_Conditions takes nothing returns boolean
    if GetSpellAbilityId() == 'A0G3' then
        return true
    endif
    if GetSpellAbilityId() == 'A0IF' then
        return true
    endif
    return false
endfunction

function RetTrig_Mine_Lasers_Actions takes nothing returns nothing

    local unit u=GetSpellAbilityUnit()
    local destructable d
    local location l=GetUnitLoc(u)
	local location destLoc = null
	local effect specialFx = null
    local real range=1000

    if GetSpellAbilityId() == 'A0IF' then
      set range = 3000
    endif
    if GetAttachedDestructable(u , "rj_RDT") == null then
		call TriggerSleepAction(0.01)
		loop
			exitwhen ( IsUnitAliveBJ(u) != true ) or GetUnitAbilityLevel(u , 'B026') <= 0
			set l = GetUnitLoc(u)
			set d = GetAttachedDestructable(u , "rj_RDT")
			if d != null then
				if IsDestructableDeadBJ(d) == true then
					call DestroyLightning(GetAttachedLightning(u , "rj_RDT_Effect"))
					call AttachObject(u , "rj_RDT_Effect" , null)
					if CountDestructablesInRange(GetUnitLoc(u) , range) >= 1 then
						set d = RandomDestructableInRange(l , range)
						set destLoc = GetDestructableLoc(d)
						call DestroyEffect(specialFx)
						set specialFx = AddSpecialEffectLoc("Abilities\\Spells\\Voidspawn\\LumberHarvest\\LumberHarvestTarget.mdl", destLoc)
						//call AttachLightning(u , "rj_RDT_Effect" , AddLightningEx("LRTJ" , true, GetLocationX(l), GetLocationY(l), GetLocationZ(l) + 160 , GetLocationX(destLoc), GetLocationY(destLoc), GetLocationZ(destLoc) + 100))
						call RemoveLocation(destLoc)
						call AttachObject(u , "rj_RDT" , d)
					endif
				else
					set destLoc = GetDestructableLoc(d)
					call ProjectileLaunchLoc("Abilities\\Spells\\Voidspawn\\LumberHarvest\\LumberHarvestMissile.mdl", 600, 0.0, destLoc, 50, l, 120)
					call RemoveLocation(destLoc)
					call SimResourceGet(GetOwningPlayer(u) , ( 3 * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_LUMBER_UPKEEP_RATE) ) ) / 100 , l , 0.00 , 78.43 , 31.37 , true)
					call SetDestructableLife(d , GetDestructableLife(d) - ( GetDestructableMaxLife(d) * 0.12 ))
					call SetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_RESOURCE_LUMBER , GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_RESOURCE_LUMBER) + ( ( 3 * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_LUMBER_UPKEEP_RATE) ) ) / 100 ))
					call SetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_LUMBER_GATHERED , GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_LUMBER_GATHERED) + ( ( 3 * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_LUMBER_UPKEEP_RATE) ) ) / 100 ))
				endif
			else
				if CountDestructablesInRange(GetUnitLoc(u) , range) >= 1 then
					set d = RandomDestructableInRange(l , range)
					set destLoc = GetDestructableLoc(d)
					//call AttachLightning(u , "rj_RDT_Effect" , AddLightningEx("LRTJ" , true, GetLocationX(l), GetLocationY(l), GetLocationZ(l) + 160 , GetLocationX(destLoc), GetLocationY(destLoc), GetLocationZ(destLoc) + 100))
					set specialFx = AddSpecialEffectLoc("Abilities\\Spells\\Voidspawn\\LumberHarvest\\LumberHarvestTarget.mdl", destLoc)
					call RemoveLocation(destLoc)
					call AttachObject(u , "rj_RDT" , d)
				endif
			endif
			call RemoveLocation(l)
			call TriggerSleepAction(2.00)
		endloop
		call DestroyLightning(GetAttachedLightning(u , "rj_RDT_Effect"))
		call AttachObject(u , "rj_RDT_Effect" , null)
		call AttachObject(u , "rj_RDT" , null)
		if specialFx != null then
			call DestroyEffect(specialFx)
			set specialFx = null
		endif
    endif
    set u = null
	set destLoc = null
	set l = null
	set d = null

endfunction

//===========================================================================
function InitRetTrig_Mine_Lumber_Lasers takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterEnterRectSimple(t , GetEntireMapRect())
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(t , Condition(function RetTrig_Mine_Lasers_Conditions))
    call TriggerAddAction(t , function RetTrig_Mine_Lasers_Actions)

  set t = null
endfunction




function RetTrig_Drain_Gold_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0G9' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold_Actions takes nothing returns nothing
    local unit u=GetSpellAbilityUnit()
    local unit gm=GetSpellTargetUnit()
    local unit array m
	local integer amt=9
    local location l=GetUnitLoc(u)
	local location gmLoc = null
    call TriggerSleepAction(0.01)
	if GetUnitTypeId(gm) == 'ngol' then
		if GetAttachedObject(u , "dg_GoldMine") == null then
			call UnitRemoveAbilityBJ('A0G9' , u)
			call UnitAddAbilityBJ('A0G5' , u)
			call UnitMakeAbilityPermanent(u , true , 'A0G5')
			call AttachObject(u , "dg_GoldMine" , gm)
			set gmLoc = GetUnitLoc(gm)
			call AttachLightning(u , "dg_GOLD_Effect" , AddLightningLoc("LRTB" , l , gmLoc))
			call RemoveLocation(gmLoc)
			loop
				exitwhen ( IsUnitAliveBJ(u) != true ) or ( IsUnitAliveBJ(gm) != true ) or GetUnitAbilityLevel(u , 'A0G5') <= 0
				call AddResourceAmount(gm , - amt)
				if GetResourceAmount(gm) <= 0 then
					call KillUnit(gm)
				endif
				call SimResourceGet(GetOwningPlayer(u) , ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 , GetUnitLoc(u) , 100.00 , 86.27 , 0.00 , true)
				call AdjustPlayerStateBJ(( ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 ) , GetOwningPlayer(u) , PLAYER_STATE_RESOURCE_GOLD)
				call PolledWait(1.20)
			endloop
			call AttachObject(u , "dg_GoldMine" , null)
			call DestroyLightning(GetAttachedLightning(u , "dg_GOLD_Effect"))
			call AttachLightning(u , "dg_GOLD_Effect" , null)
		endif
	endif
	call RemoveLocation(l)
    set gm = null
	set gmLoc = null
    set u = null
endfunction


function RetTrig_Drain_Gold_RetTrig_2_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0G5' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold_RetTrig_2_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call TriggerSleepAction(0.00)
    call UnitAddAbilityBJ('A0G9' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0G9')
    call UnitRemoveAbilityBJ('A0G5' , u)
  set u = null
endfunction

//===========================================================================
function InitRetTrig_Drain_Gold_RetTrig_2 takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold_RetTrig_2_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold_RetTrig_2_Actions)
  set t = null
endfunction


//===========================================================================
function InitRetTrig_Drain_Gold takes nothing returns nothing
  local trigger t=CreateTrigger()
    call InitRetTrig_Drain_Gold_RetTrig_2()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold_Actions)
  set t = null
endfunction

function RetTrig_Drain_Gold_Fixer_Func002C takes nothing returns boolean
    if ( ( GetUnitTypeId(GetTriggerUnit()) == 'h02F' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetTriggerUnit()) == 'h02J' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_Drain_Gold_Fixer_Conditions takes nothing returns boolean
    if ( not RetTrig_Drain_Gold_Fixer_Func002C() ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold_Fixer_Func001C takes nothing returns boolean
    if ( not ( GetUnitAbilityLevelSwapped('A0G5' , GetTriggerUnit()) > 0 or ( GetUnitAbilityLevelSwapped('A0N9' , GetTriggerUnit()) > 0 ) ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold_Fixer_Actions takes nothing returns nothing
local unit u=GetTriggerUnit()
    if ( RetTrig_Drain_Gold_Fixer_Func001C() ) then
        call UnitRemoveAbilityBJ('A0G9' , GetTriggerUnit())
        call UnitRemoveAbilityBJ('A0G6' , GetTriggerUnit())
    else
    endif
	
    //call UnitMakeAbilityPermanent( u, true, 'A0O5')//Retain generate abyss rift in spbk
    //call UnitMakeAbilityPermanent( u, true, 'A0OE')//Retain Aethergate
    //call UnitMakeAbilityPermanent( u, true, 'A0OF')//Retain void crafted hall
    //call UnitMakeAbilityPermanent( u, true, 'A0OC')//Retain Altar
    //call UnitMakeAbilityPermanent( u, true, 'A0OH')//Retain Vault
    //call UnitMakeAbilityPermanent( u, true, 'A0Q6')//Retain placeholder
	call UnitRemoveAbility(u , 'A0PP')
	call UnitRemoveAbility(u , 'A0PX')
	call UnitRemoveAbility(u , 'A0PQ')
	call UnitRemoveAbility(u , 'A0PY')
	call UnitRemoveAbility(u , 'A0PR')
	call UnitRemoveAbility(u , 'A0PZ')
	call UnitRemoveAbility(u , 'A0Q0')
	call UnitRemoveAbility(u , 'A0Q5')
	call UnitRemoveAbility(u , 'A0O7')
	
	call UnitAddAbility(u , 'A0PP')
	call UnitAddAbility(u , 'A0PX')
	call UnitAddAbility(u , 'A0PQ')
	call UnitAddAbility(u , 'A0PY')
	call UnitAddAbility(u , 'A0PR')
	call UnitAddAbility(u , 'A0PZ')
	call UnitAddAbility(u , 'A0Q0')
	call UnitAddAbility(u , 'A0Q5')
	call UnitAddAbility(u , 'A0O7')
	set u = null
endfunction

//===========================================================================
function InitRetTrig_Drain_Gold_Fixer takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_UPGRADE_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold_Fixer_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold_Fixer_Actions)
  set t = null
endfunction

function RetTrig_Portal_Link_Func004C takes nothing returns boolean
    if ( ( GetUnitTypeId(GetSpellTargetUnit()) == 'n02Z' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetSpellTargetUnit()) == 'nwgt' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_Portal_Link_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0GW' ) ) then
        return false
    endif
    if ( not RetTrig_Portal_Link_Func004C() ) then
        return false
    endif
    if ( not ( IsPlayerInForce(GetOwningPlayer(GetSpellTargetUnit()) , GetPlayersEnemies(GetOwningPlayer(GetSpellAbilityUnit()))) != true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Portal_Link_Actions takes nothing returns nothing
    call WaygateSetDestinationLocBJ(GetSpellAbilityUnit() , GetUnitLoc(GetSpellTargetUnit()))
    call WaygateActivateBJ(true , GetSpellAbilityUnit())
endfunction

//===========================================================================
function InitRetTrig_Portal_Link takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Portal_Link_Conditions))
    call TriggerAddAction(t , function RetTrig_Portal_Link_Actions)
    set t = null
endfunction

function RetTrig_Portal_Link_Snap_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0GX' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Portal_Link_Snap_Actions takes nothing returns nothing
    call WaygateActivateBJ(false , GetSpellAbilityUnit())
endfunction

//===========================================================================
function InitRetTrig_Portal_Link_Snap takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Portal_Link_Snap_Conditions))
    call TriggerAddAction(t , function RetTrig_Portal_Link_Snap_Actions)
    set t = null
endfunction

function RetTrig_SpellCastPhoenixBerserk_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0GR' ) ) then
        return false
    endif
    if ( not ( GetUnitAbilityLevelSwapped('A0GR' , GetSpellAbilityUnit()) == 1 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_SpellCastPhoenixBerserk_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()



    call UnitRemoveAbilityBJ('A0GR' , u)
    call UnitAddAbilityBJ('A0GH' , u)

    call IssueImmediateOrderBJ(u , "metamorphosis")


    call TriggerSleepAction(1.00)
    call SelectUnitRemove(u)
    set u = ReplaceUnitBJ(u , 'h02O' , bj_UNIT_STATE_METHOD_RELATIVE)
    call TriggerSleepAction(30.00)
    call IssueImmediateOrderBJ(u , "metamorphosis")
    call TriggerSleepAction(1.00)
    call ReplaceUnitBJ(u , 'h02K' , bj_UNIT_STATE_METHOD_RELATIVE)
    set u = bj_lastReplacedUnit
    call UnitRemoveAbilityBJ('A0GH' , u)
//    call UnitAddAbilityBJ( 'A0GR', u )
    call SetUnitAbilityLevel(u , 'A0GR' , 2)
    call IssueImmediateOrderBJ(u , "berserk")
    call SetUnitAbilityLevel(u , 'A0GR' , 1)


//    call TriggerSleepAction( 90.00 )
//    call UnitRemoveAbilityBJ( 'A0GR', u )
//    call UnitAddAbilityBJ( 'A0GH', u )
    set u = null
endfunction

//===========================================================================
function InitRetTrig_SpellCastPhoenixBerserk takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_SpellCastPhoenixBerserk_Conditions))
    call TriggerAddAction(t , function RetTrig_SpellCastPhoenixBerserk_Actions)
    set t = null
endfunction

function RetTrig_Phoenix_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnteringUnit()) == 'h02K' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Phoenix_Actions takes nothing returns nothing
    call UnitRemoveAbilityBJ('A0GH' , GetEnteringUnit())
endfunction

//===========================================================================
function InitRetTrig_Phoenix takes nothing returns nothing
 local trigger t=CreateTrigger()
    call TriggerRegisterEnterRectSimple(t , GetEntireMapRect())
    call TriggerAddCondition(t , Condition(function RetTrig_Phoenix_Conditions))
    call TriggerAddAction(t , function RetTrig_Phoenix_Actions)
    set t = null
endfunction

function RetTrig_Begin_Func001A takes nothing returns nothing
    call UnitRemoveAbilityBJ('A0GH' , GetEnumUnit())
endfunction


function RetTrig_Begin_Func002A takes nothing returns nothing
local unit u=GetEnumUnit()



    call TriggerSleepAction(31.50)
    call ReplaceUnitBJ(u , 'h02K' , bj_UNIT_STATE_METHOD_RELATIVE)
    set u = bj_lastReplacedUnit
    call UnitRemoveAbilityBJ('A0GH' , u)
//    call UnitAddAbilityBJ( 'A0GR', u )
    call SetUnitAbilityLevel(u , 'A0GR' , 2)
    call IssueImmediateOrderBJ(u , "berserk")
    call SetUnitAbilityLevel(u , 'A0GR' , 1)


//    call TriggerSleepAction( 90.00 )
//    call UnitRemoveAbilityBJ( 'A0GR', u )
//    call UnitAddAbilityBJ( 'A0GH', u )
    set u = null




endfunction

function RetTrig_TimedRiftLife_Func002C takes nothing returns boolean
    if ( ( GetUnitTypeId(GetConstructedStructure()) == 'n02R' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetConstructedStructure()) == 'n02V' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetConstructedStructure()) == 'n03Z' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_TimedRiftLife_Conditions takes nothing returns boolean
    if ( not RetTrig_TimedRiftLife_Func002C() ) then
        return false
    endif
    return true
endfunction

function RetTrig_TimedRiftLife_Actions takes nothing returns nothing
    call UnitApplyTimedLifeBJ(30.00 , 'BTLF' , GetConstructedStructure())
endfunction



function RetTrig_UpgradingRiftLifeNew2_Func005C takes nothing returns boolean
    if ( ( GetUnitTypeId(GetOrderedUnit()) == 'n02R' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetOrderedUnit()) == 'n02V' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetOrderedUnit()) == 'n03Z' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_UpgradingRiftLifeNew2_Conditions takes nothing returns boolean
    if ( not ( RetTrig_UpgradingRiftLifeNew2_Func005C() and ( OrderId2String(GetIssuedOrderId()) != "stop" ) and GetIssuedOrderId() != 852619 ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_UpgradingRiftLifeNew2_Func002C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetOrderedUnit()) == 'n02V' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_UpgradingRiftLifeNew2_Func003C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetOrderedUnit()) == 'n02R' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_UpgradingRiftLifeNew2_Actions takes nothing returns nothing
    call UnitPauseTimedLifeBJ(true , GetOrderedUnit())
    if ( RetTrig_UpgradingRiftLifeNew2_Func002C() ) then
        call ReplaceUnitBJ(GetOrderedUnit() , 'n044' , bj_UNIT_STATE_METHOD_RELATIVE)
    else
    endif
    if ( RetTrig_UpgradingRiftLifeNew2_Func003C() ) then
        call ReplaceUnitBJ(GetOrderedUnit() , 'n045' , bj_UNIT_STATE_METHOD_RELATIVE)
    else
    endif
    call IssueImmediateOrderById(GetLastReplacedUnitBJ() , GetIssuedOrderId())
    call SelectUnitAddForPlayer(GetLastReplacedUnitBJ() , GetOwningPlayer(GetLastReplacedUnitBJ()))
endfunction


function RetTrig_CancelUp_Func005C takes nothing returns boolean
    if ( ( GetUnitTypeId(GetTriggerUnit()) == 'n044' ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetTriggerUnit()) == 'n045' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_CancelUp_Conditions takes nothing returns boolean
    if ( not RetTrig_CancelUp_Func005C() ) then
        return false
    endif
    return true
endfunction

function RetTrig_CancelUp_Func001C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n044' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_CancelUp_Func002C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n045' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_CancelUp_Actions takes nothing returns nothing
    if ( RetTrig_CancelUp_Func001C() ) then
        call ReplaceUnitBJ(GetTriggerUnit() , 'n02V' , bj_UNIT_STATE_METHOD_RELATIVE)
    else
    endif
    if ( RetTrig_CancelUp_Func002C() ) then
        call ReplaceUnitBJ(GetTriggerUnit() , 'n02R' , bj_UNIT_STATE_METHOD_RELATIVE)
    else
    endif
    call UnitApplyTimedLifeBJ(30.00 , 'BTLF' , GetLastReplacedUnitBJ())
        call SelectUnitAddForPlayer(GetLastReplacedUnitBJ() , GetOwningPlayer(GetLastReplacedUnitBJ()))
endfunction

//===========================================================================
function InitRetTrig_VoidRiftTimerFunc takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_UPGRADE_CANCEL)
    call TriggerAddCondition(t , Condition(function RetTrig_CancelUp_Conditions))
    call TriggerAddAction(t , function RetTrig_CancelUp_Actions)
	set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_UpgradingRiftLifeNew2_Conditions))
    call TriggerAddAction(t , function RetTrig_UpgradingRiftLifeNew2_Actions)
	set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_TimedRiftLife_Conditions))
    call TriggerAddAction(t , function RetTrig_TimedRiftLife_Actions)
	set t = null
endfunction

function RetTrig_Begin_Actions takes nothing returns nothing
    call ForGroupBJ(GetUnitsOfTypeIdAll('h02K') , function RetTrig_Begin_Func001A)
    call ForGroupBJ(GetUnitsOfTypeIdAll('h02L') , function RetTrig_Begin_Func002A)
endfunction

//===========================================================================
function InitRetTrig_Begin_Phoenix takes nothing returns nothing
    call ForGroupBJ(GetUnitsOfTypeIdAll('h02K') , function RetTrig_Begin_Func001A)
    call ForGroupBJ(GetUnitsOfTypeIdAll('h02L') , function RetTrig_Begin_Func002A)
endfunction

function RetTrig_Fortifier_Tent_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetConstructedStructure()) == 'h02R' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Fortifier_Tent_Actions takes nothing returns nothing
  local location l=GetUnitLoc(GetConstructedStructure())
  local player p=GetOwningPlayer(GetConstructedStructure())
    if GetPlayerState(p , PLAYER_STATE_RESOURCE_FOOD_USED) < GetPlayerState(p , PLAYER_STATE_RESOURCE_FOOD_CAP) then
    call CreateNUnitsAtLoc(1 , 'h01D' , p , l , bj_UNIT_FACING)
    endif


  set p = null
    call RemoveLocation(l)
  set l = null

endfunction

//===========================================================================
function InitRetTrig_Fortifier_Tent takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_Fortifier_Tent_Conditions))
    call TriggerAddAction(t , function RetTrig_Fortifier_Tent_Actions)
    set t = null
endfunction

//===========================================================================
// Trigger: Steal Trees
//===========================================================================
function RetTrig_Steal_Trees_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A032' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Steal_Trees_Actions takes nothing returns nothing
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = 30
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call RemoveDestructable(RandomDestructableInRectSimpleBJ(GetPlayableMapRect()))
        call CreateDestructableLoc('LTlt' , GetRandomLocInRect(Rect(( GetLocationX(GetUnitLoc(GetSpellAbilityUnit())) - 1000.00 ) , ( GetLocationY(GetUnitLoc(GetSpellAbilityUnit())) - 1000.00 ) , ( GetLocationX(GetUnitLoc(GetSpellAbilityUnit())) + 1000.00 ) , ( GetLocationY(GetUnitLoc(GetSpellAbilityUnit())) + 1000.00 ))) , GetRandomDirectionDeg() , 1.00 , GetRandomInt(0 , 9))
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
endfunction

//===========================================================================
function InitRetTrig_Steal_Trees takes nothing returns nothing
    set rj_trg_Steal_Trees = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Steal_Trees , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(rj_trg_Steal_Trees , Condition(function RetTrig_Steal_Trees_Conditions))
    call TriggerAddAction(rj_trg_Steal_Trees , function RetTrig_Steal_Trees_Actions)
endfunction

//===========================================================================
// Trigger: Snitch
//===========================================================================
function RetTrig_Snitch_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A034' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Snitch_Func001Func001001001003 takes nothing returns boolean
    return ( GetOwningPlayer(GetFilterUnit()) != GetOwningPlayer(GetSpellAbilityUnit()) )
endfunction

function RetTrig_Snitch_Func003002 takes nothing returns nothing
    call SetUnitPositionLoc(GetEnumUnit() , GetSpellTargetLoc())
endfunction

function RetTrig_Snitch_Actions takes nothing returns nothing
    local group Snitch = CreateGroup()
    set bj_forLoopAIndex = 1
    set bj_forLoopAIndexEnd = 2
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call GroupAddUnitSimple(GroupPickRandomUnit(GetUnitsInRangeOfLocMatching(2000.00 , GetUnitLoc(GetSpellAbilityUnit()) , Condition(function RetTrig_Snitch_Func001Func001001001003))) , Snitch)
        set bj_forLoopAIndex = bj_forLoopAIndex + 1
    endloop
    call SetUnitPositionLoc(GetSpellAbilityUnit() , GetSpellTargetLoc())
    call ForGroupBJ(Snitch , function RetTrig_Snitch_Func003002)
    call DestroyGroup(Snitch)
    set Snitch = null
endfunction

//===========================================================================
function InitRetTrig_Snitch takes nothing returns nothing
    set rj_trg_Snitch = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Snitch , EVENT_PLAYER_UNIT_SPELL_FINISH)
    call TriggerAddCondition(rj_trg_Snitch , Condition(function RetTrig_Snitch_Conditions))
    call TriggerAddAction(rj_trg_Snitch , function RetTrig_Snitch_Actions)
endfunction

//===========================================================================
// Trigger: Splitting Strike
//===========================================================================
function RetTrig_Splitting_Strike_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A04Z' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Splitting_Strike_Func002001 takes nothing returns boolean
    return ( GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 1 )
endfunction

function RetTrig_Splitting_Strike_Func003001 takes nothing returns boolean
    return ( GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 2 )
endfunction

function RetTrig_Splitting_Strike_Func004001 takes nothing returns boolean
    return ( GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 3 )
endfunction

function RetTrig_Splitting_Strike_Actions takes nothing returns nothing
    call TriggerSleepAction(0.50)
    if ( (GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 1) ) then // INLINED!!
        call UnitDamageTargetBJ(GetSpellAbilityUnit() , GetSpellTargetUnit() , 50.00 , ATTACK_TYPE_HERO , DAMAGE_TYPE_NORMAL)
    else
        call DoNothing()
    endif
    if ( (GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 2) ) then // INLINED!!
        call UnitDamageTargetBJ(GetSpellAbilityUnit() , GetSpellTargetUnit() , 100.00 , ATTACK_TYPE_HERO , DAMAGE_TYPE_NORMAL)
    else
        call DoNothing()
    endif
    if ( (GetUnitAbilityLevelSwapped('A04Z' , GetSpellAbilityUnit()) == 3) ) then // INLINED!!
        call UnitDamageTargetBJ(GetSpellAbilityUnit() , GetSpellTargetUnit() , 150.00 , ATTACK_TYPE_HERO , DAMAGE_TYPE_NORMAL)
    else
        call DoNothing()
    endif
endfunction

//===========================================================================
function InitRetTrig_Splitting_Strike takes nothing returns nothing
    set rj_trg_Splitting_Strike = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Splitting_Strike , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(rj_trg_Splitting_Strike , Condition(function RetTrig_Splitting_Strike_Conditions))
    call TriggerAddAction(rj_trg_Splitting_Strike , function RetTrig_Splitting_Strike_Actions)
endfunction

//===========================================================================
// Trigger: Narcolepsy Cast
//===========================================================================
function RetTrig_Narcolepsy_Cast_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A06Q' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Narcolepsy_Cast_Actions takes nothing returns nothing
    call TriggerSleepAction(0.50)
call CasterCastAbilityLevel((GetOwningPlayer(GetSpellAbilityUnit()) ) , ( 'AUsl' ) , 1 , ( "sleep" ) , ( GetSpellTargetUnit() ) , ( true)) // INLINED!!
endfunction

//===========================================================================
function InitRetTrig_Narcolepsy_Cast takes nothing returns nothing
    set rj_trg_Narcolepsy_Cast = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Narcolepsy_Cast , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(rj_trg_Narcolepsy_Cast , Condition(function RetTrig_Narcolepsy_Cast_Conditions))
    call TriggerAddAction(rj_trg_Narcolepsy_Cast , function RetTrig_Narcolepsy_Cast_Actions)
endfunction

//===========================================================================
// Trigger: Narcolepsy Timer
//===========================================================================
function RetTrig_Narcolepsy_Timer_Func001001002 takes nothing returns boolean
    return ( UnitHasBuffBJ(GetFilterUnit() , 'B000') == true )
endfunction

function RetTrig_Narcolepsy_Timer_Func001002001 takes nothing returns boolean
    return ( GetRandomInt(1 , 2) == 1 )
endfunction

function RetTrig_Narcolepsy_Timer_Func001002 takes nothing returns nothing
    if ( (GetRandomInt(1 , 2) == 1) ) then // INLINED!!
call CasterCastAbilityLevel((Player(PLAYER_NEUTRAL_AGGRESSIVE) ) , ( 'AUsl' ) , 1 , ( "sleep" ) , ( GetEnumUnit() ) , ( true)) // INLINED!!
    else
        call DoNothing()
    endif
endfunction

function RetTrig_Narcolepsy_Timer_Actions takes nothing returns nothing
    call ForGroupBJ(GetUnitsInRectMatching(GetPlayableMapRect() , Condition(function RetTrig_Narcolepsy_Timer_Func001001002)) , function RetTrig_Narcolepsy_Timer_Func001002)
endfunction

//===========================================================================
function InitRetTrig_Narcolepsy_Timer takes nothing returns nothing
    set rj_trg_Narcolepsy_Timer = CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(rj_trg_Narcolepsy_Timer , 22.00)
    call TriggerAddAction(rj_trg_Narcolepsy_Timer , function RetTrig_Narcolepsy_Timer_Actions)
endfunction

//===========================================================================
// Trigger: Explosion
//===========================================================================
function RetTrig_Explosion_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A072' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellAbilityUnit()) != 'e013' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Explosion_Actions takes nothing returns nothing
 call CasterCastAbilityPointLoc(GetOwningPlayer(GetSpellAbilityUnit()) , 'A072' , "deathanddecay" , GetSpellTargetLoc() , false)

//   takes player owner, integer abilid, string order, location loc, boolean instant returns unit
endfunction

//===========================================================================
function InitRetTrig_Explosion takes nothing returns nothing
    set rj_trg_Explosion = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Explosion , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Explosion , Condition(function RetTrig_Explosion_Conditions))
    call TriggerAddAction(rj_trg_Explosion , function RetTrig_Explosion_Actions)
endfunction

//===========================================================================
// Trigger: Caster Setup
//===========================================================================
//===========================================================================
function InitRetTrig_Caster_Setup takes nothing returns nothing

    call CreateCasters(12)

// Create 12 Initial casters available for any usage of a caster function
// Not a needed step, but might help a little against first cast lag
// Better if you do it , at least with a value of 1 , you can just copy this trigger to your map.

endfunction



//===========================================================================
// Trigger: Nova Spells
//===========================================================================
//***************************************************************************************************
//*
//*  Nova Template
//*
//*  Requires:
//*      - A triggerer ability (has to be instant (non-target order) )
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Missile Art determines the missile
//*      - The Triggerer Ability's Special Art is spawned to the missile periodically
//*      - The Triggerer Ability's Target Art is used on targets when collision is greater than 0
//*                            And the second target art is its attachment point
//*
//***************************************************************************************************

//===================================================================================================
// Nova Template Setup
// 
function NovaTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "NovaSpellTemplate"
 //
 // integer "n"         is the number of missiles:
 // real    "dur"       is the duration for the missiles
 // real    "speed"     is the movement speed for the missiles (from 150 to 522, please)
 // real    "scale"     is the scale for the missiles:
 // real    "turnic"    is the angle incriment, changes the way the missiles spin. (0 makes them go straight)
 // integer "abil"      is the ability added to the missiles.
 // The ability added will match the level of the triggerer ability if possible
 //
 // real    "collision" Enables Bolt Collision, After this step many options are available :
 // (next options only work if missiles have collision greater than 0)
 // 
 // integer "DamageOptions" Caster System's Damage Options in saveable form, that determine which units to affect
 //
 // real    "dmg"           The Damage done to units hit by bolts
 // real    "Pdmg"          The Periodic damage done to units
 // real    "PDmgPeriod"    The Period for the periodic damage
 // real    "PDmgDur"       The duration of the periodic damage
 // integer "Spell"         The rawcode of the spell to cast
 // integer "OrderId"       The Order Id of the spell to cast
 // real    "RecDelay"      The Recycle Delay of the dummy caster that casts the Spell to cast
 //
 // integer "TargetLog"     Is 1 if it logs targets so it avoids to hit a unit more than once
 //     

 //===================================================================================================
 // Nova template Defaults:
 //
    call SetTemplateDefaultInt("NovaSpellTemplate" , "n" , 15) //Default number of bolts=15
    call SetTemplateDefaultInt("NovaSpellTemplate" , "abil" , 'Aphx') //Default ability to add is Pheonix Morphing (Egg) let's call it the null ability
    call SetTemplateDefaultReal("NovaSpellTemplate" , "dur" , 2) //Default duration is 2
    call SetTemplateDefaultReal("NovaSpellTemplate" , "scale" , 1) //Default scale is 1
    call SetTemplateDefaultReal("NovaSpellTemplate" , "turninc" , 12) //Default turning value is 12
    call SetTemplateDefaultReal("NovaSpellTemplate" , "speed" , 522) //Default speed = 522 (max)
 //==================================
 //Hydra Poison Nova ('A0AL')
 set s = SetSpellTemplate('A0AK' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_POISON) //Spell poison damage
 set D = D + (8) //Don't hurt self // INLINED!!
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 522) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 12) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets


    call SetAbilityDataReal(s , "dmg" , 0 , 20) //Level 1: 20 initial damage


    call SetAbilityDataReal(s , "Pdmg" , 0 , 5) //Level 1: 5 Periodic damage

    call SetAbilityDataReal(s , "PdmgDur" , 0 , 4) //Level 1: Periodic damage lasts 4 seconds

    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above
 //==================================
 //Death's Wake ('A0AL')
 set s = SetSpellTemplate('A0AL' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_POISON) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 6) // 0.5 seconds of duration for all levels
//    call SetAbilityDataReal(s,"turninc"      ,0,12 )  // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 0 , 275) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above

 //==================================
 //Chaotic Burst ('A0EV')
 set s = SetSpellTemplate('A0EV' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FIRE) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 1 , 0.5) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 2 , 1) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 3 , 1.5) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 0) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 80) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 160) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 240) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above



 //==================================
 //NetTrapNetExplode ('A0BT')
 set s = SetSpellTemplate('A0BT' , "NovaSpellTemplate")
 set D = 0 //
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 500) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 1) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 0) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets


    call SetAbilityDataInt(s , "Spell" , 0 , 'A0BU') // Always log targets
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("ensnare")) // Always log targets
    call SetAbilityDataInt(s , "RecDelay" , 0 , 15) // Always log targets



    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above

 //==================================
 //SeaCrush ('A0BZ')
 set s = SetSpellTemplate('A0BZ' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //Spell poison damage
 set D = D + (8) //Don't hurt self // INLINED!!
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 6) // 0.5 seconds of duration for all levels
//    call SetAbilityDataReal(s,"turninc"      ,0,12 )  // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 0 , 50) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above



 //==================================
 //AEther Shift ('A0GS')
 set s = SetSpellTemplate('A0GS' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 1 , 0.4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 2 , 0.6) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 3 , 0.8) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 0) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 50) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 70) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 100) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above





 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A00E')
    call PreloadAbility('A000')
    call PreloadAbility('A004')
    call PreloadAbility('A009')

endfunction


function InitRetTrig_Nova_Spells takes nothing returns nothing
    call ExecuteFunc("NovaTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction

//===========================================================================
// Trigger: TimedBarrel Spells
//===========================================================================
//***************************************************************************************************
//*
//*  Timed Barrel Spell Template
//*
//*  Requires:
//*      - A triggerer ability (has to be point targeteable)
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Special Art determines the effect
//*      - The Triggerer Ability's Target Art appears on the chest of the effect
//*
//***************************************************************************************************

//===================================================================================================
// Timed Barrel Spell Template Setup:
//
function TimedBarrelSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "TimedBarrelTemplate"
 //
 // integer "timeout"       is the time before "the barrel explodes" or whatever
 // real    "damage"        is the damage after "the barrel explodes" or whatever
 // real    "area"          is the area of effect for that damage
 // integer "damageoptions" The Aoe damage options , but In Saveable form ( CreateDamageOptions(<damageoptions>) ) , 
 //                         see the caster system readme for more info, 0 for default
 //
 // integer "abil"    is the ability to cast
 // real    "delay"   is the delay before recicling the caster of that ability (should match the duration of any damaging effect)
 // integer "orderid" is the orderid of that ability
 // real    "scale"   is the scale for "the barrel" or whatever
 // The casted ability added will match the level of the triggerer ability if possible
 //

 //===================================================================================================
 // Timed Barrel Template Defaults:
 //
    call SetTemplateDefaultReal("TimedBarrelTemplate" , "scale" , 1.0) //The barrel model has 1 for default scale
    call SetTemplateDefaultInt("TimedBarrelTemplate" , "timeout" , 5) //The duration is 5 by default


//=======================================================================================
//Myrmidon's Net Trap ('A0BS')
 set s = SetSpellTemplate('A0BS' , "TimedBarrelTemplate")

    call SetAbilityDataInt(s , "abil" , 0 , 'A0BT') //Using the damage options saved before
    call SetAbilityDataReal(s , "delay" , 0 , 2) //Using the damage options saved before
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("howlofterror")) //Using the damage options saved before
    call SetAbilityDataReal(s , "scale" , 0 , 1.0) //Using the damage options saved before

//=======================================================================================
//Myrmidon's Net Trap 2 ('A0BV')
 set s = SetSpellTemplate('A0BV' , "TimedBarrelTemplate")

    call SetAbilityDataInt(s , "abil" , 0 , 'A0BT') //Using the damage options saved before
    call SetAbilityDataReal(s , "delay" , 0 , 2) //Using the damage options saved before
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("howlofterror")) //Using the damage options saved before
    call SetAbilityDataReal(s , "scale" , 0 , 1.0) //Using the damage options saved before
//=======================================================================================
//Chaotic Seastone ('A0BY')
 set s = SetSpellTemplate('A0BY' , "TimedBarrelTemplate")

    call SetAbilityDataInt(s , "abil" , 0 , 'A0BZ') //Using the damage options saved before
    call SetAbilityDataReal(s , "delay" , 0 , 7) //Using the damage options saved before
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("howlofterror")) //Using the damage options saved before
    call SetAbilityDataReal(s , "scale" , 0 , 2.0) //Using the damage options saved before

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A00J')
    call PreloadAbility('A00M')
endfunction


function InitRetTrig_TimedBarrel_Spells takes nothing returns nothing
    call ExecuteFunc("TimedBarrelSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Charge Template
//===========================================================================
//**************************************************************************************************
//*
//*   Charge Template
//*
//*    Requires:
//*       -A point targeteable skill as triggerer ability
//*      - The Caster System 12.8 or greater
//*        ( http://www.wc3campaigns.net/vexorian/ )
//*       -The Alternative Spell Templates System
//*       -This Trigger (make sure the Configuration Section is pointing to
//*                      the right abilities/units)
//*    Art:
//*       - The Ability's 1st Caster Art model is attached to the caster during charge.
//*       - The Ability's 2nd Caster Art field is the attachment point of last effect
//*
//**************************************************************************************************

//==================================================================================================
// Charge Template Configuration:
//
function SetupChargeTemplate takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ChargeSpellTemplate"
 //
 // real    "durlimit"      The maximum duration of the charging
 // real    "damage"        is the damage per quarter of second during the charge movement
 // real    "area"          is the area of effect for that damage
 // integer "hurtallies"    is 1 if you want the aoe damage to also affect allies
 // integer "damageoptions" The Aoe damage options , but In Saveable form ( CreateDamageOptions(<damageoptions>) ) , 
 //                         see the caster system readme for more info, 0 for default
 //
 // real    "abiln"      is the number of passive skills to add during the charge process
 // integer "abil1id"    is the number 1 ability to add (keep increasing the number for more abilities)
 //
 // integer "spellid"    is the ability to cast each quarter of second at the position of the unit
 // integer "orderid"    is the order id for that ability
 // real    "delay"      is the time before recicling the caster that casts that ability
 //
 // integer "nopathing"  is 1 when you want to disable the collision of the caster
 // integer "cliffcheck" is 1 when the caster is not allowed to change clifflevels during charge
 // real    "timeout"    the maximum duration of the charge effect, specially useful when nopathing is 0
 // integer "eyecandy"   is 1 when you want the shadow like images eyecandy.

 //===================================================================================================
 // Charge Template Defaults:
 //
    call SetTemplateDefaultInt("ChargeSpellTemplate" , "eyecandy" , 1) //Show eyecandy is 1 by default
    call SetTemplateDefaultInt("ChargeSpellTemplate" , "nopathing" , 1) //No pathing is 1 by default
    call SetTemplateDefaultInt("ChargeSpellTemplate" , "cliffcheck" , 1) //Cliff Level check is 1 by default
    call SetTemplateDefaultReal("ChargeSpellTemplate" , "durlimit" , 1000000) //Maximum duration is 1000000 by default
    call SetTemplateDefaultInt("TheOtherChargeSpellTemplate" , "eyecandy" , 1) //Show eyecandy is 1 by default
    call SetTemplateDefaultInt("TheOtherChargeSpellTemplate" , "nopathing" , 1) //No pathing is 1 by default
    call SetTemplateDefaultInt("TheOtherChargeSpellTemplate" , "cliffcheck" , 1) //Cliff Level check is 1 by default
    call SetTemplateDefaultReal("TheOtherChargeSpellTemplate" , "durlimit" , 1000000) //Maximum duration is 1000000 by default
 //===================================================================================================
 // Charge ('A0A2')
 //
 set s = SetSpellTemplate('A0A2' , "ChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 5) //Level 1: 140 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus

 //===================================================================================================
 // Salamander Charge ('A0DE')
 //
 set s = SetSpellTemplate('A0DE' , "ChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 5) //Level 1: 140 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus


 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A014')
    call PreloadAbility('A016')
    call PreloadAbility('A01M')

endfunction

function InitRetTrig_Charge_Template takes nothing returns nothing
    call ExecuteFunc("SetupChargeTemplate")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction

//===========================================================================
// Trigger: FireSpawner Template
//
// Heck, When I decided to change the charge template to leave flames , I found that the only way was making a custom spell as sub spell, this makes it leave flames, All because flame strike always leaves the same amount of flames, and that in a small area is really bad.
//===========================================================================
//**************************************************************************************************
//*
//*   Fire Spawner (used to make Magma Surfer cooler)
//*
//*    Requires:
//*       -A point targeteable triggerer ability.
//*       -The Alternative Spell Templates System
//*       -This Trigger (make sure the Configuration Section is pointing to
//*                      the right abilities/units)
//*    Art:
//*       - The Ability's Area Effect Art determines the model of the flames
//*       - The Ability's 1st Special Art field determines the target effect.
//*       - The Ability's 2nd Special Art field determines the target attachment point.
//*
//**************************************************************************************************

//==================================================================================================
//   Fire Spawner Template Configuration:
//
function FireSpawnerSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id =       "FireSpawnerTemplate"
 // real     "duration"      The game time duration of the flames.
 // real     "period"        The time between each damage wave.
 // real     "damage"        The area of effect damage per second each flame causes
 // real     "area"          The area of effect for each spawned fire.
 // integer  "n"             Is the number of flames spawned.
 // integer  "affectallied"  is 1 if allies take damage from the fire too
 // integer "damageoptions" The Aoe damage options , but In Saveable form ( CreateDamageOptions(<damageoptions>) ) , 
 //                         see the caster system readme for more info, 0 for default

 //===================================================================================================
 // Fire Spawner Template Defaults:
 //
    call SetTemplateDefaultInt("FireSpawnerTemplate" , "affectallied" , 0) //By default the damage doesn't hur allies
    call SetTemplateDefaultReal("FireSpawnerTemplate" , "period" , 1) //By default it does damage per second

endfunction

function InitRetTrig_FireSpawner_Template takes nothing returns nothing
    call ExecuteFunc("FireSpawnerSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Shield Template
//===========================================================================
//***************************************************************************************************
//*
//*   Shield Template
//*
//*    Requires:
//*       - A triggerer ability (can be either instant or unit targeteable)
//*       - The Alternative Spell Templates System
//*       - This Trigger
//*
//*    Art:
//*       - The Triggerer Ability's Special art determines the missile effect
//*       - The Triggerer Ability's Target art determines the damage/healing effect
//*       - The Triggerer Ability's Effect art keeps spawning at the position of the missiles
//*
//***************************************************************************************************

//===================================================================================================
// Shield Spell Template Configuration:
//
function ShieldTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id =       "FireSpawnerTemplate"
 // real    "mainspeed"  if the spell is unit targeteable and non instant, this should match
 //                      the speed of the projectile of the triggerer ability.
 // integer "n"          is the total number of the shield's missiles
 // real    "dur"        is the game-time duration of the shield's missiles
 // real    "area"       is the acquire range for the missiles
 // real    "distance"   is the distance the missiles take between them and the target
 // real    "speed"      is the movement speed for each missile
 // integer "pasN"       is the total number of passive skills to add to the missiles.
 // integer "pas1id"     is #1 passive skill to add
 // integer "pas2id"     is #2 passive skill to add
 // integer "pas...id"   is #... passive skill to add (Data is ignored depending of "pasN"  
 // real    "damage"     Is the target damage
 // real    "dmgps"      is the damage per movement each of the parts of the shield perform
 // real    "dmgpsarea"  is the amount of damage that each of the missiles is able to perform at a target.
 // integer "dmgoptions" The damage options , but In Saveable form ( CreateDamageOptions(<damageoptions>) ) , 
 //                      see the caster system readme for more info, 0 for default. Area damage considers every option
 //                      while target damage only considers attack and damage types.
 // integer "spell"      is the active spell that each of the missiles is able to cast at a target.
 // integer "orderid"    is the order id for that spell ( example: OrderId("chainlightning") or 12444234 )
 // real    "delay"      is the time before recicling the caster after it casts the active spell
 //                      for instant spells leave it as 0.
 // real    "cooldown"   is the time before each of the missiles of the shield casts the active
 //                      ability/ causes damage again.
 // integer "goodspell"  is 1 when the active spell or the damage affects allies,
 //                      and 0 if they affect enemies. ("damage" can be a negative value and
 //                      becomes healing)
 // real    "maxpercent" is the maximum percentage life a unit can have to become a valid target
 //                      of the active spell and the damage.
 // real    "minpercent" is the minimum percentage life a unit can have to become a valid target
 //                      of the active spell and the damage.
 // integer "nonhero"    is 1 if only non heroes can be acquired by the missiles.
 // integer "clockwise"  is 1 when the missiles go clockwise.
 // integer "opposite"   is 1 when you want each pair of missiles have opposite directions,
 // integer "directmove" is 1 when the missiles are instantly moved instead of using orders
 // integer "fromfacing" determines if the missiles move depending on the facing angle of the target
 //
 // The template tries to match the level of the castable and addable abilities to the level
 // of the triggerer ability.
 //

 //===================================================================================================
 // Shield Template Defaults:
 //
    call SetTemplateDefaultReal("ShieldTemplate" , "speed" , 400) //Shield bolt speed is 400 by default
    call SetTemplateDefaultReal("ShieldTemplate" , "distance" , 150) //Distance between bolts and casters is 100 by default
    call SetTemplateDefaultReal("ShieldTemplate" , "maxpercent" , 100) //Maximum Life Percentage required to make a bolt do something is 100% by default
    call SetTemplateDefaultReal("ShieldTemplate" , "minpercent" , 0) //Mininmum Life Percentage required to make a bolt do something is 0% by default
    call SetTemplateDefaultReal("ShieldTemplate" , "height" , 120) //Height of the shield bolts is 120 by default
    call SetTemplateDefaultReal("ShieldTemplate" , "mainspeed" , 100) //Speed of projectile is 100 by default
 
//===================================================================================================
 // Water Shield ('A0CQ')
 //

 //
 set s = SetSpellTemplate('A0CQ' , "ShieldTemplate")
 set D = 0 //Shield of divinity damage Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //
 set D = CreateDamageOptions(D) //Save the damage options
    call SetAbilityDataInt(s , "n" , 1 , 2) //Level 1: 5 bolts
    call SetAbilityDataInt(s , "n" , 2 , 4) //Level 2: 6 bolts
    call SetAbilityDataInt(s , "n" , 3 , 6) //Level 3: 7 bolts
    call SetAbilityDataReal(s , "dur" , 1 , 50) //Level 1: Lasts 52 seconds
    call SetAbilityDataReal(s , "dur" , 2 , 70) //Level 2: Lasts 59 seconds
    call SetAbilityDataReal(s , "dur" , 3 , 90) //Level 3: Lasts 66 seconds
    call SetAbilityDataReal(s , "area" , 0 , 300) //Target acquire area is 300
    call SetAbilityDataReal(s , "damage" , 1 , 100) //Level 1: Heals 200 hp
    call SetAbilityDataReal(s , "damage" , 2 , 200) //Level 2: Heals 300 hp
    call SetAbilityDataReal(s , "damage" , 3 , 300) //Level 3: Heals 400 hp
    call SetAbilityDataReal(s , "dmgoptions" , 0 , D) //Using damage options D
    call SetAbilityDataInt(s , "goodspell" , 0 , 0) //This is a positive spell
    call SetAbilityDataReal(s , "maxpercent" , 0 , 0) //Maximum percentage life required is 50%
    call SetAbilityDataReal(s , "mainspeed" , 0 , 1000)

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A000')
    call PreloadAbility('A00G')
    call PreloadAbility('A00H')
    call PreloadAbility('A00I')
    call PreloadAbility('A00E')
endfunction


function InitRetTrig_Shield_Template takes nothing returns nothing
    call ExecuteFunc("ShieldTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Aura Template
//===========================================================================
//***************************************************************************************************
//*
//*  Aura Template
//*
//*  Requires:
//*      - A triggerer ability (Should be passive)
//*      - The Caster System
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//***************************************************************************************************

//===================================================================================================
// Aura Template Setup:
//
function AuraTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "AuraTemplate"
 //
 // real    "area"     is area of effect of the aura
 // integer "bad"      is 1 if the aura affects enemies, and 0 if it affects allies
 // integer "notself"  is 1 when the hero shouldn't be affected by his aura (if it is a good aura)
 // integer "n"        is the total number of passive abilities to add.
 // integer "spell1id" is the 1st ability to add
 // integer "spell2id" is the 2nd ability to add (if n>=2)
 // integer "spell3id" is the 3rd ability to add (if n>=3)
 //
 // (keep increasing the number between spell and id to use more abilities, (till n))
 //
 // integer "spbk1"    is 0, when you don't want to add the first ability using a dummy spell book,
 //                    otherwise it is the rawcode of the Auxiliar Spell Book ability used to add
 //                    the ability, the point of this is usually to hide icons.
 // integer "spbk2"    The same, for ability 2.
 //
 // (keep increasing the number between spell and id to use more abilities, (till n))
 //
 // integer "options"  Caster system damage options in saveable form, determines which unit can
 //                    Be affected by the aura.
 //
 // Remember than any value is 0 or "" by default unless stated in the Defaults section.
 //
 // The template will try to match each of the spell's level with the current level of the
 // aura, if the spell has less levels than the level of the aura, it will stay at max level
 //

 //===================================================================================================
 // Aura Template Defaults:
 //
    call SetTemplateDefaultInt("AuraTemplate" , "n" , 1) //Deafult number of abilities to be added is 1
    call SetTemplateDefaultReal("AuraTemplate" , "area" , 900) //Deafult area is 900

 //===================================================================================================
 // Clinging Shadows ('A06R')
 //
 set s = SetPassiveTemplate('A06R' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 500)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'ACev')
    call SetAbilityDataInt(s , "spbk1" , 0 , 'A06T')
    call SetAbilityDataInt(s , "spell2id" , 0 , 'ACrk')
    call SetAbilityDataInt(s , "spbk2" , 0 , 'A06U')
    call SetAbilityDataInt(s , "spell3id" , 0 , 'Apiv')
    call SetAbilityDataInt(s , "n" , 1 , 1)
    call SetAbilityDataInt(s , "n" , 2 , 2)
    call SetAbilityDataInt(s , "n" , 3 , 3)

 //===================================================================================================
 // Aura of Rage ('A06R')
 //
 set s = SetPassiveTemplate('A0EX' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = D + DamageOnlyTo(UNIT_TYPE_MELEE_ATTACKER) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 650)
//    call SetAbilityDataInt( s,"notself", 0, 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0EZ')
    call SetAbilityDataInt(s , "spbk1" , 0 , 'A0F1')
    call SetAbilityDataInt(s , "spell2id" , 0 , 'A0EY')
    call SetAbilityDataInt(s , "n" , 0 , 2)

 //===================================================================================================
 // Elemental fury ('A0F7')
 //
 set s = SetPassiveTemplate('A0F7' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 400)
 //   call SetAbilityDataInt( s,"notself", 0, 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0F6')
    call SetAbilityDataInt(s , "n" , 0 , 1)


 //===================================================================================================
 // Aura of the Kraken ('A0CA')
 //
 set s = SetPassiveTemplate('A0CA' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options
    //call BJDebugMsg("Aura of Kraken has been initialized")
    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0CB')
    call SetAbilityDataInt(s , "spell2id" , 1 , 'A0CC')
    call SetAbilityDataInt(s , "spell2id" , 2 , 'A0CR')
    call SetAbilityDataInt(s , "spell2id" , 3 , 'A0CS')
    call SetAbilityDataInt(s , "n" , 0 , 2)



 //===================================================================================================
 // Snow Aura 1 ('A07I')
 //
 set s = SetPassiveTemplate('A07I' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 1000)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0FT')
    call SetAbilityDataInt(s , "spell2id" , 0 , 'A0FS')
    call SetAbilityDataInt(s , "n" , 1 , 2)

 //===================================================================================================
 // North Aura 1 ('AFat')
 //
 set s = SetPassiveTemplate('AFat' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A09H')
    call SetAbilityDataInt(s , "n" , 1 , 1)

 //===================================================================================================
 // Seer's Vision Aura ('A0E6')
 //
 set s = SetPassiveTemplate('A0E6' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 800)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0E7')
    call SetAbilityDataInt(s , "spbk1" , 0 , 'A0E8')
    call SetAbilityDataInt(s , "n" , 1 , 1)


 //===================================================================================================
 // Bash Aura ('A07J')
 //
 set s = SetPassiveTemplate('A07S' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A07V')
    call SetAbilityDataInt(s , "spbk1" , 0 , 'A07W')
    call SetAbilityDataInt(s , "n" , 0 , 1)


endfunction

function InitRetTrig_Aura_Template takes nothing returns nothing
    call ExecuteFunc("AuraTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Spiral Template
//===========================================================================
//***************************************************************************************************
//*
//*   Spiral Beam Template
//*
//*  Requires:
//*      - A triggerer ability (has to be non-targeteable, or point targeteable)
//*                            (Point targeteable spells need "dontfollow" to be 1.)
//*                            (channeling spells need "channel" to be 1.)
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Special Art is the missile effect
//*      - The Triggerer Ability's Effect Art keeps being spawned at the position of the missile
//*      - The Triggerer Ability's Target Art is the target effect or the damage over time effect
//*      - The Triggerer Ability's 2nd Target Art is the attachment point for that effect
//*      - The Triggerer Ability's Area Effect Art appears at the position of the spiral effect at
//*        the end of the spell
//*
//***************************************************************************************************

//===================================================================================================
// Spiral Beam Spell Template declarations:
//
function SetupSpiralBeamTemplate takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "SpiralBeamDamage" (active)
 //
 // real     "height"        The spiral effect height
 // real     "scale"         The Spiral effect scale
 // integer  "color"         The spiral effect color, 0xAARRGGBB , in hex, AA is the alpha (from 00 to FF)
 //                          RR the red, GG the green and BB the Blue
 // real     "duration"      The duration of the spiral
 //
 // integer  "abilN"         The number of passive abilities to add
 // integer  "abil1id"       The Rawcode of the first passive ability to add (if any)
 // integer  "abil2id"       The Rawcode of the second passive ability to add (if any)
 //             
 // integer  "abilNid"       The Rawcode of the nth passive ability to add (depends on AbilN)
 //
 // real     "area"          The Area of effect of the hammer (how close a target must be to be affected)
 // real     "damage"        The initial damage of the spiral
 // real     "dmgduration"   The duration of a damage over time effect
 // real     "damageps"      The Damage over time value
 // real     "damageperiod"  The damage over time period
 //
 // integer  "spell"         The Rawcode of an active spell to cast against units that come close         
 // real     "recycledelay"  The Recycle delay for the caster that uses that ability.
 // integer  "orderid"       The OrderId of the spell (Example: OrderId("holylight")
 //
 // integer "options"       (Caster System Damage Options in saveable form) determine
 //                          which units can be hit, if the Damage Options return 0 as factor of
 //                          an unit, the unit won't be affected by the antiorb, This is ignored
 //                          for type 1 antiorbs ( the ones that cast stuff on self)
 //
 // integer  "dontfollow"    Is 1 if you don't want the missile's movement to be based on the position of the casting unit.
 //                          Must be one if the spell is point targeteable.
 // integer  "channel"       Is 1 if you want the spiral to stop when the trigger ability ends. (the caster moves or gets stunned)
 // real     "StartDistance" The initial distance between the spiral effect and the unit that casts the ability
 // real     "DistanceSpeed" The increment per 0.01 seconds for the distance
 // real     "TanSpeed"      The Tangential speed, or the real speed of the spiral effect, a negative value
 //                          would make the missile go clock-wise.
 // real     "fxperiod"      The period before spawning the EFFECT on the missile.

 //===================================================================================================
 // Spiral Spell Template Defaults:
 //
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "area" , 100) //Default Area is 100
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "duration" , 10) //Default duration 10
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "DistanceSpeed" , 100) //Default DistanceSpeed 100
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "StartDistance" , 50) //Default Start distance=50
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "height" , 60) //Default missile height is 60
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "damageperiod" , 1) //Default damageperiod is 1 second
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "fxperiod" , 0.4) //Default FX period is 0.4 seconds
    call SetTemplateDefaultReal("SpiralBeamTemplate" , "scale" , 1) //Default missile scale is 1
    call SetTemplateDefaultInt("SpiralBeamTemplate" , "color" , 0xFFFFFFFF) //Default Colors: 255,255,255,255
    call SetTemplateDefaultInt("SpiralBeamTemplate" , "options" , CreateDamageOptions(DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_MAGIC) + DamageOnlyEnemies())) //Default target options are magical damage that only hits enemies


 //===================================================================================================
 // Rampage ('A0FD')
 //
 set s = SetSpellTemplate('A0FD' , "SpiralBeamTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = D + DamageOnlyEnemies() //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "damage" , 1 , 60)
    call SetAbilityDataReal(s , "damage" , 2 , 120)
    call SetAbilityDataReal(s , "damage" , 3 , 180)
    call SetAbilityDataReal(s , "duration" , 0 , 3.5)
    call SetAbilityDataReal(s , "DistanceSpeed" , 0 , 0.55) //Distance Speed is 0.55
    call SetAbilityDataReal(s , "TanSpeed" , 0 , 720) //Tangential speed is -720 (goes anti-clockwise))



 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A01B') //Arctic bolt freezing

endfunction

function InitRetTrig_Spiral_Template takes nothing returns nothing
    call ExecuteFunc("SetupSpiralBeamTemplate")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Beam Template
//===========================================================================
//***************************************************************************************************
//*
//*  Beam Template
//*
//*  Requires:
//*      - A triggerer ability (has to be instant point-target order)
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Area Effect Art is the missile art
//*      - The Triggerer Ability's Special Art keeps spawning at the position of the beam
//*      - The Triggerer Ability's Target Art shall be the target effect for the damage per second
//*
//***************************************************************************************************

//===================================================================================================
// Beam Template Setup
// 
function BeamTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "BeamSpellTemplate" (active)
 //
 // real    "speed"      Beam speed
 // real    "scale"      Beam scale
 // integer "color"      The Beam Missilecolor, 0xAARRGGBB , in hex, AA is the alpha (from 00 to FF)
 //                       RR the red, GG the green and BB the Blue
 // real    "height"     Beam flyheight
 // real    "area"       This is the area of effect of the beam
 // real    "distance"   The total distance
 // real    "offset"     Offset of initial position of beam from caster
 // integer "canrepeat"  Is 1 if a unit can be considered as a target twice
 //
 // integer "spell"      The spell to cast if an unit is hit by the beam
 // integer "orderid"    The orderid of that spell
 // real    "delay"      The recycle delay of the caster for that spell (how longer the spell deals damage)
 //
 // real    "damage"     The initial damage
 // real    "damageps"   The damage per period
 // real    "duration"   The damage per period duration
 // real    "period"     The time for each damage per period to make effect
 //
 // integer "options"    (Caster System Damage Options in saveable form) determine
 //                      which units can be hit, if the Damage Options return 0 as factor of
 //                      an unit, the unit won't be affected by the antiorb, This is ignored
 //                      for type 1 antiorbs ( the ones that cast stuff on self)
 //
 // integer "boomerang"  The times the beam goes backwards
 //
 // string  "spc"        The attachment point for the extra spawning effect
 //                       ("point" if you want it to just be spawned at the position of the beam)

 //===================================================================================================
 // Beam Template Defaults:
 //
    call SetTemplateDefaultInt("BeamSpellTemplate" , "options" , CreateDamageOptions(0)) //Default target options are null
    call SetTemplateDefaultInt("BeamSpellTemplate" , "color" , 0xFFFFFFFF) //Default color is 255,255,255,255
    call SetTemplateDefaultReal("BeamSpellTemplate" , "speed" , 800) //Make default beam speed 800
    call SetTemplateDefaultReal("BeamSpellTemplate" , "scale" , 1) //Make default scale 1
    call SetTemplateDefaultReal("BeamSpellTemplate" , "distance" , 900) //Default distance is 900
    call SetTemplateDefaultReal("BeamSpellTemplate" , "period" , 1) //Default period is 1 second
    call SetTemplateDefaultString("BeamSpellTemplate" , "spc" , "origin") //Default Attachment point is origin

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A01O') //Electric Beam purge
    call PreloadAbility('A01R') //Frost guard bolt freezing

endfunction

function InitRetTrig_Beam_Template takes nothing returns nothing
    call ExecuteFunc("BeamTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Cone Template
//===========================================================================
//*************************************************************************************************
//*
//*   Cone Spell Template
//*
//*     Requires:
//*        - A triggerer ability (should either be point or unit active spell )
//*        - The GroupAddUnitsInTriangle function
//*        - The Alternative Spell Templates System
//*        - This Trigger (make sure it points to the right rawcode)
//*
//* Art Info:
//* - The Ability's Target effect is attached to the units when hit.
//* - The Ability's Second Target effect is the attachment point of that effect.
//*
//*************************************************************************************************

//=================================================================================================
// Cone Spell TemplateConfiguration:
//
function SetupConeSpellTemplate takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ConeSpellTemplate" (active)
 //
 //                  |--Final Area---|
 //           _       _______________
 //           |       \      |      /
 //           |        \     |     /
 //        distance     \    |    /
 //           |          \   |   /
 //                      ||
 //                    Initial Area
 //
 // real     "initialarea"     The initial area of the cone (see the graphic)
 // real     "distance"        The lenght of the cone (see the graphic)
 // real     "finalarea"       The final area of the cone (see the graphic)
 //                                
 // integer  "maxtargets"      The maximum number of targets
 //
 // integer  "spell"           The Rawcode of the spell to cast to the units in the cone
 // real     "recycledelay"    The Waitime before recycling the caster, must match the duration of the spell's damaging effect
 // integer  "orderid"         The order id of the Spell, (OrderId("stomp") , OrderId("dispell") or 8353353 )
 // integer  "castfromcaster"  Is 1 if the spell has the origin point at the position of the caster
 //                                 
 // real     "damage"          The Initial Damage done to the affected units
 //                                 
 // real     "dmgps"           The damage per period of time
 // real     "dmgdur"          The damage per period of time duration
 // real     "dmgpsperiod"     The period of time                              
 //

 //===================================================================================================
 // Cone Template Defaults:
 //
    call SetTemplateDefaultInt("ConeSpellTemplate" , "options" , CreateDamageOptions(DamageOnlyEnemies())) //Only hit enemies by default
    call SetTemplateDefaultInt("ConeSpellTemplate" , "maxtargets" , 1000) //Default Maximum targets is 1000
    call SetTemplateDefaultReal("ConeSpellTemplate" , "initialarea" , 100) //Default initial area is 100
    call SetTemplateDefaultReal("ConeSpellTemplate" , "distance" , 800) //Default Distance is 800
    call SetTemplateDefaultReal("ConeSpellTemplate" , "finalarea" , 300) //Default final area is 300
 //===================================================================================================
 // Forked Chain Lightning ('A0CF')
 //
 set s = SetSpellTemplate('A0CF' , "ConeSpellTemplate") //The ability Rawcode
 set D = 0 //Frost Breath options
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_LIGHTNING) //spell cold (magical) damage
 set D = D + DamageOnlyEnemies() //Don't harm allies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "initialarea" , 0 , 150) //Initial area is 150
    call SetAbilityDataReal(s , "distance" , 0 , 800) //Distance is 800
    call SetAbilityDataReal(s , "finalarea" , 0 , 500) //Final area is 500
    call SetAbilityDataInt(s , "maxtargets" , 1 , 3) //Maximum number of targets is 3
    call SetAbilityDataInt(s , "maxtargets" , 2 , 5) //Maximum number of targets is 5
    call SetAbilityDataInt(s , "maxtargets" , 3 , 7) //Maximum number of targets is 7
    call SetAbilityDataInt(s , "spell" , 0 , 'A0CG') //Spell to cast is "Chain Lightning (forked chain lightning)" (A01V)
    call SetAbilityDataInt(s , "castfromcaster" , 0 , 1) //Casters cast the spell from the position of the caster
    call SetAbilityDataReal(s , "recycledelay" , 0 , 4.0) //The spell has a 4 seconds delay before recycling casters
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("chainlightning")) //The orderstring of that spell is chainlightning

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A01T') //Frost Breath Freezing
    call PreloadAbility('A01R') //Frost guard bolt freezing

endfunction

function InitRetTrig_Cone_Template takes nothing returns nothing
    call ExecuteFunc("SetupConeSpellTemplate")
endfunction//===========================================================================
// Trigger: SpellCast Template
//===========================================================================
//***************************************************************************************************
//*
//*  SpellCast Template
//*  
//*  Requires:
//*      - A triggerer ability
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Area Effect Art is used at the target point each spellcast wave
//*      - The Triggerer Ability's Missile is used as missile when "UseMissile" is 1
//*      - The Triggerer Ability's Target Art is used on the target units
//*
//***************************************************************************************************

//===================================================================================================
// SpellCast Template Setup
// 
function SpellCastTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "SpellCastTemplate"
 //
 // This spell was going to be called UniversalTemplate, This template just extracts all the juice
 // from the caster system, make whatever you need, Channeling Spells, Channeling Spells like 
 // flamestrike, Use missiles, make it do the job as much times as you want, for the effect it can
 // cast up to N spells and do damage and damage per second.
 // 
 //
 // integer "Times"              Is the number of times that the casting / damage wave will happen on the
 //                              target point. Use 0 if you want them to be infinite (so it stops only when
 //                              the spell is channeling and the unit stops casting)
 //
 // real    "Timer"              The period of time between each new casting / damage wave.
 //
 // integer "instantStart"       Is 1 when you want it to instantly start the spells, instead of waiting
 //                              for the timer to expire, this is ignore when "ChannelType" is 2
 //
 // integer "ChannelType"        Is 0 if you want the spell to be instant and ignore any channeling stuff.
 //                              Is 1 if you want the hero to be channeling the spell else the template stops
 //                              Is 2 if you want a spell like flamestrike that has to be succesfully channeled
 //                              before starting.
 //
 // integer "maxtargets"         Is the maximum number of targets affected by damage and targeteable spells
 // real    "area"               Is the area of effect for damage and targeteable spells.
 //
 // integer "DamageOptions"      Caster System Damage Options in saveable form, used to determine which units
 //                              can be affected by damage and targeteable spells, if the damage factor is 0
 //                              The unit is not affected by the target spells nor damage, otherwise the value is
 //                              only important for damage.
 //
 // integer "spellN"             is the number of spells to cast
 // integer "spell1type"         Is the type of the spell to cast #1
 //                              (1 if it is a point spell to cast at the target point,
 //                              0 if it is a unit targeteable spell)
 // integer "spell1id"           Is the rawcode of the spell to cast #1
 // integer "spell1OrderId"      Is the orderid of the spell to cast #1
 // integer "spell1RecDelay"     Is the recycle delay for the caster that casts spell #1 (0 if it is instant)
 // integer "spell1FromSource"   Is 1 when you want the caster to be located at the source point
 // integer "spell1CasterHeight" Is the height of the caster that casts spell #1
 //
 // (The same options work for every spell to cast, just change the number, so when spellN is 2 you can also
 // use spell2id , spell2OrderId , spell2RecDelay, spell2FromSource, spell2CasterHeight.
 //
 // real    "dmg"                Is the damage done to units  (0 if you don't want any, negative for healing)
 // real    "dmgps"              Is the periodic damage done to units  (0 if you don't want any, negative for healing)
 // real    "dmgpsPeriod"        Is the period of time for the periodic damage
 // real    "dmgpsDur"           Is the duration for the periodic damage.
 //
 // integer "SourceIsUnit"       Is 1 when you want the source point to be the position of the unit, otherwise
 //                              it is the target point (The source point is considered when SpellXFromSource is 1
 //
 // integer "UseMissile"         Is 1 when you want to use a missile (spell must be targeteable for this option)
 //                              Wil automatically set "SourceIsUnit" to 1
 // real    "MissileArc"         Is the arc of the missile when "UseMissile" is 1
 // real    "MissileSpeed"       Is the speed of the missile when "UseMissile" is 1
 // real    "MissileScale"       Is the scale of the missile
 // integer "MissileColor"       Contains the Color of the missile in 0xAARRGGBB form
 //                              ( RR is red, GG is green, BB is blue, and AA is alpha
 //                              (all in hex representation from 00 to FF)

 //===================================================================================================
 // SpellCast template Defaults:
 //
    call SetTemplateDefaultInt("SpellCastTemplate" , "Times" , 1) //Default number of times=1
    call SetTemplateDefaultReal("SpellCastTemplate" , "Timer" , 1) //Default timer is 1
    call SetTemplateDefaultInt("SpellCastTemplate" , "spellN" , 1) //Default number of spells is 1
    call SetTemplateDefaultInt("SpellCastTemplate" , "maxtargets" , 100) //Default max targets is 100
    call SetTemplateDefaultReal("SpellCastTemplate" , "MissileScale" , 1) //Default missile scale is 1
    call SetTemplateDefaultReal("SpellCastTemplate" , "MissileSpeed" , 800) //Default missile speed is 800
    call SetTemplateDefaultReal("SpellCastTemplate" , "MissileLHeight" , 60) //Default missile launch height is 60
    call SetTemplateDefaultReal("SpellCastTemplate" , "MissileIHeight" , 60) //Default missile impact height is 60
    call SetTemplateDefaultReal("SpellCastTemplate" , "MissileArc" , 0.15) //Default missile arc is 0.15
    call SetTemplateDefaultInt("SpellCastTemplate" , "MissileColor" , 0xFFFFFFFF) //Default missile color is 255255255255


 //===================================================================================================
 // FrostShock ('A0FA')
 //
 set s = SetSpellTemplate('A0FA' , "SpellCastTemplate")
 set D = 0 //Winds Aura target Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_COLD) //Cold spell damage
// set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)         //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

//    call SetAbilityDataInt( s,"DamageOptions",0,D)
    call SetAbilityDataInt(s , "ChannelType" , 0 , 0)
    call SetAbilityDataReal(s , "Timer" , 1 , 0)
    call SetAbilityDataReal(s , "area" , 1 , 2000)
    call SetAbilityDataReal(s , "area" , 2 , 2750)
    call SetAbilityDataReal(s , "area" , 3 , 3500)
    call SetAbilityDataInt(s , "spell1type" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0FB')
    call SetAbilityDataInt(s , "spell1OrderId" , 0 , OrderId("thunderbolt"))
    call SetAbilityDataInt(s , "spell1FromSource" , 0 , 1)
    call SetAbilityDataReal(s , "spell1RecDelay" , 0 , 1)
    call SetAbilityDataInt(s , "spell2type" , 0 , 1)
    call SetAbilityDataInt(s , "spell2id" , 0 , 'AHbz')
    call SetAbilityDataInt(s , "spell2OrderId" , 0 , OrderId("blizzard"))
    call SetAbilityDataReal(s , "spell2RecDelay" , 0 , 20)
    call SetAbilityDataInt(s , "spellN" , 0 , 2)
    call SetAbilityDataInt(s , "SourceIsUnit" , 0 , 1)
    call SetAbilityDataInt(s , "instantStart" , 0 , 1)
    call SetAbilityDataInt(s , "maxtargets" , 0 , 5) //Max Targets cap is 5 for all levels
 //===================================================================================================
 // STORM EARTH AND FIRE ('A0FA')
 //
 set s = SetSpellTemplate('A0FK' , "SpellCastTemplate")
 set D = 0 //Winds Aura target Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_COLD) //Cold spell damage
// set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)         //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

//    call SetAbilityDataInt( s,"DamageOptions",0,D)
    call SetAbilityDataInt(s , "ChannelType" , 0 , 1)
    call SetAbilityDataReal(s , "Timer" , 0 , 5)
    call SetAbilityDataInt(s , "Times" , 0 , 8)
//    call SetAbilityDataReal(s,"area", 1, 200 )
//    call SetAbilityDataReal(s,"area", 2, 275 )
//    call SetAbilityDataReal(s,"area", 3, 350 )
    call SetAbilityDataInt(s , "spell1type" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0FM')
    call SetAbilityDataInt(s , "spell1OrderId" , 0 , OrderId("clusterrockets"))
    call SetAbilityDataInt(s , "spell1FromSource" , 0 , 1)
    call SetAbilityDataReal(s , "spell1RecDelay" , 0 , 3)
    call SetAbilityDataInt(s , "spell2type" , 0 , 1)
    call SetAbilityDataInt(s , "spell2id" , 0 , 'A0FL')
    call SetAbilityDataInt(s , "spell2OrderId" , 0 , OrderId("stomp"))
    call SetAbilityDataReal(s , "spell2RecDelay" , 0 , 0)
    call SetAbilityDataInt(s , "spell3type" , 0 , 1)
    call SetAbilityDataInt(s , "spell3id" , 0 , 'A0FM')
    call SetAbilityDataInt(s , "spell3OrderId" , 0 , OrderId("clusterrockets"))
    call SetAbilityDataInt(s , "spell3FromSource" , 0 , 1)
    call SetAbilityDataReal(s , "spell3RecDelay" , 0 , 2)
    call SetAbilityDataInt(s , "spellN" , 0 , 3)
    call SetAbilityDataInt(s , "SourceIsUnit" , 0 , 1)
    call SetAbilityDataInt(s , "instantStart" , 0 , 1)
//    call SetAbilityDataInt( s,"maxtargets",0,5)   //Max Targets cap is 5 for all levels

 //===================================================================================================
 // Soul Imprisonment ('A0GZ')
 //
 set s = SetSpellTemplate('A0GZ' , "SpellCastTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D)
    call SetAbilityDataInt(s , "ChannelType" , 0 , 0)
    call SetAbilityDataInt(s , "Times" , 0 , 1)
    call SetAbilityDataReal(s , "area" , 1 , 200)
    call SetAbilityDataReal(s , "area" , 2 , 275)
    call SetAbilityDataReal(s , "area" , 3 , 350)
    call SetAbilityDataInt(s , "spell1type" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0HD')
    call SetAbilityDataInt(s , "spell1OrderId" , 0 , OrderId("hex"))
    call SetAbilityDataInt(s , "spell1FromSource" , 0 , 0)
    call SetAbilityDataReal(s , "spell1RecDelay" , 0 , 3)
    call SetAbilityDataInt(s , "spellN" , 0 , 1)
    call SetAbilityDataInt(s , "instantStart" , 0 , 1)
//    call SetAbilityDataInt( s,"maxtargets",0,5)   //Max Targets cap is 5 for all levels

 //===================================================================================================
 // DemonicPossession ('A0HH')
 //
 //set s=SetSpellTemplate('A0HH',"SpellCastTemplate")
 //set D=0                                         //Winds Aura target Options :
// set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)         //Ignores structures
// set D=CreateDamageOptions(D)                      //Save the damage options
//
//    call SetAbilityDataInt( s,"DamageOptions",0,D)
//    call SetAbilityDataInt( s,"ChannelType",0,0)
//    call SetAbilityDataInt(s,"Times", 0, 1 )
//    call SetAbilityDataReal(s,"area", 1, 1 )
//    call SetAbilityDataReal(s,"area", 2, 1 )
//    call SetAbilityDataReal(s,"area", 3, 1 )
//    call SetAbilityDataInt( s,"spell1type",0, 0)
//    call SetAbilityDataInt( s,"spell1id",0, 'A0HI')
//    call SetAbilityDataInt( s,"spell1OrderId",0, OrderId("parasite"))
//    call SetAbilityDataInt( s,"spell1FromSource",0,1)
//    call SetAbilityDataReal( s,"spell1RecDelay",0,3)
//    call SetAbilityDataInt( s,"spell2type",0, 0)
//    call SetAbilityDataInt( s,"spell2id",0, 'A0HJ')
//    call SetAbilityDataInt( s,"spell2OrderId",0, OrderId("unholyfrenzy"))
//    call SetAbilityDataInt( s,"spell2FromSource",0,0)
//    call SetAbilityDataReal( s,"spell2RecDelay",0,3)
//    call SetAbilityDataInt( s,"spellN", 0, 2)
//    call SetAbilityDataInt( s,"instantStart", 0, 1)
//    call SetAbilityDataInt( s,"maxtargets",0,5)   //Max Targets cap is 5 for all levels


 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A01Y') //Blizzard Cripple
    call PreloadAbility('A01Z') //Blizzard Freeze
    call PreloadAbility('A021') //Fireball flames
    call PreloadAbility('ANcs') //cluster rockets
endfunction

function InitRetTrig_SpellCast_Template takes nothing returns nothing
    call ExecuteFunc("SpellCastTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Wave Template
//===========================================================================
//***************************************************************************************************
//*
//* Wave Template
//* 
//* Requires:
//*          -A triggerer ability ( Point targetable please)
//*          -The Alternative Spell Templates System
//*          -This Trigger
//*
//* Art: The Triggerer ability has art fields that are considered:
//* - Area Effect art is the wave effect
//* - Target art is the target effect, or the periodic damage effect if used, and the
//*   second target effect is its attachment point.
//*
//***************************************************************************************************

//===================================================================================================
// Wave Template Setup
// 
function WaveTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "WaveTemplate"
 //
 // A template that allows spells similar to shockwave, but with nice looking variations and just
 // effects that appear in a line instead of a missile, allows casting of spells, damage and
 // damage per second.
 //
 //
 // integer "SpellKind"      The kind of the spell to cast, 0 if it is point targeteable, and 1
 //                          if it is unit targeteable
 // integer "Spell"          The Spell To Cast, use 0 (So don't change this field at all) if you
 //                          don't want it to cast any spell.
 // real    "RecDelay"       The recycle delay of the caster that casts the spell to cast
 // integer "OrderId"        The order Id of the spell to cast
 // real    "SpellHeight"    Probably for eye candy reasons you might want to set the flying height
 //                          of the caster that casts the spell to cast.
 // integer "FromWaveCenter" For the same eyecandy reasons you might want the caster to be located
 //                          at the wave's center instead of the positions of units, use 1 here
 //                          in that case (only considered when SpellKind is 1)
 //
 // integer "WaveN"          The number of waves per cast
 // real    "dmg"            The Damage done to targets
 // real    "PDmg"           The Periodic Damage done to targets
 // real    "PDmgPeriod"     The Period for the Periodic Damage
 // real    "PDmgDur"        The duration for the Periodic Damage
 // integer "WaveMaxTargets" The Maximum number of targets for each wave
 // real    "WaveArea"       The area for each wave
 // real    "Variation"      The maximum distance variation for each wave
 // real    "AdvanceDist"    The Distance advanced per each wave
 //
 // integer "AvoidHitTwice"  Is 1 if you don't want a wave to affect a target more than once
 //
 // integer "DamageOptions"      Caster System Damage Options in saveable form, used to determine which units
 //                              can be affected by damage and targeteable spells, if the damage factor is 0
 //                              The unit is not affected by the target spells nor damage, otherwise the value is
 //                              only important for damage.

 //===================================================================================================
 // Wave template Defaults:
 //
    call SetTemplateDefaultInt("WaveTemplate" , "WaveN" , 3) //Default number of waves=3
    call SetTemplateDefaultReal("WaveTemplate" , "AdvanceDist" , 100) //Default advance dist is 100
    call SetTemplateDefaultReal("WaveTemplate" , "Variation" , 50) //Default variation is 50
    call SetTemplateDefaultInt("WaveTemplate" , "WaveMaxTargets" , 100) //Default max targets is 100

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A048')

endfunction

//===================================================================================================
function InitRetTrig_Wave_Template takes nothing returns nothing
    call ExecuteFunc("WaveTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Knockback Wave Template
//===========================================================================
//***************************************************************************************************
//*
//* Wave Template
//* 
//* Requires:
//*          -A triggerer ability ( Point targetable please)
//*          -The Alternative Spell Templates System
//*          -This Trigger
//*
//* Art: The Triggerer ability has art fields that are considered:
//* - Area Effect art is the wave effect
//* - Target art is the target effect, or the periodic damage effect if used, and the
//*   second target effect is its attachment point.
//*
//***************************************************************************************************

//===================================================================================================
// Wave Template Setup
// 
function WaveKBTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "WaveKBTemplate"
 //
 // A template that allows spells similar to shockwave, but with nice looking variations and just
 // effects that appear in a line instead of a missile, allows casting of spells, damage and
 // damage per second.
 //
 //
 // integer "SpellKind"      The kind of the spell to cast, 0 if it is point targeteable, and 1
 //                          if it is unit targeteable
 // integer "Spell"          The Spell To Cast, use 0 (So don't change this field at all) if you
 //                          don't want it to cast any spell.
 // real    "RecDelay"       The recycle delay of the caster that casts the spell to cast
 // integer "OrderId"        The order Id of the spell to cast
 // real    "SpellHeight"    Probably for eye candy reasons you might want to set the flying height
 //                          of the caster that casts the spell to cast.
 // integer "FromWaveCenter" For the same eyecandy reasons you might want the caster to be located
 //                          at the wave's center instead of the positions of units, use 1 here
 //                          in that case (only considered when SpellKind is 1)
 //
 // integer "WaveN"          The number of waves per cast
 // real    "dmg"            The Damage done to targets
 // real    "PDmg"           The Periodic Damage done to targets
 // real    "PDmgPeriod"     The Period for the Periodic Damage
 // real    "PDmgDur"        The duration for the Periodic Damage
 // integer "WaveMaxTargets" The Maximum number of targets for each wave
 // real    "WaveArea"       The area for each wave
 // real    "Variation"      The maximum distance variation for each wave
 // real    "AdvanceDist"    The Distance advanced per each wave
 //
 // integer "AvoidHitTwice"  Is 1 if you don't want a wave to affect a target more than once
 //
 // integer "DamageOptions"      Caster System Damage Options in saveable form, used to determine which units
 //                              can be affected by damage and targeteable spells, if the damage factor is 0
 //                              The unit is not affected by the target spells nor damage, otherwise the value is
 //                              only important for damage.

 //===================================================================================================
 // Wave template Defaults:
 //
    call SetTemplateDefaultInt("WaveKBTemplate" , "WaveN" , 3) //Default number of waves=3
    call SetTemplateDefaultReal("WaveKBTemplate" , "AdvanceDist" , 100) //Default advance dist is 100
    call SetTemplateDefaultReal("WaveKBTemplate" , "Variation" , 50) //Default variation is 50
    call SetTemplateDefaultInt("WaveKBTemplate" , "WaveMaxTargets" , 100) //Default max targets is 100
 //==================================
 //Crushing Wave ('A0AN')
 set s = SetSpellTemplate('A0AN' , "WaveKBTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_COLD) //Spell poison damage
 set D = D + DamageOnlyEnemies()
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "WaveArea" , 0 , 100) //Area Is 200 for all levels
    call SetAbilityDataReal(s , "AdvanceDist" , 0 , 75) //AdvanceDist is 50
    call SetAbilityDataReal(s , "dmg" , 0 , 125) //10 seconds of recycle delay ensure chain lightning to be cast

    call SetAbilityDataInt(s , "WaveN" , 0 , 12) //Level 1: 6 waves
    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before

    call SetAbilityDataInt(s , "AvoidHitTwice" , 0 , 1) //Won't hit the same unit twice with direct chain ligthing
                                                   //Although the bounces of other chain lightnings might hit it still
 //==================================
 //Forcewave ('A0EW')
 set s = SetSpellTemplate('A0EW' , "WaveKBTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //Spell poison damage
 set D = D + DamageOnlyEnemies()
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "WaveArea" , 0 , 200) //Area Is 200 for all levels
    call SetAbilityDataReal(s , "AdvanceDist" , 0 , 75) //AdvanceDist is 50
    call SetAbilityDataReal(s , "dmg" , 1 , 75) //10 seconds of recycle delay ensure chain lightning to be cast
    call SetAbilityDataReal(s , "dmg" , 2 , 130) //10 seconds of recycle delay ensure chain lightning to be cast
    call SetAbilityDataReal(s , "dmg" , 3 , 200) //10 seconds of recycle delay ensure chain lightning to be cast

    call SetAbilityDataInt(s , "WaveN" , 0 , 12) //Level 1: 6 waves
    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before

    call SetAbilityDataInt(s , "AvoidHitTwice" , 0 , 1) //Won't hit the same unit twice with direct chain ligthing
   

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A048')

endfunction

//===================================================================================================
function InitRetTrig_Knockback_Wave_Template takes nothing returns nothing
    call ExecuteFunc("WaveKBTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Toggleable Template
//===========================================================================
//***************************************************************************************************
//*
//* Toggleable Template
//* 
//* Requires:
//*
//* - A triggerer Ability (Any non targetable spell that gives a buff to the casting unit)
//* - The Alternative Spell Templates System
//* - A Buff used by that Ability
//* - This Trigger 
//*
//* Art:
//* - The Ability's Caster Art randomly appears at the position of the caster during the spell.
//* - The Ability's Special Art appears at the position of the caster at the end of the spell.
//* - Other stuff can be changed through the buff.
//*
//***************************************************************************************************
   
//===================================================================================================
// Toggleable Template Setup
// 
function ToggleableTemplateSetup takes nothing returns nothing
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ToggleableTemplate"
 //
 // A template that allows to use Immolation like spells to add N passive abilities.
 //
 // integer "BuffId"  Rawcode of a buff, Specifically the Buff used by the spell, required
 // integer "AbilN"   The number of Abilities added
 //
 // integer "Abil1"   Rawcode of the Added Ability #1
 //                   The template will try to make its level match the level of the triggerer
 //                   spell, but if Abil1 doesn't have enough levels its level will be raised to
 //                   its maximum level, which can be 1
 // integer "SPB1"    Rawcode of the Ability's SpellBook #1 
 //                   * You DON't have to use spellbooks, if you use 0 for this field (or don't
 //                     set this field at all), it will not use spellbooks
 //                   * To use this option, the spellbook must have the ability included
 //                   * The spellbook is added and Disabled for the player
 //                   * This allows things like adding the ability to other spellbook (The
 //                     other spellbook must have the same orderid as this.
 //                   * If the spellbook has a Base Order Id that is not used, this will help
 //                   * you to hide the ability
 //                   * The spellbook might add more than one ability, but only the ability
 //                     indicated by Abil1 will get leveled up
 //
 // integer "Abil2"   These work the same as Abil1 and SPB1 but
 // integer "SPB2"    they are for ability 2 (if AbilN >= 2)
 //
 // (Just change the number for every number of ability, depending on AbilN )
 //
 // integer "CasterEffectPeriods" This is just an eye candy helper, high values mean longer
 //                               periods without spawning the caster effect, 0 will make
 //                               spawn as periodically as possible

 //===================================================================================================
 // Toggleable template Defaults:
 //
    call SetTemplateDefaultInt("ToggleableTemplate" , "AbilN" , 1) //Default number of abilities is 1
    call SetTemplateDefaultInt("ToggleableTemplate" , "CasterEffectPeriods" , 10) //Default number of effect periods is 1
 //=================================
 //Frosttrail (A08T which adds A08Q with spellbook A08U)

 //set s = SetSpellTemplate('A08T' , "ToggleableTemplate")

 //   call SetAbilityDataInt(s , "BuffId" , 0 , 'B00N') //The buff of the spell is B00N
 //   call SetAbilityDataInt(s , "AbilN" , 0 , 1) //It Adds 1 ability in total
//    call SetAbilityDataInt(s , "Abil1" , 0 , 'A08Q') //Frosttrail factory
//    call SetAbilityDataInt(s , "SPB1" , 0 , 'A08U') //Frosttrail adder

    //Ghost Visible and Permanent invisibility are the perfect combination to create cloaking)
 //=================================
 //Envenomed Hydro Shield

 set s = SetSpellTemplate('A0C4' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B014') //The buff of the spell is B014
    call SetAbilityDataInt(s , "AbilN" , 0 , 1) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'A0C5') //ability
    call SetAbilityDataInt(s , "SPB1" , 0 , 'A0C6') //spellbook

    //Ghost Visible and Permanent invisibility are the perfect combination to create cloaking)

 //=================================
 //Undying Rage

 set s = SetSpellTemplate('A0ES' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B01V') //The buff of the spell is B01L
    call SetAbilityDataInt(s , "AbilN" , 0 , 1) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'A0EP') //ability
    call SetAbilityDataInt(s , "SPB1" , 0 , 'A0F3') //spellbook

    //Ghost Visible and Permanent invisibility are the perfect combination to create cloaking)

 //=================================
 //Seer's Vision

 set s = SetSpellTemplate('A0E5' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B01L') //The buff of the spell is B01L
    call SetAbilityDataInt(s , "AbilN" , 0 , 1) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'A0E7') //ability
    call SetAbilityDataInt(s , "SPB1" , 0 , 'A0E9') //spellbook



 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('Apiv')
    call PreloadAbility('Agho')


endfunction


//===================================================================================================
function InitRetTrig_Toggleable_Template takes nothing returns nothing
    call ExecuteFunc("ToggleableTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================

//***************************************************************************************************
//*
//* Toggleable Template
//* 
//* Requires:
//*
//* - A triggerer Ability (Any non targetable spell that gives a buff to the casting unit)
//* - The Alternative Spell Templates System
//* - A Buff used by that Ability
//* - This Trigger 
//*
//* Art:
//* - The Ability's Caster Art randomly appears at the position of the caster during the spell.
//* - The Ability's Special Art appears at the position of the caster at the end of the spell.
//* - Other stuff can be changed through the buff.
//*
//***************************************************************************************************
   
//===================================================================================================
// Toggleable Template Setup
// 
function ToggleableTemplateXSetup takes nothing returns nothing
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ToggleableUSTemplate"
 //
 // A template that allows to use Immolation like spells to add N passive abilities.
 //
 // integer "BuffId"  Rawcode of a buff, Specifically the Buff used by the spell, required
 // integer "AbilN"   The number of Abilities added
 //
 // integer "Abil1"   Rawcode of the Added Ability #1
 //                   The template will try to make its level match the level of the triggerer
 //                   spell, but if Abil1 doesn't have enough levels its level will be raised to
 //                   its maximum level, which can be 1
 // integer "SPB1"    Rawcode of the Ability's SpellBook #1 
 //                   * You DON't have to use spellbooks, if you use 0 for this field (or don't
 //                     set this field at all), it will not use spellbooks
 //                   * To use this option, the spellbook must have the ability included
 //                   * The spellbook is added and Disabled for the player
 //                   * This allows things like adding the ability to other spellbook (The
 //                     other spellbook must have the same orderid as this.
 //                   * If the spellbook has a Base Order Id that is not used, this will help
 //                   * you to hide the ability
 //                   * The spellbook might add more than one ability, but only the ability
 //                     indicated by Abil1 will get leveled up
 //
 // integer "Abil2"   These work the same as Abil1 and SPB1 but
 // integer "SPB2"    they are for ability 2 (if AbilN >= 2)
 //
 // (Just change the number for every number of ability, depending on AbilN )
 //
 // integer "CasterEffectPeriods" This is just an eye candy helper, high values mean longer
 //                               periods without spawning the caster effect, 0 will make
 //                               spawn as periodically as possible

 //===================================================================================================
 // Toggleable template Defaults:
 //
    call SetTemplateDefaultInt("ToggleableUSTemplate" , "AbilN" , 1) //Default number of abilities is 1
    call SetTemplateDefaultInt("ToggleableUSTemplate" , "CasterEffectPeriods" , 2) //Default number of effect periods is 1
 //=================================
 //Frosttrail (A08T which adds A08Q with spellbook A08U)

 set s = SetSpellTemplate('A08T' , "ToggleableUSTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B00N') //The buff of the spell is B00N
    call SetAbilityDataInt(s , "AbilN" , 0 , 1) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'A09E') //Frosttrail factory
    call SetAbilityDataInt(s , "SPB1" , 0 , 'A08U') //Frosttrail adder
    call SetAbilityDataInt(s , "UnitId" , 0 , 'u01A') //Ice unit
    call SetAbilityDataInt(s , "UAbilN" , 0 , 2) //It uses 2 abilities in total for the spawned unit
    call SetAbilityDataInt(s , "UAbil1" , 0 , 'A0D3') //Aura of Slow for the spawned units
    call SetAbilityDataInt(s , "UAbil2" , 1 , 'A0UO') //Aura of Death for the spawned units lvl 1 (you cant set abl lvl of permanent immolation)
    call SetAbilityDataInt(s , "UAbil2" , 2 , 'A0UP') //Aura of Death for the spawned units lvl 2
    call SetAbilityDataInt(s , "UAbil2" , 3 , 'A0UQ') //Aura of Death for the spawned units lvl 3


 //=================================
 //AEther Flame Trail (A0GK which adds A0GL to its fires)  **u01J is the unittype**

 set s = SetSpellTemplate('A0GK' , "ToggleableUSTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B02E') //The buff of the spell is B00N
    call SetAbilityDataInt(s , "UnitId" , 0 , 'u01J') //Ice unit
    call SetAbilityDataInt(s , "UAbilN" , 0 , 1) //It uses 1 ability in total for the spawned unit
    call SetAbilityDataInt(s , "UAbil1" , 1 , 'A0GL') //Aura of Death for the spawned units lvl 1 (you cant set abl lvl of permanent immolation)
    call SetAbilityDataInt(s , "UAbil1" , 2 , 'A0GM') //Aura of Death for the spawned units lvl 2
    call SetAbilityDataInt(s , "UAbil1" , 3 , 'A0GN') //Aura of Death for the spawned units lvl 3


    //Ghost Visible and Permanent invisibility are the perfect combination to create cloaking)
 //=================================
 //Envenomed Hydro Shield

 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('Apiv')
    call PreloadAbility('Agho')


endfunction


//===================================================================================================
function InitRetTrig_Toggleable_Unitspawn_Template takes nothing returns nothing
    call ExecuteFunc("ToggleableTemplateXSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction

// Trigger: Slash Template
//===========================================================================
//***************************************************************************************************
//*
//* Slash Template
//* 
//* Requires:
//*          -A triggerer ability ( Unit targetable please)
//*          -The Caster System
//*          -The Alternative Spell Templates System
//*          -This Trigger
//*
//* Art: The Triggerer ability has art fields that are considered:
//* - Caster effect is attached twice to the hero during the slash.
//* - Second and Third Caster Effects are attachment points for the Caster Effect
//* - Special effect is used on the feet of the hero before teleporting to slash
//* - Target art is the target effect, or the periodic damage effect if used, and the
//*   second target effect is its attachment point.
//*
//***************************************************************************************************

//===================================================================================================
// Slash Template Configuration:
//
function SlashTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "SlashTemplate"
 //
 // The hero just gets teleported and attacks the targets fast, it looks nice and allows to cast
 // a spell, do damage, damage per second, and also has options for the way to choose targets and
 // factor for each target and that stuff.
 //
 //
 // integer "totalhits"  The maximum number of hits done per cast
 // real    "dmg"        The initial damage
 // real    "PDmg"       The initial Periodic Damage
 // real    "PDmgPeriod" The period of the Periodic Damage
 // real    "PDmgDur"    The Duration of the periodic Damage
 //
 // real    "dmgfct"     The factor per target for the damage, each time the unit hits a target,
 //                      the damage will be multiplied by this value to get reduced or incremented
 //
 // integer "Spell"      Rawcode of the Spell to cast (if any)
 // real    "SpellHeight" Height of the caster that casts the spell to cast
 // integer "OrderId"    Order Id of that spell
 // real    "RecDelay"   Caster Recycle delay for that spell
 //
 //
 // real    "area"       The new target detection range
 // integer "canrepeat"  Is 1 if the slash can repeat targets, otherwise 0
 //
 // integer "SelMethod"  Is 0 if the slash should pick the closest unit, 1 to pick random units
 // integer "SlashKind"  The kind of the Slash, 0 will try to get to the back of the unit, 1
 //                      will attack in random direction, and 2 is a combination of both
 //
 // integer "AngleKind"  Is 0 for the default angle kind, is 1 to multiple the angle by -1
 //
 // string  "animation"  The animation used by the slash
 //
 // integer "colorize"   If it is 1 enables casting unit "colorizing"
 // integer "SlashColor" Color in 0xAARRGGBB form for the duration of the slash 
 // integer "EndColor"   Color in 0xAARRGGBB form after the slash (original color of the hero)
 // 

 // integer "DamageOptions" Caster System Damage Options in saveable form, used to determine which
 //                         units can be attacked by the slash, if the damage factor is 0 the unit
 //                         is not affected by the target spells nor damage, otherwise the value
 //                         is only important as a damage factor.


 //===================================================================================================
 // Slash template Defaults:
 //
    call SetTemplateDefaultInt("SlashTemplate" , "totalhits" , 1) //Default Total Hits is 1
    call SetTemplateDefaultInt("SlashTemplate" , "canrepeat" , 0) //Can't repeat targets
    call SetTemplateDefaultReal("SlashTemplate" , "area" , 100) //Default area is 100
    call SetTemplateDefaultReal("SlashTemplate" , "dmg" , 150) //Default initial damage is 150
    call SetTemplateDefaultReal("SlashTemplate" , "dmgfct" , 1) //Default damage factor is 1
    call SetTemplateDefaultString("SlashTemplate" , "animation" , "attack slam") //Default animation is attack slam
    call SetTemplateDefaultInt("SlashTemplate" , "SlashColor" , 0xFFFFFFFF) //Default slash color is 255-255-255-255
    call SetTemplateDefaultInt("SlashTemplate" , "EndColor" , 0xFFFFFFFF) //Default end color is 255-255-255-255

 //===================================================================================================
 // Murder Spree ('A06S')
 //
 set s = SetSpellTemplate('A06S' , "SlashTemplate")
 set D = 0 //Options :
 set D = DamageTypes(ATTACK_TYPE_HERO , DAMAGE_TYPE_NORMAL) //Hero damage
 set D = DamageOnlyEnemies() //Only hurt enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "totalhits" , 0 , 7) //7 Hits

    call SetAbilityDataReal(s , "dmg" , 0 , 450) //Level 1: 450 damage


    call SetAbilityDataReal(s , "area" , 0 , 600) //Always 600 of area

    call SetAbilityDataInt(s , "SlashKind" , 0 , 0) //Slash Kind is 0
    call SetAbilityDataInt(s , "canrepeat" , 0 , 1) //It can repeat targets!

    call SetAbilityDataReal(s , "dmgfct" , 0 , 0.90) //Will lose 10% of the damage per target

    call SetAbilityDataString(s , "animation" , 0 , "attack") //Use attack animation

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before


 //===================================================================================================
 // Chaotic Fury ('A0DG')
 //
 set s = SetSpellTemplate('A0DG' , "SlashTemplate")
 set D = 0 //Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Hero damage
 set D = DamageOnlyEnemies() //Only hurt enemies
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "totalhits" , 0 , 5) //7 Hits

    call SetAbilityDataReal(s , "dmg" , 0 , 25) //Level 1: 450 damage

    call SetAbilityDataReal(s , "area" , 0 , 600) //Always 600 of area

    call SetAbilityDataInt(s , "SlashKind" , 0 , 1) //Slash Kind is 0
    call SetAbilityDataInt(s , "canrepeat" , 0 , 0) //It can't repeat targets!


    call SetAbilityDataString(s , "animation" , 0 , "attack") //Use attack animation

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before



 //===================================================================================================
 // Slice N Dice for Hero Illidan ('A0SR')
 //
 set s = SetSpellTemplate('A0SR' , "SlashTemplate")
 set D = 0 //Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Hero damage
 set D = DamageOnlyEnemies() //Only hurt enemies
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "totalhits" , 1 , 10) //7 Hits
    call SetAbilityDataInt(s , "totalhits" , 2 , 13) //7 Hits
    call SetAbilityDataInt(s , "totalhits" , 3 , 16) //7 Hits

    call SetAbilityDataReal(s , "dmg" , 0 , 45) //Level 1: 450 damage
    call SetAbilityDataReal(s , "dmg" , 0 , 55) //Level 1: 450 damage
    call SetAbilityDataReal(s , "dmg" , 0 , 70) //Level 1: 450 damage

    call SetAbilityDataReal(s , "area" , 0 , 600) //Always 600 of area

    call SetAbilityDataInt(s , "SlashKind" , 0 , 0) //Slash Kind is 0
    call SetAbilityDataInt(s , "canrepeat" , 0 , 1) //It can't repeat targets!


    call SetAbilityDataString(s , "animation" , 0 , "attack") //Use attack animation

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before

    
endfunction

function InitRetTrig_Slash_Template takes nothing returns nothing
    call ExecuteFunc("SlashTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Jump Template
//===========================================================================
//*************************************************************************************************
//*
//* Jump Template
//* 
//* Requires:
//*          -A triggerer ability ( Point targetable please, 
//*           was kind of specially designed for blink)
//*          -The Caster System
//*          -The Alternative Spell Templates System
//*          -This Trigger
//*
//* Art:
//* - The Ability's Caster Art is attached to the unit while jumping and uses the second caster
//*   art as attachment point
//* - If "UseOtherModel" is 1 , the Ability's Caster Art becomes the missile effect of the jump
//* - The ability's effect art is played on impace
//* - The ability's target art is used on targets.
//*
//*************************************************************************************************

//===========================================================================
function JumpTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "JumpTemplate"
 //
 // Everything you need for a jump spell is here, it controls the jump effect and the things that
 // happen on the impact.
 //
 //
 // real    "speed"         The jump speed
 // real    "arc"           The jump arc
 // integer "UseOtherModel" If this option is 1, the template will use another model for the jump,
 //                         the behaviour of the jump is different and uses extra options:
 //                         (In this case the Caster Model is the model used)
 // 
 // integer "OModelColor"   The vertex color of the OtherModel (when UseOtherModel is 1) 
 //                         It is in 0xAARRGGBB form
 // real    "OModelScale"   The scale of the Other Model
 // real    "z1"            The Launch height of the Other Model
 // real    "z2"            The Impact height of the Other Model
 //
 // (Last 4 options are only considered when UseOtherModel is 1
 //
 // string  "JumpAnim"      This is considered when UseOtherModel is 0, and is the jump animation
 // string  "EndAnim"       The Animation after the jump
 //
 // * If you use numbers between quotes for the animations, they will play them as indexes
 // Example: "1" will make it play the animation indexed with 1 of the model
 //
 // real    "AnimSpeed"     The animation speed during the jump, "UseOtherModel" ignores this
 //                         (This is a factor)
 //
 // Next options are used on the impact:
 //
 // real    "area"          The Area of effect of the impact
 // integer "MaxTargets"    Maximum number of targets affected by the impact
 //                         (only damage, periodic damage and Target spells consider this)
 // real    "Damage"        The damage done to targets
 //
 // real    "PDmg"          Periodic damage done to targets
 // real    "PDmgPeriod"    The Period of the Periodic Damage
 // real    "PDmgDur"       The duration of the Periodic Damage
 // 
 // integer "Spell"         The Spell to cast
 // integer "SpellKind"     If it is 1, it is a unit targetable spell
 // integer "FromCenter"    If it is 1, the casters will be spawned from the impact point
 //                         this is mostly an eye candy option when the spell to cast is unit
 //                         targetable and has a projectile or lightning effects.
 // integer "OrderId"       The OrderId of the spell to cast
 // real    "RecDelay"      The recycle delay of the spell to cast
 // real    "SpellHeight"   The caster's height when casting the spell to cast
 //
 // integer "DamageOptions"      Caster System Damage Options in saveable form, used to determine which units
 //                              can be affected by damage and targeteable spells, if the damage factor is 0
 //                              The unit is not affected by the target spells nor damage, otherwise the value is
 //                              only important for damage.

 //===================================================================================================
 // Jump template Defaults:
 //
    call SetTemplateDefaultInt("JumpTemplate" , "MaxTargets" , 100) //Default max targets is 100
   
    call SetTemplateDefaultReal("JumpTemplate" , "speed" , 800) //Default speed is 800
    call SetTemplateDefaultReal("JumpTemplate" , "arc" , 0.25) //Default arc os 0.25

    call SetTemplateDefaultInt("JumpTemplate" , "OModelColor" , 0xFFFFFFFF) //Default other model's color is 255-255-255-255
    call SetTemplateDefaultReal("JumpTemplate" , "OModelScale" , 1) //Default other model's scale is 1

    call SetTemplateDefaultReal("JumpTemplate" , "z1" , 60) //Default other model's launch height is 60
    call SetTemplateDefaultReal("JumpTemplate" , "z2" , 60) //Default other model's impact height is 60

    call SetTemplateDefaultString("JumpTemplate" , "JumpAnim" , "attack slam") //Default jump animation is attack slam
    call SetTemplateDefaultString("JumpTemplate" , "EndAnim" , "stand") //Default end animation is stand
    call SetTemplateDefaultReal("JumpTemplate" , "AnimSpeed" , 1) //Default Animation Speed is 1

    call SetTemplateDefaultInt("JumpTemplateNX" , "MaxTargets" , 100) //Default max targets is 100
   
    call SetTemplateDefaultReal("JumpTemplateNX" , "speed" , 800) //Default speed is 800
    call SetTemplateDefaultReal("JumpTemplateNX" , "arc" , 0.25) //Default arc os 0.25

    call SetTemplateDefaultInt("JumpTemplateNX" , "OModelColor" , 0xFFFFFFFF) //Default other model's color is 255-255-255-255
    call SetTemplateDefaultReal("JumpTemplateNX" , "OModelScale" , 1) //Default other model's scale is 1

    call SetTemplateDefaultReal("JumpTemplateNX" , "z1" , 60) //Default other model's launch height is 60
    call SetTemplateDefaultReal("JumpTemplateNX" , "z2" , 60) //Default other model's impact height is 60

    call SetTemplateDefaultString("JumpTemplateNX" , "JumpAnim" , "attack slam") //Default jump animation is attack slam
 //   call SetTemplateDefaultString("JumpTemplateNX","EndAnim" ,"stand")       //Default end animation is stand
    call SetTemplateDefaultReal("JumpTemplateNX" , "AnimSpeed" , 1) //Default Animation Speed is 1

 //===================================================================================================
 // Leap ('A075')
 //
 set s = SetSpellTemplate('A075' , "JumpTemplateNX")
 //(Earth Crush doesn't need damage options)

    call SetAbilityDataInt(s , "UseOtherModel" , 0 , 1) //Use another model

    call SetAbilityDataInt(s , "OModelColor" , 0 , 0xFFB5B5FF) //Use another model
 
    call SetAbilityDataInt(s , "Spell" , 0 , 'A0H3') //Spell to cast is A02E (Earth crush war stomp)
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("thunderclap")) //Its orderid is stomp

    call SetAbilityDataString(s , "JumpAnim" , 0 , "walk") //Play birth animation when jump ends
    call SetAbilityDataString(s , "EndAnim" , 0 , "birth") //Play birth animation when jump ends

    call SetAbilityDataString(s , "OtherModel" , 0 , "Abilities\\Spells\\FreezingLegion\\Leap\\FrostwolfBlueMissile.mdl") //Play birth animation when jump ends
    call SetAbilityDataReal(s , "RecDelay" , 0 , 0.00) //Use another model

 //===================================================================================================
 // Leap ('A0GY') Bear Version
 //
 set s = SetSpellTemplate('A0GY' , "JumpTemplateNX")
 //(Earth Crush doesn't need damage options)

    call SetAbilityDataInt(s , "UseOtherModel" , 0 , 1) //Use another model
    call SetAbilityDataInt(s , "OModelColor" , 0 , 0xFFD5FFFF) //Use another model
 
    call SetAbilityDataInt(s , "Spell" , 0 , 'A076') //Spell to cast is A02E (Earth crush war stomp)
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("stomp")) //Its orderid is stomp

    call SetAbilityDataString(s , "JumpAnim" , 0 , "walk") //Play birth animation when jump ends
    call SetAbilityDataString(s , "EndAnim" , 0 , "birth") //Play birth animation when jump ends
    call SetAbilityDataString(s , "OtherModel" , 0 , "Abilities\\Spells\\FreezingLegion\\Leap\\PolarBearLeapMissile.mdl") //Play birth animation when jump ends
    call SetAbilityDataReal(s , "RecDelay" , 0 , 0.00) //Use another model

 //===================================================================================================
 // Leap Cub ('A09Y')
 //
 set s = SetSpellTemplate('A09Y' , "JumpTemplateNX")
 //(Earth Crush doesn't need damage options)

    call SetAbilityDataInt(s , "UseOtherModel" , 0 , 1) //Use another model
    call SetAbilityDataReal(s , "OModelScale" , 0 , 0.5) //Use another model
    call SetAbilityDataInt(s , "OModelColor" , 0 , 0xFFD5FFFF) //Use another model
 
    call SetAbilityDataInt(s , "Spell" , 0 , 'A0H2') //Spell to cast is A02E (Earth crush war stomp)
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("thunderclap")) //Its orderid is stomp

    call SetAbilityDataString(s , "JumpAnim" , 0 , "walk") //Play birth animation when jump ends
    call SetAbilityDataString(s , "EndAnim" , 0 , "birth") //Play birth animation when jump ends

    call SetAbilityDataString(s , "OtherModel" , 0 , "Abilities\\Spells\\FreezingLegion\\Leap\\PolarBearCubLeapMissileX.mdl") //Play birth animation when jump ends
    call SetAbilityDataReal(s , "RecDelay" , 0 , 0.00) //Use another model


 //===================================================================================================
 // Ability Preloading
 //
 // Next is unrelated to the templates system, just avoids the first time cast lag, here you 
 // should preload any ability used as auxiliar ability for the template, just to avoid first
 // time cast lag.
 //
    call PreloadAbility('A02E')


endfunction



//===========================================================================
function InitRetTrig_Jump_Template takes nothing returns nothing
    call ExecuteFunc("JumpTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: ChannelAura Template
//===========================================================================
//***************************************************************************************************
//*
//*  ChannelAura Template
//*
//*  Requires:
//*      - A triggerer ability (Should be non targetable and channeling)
//*      - The Caster System
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//***************************************************************************************************

//===================================================================================================
// ChannelAura Template Setup:
//
function ChannelAuraTemplateSetup takes nothing returns nothing
 local integer D
 local integer s

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ChannelAuraTemplate"
 //
 // This is the AuraTemplate but channeling instead of passive, it works for making spells like
 // Big Bad Voodoo, and the such.
 //
 //
 // real    "area"     is area of effect of the aura
 //
 // integer "n"        is the total number of passive abilities to add.
 // integer "spell1id" is the 1st ability to add
 // integer "spell2id" is the 2nd ability to add (if n>=2)
 // integer "spell3id" is the 3rd ability to add (if n>=3)
 //
 // (keep increasing the number between spell and id to use more abilities, (till n))
 //
 // integer "spbk1"    is 0, when you don't want to add the first ability using a dummy spell book,
 //                    otherwise it is the rawcode of the Auxiliar Spell Book ability used to add
 //                    the ability, the point of this is usually to hide icons.
 // integer "spbk2"    The same, for ability 2.
 //
 // (keep increasing the number between spell and id to use more abilities, (till n))
 //
 // integer "options"  Caster system damage options in saveable form, determines which unit can
 //                    Be affected by the aura.
 //
 // integer "WeatherEffect" Id of a special weather effect, if you want any, Why a wather effect?
 //                         I don't really know, perhaps it is because I based the idea of this
 //                         template on a spell called SnowStorm
 //
 // Remember than any value is 0 or "" by default unless stated in the Defaults section.
 //
 // The template will try to match each of the spell's level with the current level of the
 // aura, if the spell has less levels than the level of the aura, it will stay at max level
 //

 //===================================================================================================
 // ChannelAura Template Defaults:
 //
    call SetTemplateDefaultInt("ChannelAuraTemplate" , "n" , 1) //Deafult number of abilities to be added is 1
    call SetTemplateDefaultReal("ChannelAuraTemplate" , "area" , 900) //Deafult area is 900

endfunction

function InitRetTrig_ChannelAura_Template takes nothing returns nothing
    call ExecuteFunc("ChannelAuraTemplateSetup")
//Must use ExecuteFunc to prevent the Map init thread from getting too long and crash.
endfunction//===========================================================================
// Trigger: Chain Template
//===========================================================================
//***************************************************************************************************
//*
//*  ChainSpell Template
//*
//*  Requires:
//*      - A triggerer ability (Should be non targetable and channeling)
//*      - The Caster System
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//*  Art:
//*      - The Triggerer Ability's Area Effect Art is the missile art
//*      - The Triggerer Ability's Special Art shall be the target effect for the damage per second
//*      - The Triggerer Ability's 2nd Special Art shall be the attachment point of the last effect.
//*
//***************************************************************************************************

//===================================================================================================
// ChainFire Spell Configuration:
//
function InitRetTrig_Chain_Template takes nothing returns nothing
 local integer s
 local integer D

 //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "ChainSpellTemplate"
 //
 // Abilities that act like chain lightning / healing wave
 //
 //
 // real    "speed"       projectile speed, If it is 0, the movement will be
 //                       instant, some projectile effects look well with this, some don't
 //                       it can be as high as you want
 //
 // real    "area"        Bounce target detection range
 // integer "bounces"     Maximum number of targets
 // integer "isgoodspell" is 1 if the spell affects allies only , and 0 if it affects enemies only
 // integer "spellid"     the spell to cast against targets, will try to level it up to match the level of the ability
 // integer "orderid"     the orderid of that spell
 // real    "delay"       the caster recicle delay
 // integer "option"      Caster System's damage options, they determine what stuff the spell targets, check below for more info.
 // real    "damage"      the initial damage
 // real    "damageps"    the damage per period
 // real    "factor"      the factor for the damage after each new target
 // real    "duration"    the damage per period duration
 // real    "period"      the time for each damage per period to make effect
 // real    "height"      the missile height
 //
 
 
 //===================================================================================================
 // ChannelAura Template Defaults:
 //
    call SetTemplateDefaultReal("ChainSpellTemplate" , "speed" , 522) /// Make default projectile speed 522
    call SetTemplateDefaultReal("ChainSpellTemplate" , "scale" , 1) /// Make default projectile scale 1.0
    call SetTemplateDefaultReal("ChainSpellTemplate" , "height" , 60) /// Make default projectile height 60
    call SetTemplateDefaultReal("ChainSpellTemplate" , "period" , 1) /// Default period is 1 second
    call SetTemplateDefaultReal("ChainSpellTemplate" , "area" , 500) /// Default Area is 500
    call SetTemplateDefaultString("ChainSpellTemplate" , "attach" , "chest") /// Default Attachment point is chest
 //===================================================================================================
 // Chain Freezing ('A02P')
 //
 set s = SetSpellTemplate('A0CJ' , "ChainSpellTemplate")
 set D = 0 //chain freezing target Options :
 set D = D + DamageTypes(ATTACK_TYPE_PIERCE , DAMAGE_TYPE_COLD) //Do pierce cold (magical) damage
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options
 
 
    call SetAbilityDataInt(s , "options" , 0 , D) //// Use the damage option D for damage/target options.
    call SetAbilityDataInt(s , "bounces" , 0 , 5) //// Chain Freezing has 3 targets
    call SetAbilityDataReal(s , "factor" , 0 , 0.75) //// Chain Freezing has a 0.75 damage factor
    call SetAbilityDataReal(s , "speed" , 0 , 0) //// Chain Freezing 's missile allows instant speed
    call SetAbilityDataReal(s , "damage" , 0 , 200) //// Chain Freezing has a 110 initial damage
    call SetAbilityDataInt(s , "spellid" , 0 , PreloadAbility('A0CK')) // Chain Freezing Freeze ability
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("entanglingroots"))

endfunction




//***************************************************************************************************
//*
//*  Field Template
//*
//*  Requires:
//*      - A triggerer ability (Should be passive)
//*      - The Caster System
//*      - The Alternative Spell Templates System
//*      - This Trigger
//*
//***************************************************************************************************

//===================================================================================================
// Field Template Setup:
function KS_Field_Template_Setup takes nothing returns nothing
    local integer D
    local integer s
//===================================================================================================
 // Template Info:
 //
 // Template Name Id = "KS_FieldTemplate"
 //
 // real    "range"        is area of effect of the field
 // integer "dur"          is the duration of the field
 // integer "channeled"    is 1 if the field must be channeled to continue
 // integer "bad"          is 1 if the field affects enemies, 0 if it affects allies, and 2 if it affect regardless
 // integer "notself"      is 1 when the caster shouldn't be affected by the field [0 for false, 1 for true]
 // NOTE: notself and bad are depreciated; use damageoptions instead
 // string  "fieldart"     is the special effect art of the field
 // real    "artsize"      is the size of the special effect art (standard is 1.00)
 // integer "pauseany"     should any units in the field be paused? [0 for false, 1 for true]
 // integer "pauseoptions" use caster damage options to determine what can be paused
 // integer "allN"         is the number of abilities to ADD to all units
 // integer "allabil#"     is the ability(abilities) that is added to all units in the 
 // integer "allspbk#"     is the spellbook ability to add instead of the ability itself(autohides the spellbook; replaces allabil#)
 // integer "alloptions#"  use caster damage options to determine what will be given the ability
 // NOTE: unpaused abilities are not used if pauseany is 0 (false)
 // integer "unpausedN"    is the number of abilities to ADD to unpaused units
 // integer "unpausedabil#"is the ability(abilities) given to heros and buildings if they are not paused
 // integer "unpausedspbk#"is the spellbook ability to add instead of the unpaused ability itself(autohides the spellbook; replaces pausedabil#)
 // integer "unpausedoptions#"use caster damage options to determine what will be given the ability
 // integer "enterN"       is the number of abilities to CAST on entering units
 // integer "enterabil#"   is the ability(abilities) to cast on entering units
 // string "enterorderId#" is the orderId of the enterabil
 // integer "enteroptions#"use caster damage options to determine what will be given the ability
 // integer "areaN"        is the number of abilities to cast in the center 
 // integer "areaabil#"    is the ability(abilities) that is cast at the center of the field  
 // string  "areaorderId#" is the order string of the castAbil
 // integer "preventleave" should units be able to leave the field [0 for false, 1 for true]   
 //
 //
 // Remember than any value is 0 or "" by default unless stated in the Defaults section.
 //
 // The template will try to match each of the spell's level with the current level of the
 // aura, if the spell has less levels than the level of the aura, it will stay at max level
 //
 
 //===================================================================================================
 // KS_Field template Defaults:
 //
    call SetTemplateDefaultReal("KS_FieldTemplate" , "artsize" , 1.00) //Default size of special effect
    call SetTemplateDefaultInt("KS_FieldTemplate" , "bad" , 2) //Default size of special effect
 

endfunction


function RJ_FilterMobileEnemies takes nothing returns boolean
    return ( not ( GetUnitMoveSpeed(GetFilterUnit()) == 0.00 ) ) and not IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE) // CasterAOE_IsFilterEnemy()
endfunction




//===========================================================================
// Trigger: Get
//===========================================================================
function RetTrig_Untitled_Trigger_022Zez_Func003A takes nothing returns nothing
//    call UnitShareVisionBJ( true, rdg_Obelisk, GetEnumPlayer() )
    call CreateFogModifierRadiusLocBJ(true , GetEnumPlayer() , FOG_OF_WAR_FOGGED , GetUnitLoc(rdg_Obelisk) , 512)
endfunction

function RetTrig_GetCustom1 takes nothing returns boolean
    return ( GetFilterPlayer() != rdg_MoonSummoner )
endfunction

function RetTrig_GetCustom2 takes nothing returns nothing
    call SetPlayerAbilityAvailableBJ(false , 'A09B' , GetEnumPlayer())
    call SetPlayerAbilityAvailableBJ(true , 'A09C' , GetEnumPlayer())
endfunction

function GetIsObeliskProperTarget takes nothing returns boolean
    if ( not ( IsUnitDeadBJ(rdg_Obelisk) != true ) ) then
        return false
    endif
    if ( not ( GetSpellTargetUnit() == rdg_Obelisk ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Get_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A09B' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'fbmo' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Get_Actions takes nothing returns nothing
//    if (GetAttachedBoolean(GetOwningPlayer(GetSpellAbilityUnit()),"ObeliskInUse")==)
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetSpellTargetUnit() ))) , ( "MoonCasters"))) < 3 ) then // INLINED!!
    call AttachInt(GetSpellAbilityUnit() , "IsCasting" , 1)
    call AttachInt(GetSpellTargetUnit() , "MoonCasters" , (GetStoredInteger(cs_cache , I2S(GetHandleId((GetSpellTargetUnit() ))) , ( "MoonCasters"))) + 1) // INLINED!!
//    call AttachObject(GetSpellTargetUnit(),"ObeliskTarget",GetSpellAbilityUnit())
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetSpellTargetUnit() ))) , ( "MoonCasters"))) == 1 ) and ( rdg_Obelisk == null ) then // INLINED!!
    set rdg_MoonSummoner = GetOwningPlayer(GetSpellTargetUnit())
    set rdg_Obelisk = GetSpellTargetUnit()
    call DisplayTextToForce(GetPlayersAll() , GetPlayerName(rdg_MoonSummoner) + " has begun summoning the Blue Moon! Kill the summoners or the Blue Moon Obelisk before it's too late!")
    call PingMinimapLocForForceEx(GetPlayersAll() , GetUnitLoc(rdg_Obelisk) , 3.00 , bj_MINIMAPPINGSTYLE_ATTACK , 100 , 100 , 100)
    call ForForce(GetPlayersEnemies(rdg_MoonSummoner) , function RetTrig_Untitled_Trigger_022Zez_Func003A)
    call ForForce(GetPlayersMatching(Condition(function RetTrig_GetCustom1)) , function RetTrig_GetCustom2)
    call StartTimerBJ(rdg_BlueMoonT , false , 480.00)
    call CreateTimerDialogBJ(rdg_BlueMoonT , "Blue Moon Rises")
    set rdg_BlueMoon = GetLastCreatedTimerDialogBJ()
    call QueueUnitAnimationBJ(rdg_Obelisk , "stand work")
    call TimerDialogDisplayBJ(true , rdg_BlueMoon)
    else

    if GetSpellTargetUnit() == rdg_Obelisk then
    call StartTimerBJ(rdg_BlueMoonT , false , ( TimerGetRemaining(rdg_BlueMoonT) / 2.00 ))
    endif


    endif
    else
    endif

endfunction

//===========================================================================
function InitRetTrig_Get takes nothing returns nothing
    set rj_trg_Get = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Get , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(rj_trg_Get , Condition(function RetTrig_Get_Conditions))
    call TriggerAddAction(rj_trg_Get , function RetTrig_Get_Actions)
endfunction

//===========================================================================
// Trigger: CasterDeath
//===========================================================================
function RetTrig_Untitled_Trigger_022Zez_Func006A takes nothing returns nothing
    call UnitShareVisionBJ(false , rdg_Obelisk , GetEnumPlayer())
endfunction

function RetTrig_ZCustom1 takes nothing returns boolean
    return ( GetFilterPlayer() != rdg_MoonSummoner )
endfunction

function RetTrig_ZCustom2 takes nothing returns nothing
    call SetPlayerAbilityAvailableBJ(true , 'A09B' , GetEnumPlayer())
    call SetPlayerAbilityAvailableBJ(false , 'A09C' , GetEnumPlayer())
endfunction

function RetTrig_Untitled_Trigger_010_Conditionsz takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A09B' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_010_Actionsz takes nothing returns nothing
    local unit o=rdg_Obelisk
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((GetSpellAbilityUnit() ))) , ( "IsCasting"))) == 1 ) then // INLINED!!
    call AttachInt(o , "MoonCasters" , (GetStoredInteger(cs_cache , I2S(GetHandleId((o ))) , ( "MoonCasters"))) - 1) // INLINED!!
    if ( (GetStoredInteger(cs_cache , I2S(GetHandleId((o ))) , ( "MoonCasters"))) == 0 ) then // INLINED!!
    call TimerDialogDisplayBJ(false , rdg_BlueMoon)
    call DestroyTimerDialogBJ(rdg_BlueMoon)
    call PauseTimerBJ(true , rdg_BlueMoonT)
    call DisplayTextToForce(GetPlayersAll() , "There are no longer any summoners at the Blue Moon Obelisk, and the threat is no more.")
    call ForForce(GetPlayersEnemies(rdg_MoonSummoner) , function RetTrig_Untitled_Trigger_022Zez_Func006A)
        call ForForce(GetPlayersMatching(Condition(function RetTrig_ZCustom1)) , function RetTrig_ZCustom2)
    call QueueUnitAnimationBJ(rdg_Obelisk , "stand")
	set rdg_Obelisk = null

    else
    call StartTimerBJ(rdg_BlueMoonT , false , ( TimerGetRemaining(rdg_BlueMoonT) * 2.00 ))
    endif
    call TriggerSleepAction(1.00)
    call AttachInt(GetSpellAbilityUnit() , "IsCasting" , 0)
    else
    endif



endfunction

//===========================================================================
function InitRetTrig_CasterDeath takes nothing returns nothing
    set rj_trg_CasterDeath = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_CasterDeath , EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    call TriggerAddCondition(rj_trg_CasterDeath , Condition(function RetTrig_Untitled_Trigger_010_Conditionsz))
    call TriggerAddAction(rj_trg_CasterDeath , function RetTrig_Untitled_Trigger_010_Actionsz)
endfunction

//===============Draenei Stuff==================================
//===============Draenei Stuff==================================
//===============Draenei Stuff==================================
//===============Draenei Stuff==================================
//Shroud vision trigger

function ShroudVisionInFifteen takes player p,unit u returns nothing
    call DestroyFogModifier(GetAttachedFogModifier(u , "ShroudModifier_" + I2S(GetPlayerId(p))))
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"destroying for player "+I2S(GetPlayerId(p)))
endfunction

function ShroudVisionActions takes nothing returns nothing
    local unit u=GetSpellAbilityUnit()
    local player p=GetEnumPlayer()

    call AttachObject(u , "ShroudModifier_" + I2S(GetPlayerId(p)) , CreateFogModifierRadiusLocBJ(true , GetEnumPlayer() , FOG_OF_WAR_MASKED , GetSpellTargetLoc() , 900.00))
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"creating for player "+I2S(GetPlayerId(p)))
    call ShroudVisionInFifteen(p , u)


  set u = null
  set p = null
endfunction


function RetTrig_ShroudVision_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0EB' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_ShroudVision_Actions takes nothing returns nothing
    local unit u=GetSpellAbilityUnit()
    local player p=GetEnumPlayer()

    call ForForce(GetPlayersEnemies(GetOwningPlayer(GetSpellAbilityUnit())) , function ShroudVisionActions)
//    call ForForce( GetPlayersAll(), function ShroudVisionActions )


  set u = null
  set p = null
endfunction

//===========================================================================
function InitRetTrig_ShroudVision takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_ShroudVision_Conditions))
    call TriggerAddAction(t , function RetTrig_ShroudVision_Actions)
  set t = null
endfunction
//=================================================================
//Crystal Thrower Training Trigger
function RetTrig_CrystalThrowers_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnteringUnit()) == 'lthr' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_CrystalThrowers_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetEnteringUnit() , "unroot")
endfunction

//===========================================================================
function InitRetTrig_CrystalThrowers takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterEnterRectSimple(t , GetEntireMapRect())
    call TriggerAddCondition(t , Condition(function RetTrig_CrystalThrowers_Conditions))
    call TriggerAddAction(t , function RetTrig_CrystalThrowers_Actions)
  set t = null
endfunction
//Spinning Blade 1
function RetTrig_SpinningBlade_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0DJ' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_SpinningBlade_Actions takes nothing returns nothing
    local unit u= GetSpellAbilityUnit()
    local location l= PolarProjectionBJ(GetSpellTargetLoc() , DistanceBetweenPoints(GetSpellTargetLoc() , GetUnitLoc(u)) / 2 , AngleBetweenPoints(GetSpellTargetLoc() , GetUnitLoc(u)))
    local unit u2
    local real a= AngleBetweenPoints(l , GetUnitLoc(u))
    local real r= AngleBetweenPoints(l , GetUnitLoc(u))
    local real d= DistanceBetweenPoints(l , GetUnitLoc(u))
    call CreateNUnitsAtLoc(1 , 'u01D' , Player(0) , PolarProjectionBJ(l , DistanceBetweenPoints(l , GetUnitLoc(u)) , AngleBetweenPoints(l , GetUnitLoc(u))) , AngleBetweenPoints(l , GetUnitLoc(u)) + 90)
    set u2 = GetLastCreatedUnit()


    call AttachReal(u , "blade_lx" , GetLocationX(l))
    call AttachReal(u , "blade_ly" , GetLocationY(l))
    call AttachObject(u , "blade_u2" , u2)
    call AttachReal(u , "blade_a" , a)
    call AttachReal(u , "blade_r" , r)
    call AttachReal(u , "blade_d" , d)
    call AttachBoolean(u , "blade_HS" , true)
//    loop
//        exitwhen a>r+360
//        set a=a+2
//        call SetUnitPositionLoc( u, PolarProjectionBJ(l, d, a))
//        call SetUnitFacing(u,a+90)
//    endloop
endfunction

//===========================================================================
function InitRetTrig_SpinningBlade takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_SpinningBlade_Conditions))
    call TriggerAddAction(t , function RetTrig_SpinningBlade_Actions)
  set t = null
endfunction
//Spinning Blade 2
function RetTrig_SpinningBlade2_Func001A takes nothing returns nothing
    local location l= Location((GetStoredReal(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "blade_lx"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((GetEnumUnit() ))) , ( "blade_ly")))) // INLINED!!
    local unit u= GetEnumUnit()
    local unit u2= GetAttachedUnit(u , "blade_u2")
    local real a= (GetStoredReal(cs_cache , I2S(GetHandleId((u ))) , ( "blade_a"))) // INLINED!!
    local real r= (GetStoredReal(cs_cache , I2S(GetHandleId((u ))) , ( "blade_r"))) // INLINED!!
    local real d= (GetStoredReal(cs_cache , I2S(GetHandleId((u ))) , ( "blade_d"))) // INLINED!!

  if (GetStoredBoolean(cs_cache , I2S(GetHandleId((u ))) , ( "blade_HS"))) == true then // INLINED!!
  
        if a <= r + 360 then

            set a = a + 1
            call SetUnitPositionLoc(u2 , PolarProjectionBJ(l , d , a))
            call SetUnitFacing(u2 , a + 90)
            call UnitDamagePointLoc(u , 0 , 200 , GetUnitLoc(u2) , 0.10 , ATTACK_TYPE_PIERCE , DAMAGE_TYPE_NORMAL)

            call AttachReal(u , "blade_a" , a)
        else
            call AttachBoolean(u , "blade_HS" , false)
            call RemoveUnit(u2)
        endif
  endif


    set l = null
    set u = null
    set u2 = null
    set a = 0
    set r = 0
    set d = 0
endfunction

function RetTrig_SpinningBlade2_Actions takes nothing returns nothing
    call ForGroupBJ(GetUnitsOfTypeIdAll('ohun') , function RetTrig_SpinningBlade2_Func001A)
endfunction

//===========================================================================
function InitRetTrig_SpinningBlade2 takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(t , 0.01)
    call TriggerAddAction(t , function RetTrig_SpinningBlade2_Actions)
  set t = null
endfunction
//Sacrificial Curse
function RetTrig_SacrificialCurse_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0EC' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_SacrificialCurse_Actions takes nothing returns nothing
    call SetUnitLifeBJ(GetSpellAbilityUnit() , ( GetUnitStateSwap(UNIT_STATE_LIFE , GetSpellAbilityUnit()) - ( GetUnitStateSwap(UNIT_STATE_LIFE , GetSpellAbilityUnit()) / 4.00 ) ))
endfunction

//===========================================================================
function InitRetTrig_SacrificialCurse takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_SacrificialCurse_Conditions))
    call TriggerAddAction(t , function RetTrig_SacrificialCurse_Actions)
  set t = null
endfunction

function InitNewDraenei takes nothing returns nothing
    call InitRetTrig_ShroudVision()
    call InitRetTrig_CrystalThrowers()
    call InitRetTrig_SpinningBlade()
//    call InitRetTrig_SpinningBlade2()
    call InitRetTrig_SacrificialCurse()

endfunction






//===========================================================================
// Trigger: BuildingDeath
//===========================================================================
function RetTrig_Untitled_Trigger_022Zezi_Func006A takes nothing returns nothing
    call UnitShareVisionBJ(false , rdg_Obelisk , GetEnumPlayer())
endfunction

function RetTrig_BuildingDeath_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetDyingUnit()) == 'h021' ) ) then
        return false
    endif
    if ( not ( GetDyingUnit() == rdg_Obelisk ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_BuildingDeath_Func004001001 takes nothing returns boolean
    return ( GetFilterPlayer() != rdg_MoonSummoner )
endfunction

function RetTrig_BuildingDeath_Func004A takes nothing returns nothing
    call SetPlayerAbilityAvailableBJ(true , 'A09B' , GetEnumPlayer())
    call SetPlayerAbilityAvailableBJ(false , 'A09C' , GetEnumPlayer())
endfunction

function RetTrig_BuildingDeath_Actions takes nothing returns nothing
    call TimerDialogDisplayBJ(false , rdg_BlueMoon)
    call DestroyTimerDialogBJ(rdg_BlueMoon)
    call PauseTimerBJ(true , rdg_BlueMoonT)
    call DisplayTextToForce(GetPlayersAll() , "The Blue Moon Obelisk has been burned to the ground, and the threat is no more.")
    call ForForce(GetPlayersEnemies(rdg_MoonSummoner) , function RetTrig_Untitled_Trigger_022Zezi_Func006A)

    call ForForce(GetPlayersMatching(Condition(function RetTrig_BuildingDeath_Func004001001)) , function RetTrig_BuildingDeath_Func004A)
    set rdg_Obelisk = null
endfunction

//===========================================================================
function InitRetTrig_BuildingDeath takes nothing returns nothing
    set rj_trg_BuildingDeath = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_BuildingDeath , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(rj_trg_BuildingDeath , Condition(function RetTrig_BuildingDeath_Conditions))
    call TriggerAddAction(rj_trg_BuildingDeath , function RetTrig_BuildingDeath_Actions)
endfunction

//===========================================================================
// Trigger: TimerExpire
//===========================================================================
function RetTrig_TimerExpire_Func006A takes nothing returns nothing
    call SetPlayerTechResearchedSwap('RFbm' , 1 , GetEnumPlayer())
endfunction

function RetTrig_TimerExpire_Actions takes nothing returns nothing
    call DisableTrigger(rj_trg_Get)
    call DisableTrigger(rj_trg_CasterDeath)
    call DisableTrigger(rj_trg_BuildingDeath)
    call SetPlayerAbilityAvailableBJ(false , 'A09B' , rdg_MoonSummoner)
    call SetPlayerAbilityAvailableBJ(true , 'A09C' , rdg_MoonSummoner)
    call ForForce(GetPlayersAll() , function RetTrig_TimerExpire_Func006A)
        call SetDayNightModels("Environment\\DNC\\DNCBlueMoon\\DNCLightBlueMoon.mdl" , "Environment\\DNC\\DNCBlueMoon\\DNCLightBlueMoon.mdl")
    call CreateNUnitsAtLoc(1 , 'n01L' , rdg_MoonSummoner , GetUnitLoc(rdg_Obelisk) , bj_UNIT_FACING)
    call TriggerSleepAction(2)
    call TimerDialogDisplayBJ(false , rdg_BlueMoon)
    call DestroyTimerDialogBJ(rdg_BlueMoon)
endfunction

//===========================================================================
function InitRetTrig_TimerExpire takes nothing returns nothing
    set rj_trg_TimerExpire = CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(rj_trg_TimerExpire , rdg_BlueMoonT)
    call TriggerAddAction(rj_trg_TimerExpire , function RetTrig_TimerExpire_Actions)
endfunction

//===========================================================================
// Trigger: Coral of the Gentle Rain
//===========================================================================
function RetTrig_Coral_of_the_Gentle_Rain_Conditions takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I004' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Coral_of_the_Gentle_Rain_Actions takes nothing returns nothing
 call CasterCastAbilityPointLoc(GetOwningPlayer(GetManipulatingUnit()) , 'A0BX' , "tranquility" , GetUnitLoc(GetManipulatingUnit()) , false)
endfunction

//===========================================================================
function InitRetTrig_Coral_of_the_Gentle_Rain takes nothing returns nothing
    set rj_trg_Coral_of_the_Gentle_Rain = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Coral_of_the_Gentle_Rain , EVENT_PLAYER_UNIT_USE_ITEM)
    call TriggerAddCondition(rj_trg_Coral_of_the_Gentle_Rain , Condition(function RetTrig_Coral_of_the_Gentle_Rain_Conditions))
    call TriggerAddAction(rj_trg_Coral_of_the_Gentle_Rain , function RetTrig_Coral_of_the_Gentle_Rain_Actions)
endfunction

function RetTrig_Untitled_Trigger_004BOB_Func001A takes nothing returns nothing
if ( not IsPlayerObserver(GetEnumPlayer()) ) then

    call DialogDisplayBJ(true , rdg_RaceChoice , GetEnumPlayer())
endif
endfunction

function RetTrig_Untitled_Trigger_004BOB_Actions takes nothing returns nothing
//    call DisplayTextToForce( GetPlayersAll(), "Hello! This is a text test. If it displays, the game is working semi-properly." )
    call DisableTrigger(rdg_enableCheats)
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00ff8800Zear Fallen|r")
    set rdg_RaceChoiceButton[4]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c0000ffffThe Enlightened Tide|r")
    set rdg_RaceChoiceButton[2]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c000000ffFreezing Legion|r")
    set rdg_RaceChoiceButton[5]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00880000Lost Tribe|r")
    set rdg_RaceChoiceButton[1]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00333333Voidspawn|r")
    set rdg_RaceChoiceButton[6]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00FFEEDDFinal Alliance|r")
    set rdg_RaceChoiceButton[8]=GetLastCreatedButtonBJ()
	if rdg_oldies then
    call DialogAddButtonBJ(rdg_RaceChoice , "|cffffcc00The Human Alliance (NO PROMISES)|r")
    set rdg_RaceChoiceButton[9]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00229922Orcish Horde (NO PROMISES)|r")
    set rdg_RaceChoiceButton[10]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00dd00ffThe Kaldorei (NO PROMISES)|r")
    set rdg_RaceChoiceButton[11]=GetLastCreatedButtonBJ()
	call DialogAddButtonBJ(rdg_RaceChoice , "|c00777777Ner'zul's Scourge (NO PROMISES)|r")
    set rdg_RaceChoiceButton[12]=GetLastCreatedButtonBJ()
	endif
	if rdg_isCheats then
    call DialogAddButtonBJ(rdg_RaceChoice , "|caaaaaaaaThe Risen (DEVELOPMENT)|r")
    set rdg_RaceChoiceButton[3]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c0000ff00High Elves (DEVELOPMENT)|r")
    set rdg_RaceChoiceButton[0]=GetLastCreatedButtonBJ()
    call DialogAddButtonBJ(rdg_RaceChoice , "|c00ff0000That other race... (DEVELOPMENT, LOSE THE GAME)|r")
    set rdg_RaceChoiceButton[7]=GetLastCreatedButtonBJ()
	endif
    call DialogSetMessageBJ(rdg_RaceChoice , "Choose a Race")
    call TriggerSleepAction(1.00)
    call ForForce(GetPlayersAll() , function RetTrig_Untitled_Trigger_004BOB_Func001A)
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(0))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(1))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(2))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(3))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(4))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(5))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(6))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(7))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(8))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(9))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(10))
    call DialogDisplayBJ(true , rdg_RaceChoice , Player(11))




endfunction





function RetTrig_Period_ReAttempt_Blue_Moon_AI_Func001A takes nothing returns nothing
    call IssueTargetOrderBJ(GetEnumUnit() , "channel" , GroupPickRandomUnit(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetEnumUnit()) , 'h021')))
endfunction

function RetTrig_Period_ReAttempt_Blue_Moon_AI_Actions takes nothing returns nothing
  local player p=Player((GetStoredInteger(cs_cache , I2S(GetHandleId((GetTriggeringTrigger() ))) , ( "AIplayer")))) // INLINED!!
    if GetPlayerTechCountSimple('R01G' , p) == 1 then

    call AttachInt(GetTriggeringTrigger() , "AIplayer" , 0)
    call DestroyTrigger(GetTriggeringTrigger())
    else

    call ForGroupBJ(GetUnitsOfPlayerAndTypeId(p , 'n01N') , function RetTrig_Period_ReAttempt_Blue_Moon_AI_Func001A)
    endif
  set p = null
endfunction

//===========================================================================
function InitRetTrig_Period_ReAttempt_Blue_Moon_AI takes player p returns nothing
    local trigger t= CreateTrigger()
    call AttachInt(t , "AIplayer" , GetPlayerId(p))
    call TriggerRegisterTimerEventPeriodic(t , 300.00)
    call TriggerAddAction(t , function RetTrig_Period_ReAttempt_Blue_Moon_AI_Actions)
    set t = null
endfunction


function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002001 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) == true )
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002002001 takes nothing returns boolean
    return ( IsUnitAliveBJ(GetFilterUnit()) == true )
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002002002 takes nothing returns boolean
    return ( true == true )
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002002 takes nothing returns boolean
    return GetBooleanAnd((IsUnitAliveBJ(GetFilterUnit()) == true) , (true == true)) // INLINED!!
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002 takes nothing returns boolean
    return GetBooleanAnd((IsUnitType(GetFilterUnit() , UNIT_TYPE_TOWNHALL) == true) , (GetBooleanAnd((IsUnitAliveBJ(GetFilterUnit()) == true) , (true == true)))) // INLINED!!
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetConstructedStructure()) == 'h01C' ) ) then
        return false
    endif
    if ( not ( CountUnitsInGroup(GetUnitsOfPlayerMatching(GetOwningPlayer(GetConstructingStructure()) , Condition(function RetTrig_Freezing_Legion_Blue_Moon_AI_Func003001001002))) >= 3 ) ) then
        return false
    endif
    if ( not ( GetPlayerController(GetOwningPlayer(GetConstructingStructure())) == MAP_CONTROL_COMPUTER ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Func001A takes nothing returns nothing
    call IssueTargetOrderBJ(GetEnumUnit() , "charm" , GroupPickRandomUnit(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetConstructingStructure()) , 'h021')))
endfunction

function RetTrig_Freezing_Legion_Blue_Moon_AI_Actions takes nothing returns nothing
    call ForGroupBJ(GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetConstructingStructure()) , 'n01N') , function RetTrig_Freezing_Legion_Blue_Moon_AI_Func001A)
    call InitRetTrig_Period_ReAttempt_Blue_Moon_AI(GetOwningPlayer(GetConstructingStructure()))
endfunction

//===========================================================================
function InitRetTrig_Freezing_Legion_Blue_Moon_AI takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_START)
    call TriggerAddCondition(t , Condition(function RetTrig_Freezing_Legion_Blue_Moon_AI_Conditions))
    call TriggerAddAction(t , function RetTrig_Freezing_Legion_Blue_Moon_AI_Actions)
    set t = null
endfunction


function RetTrig_SummonBeast_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0FC' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_SummonBeast_Actions takes nothing returns nothing
    call CreateNUnitsAtLoc(1 , ChooseRandomCreepBJ(( 3 + ( 1 * GetUnitAbilityLevelSwapped('A0FC' , GetSpellAbilityUnit()) ) )) , GetOwningPlayer(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellAbilityUnit()) , GetUnitFacing(GetSpellAbilityUnit()))
    call UnitApplyTimedLifeBJ(30.00 , 'B01X' , GetLastCreatedUnit())
endfunction

//===========================================================================
function InitRetTrig_SummonBeast takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_SummonBeast_Conditions))
    call TriggerAddAction(t , function RetTrig_SummonBeast_Actions)
    set t = null
endfunction





function BOBTwo takes nothing returns nothing
  local trigger t
  local integer i= 0
    set t = CreateTrigger()
    call TriggerRegisterTimerEventSingle(t , 3)
    call TriggerAddAction(t , function RetTrig_Untitled_Trigger_004BOB_Actions)
 set t = null

endfunction
//===========================================================================
function BOB takes nothing returns nothing
    call InitRetTrig_SummonBeast()
endfunction

//===========================================================================
// Trigger: Melee Initialization
//
// Default melee game initialization for all players
//===========================================================================
function RetTrig_Melee_Initialization_Func018A takes nothing returns nothing
    call DialogDisplayBJ(true , rdg_RaceChoice , GetEnumPlayer())
endfunction

function RetTrig_Melee_Initialization_B_Actions takes nothing returns nothing



    call TriggerSleepAction(4)

 //   call ForForce( GetPlayersAll(), function RetTrig_Melee_Initialization_Func018A )
endfunction

//===========================================================================
function InitRetTrig_Melee_Initialization_B takes nothing returns nothing
    set rj_trg_Melee_Initialization_B = CreateTrigger()
    call TriggerAddAction(rj_trg_Melee_Initialization_B , function RetTrig_Melee_Initialization_B_Actions)
endfunction

//===========================================================================
// Trigger: Untitled Trigger 002
//===========================================================================
function RetTrig_Untitled_Trigger_002_Func001C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[0] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func002C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[1] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func003C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[2] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func004C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[3] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func005C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[4] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func006C takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[5] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func007XC takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[6] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func008XC takes nothing returns boolean
    if ( not ( GetClickedButtonBJ() == rdg_RaceChoiceButton[7] ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_002_Func008Func002003001001 takes nothing returns boolean
    return ( GetPlayerController(GetFilterPlayer()) == MAP_CONTROL_USER )
endfunction

function RetTrig_Untitled_Trigger_002_Func008C takes nothing returns boolean
    if ( not ( rdg_numberofdoneplayers >= CountPlayersInForceBJ(GetPlayersMatching(Condition(function RetTrig_Untitled_Trigger_002_Func008Func002003001001))) ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Untitled_Trigger_004_Func001A takes nothing returns nothing
    call UnitApplyTimedLifeBJ(0.50 , 'BTLF' , GetEnumUnit())
endfunction

//===========================================================================
// Starting Units for Zear Players
//   - 1 Encampment, placed at start location
//   - 3 Fortifiers, placed between start location and nearest gold mine
//   - 1 Storage Wagon, placed between start location and nearest gold mine
//
function MeleeStartingUnitsZear takes player whichPlayer,location startLoc,boolean doHeroes,boolean doCamera,boolean doPreload returns nothing
    local boolean useRandomHero= false // IsMapFlagSet(MAP_RANDOM_HERO)
    local real unitSpacing= 64.00
    local unit nearestMine
    local unit topunit
    local unit bottomunit
    local location nearMineLoc
    local location nearTownLoc
    local location heroLoc
    local real peonX
    local real peonY
    local real ghoulX
    local real ghoulY

    if ( doPreload ) then
//        call Preloader( "scripts\\UndeadMelee.pld" )
    endif

    set nearestMine = MeleeFindNearestMine(startLoc , bj_MELEE_MINE_SEARCH_RADIUS)
    if ( nearestMine != null ) then
        // Spawn Encampment at the start location.
        call CreateUnitAtLoc(whichPlayer , 'h013' , startLoc , bj_UNIT_FACING)

        // Spawn Storage Wagon near the Encampment.
        set nearTownLoc = MeleeGetProjectedLoc(startLoc , GetUnitLoc(nearestMine) , 288 , 0)
        set ghoulX = GetUnitX(nearestMine)
        set ghoulY = GetUnitY(nearestMine)
        set bj_ghoul[GetPlayerId(whichPlayer)]=CreateUnit(whichPlayer , 'e00F' , ghoulX + 0.00 * unitSpacing , ghoulY + 0.00 * unitSpacing , bj_UNIT_FACING)
        set bottomunit = bj_ghoul[GetPlayerId(whichPlayer)]
    call ShowUnitHide(bottomunit)
    call PauseUnit(bottomunit , true)
        set topunit = CreateUnit(whichPlayer , 'e01F' , ghoulX + 0.00 * unitSpacing , ghoulY + 0.00 * unitSpacing , bj_UNIT_FACING)
    call AttachObject(bottomunit , "WG_topunit" , topunit)
    call AttachObject(topunit , "WG_bottomunit" , bottomunit)

        // Spawn Fortifiers near the mine.
        set nearMineLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 320 , 0)
        set peonX = GetLocationX(nearMineLoc)
        set peonY = GetLocationY(nearMineLoc)
        call CreateUnit(whichPlayer , 'h01D' , peonX + 0.00 * unitSpacing , peonY + 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h01D' , peonX + 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h01D' , peonX - 0.65 * unitSpacing , peonY - 0.50 * unitSpacing , bj_UNIT_FACING)

        // Set random hero spawn point to be off to the side of the start location.
        set heroLoc = MeleeGetProjectedLoc(GetUnitLoc(nearestMine) , startLoc , 384 , 45)
    else
        // Spawn Encampment at the start location.
        call CreateUnitAtLoc(whichPlayer , 'h013' , startLoc , bj_UNIT_FACING)
        
        // Spawn Acolytes and Ghoul directly south of the Necropolis.
        set peonX = GetLocationX(startLoc)
        set peonY = GetLocationY(startLoc) - 224.00
        call CreateUnit(whichPlayer , 'h01D' , peonX - 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h01D' , peonX - 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        call CreateUnit(whichPlayer , 'h01D' , peonX + 0.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
        set bottomunit = CreateUnit(whichPlayer , 'e00F' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
    call ShowUnitHide(bottomunit)
    call PauseUnit(bottomunit , true)
        set topunit = CreateUnit(whichPlayer , 'e01F' , peonX + 1.50 * unitSpacing , peonY + 0.00 * unitSpacing , bj_UNIT_FACING)
    call AttachObject(bottomunit , "WG_topunit" , topunit)
    call AttachObject(topunit , "WG_bottomunit" , bottomunit)


        // Set random hero spawn point to be just south of the start location.
        set heroLoc = Location(peonX , peonY - 2.00 * unitSpacing)
    endif

    if ( doHeroes ) then
        // If the "Random Hero" option is set, start the player with a random hero.
        // Otherwise, give them a "free hero" token.
        if useRandomHero then
            call MeleeRandomHeroLoc(whichPlayer , 'N02B' , 'N00Y' , 'N011' , 'N00Z' , heroLoc)
        else
            call SetPlayerState(whichPlayer , PLAYER_STATE_RESOURCE_HERO_TOKENS , bj_MELEE_STARTING_HERO_TOKENS)
        endif
    endif

    if ( doCamera ) then
        // Center the camera on the initial Acolytes.
        call SetCameraPositionForPlayer(whichPlayer , peonX , peonY)
        call SetCameraQuickPositionForPlayer(whichPlayer , peonX , peonY)
    endif
    set topunit = null
    set bottomunit = null
endfunction

//===========================================================================
//              Spawn Starting Units for All player (EDITED)
//===========================================================================
function MeleeStartingUnits takes nothing returns nothing
local integer  index
local player   indexPlayer
local location indexStartLoc
local race  indexRace
local real  racialHandicap

set index = 0
loop
     set indexPlayer = Player(index)
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
            set indexStartLoc = GetStartLocationLoc(GetPlayerStartLocation(indexPlayer))
            
            set indexRace = GetPlayerRace(indexPlayer)
            set racialHandicap = GetPlayerHandicap(indexPlayer)

            if (indexRace == RACE_ORC and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                call MeleeStartingUnitsNightElfTide(indexPlayer, indexStartLoc, true, true, true)
                //call SetPlayerHandicapBJ(indexPlayer,100)
            elseif (indexRace == RACE_HUMAN and racialHandicap >= 0.89 and racialHandicap <= 0.91) then
                call MeleeStartingUnitsFinalHumans(indexPlayer, indexStartLoc, true, true, true)
                //call SetPlayerHandicapBJ(indexPlayer,100)
            else
                // Create initial race-specific starting units
                if (indexRace == RACE_HUMAN) then
                    call MeleeStartingUnitsZear(indexPlayer, indexStartLoc, true, true, true)
                elseif (indexRace == RACE_ORC) then
                    call MeleeStartingUnitsOrcDrae(indexPlayer, indexStartLoc, true, true, true)
                elseif (indexRace == RACE_UNDEAD) then
                    call MeleeStartingUnitsVoid(indexPlayer, indexStartLoc, true, true, true)
                elseif (indexRace == RACE_NIGHTELF) then
                    call MeleeStartingUnitsNorthpact(indexPlayer, indexStartLoc, true, true, true)
                else
                    call MeleeStartingUnitsUnknownRace(indexPlayer, indexStartLoc, true, true, true)
                endif
            endif
            
        endif
     set index = index + 1
     exitwhen index == bj_MAX_PLAYERS
endloop
endfunction

function RetTrig_Untitled_Trigger_002_Actions takes nothing returns nothing
//    call ForGroupBJ( GetUnitsOfPlayerAll(GetTriggerPlayer()), function RetTrig_Untitled_Trigger_004_Func001A )
//    call DisplayTextToForce( GetPlayersAll(), "YOUR MOM" )

    if ( RetTrig_Untitled_Trigger_002_Func001C() ) then
        call MeleeStartingUnitsHuman(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func002C() ) then
        call MeleeStartingUnitsOrcDrae(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func003C() ) then
        call MeleeStartingUnitsNightElfTide(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func004C() ) then
        call MeleeStartingUnitsUndeadRis(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func005C() ) then
        call MeleeStartingUnitsZear(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func006C() ) then
        call MeleeStartingUnitsFreezingLegion(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func007XC() ) then
        call MeleeStartingUnitsVoid(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
    if ( RetTrig_Untitled_Trigger_002_Func008XC() ) then
        call MeleeStartingUnitsUnknownRace(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
	if ( GetClickedButtonBJ() == rdg_RaceChoiceButton[8] ) then
        call MeleeStartingUnitsFinalHumans(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    else
    endif
	if ( GetClickedButtonBJ() == rdg_RaceChoiceButton[9] ) then
        call MeleeStartingUnitsAlliance(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    endif
	if ( GetClickedButtonBJ() == rdg_RaceChoiceButton[10] ) then
        call MeleeStartingUnitsHorde(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    endif
	if ( GetClickedButtonBJ() == rdg_RaceChoiceButton[11] ) then
        call MeleeStartingUnitsKaldorei(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    endif
	if ( GetClickedButtonBJ() == rdg_RaceChoiceButton[12] ) then
        call MeleeStartingUnitsScourge(GetTriggerPlayer() , GetPlayerStartLocationLoc(GetTriggerPlayer()) , true , true , true)
    endif
    call DialogDisplayBJ(false , rdg_RaceChoice , GetTriggerPlayer())
    set rdg_numberofdoneplayers = ( rdg_numberofdoneplayers + 1 )
    if ( RetTrig_Untitled_Trigger_002_Func008C() ) then
        call MeleeInitVictoryDefeatB()
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_Untitled_Trigger_002 takes nothing returns nothing
  local trigger t
    set t = CreateTrigger()
    call TriggerRegisterDialogEventBJ(t , rdg_RaceChoice)
    call TriggerAddAction(t , function RetTrig_Untitled_Trigger_002_Actions)
    set t = null
endfunction


//DEBUG FOR THE NEW RACE MOD

//fastunit

function RetTrig_fastunit_Actions takes nothing returns nothing
    local unit u=GetTriggerUnit()
    call CreateNUnitsAtLoc(1 , GetTrainedUnitType() , GetOwningPlayer(GetTriggerUnit()) , GetUnitLoc(GetTriggerUnit()) , bj_UNIT_FACING)
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"Creating "+UnitId2String(GetTrainedUnitType())+" for player "+I2S(GetPlayerId(GetOwningPlayer(GetTriggerUnit())))+" at location ("+R2S(GetLocationX(GetUnitLoc(GetTriggerUnit())))+", "+R2S(GetLocationY(GetUnitLoc(GetTriggerUnit())))+")")
    call IssueImmediateOrderBJ(GetTriggerUnit() , "stop")
    call IssueImmediateOrderBJ(GetTriggerUnit() , "cancel")
    call TriggerSleepAction(0.03)
    call ForceUICancelBJ(GetOwningPlayer(u))
  set u = null
endfunction

//===========================================================================
function InitRetTrig_fastunit takes nothing returns nothing
    set rj_trg_fastunit = CreateTrigger()
    call DisableTrigger(rj_trg_fastunit)
    call TriggerRegisterAnyUnitEventBJ(rj_trg_fastunit , EVENT_PLAYER_UNIT_TRAIN_START)
    call TriggerAddAction(rj_trg_fastunit , function RetTrig_fastunit_Actions)
endfunction




//fastbuild

function RetTrig_fastbuild_Actions takes nothing returns nothing
  local unit u=GetConstructingStructure()
    call UnitSetUpgradeProgress(GetTriggerUnit() , 100)

    call TriggerSleepAction(0.05)
    call UnitSetConstructionProgress(u , 100)
  set u = null
endfunction


//===========================================================================
function InitRetTrig_fastbuild takes nothing returns nothing
    set rj_trg_fastbuild = CreateTrigger()
    call DisableTrigger(rj_trg_fastbuild)
    call TriggerRegisterAnyUnitEventBJ(rj_trg_fastbuild , EVENT_PLAYER_UNIT_CONSTRUCT_START)
    call TriggerRegisterAnyUnitEventBJ(rj_trg_fastbuild , EVENT_PLAYER_UNIT_UPGRADE_START)
    call TriggerAddAction(rj_trg_fastbuild , function RetTrig_fastbuild_Actions)
endfunction






//fasttech

function RetTrig_fasttech_Actions takes nothing returns nothing
    call SetPlayerTechResearchedSwap(GetResearched() , ( GetPlayerTechCountSimple(GetResearched() , GetOwningPlayer(GetResearchingUnit())) + 1 ) , GetOwningPlayer(GetResearchingUnit()))
endfunction

//===========================================================================
function InitRetTrig_fasttech takes nothing returns nothing
    set rj_trg_fasttech = CreateTrigger()
    call DisableTrigger(rj_trg_fasttech)
    call TriggerRegisterAnyUnitEventBJ(rj_trg_fasttech , EVENT_PLAYER_UNIT_RESEARCH_START)
    call TriggerAddAction(rj_trg_fasttech , function RetTrig_fasttech_Actions)
endfunction


//reset ability cooldowns

function RetTrig_reset_Func013002 takes nothing returns nothing
    call UnitResetCooldown(GetEnumUnit())
endfunction

function RetTrig_reset_Actions takes nothing returns nothing
    if rdg_isCheats then
    call ForGroupBJ(GetUnitsOfPlayerAll(GetTriggerPlayer()) , function RetTrig_reset_Func013002)
	endif
endfunction

//===========================================================================
function InitRetTrig_reset takes nothing returns nothing
    set rj_trg_reset = CreateTrigger()
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(0) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(1) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(2) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(3) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(4) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(5) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(6) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(7) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(8) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(9) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(10) , "reset" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_reset , Player(11) , "reset" , true)
    call TriggerAddAction(rj_trg_reset , function RetTrig_reset_Actions)
endfunction





//infinite money

function RetTrig_money_Func001A takes nothing returns nothing
    call SetPlayerStateBJ(GetEnumPlayer() , PLAYER_STATE_RESOURCE_LUMBER , 1000000000)
    call SetPlayerStateBJ(GetEnumPlayer() , PLAYER_STATE_RESOURCE_GOLD , 1000000000)
endfunction

function RetTrig_money_Actions takes nothing returns nothing
    if rdg_isCheats then
    call ForForce(GetPlayersAll() , function RetTrig_money_Func001A)
	endif
endfunction

//===========================================================================
function InitRetTrig_money takes nothing returns nothing
    set rj_trg_money = CreateTrigger()
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(0) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(1) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(2) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(3) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(4) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(5) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(6) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(7) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(8) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(9) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(10) , "money" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_money , Player(11) , "money" , true)
    call TriggerAddAction(rj_trg_money , function RetTrig_money_Actions)
endfunction




//fast cheat

function RetTrig_fast_Actions takes nothing returns nothing
    if IsTriggerEnabled(rj_trg_fastbuild) == false and rdg_isCheats then
    call EnableTrigger(rj_trg_fastbuild)
    call EnableTrigger(rj_trg_fasttech)
    call EnableTrigger(rj_trg_fastunit)
    else
    call DisableTrigger(rj_trg_fastbuild)
    call DisableTrigger(rj_trg_fasttech)
    call DisableTrigger(rj_trg_fastunit)
    endif
endfunction

//===========================================================================
function InitRetTrig_fast takes nothing returns nothing
    set rj_trg_fast = CreateTrigger()
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(0) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(1) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(2) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(3) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(4) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(5) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(6) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(7) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(8) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(9) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(10) , "fast" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_fast , Player(11) , "fast" , true)
    call TriggerAddAction(rj_trg_fast , function RetTrig_fast_Actions)
endfunction


//vision cheat


function RetTrig_vision_Func013002 takes nothing returns nothing
    call CreateFogModifierRectBJ(true , GetEnumPlayer() , FOG_OF_WAR_VISIBLE , GetPlayableMapRect())
endfunction

function RetTrig_vision_Actions takes nothing returns nothing
    if rdg_isCheats then
    call ForForce(GetPlayersAll() , function RetTrig_vision_Func013002)
	endif
endfunction

//===========================================================================
function InitRetTrig_vision takes nothing returns nothing
    set rj_trg_vision = CreateTrigger()
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(0) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(1) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(2) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(3) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(4) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(5) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(6) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(7) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(8) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(9) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(10) , "vision" , true)
    call TriggerRegisterPlayerChatEvent(rj_trg_vision , Player(11) , "vision" , true)
    call TriggerAddAction(rj_trg_vision , function RetTrig_vision_Actions)
endfunction


function RetTrig_EnableCheats_Actions takes nothing returns nothing
    set rdg_isCheats = true
endfunction

//===========================================================================
function InitRetTrig_EnableCheats takes nothing returns nothing
local trigger t
    set rdg_enableCheats = CreateTrigger()
	set t = rdg_enableCheats
    call TriggerRegisterPlayerChatEvent(t , Player(0) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(1) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(2) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(3) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(4) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(5) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(6) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(7) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(8) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(9) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(10) , "activateX" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(11) , "activateX" , true)
    call TriggerAddAction(t , function RetTrig_EnableCheats_Actions)
	set t = null
endfunction

function RetTrig_EnableOldies_Actions takes nothing returns nothing
    set rdg_oldies = true
endfunction

//===========================================================================
function InitRetTrig_EnableOldies takes nothing returns nothing
local trigger t
	set t = CreateTrigger()
    call TriggerRegisterPlayerChatEvent(t , Player(0) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(1) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(2) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(3) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(4) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(5) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(6) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(7) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(8) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(9) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(10) , "oldies" , true)
    call TriggerRegisterPlayerChatEvent(t , Player(11) , "oldies" , true)
    call TriggerAddAction(t , function RetTrig_EnableOldies_Actions)
	set t = null
endfunction

function DemonicPossession takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local unit target=GetSpellTargetUnit()
    local player castplayer=GetOwningPlayer(caster)
    local player targetplayer=GetOwningPlayer(target)
    if IsPlayerAlly(targetplayer , castplayer) then
      call CasterCastAbilityLevel(castplayer , 'A0HJ' , GetUnitAbilityLevel(caster , 'A0HH') , "unholyfrenzy" , target , true)
    else
      call CasterCastAbilityEx(castplayer , GetUnitX(caster) , GetUnitY(caster) , 60 , 'A0HI' , GetUnitAbilityLevel(caster , 'A0HH') , "parasite" , target , 0.5)
    endif
    set caster = null
    set target = null
endfunction



function HealingBolt_Collide takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit missile=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
    local integer i= (GetStoredInteger(cs_cache , I2S(GetHandleId((missile ))) , ( "level"))) // INLINED!!
    local player castplayer=GetOwningPlayer(missile)
    if IsPlayerAlly(GetOwningPlayer(u) , castplayer) then
      call CasterCastAbilityLevel(castplayer , 'A0HO' , i , "rejuvination" , u , true)
    endif
    set u = null
    set missile = null
endfunction



function WarlockBolt_End takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit missile=GetAttachedUnit(t , "missile")
    call FlushStoredMission(cs_cache , I2S(GetHandleId((missile)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(missile))
    call CollisionMissile_Destroy(missile)
    call CS_KillTimer(t)
endfunction

function HealingBolt takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
//    local location targetloc=GetSpellTargetLoc()
    local player castplayer=GetOwningPlayer(caster)
    local unit missile=CollisionMissile_Create("abilities\\spells\\FinalAlliance\\HealingBolt\\HealingBoltMissile.mdl" , GetUnitX(caster) , GetUnitY(caster) , GetUnitFacing(caster) , 1050 , 0 , 800 , 80 , false , 125 , function HealingBolt_Collide)
//    local timer t=CreateTimer()
    call SetUnitOwner(missile , castplayer , true)
//    call CollisionMissile_Move(missile,1050)
    call AttachInt(missile , "level" , GetUnitAbilityLevel(caster , 'A0HL'))
//    call TimerStart(t,2.00,false,function HealingBolt_End)
//    call AttachObject(t,"missile",missile)
    set caster = null
    set missile = null
    set castplayer = null
endfunction


function MurgulBolt_Collide takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit missile=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
    local player castplayer=GetOwningPlayer(missile)
    if IsUnitType(u , UNIT_TYPE_STRUCTURE) then
    else
      set rdg_delayhack = 15
    if u != null then
call CasterCastAbilityLevelPoint((castplayer ) , ( 'A0IL' ) , 1 , ( "blizzard" ) , (( GetUnitX(u) )*1.0) , (( GetUnitY(u) )*1.0) , ( false)) // INLINED!!
    endif
      call CollisionMissile_Destroy(missile)
    endif
    set u = null
    set missile = null
endfunction

function MurgulBolt takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()

    local player castplayer=GetOwningPlayer(caster)

    local integer abil=GetSpellAbilityId()
    local unit missile=CollisionMissile_Create(GetAbilityEffectById(abil , EFFECT_TYPE_MISSILE , 1) , GetUnitX(caster) , GetUnitY(caster) , GetUnitFacing(caster) , 1050 , 0 , 800 , 80 , false , 125 , function MurgulBolt_Collide)
    call SetUnitOwner(missile , castplayer , true)
    set missile = CollisionMissile_Create(GetAbilityEffectById(abil , EFFECT_TYPE_MISSILE , 2) , GetUnitX(caster) , GetUnitY(caster) , GetUnitFacing(caster) , 1050 , 200 , 800 , 80 , false , 125 , function MurgulBolt_Collide)
    call SetUnitOwner(missile , castplayer , true)
    set missile = CollisionMissile_Create(GetAbilityEffectById(abil , EFFECT_TYPE_MISSILE , 2) , GetUnitX(caster) , GetUnitY(caster) , GetUnitFacing(caster) , 1050 , - 200 , 800 , 80 , false , 125 , function MurgulBolt_Collide)
    call SetUnitOwner(missile , castplayer , true)

    set caster = null
    set missile = null
    set castplayer = null
endfunction

function WarlockBolt_Collide takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit missile=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
    local integer i= (GetStoredInteger(cs_cache , I2S(GetHandleId((missile ))) , ( "level"))) // INLINED!!
    local player castplayer=GetOwningPlayer(missile)
    if IsUnitAlly(u , castplayer) then
    elseif IsUnitType(u , UNIT_TYPE_STRUCTURE) then
    else
      call CasterCastAbilityLevel(castplayer , 'A0HP' , i , "cripple" , u , true)
      call CollisionMissile_Destroy(missile)
      call UnitRemoveAbility(missile , 'A0HN')
    endif
    set u = null
    set missile = null
endfunction

function WarlockBolt takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local player castplayer=GetOwningPlayer(caster)
    local location target=GetSpellTargetLoc()
    local unit array missile
//    local effect array fx
    local integer i=1
    local integer n=12 //This defines number of missiles
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    call PingMinimapLocForPlayer(castplayer , target , 10)
    loop
        exitwhen i > n
        set missile[i]=CollisionMissile_Create(GetAbilityEffectById(abil , EFFECT_TYPE_MISSILE , n) , GetUnitX(caster) , GetUnitY(caster) , GetUnitFacing(caster) + ( 360 / n ) * i , 400 , 0 , 3000 , 80 , false , 100 , function WarlockBolt_Collide)
        call AttachInt(missile[i] , "level" , lvl)
        //An important note: when a caster is Recycled (the function name is Recicle)
        // they do not lose their abilities. Because I plan to use phoenix fire for this ability,
        // I need to remove it before recycling.
//        set fx[i]=AddSpellEffectTargetById(abil,EFFECT_TYPE_MISSILE,missile[i],"origin")
        call SetUnitOwner(missile[i] , castplayer , true)
        call UnitAddAbility(missile[i] , 'A0HN')
        call SetUnitAbilityLevel(missile[i] , 'A0HN' , lvl)
        set i = i + 1
    endloop
    call PolledWait(0.90)
    set i = 1
    loop
        exitwhen i > n
        call CollisionMissile_SetAngleSpeed(missile[i] , 140)
        call CollisionMissile_SetTargetPointLoc(missile[i] , target)
        set missile[i]=null
        set i = i + 1
    endloop
    call PingMinimapLocForPlayer(castplayer , target , 10)
    call RemoveLocation(target)
    set caster = null
    set castplayer = null
    set target = null
endfunction

function DarkArmor_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "caster")
    call UnitRemoveType(u , UNIT_TYPE_MAGIC_IMMUNE)
    call UnitRemoveAbility(u , 'A0HU')
    call CS_KillTimer(t)
endfunction

function DarkArmor_Actions takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local integer lvl=GetUnitAbilityLevel(u , 'A0HQ')
    local unit atker=GetEventDamageSource()
    local integer i=GetRandomInt(1 , 100)
//    local timer t=CreateTimer()
    if i <= ( 5 + ( lvl * 5 ) ) then
        call CasterCastAbilityEx(GetOwningPlayer(u) , GetUnitX(u) , GetUnitY(u) , 60 , 'A0HR' , lvl , "chainlightning" , atker , 0.5)
//        call CasterCastAbility(GetOwningPlayer(u),'A0HT',"antimagicshell",u,true)
        call CasterCastAbilityLevel(Player(15) , 'A0HS' , lvl , "banish" , u , true)
//        call SetPlayerAbilityAvailable(GetOwningPlayer(u),'A0HU',false)
//        call UnitAddAbility(u,'A0HU')
//        call UnitAddType( u,UNIT_TYPE_MAGIC_IMMUNE )
//        call TimerStart(t,6.00,false,function DarkArmor_Timer)
//        call AttachObject(t,"caster",u)
    endif
    set u = null
    set atker = null
endfunction

function DarkArmor takes nothing returns nothing
    local unit u=GetLearningUnit()
    local integer lvl=GetLearnedSkillLevel()
    local trigger t
    if lvl > 1 then
    set t = GetAttachedTrigger(u , "darkarmortrig")
    else
    set t = CreateTrigger()
    call AttachObject(u , "darkarmortrig" , t)
    call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_DAMAGED)
    call TriggerAddAction(t , function DarkArmor_Actions)
    endif
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwned"+I2S(lvl))
    set u = null
    set t = null
endfunction

function FlameBurstAbility takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer castn=8 + lvl * 4
    local integer i=1

    loop
        exitwhen i > castn
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0JU' , lvl , "shockwave" , GetUnitX(caster) + 30 * Cos(( 360 / castn ) * i * bj_DEGTORAD) , GetUnitY(caster) + 30 * Sin(( 360 / castn ) * i * bj_DEGTORAD) , 3)
        set i = i + 1
    endloop

    set caster = null
endfunction

function RollStone_Collide takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit missile=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
    local integer i= (GetStoredInteger(cs_cache , I2S(GetHandleId((missile ))) , ( "level"))) // INLINED!!
    local player castplayer=GetOwningPlayer(missile)
    if IsPlayerEnemy(GetOwningPlayer(u) , castplayer) and not IsUnitType(u , UNIT_TYPE_STRUCTURE) then
      call CollisionMissile_SetDirAngle(missile , ( bj_RADTODEG * Atan2(GetUnitY(missile) - GetUnitY(u) , GetUnitX(missile) - GetUnitX(u)) ))
      call RJ_Knockback(u , bj_RADTODEG * Atan2(GetUnitY(u) - GetUnitY(missile) , GetUnitX(u) - GetUnitX(missile)) , 350 , true)
      call CasterCastAbilityLevel(castplayer , 'A0K2' , i , "creepthunderbolt" , u , true)
    endif
    set u = null
    set missile = null
endfunction

function RollStone takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local player castplayer=GetOwningPlayer(caster)
    local location targ=GetSpellTargetLoc()
    local unit missile=CollisionMissile_Create("abilities\\weapons\\catapult\\catapultmissile.mdl" , GetUnitX(caster) , GetUnitY(caster) , bj_RADTODEG * Atan2(GetLocationY(targ) - GetUnitY(caster) , GetLocationX(targ) - GetUnitX(caster)) , 700 , 0 , 800 + ( GetUnitAbilityLevel(caster , 'A0K1') * 300 ) , 80 , false , 125 , function RollStone_Collide)
    call SetUnitScale(missile , 3 , 3 , 3)
    call SetUnitOwner(missile , castplayer , true)
    call AttachInt(missile , "level" , GetUnitAbilityLevel(caster , 'A0K1'))

    set caster = null
    set missile = null
    set castplayer = null
    call RemoveLocation(targ)
    set targ = null
endfunction

function AetherUnleashedCancel takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local timer t=GetAttachedTimer(cast , "AetherUnleashed_timer")
local integer i=0
loop
    exitwhen i > 4
    call KillUnit(GetAttachedUnit(cast , "AESpell_unit" + I2S(i)))
    
    set i = i + 1
endloop
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call DestroyTimer(t)
call IssueImmediateOrder(GetAttachedUnit(cast , "AESpell_caster") , "stop")
set cast = null
set t = null
endfunction

function RetTrig_AetherUnleashedCollider takes nothing returns nothing
local unit mis=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
local unit u=GetTriggerUnit()
local unit cast=GetAttachedUnit(mis , "missileunit")
local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((mis ))) , ( "missileint"))) // INLINED!!
local integer abi='A0MO'
call CollisionMissile_SetTarget(mis , u)
if IsUnitEnemy(u , GetOwningPlayer(mis)) then
call DestroyEffect(AddSpecialEffectTarget(GetAbilityEffectById(abi , EFFECT_TYPE_MISSILE , i + 3) , u , "origin"))
call UnitDamageTarget(cast , u , 50 , true , false , ATTACK_TYPE_MAGIC , DAMAGE_TYPE_FIRE , WEAPON_TYPE_WHOKNOWS)
//call BJDebugMsg(GetUnitName(u)+" is being struck by "+GetUnitName(mis))
endif
if u == null then
call FlushStoredMission(cs_cache , I2S(GetHandleId((mis)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(mis))
call CollisionMissile_Destroy(mis)
endif
set u = null
set cast = null
set mis = null
endfunction

function RetTrig_AetherUnleashedTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit cast=GetAttachedUnit(t , "timerunit")
local integer abi='A0MO'
local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "timerint"))) // INLINED!!
local integer i2=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "timerint2"))) // INLINED!!
local string art=GetAbilityEffectById(abi , EFFECT_TYPE_MISSILE , i)
local real ang=(GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "timerang"))) + 22.5 // INLINED!!
local unit mis=CollisionMissile_Create(art , GetUnitX(cast) , GetUnitY(cast) , ang , 650 , 7 , 900 , 120 , false , 100 , function RetTrig_AetherUnleashedCollider)

call AttachObject(mis , "missileunit" , cast)
call SetUnitOwner(mis , GetOwningPlayer(cast) , true)
set mis = CollisionMissile_Create(art , GetUnitX(cast) , GetUnitY(cast) , ang + 120 , 650 , 45 , 900 , 120 , false , 100 , function RetTrig_AetherUnleashedCollider)

call AttachObject(mis , "missileunit" , cast)
call SetUnitOwner(mis , GetOwningPlayer(cast) , true)
set mis = CollisionMissile_Create(art , GetUnitX(cast) , GetUnitY(cast) , ang + 240 , 650 , 45 , 900 , 120 , false , 100 , function RetTrig_AetherUnleashedCollider)

call AttachObject(mis , "missileunit" , cast)
call SetUnitOwner(mis , GetOwningPlayer(cast) , true)

call AttachReal(t , "timerang" , ang)
if i < 2 then
  call AttachInt(t , "timerint" , i + 1)
else
  call AttachInt(t , "timerint" , 0)
endif
call AttachInt(t , "timerint2" , i2 + 1)

if i2 == 100 then
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call DestroyTimer(t)
endif
set mis = null
set cast = null
set t = null
endfunction


function RetTrig_AetherUnleashed_Conditions takes nothing returns boolean
    return GetSpellAbilityId() == 'A0MO'
endfunction

function RetTrig_AetherUnleashed_Actions takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local unit spawn
local timer t1= CreateTimer()
local real x=GetUnitX(cast)
local real y=GetUnitY(cast)
local real x1
local real y1
local real ang
local player p=GetOwningPlayer(cast)
call DestroyEffect(AddSpellEffectById('A0MO' , EFFECT_TYPE_AREA_EFFECT , GetUnitX(cast) , GetUnitY(cast)))
call AttachObject(cast , "AESpell_caster" , CasterCastAbilityPointEx(GetOwningPlayer(cast) , x , y , 0 , 'A0MP' , 1 , "monsoon" , x , y , 51))
call SetTerrainType(GetUnitX(cast) , GetUnitY(cast) , 'Dlvc' , - 1 , 5 , 0)
call SetTerrainType(GetUnitX(cast) , GetUnitY(cast) , 'Dlav' , - 1 , 2 , 0)
//string MissileModelPath, real x, real y, real dirangle, real speed, real AngleSpeed, real MaxDist,  real height, boolean UseNewCaster, real Collision, code OnImpact    
call AttachObject(t1 , "timerunit" , cast)
call AttachInt(t1 , "timerint" , 0)
call AttachObject(cast , "AetherUnleashed_timer" , t1)
call TimerStart(t1 , 0.5 , true , function RetTrig_AetherUnleashedTimer)
set ang = 0
loop
    exitwhen ang > 288
    set x1 = x + 285 * Cos(ang * bj_DEGTORAD)
    set y1 = y + 285 * Sin(ang * bj_DEGTORAD)
    set spawn = CreateUnit(p , 'n03S' , x1 , y1 , ang)
    call IssueImmediateOrder(spawn , "cripple")
    call UnitApplyTimedLife(spawn , 'BTLF' , 50)
    call AttachObject(cast , "AESpell_unit" + I2S(R2I(ang) / 72) , spawn)
    set ang = ang + 72
endloop
set cast = null
set t1 = null
endfunction

//==== Init Trigger NewTrigger ====
function InitRetTrig_AetherUnleashed takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(t , Condition(function RetTrig_AetherUnleashed_Conditions))
    call TriggerAddAction(t , function RetTrig_AetherUnleashed_Actions)
    set t = null
    call OnAbilityEndCast('A0MO' , "AetherUnleashedCancel")
endfunction

function SacVoidFood takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local player p= GetOwningPlayer(cast)
local unit targ= GetSpellTargetUnit()
local integer curCap = GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_CAP)
if curCap > rj_foodMax[GetPlayerId(p)] + 1.00 then
	set rj_foodMax[GetPlayerId(p)] = curCap + rj_foodMax[GetPlayerId(p)] - R2I(rj_foodMax[GetPlayerId(p)])
endif

set rj_foodMax[GetPlayerId(p)]=rj_foodMax[GetPlayerId(p)] + ( I2R(GetUnitFoodUsed(targ)) * 1.50 )
call SetPlayerState(p , PLAYER_STATE_RESOURCE_FOOD_CAP , R2I(rj_foodMax[GetPlayerId(p)]))
set cast = null
set targ = null
endfunction

function DrainGoldMineForPlayer takes unit goldMine,player whichPlayer returns unit
    local real mineX
    local real mineY
//    local integer mineGold
//    local unit    newMine
    local unit csc=GetACaster()

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(goldMine) != 'ngol' then
        return null
    endif

    call SetUnitOwner(csc , whichPlayer , false)
    // Save the Gold Mine's properties and remove it.
    set mineX = GetUnitX(goldMine)
    set mineY = GetUnitY(goldMine)
    call SetUnitPosition(csc , mineX , mineY + 400)
    call UnitAddAbility(csc , 'A0NA')
    call UnitAddAbility(csc , 'Aro1')
    call IssueTargetOrder(csc , "entangle" , goldMine)
//    call IssuePointOrderById(csc,852619,mineX,mineY)
    call AttachObject(goldMine , "csc" , csc)
//    set mineGold = GetResourceAmount(goldMine)
//    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
//    set newMine = CreateUnit(whichPlayer,'e01L', mineX, mineY, bj_UNIT_FACING)
//    call SetUnitPosition(newMine,mineX,mineY)
//    call SetResourceAmount(newMine, mineGold)
    return bj_lastCreatedUnit
endfunction

function DrainGoldMineForPlayerInstant takes unit goldMine,player whichPlayer returns unit
    local real mineX
    local real mineY
//    local integer mineGold
//    local unit    newMine
    local unit csc=GetACaster()

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(goldMine) != 'ngol' then
        return null
    endif

    call SetUnitOwner(csc , whichPlayer , false)
    // Save the Gold Mine's properties and remove it.
    set mineX = GetUnitX(goldMine)
    set mineY = GetUnitY(goldMine)
    call SetUnitPosition(csc , mineX , mineY + 400)
    call UnitAddAbility(csc , 'A0NA')
    call UnitAddAbility(csc , 'Aro1')
    call IssueTargetOrder(csc , "entangleinstant" , goldMine)
//    call IssuePointOrderById(csc,852619,mineX,mineY)
    call AttachObject(goldMine , "csc" , csc)
//    set mineGold = GetResourceAmount(goldMine)
//    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
//    set newMine = CreateUnit(whichPlayer,'e01L', mineX, mineY, bj_UNIT_FACING)
//    call SetUnitPosition(newMine,mineX,mineY)
//    call SetResourceAmount(newMine, mineGold)
    return bj_lastCreatedUnit
endfunction


function RisenifyGoldMineForPlayer takes unit goldMine,player whichPlayer returns unit
    local real mineX
    local real mineY
//    local integer mineGold
//    local unit    newMine
    local unit csc=GetACaster()

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(goldMine) != 'ngol' then
        return null
    endif

    call SetUnitOwner(csc , whichPlayer , false)
    // Save the Gold Mine's properties and remove it.
    set mineX = GetUnitX(goldMine)
    set mineY = GetUnitY(goldMine)
    call SetUnitPosition(csc , mineX , mineY + 400)
    call UnitAddAbility(csc , 'A0UG')
    call UnitAddAbility(csc , 'Aro1')
    call IssueTargetOrder(csc , "entangle" , goldMine)
//    call IssuePointOrderById(csc,852619,mineX,mineY)
    call AttachObject(goldMine , "csc" , csc)
//    set mineGold = GetResourceAmount(goldMine)
//    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
//    set newMine = CreateUnit(whichPlayer,'e01L', mineX, mineY, bj_UNIT_FACING)
//    call SetUnitPosition(newMine,mineX,mineY)
//    call SetResourceAmount(newMine, mineGold)
    return bj_lastCreatedUnit
endfunction

function RisenifyGoldMineForPlayerInstant takes unit goldMine,player whichPlayer returns unit
    local real mineX
    local real mineY
//    local integer mineGold
//    local unit    newMine
    local unit csc=GetACaster()

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(goldMine) != 'ngol' then
        return null
    endif

    call SetUnitOwner(csc , whichPlayer , false)
    // Save the Gold Mine's properties and remove it.
    set mineX = GetUnitX(goldMine)
    set mineY = GetUnitY(goldMine)
    call SetUnitPosition(csc , mineX , mineY + 400)
    call UnitAddAbility(csc , 'A0UG')
    call UnitAddAbility(csc , 'Aro1')
    call IssueTargetOrder(csc , "entangleinstant" , goldMine)
//    call IssuePointOrderById(csc,852619,mineX,mineY)
    call AttachObject(goldMine , "csc" , csc)
//    set mineGold = GetResourceAmount(goldMine)
//    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
//    set newMine = CreateUnit(whichPlayer,'e01L', mineX, mineY, bj_UNIT_FACING)
//    call SetUnitPosition(newMine,mineX,mineY)
//    call SetResourceAmount(newMine, mineGold)
    return bj_lastCreatedUnit
endfunction

function UnDrainGoldMine takes unit netherMine, unit goldMine returns nothing
//    local real    mineX
//    local real    mineY
//    local integer mineGold
//    local unit    newMine
local unit csc

    // Make sure we're replacing a Gold Mine and not some other type of unit.
    if GetUnitTypeId(netherMine) != 'e01L' and GetUnitTypeId(netherMine) != 'e003' then
        return 
    endif
    set csc = GetAttachedUnit(goldMine , "csc")
	call AttachObject(goldMine,"csc",null)
    call KillUnit(netherMine)
    call UnitRemoveAbility(csc , 'A0NA')
    call UnitRemoveAbility(csc , 'Aro1')
    call RecycleCaster((csc)) // INLINED!!

    // Save the Gold Mine's properties and remove it.
//    set mineX    = GetUnitX(goldMine)
//    set mineY    = GetUnitY(goldMine)
//    set mineGold = GetResourceAmount(goldMine)
//    call RemoveUnit(goldMine)

    // Create a Haunted Gold Mine to replace the Gold Mine.
//    set newMine = CreateUnit(Player(15),'ngol', mineX, mineY, bj_UNIT_FACING)
//    call SetUnitPosition(newMine,mineX,mineY)
//    call SetResourceAmount(newMine, mineGold)
endfunction

function VoidFissure takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
set rdg_delayhack = 3
call CasterCastAbilityLevelPoint((GetOwningPlayer(cast) ) , ( 'A0N6' ) , 1 , ( "flamestrike" ) , (( GetUnitX(cast) )*1.0) , (( GetUnitY(cast) )*1.0) , ( false)) // INLINED!!
call ExplodeUnitBJ(cast)
set cast = null
endfunction

//Ascended Overlord Spells
//Void Hero #3
//Scripts designed by Retera 5/31/2011

function RJ_DistanceBetweenUnits takes unit unitA,unit unitB returns real
    local real dx= GetUnitX(unitB) - GetUnitX(unitA)
    local real dy= GetUnitY(unitB) - GetUnitY(unitA)
    return SquareRoot(dx * dx + dy * dy)
endfunction

function SetUnitPolarPos takes unit u,real xsource,real ysource,real r,real theta returns nothing
    local real x= xsource + r * Cos(theta)
    local real y= ysource + r * Sin(theta)
    call CS_MoveUnit(u , x , y)
endfunction

function RJ_Knockback_NewThreadFunc takes nothing returns nothing
//local timer t=GetExpiredTimer()
call RJ_Knockback(bj_lastCreatedUnit , rdg_TempReal , bj_meleeNearestMineDist , bj_slotControlReady)
//call DestroyTimer(t)
//set t=null
endfunction

function RJ_Knockback_NewThread takes unit victim,real angle,real distance,boolean doEffect returns nothing
//local timer t=CreateTimer()
set bj_lastCreatedUnit = victim
set rdg_TempReal = angle
set bj_meleeNearestMineDist = distance
set bj_slotControlReady = doEffect
//call TimerStart(t,0.05,false,function RJ_Knockback_NewThreadFunc)
call ExecuteFunc("RJ_Knockback_NewThreadFunc")
//set t=null
endfunction

function VoidicPossessionMinionDeath takes nothing returns nothing
local trigger t=GetTriggeringTrigger()
local unit s=GetAttachedUnit(t , "trigspawn")
local unit u=GetAttachedUnit(t , "trigunit")
call ShowUnit(s , false)
call SetUnitPosition(u , GetUnitX(s) , GetUnitY(s))
call SetUnitFacing(u , GetUnitFacing(s))
call ShowUnit(u , true)
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call RemoveUnit(s)
call DestroyTrigger(t)
set t = null
set s = null
set u = null
endfunction


function VoidicPossession takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local player p=GetOwningPlayer(cast)
local integer typeid='n03W'
local trigger t
local unit spawn
local player p2=GetOwningPlayer(target)
if IsUnitAlly(target , p) then
//call UnitRemoveAbility(cast,'')//EngineeringUpgrade for enemy
//call UnitAddAbility(cast,'')//EngineeringUpgrade for ally
if GetUnitTypeId(target) != 'n03U' and GetUnitTypeId(target) != 'n03V' and GetUnitTypeId(target) != 'n03W' then
call ShowUnit(target , false)
call IssueImmediateOrder(target , "stop")
if lvl == 1 then
set typeid = 'n03U'
elseif lvl == 2 then
set typeid = 'n03V'
endif
set spawn = CreateUnit(p , typeid , GetUnitX(target) , GetUnitY(target) , GetUnitFacing(target))
call UnitApplyTimedLife(spawn , 'BTLF' , 5 + 10 * lvl)
set t = CreateTrigger()
call TriggerRegisterUnitEvent(t , spawn , EVENT_UNIT_DEATH) //This creates a trigger, when spawned unit dies the old unit returns
call AttachObject(t , "trigspawn" , spawn)
call AttachObject(t , "trigunit" , target)
call TriggerAddAction(t , function VoidicPossessionMinionDeath)
//The timed life will inevitably kill the unit and activate the trigger, so no more scripting is needed here
endif
elseif IsUnitType(target , UNIT_TYPE_HERO) then
call CasterCastAbilityLevel(p , 'A0MZ' , lvl , "thunderbolt" , target , true)
elseif IsUnitType(target , UNIT_TYPE_PEON) and IsUnitType(target, UNIT_TYPE_MECHANICAL) then
call CasterCastAbilityLevel(p , 'A0MZ' , lvl , "thunderbolt" , target , true)
elseif IsUnitType(target , UNIT_TYPE_PEON) then
call KillUnit(target)
else //(target is not an ally AND not a hero)
//call CasterCastAbilityLevel(p,'A0MQ',lvl,"bloodlust",target,true)
if (GetStoredInteger(cs_cache , I2S(GetHandleId((target ))) , ( "VP_count"))) == 0 then // INLINED!!
call AttachInt(target , "VP_owner_original" , GetConvertedPlayerId(p2))
call AttachInt(target , "VP_count" , 1)
call UnitAddAbility(target , 'A0MQ')
call SetUnitOwner(target , p , false)
else
call AttachInt(target , "VP_count" , (GetStoredInteger(cs_cache , I2S(GetHandleId((target ))) , ( "VP_count"))) + 1) // INLINED!!
call SetUnitOwner(target , p , false)
endif
call PolledWait(5 + 10 * lvl)
if (GetStoredInteger(cs_cache , I2S(GetHandleId((target ))) , ( "VP_count"))) == 1 then // INLINED!!
call AttachInt(target , "VP_count" , 0)
call UnitRemoveAbility(target , 'A0MQ')
call SetUnitOwner(target , ConvertedPlayer((GetStoredInteger(cs_cache , I2S(GetHandleId((target ))) , ( "VP_owner_original")))) , true) // INLINED!!
call AttachInt(target , "VP_owner_original" , 0)
else
call AttachInt(target , "VP_count" , (GetStoredInteger(cs_cache , I2S(GetHandleId((target ))) , ( "VP_count"))) - 1) // INLINED!!
call SetUnitOwner(target , p2 , false)
endif
endif
set cast = null
set target = null
set t = null
set spawn = null
set p2 = null
set p = null
endfunction


function RetTrig_VoidicPossesion_Conditions takes nothing returns boolean
    return GetIssuedOrderId() == OrderId("antimagicshell") and GetUnitTypeId(GetOrderedUnit()) == 'U01L'
endfunction

function RetTrig_VoidicPossesion_Actions takes nothing returns nothing
local unit u=GetOrderedUnit()
if IsUnitAlly(GetOrderTargetUnit() , GetOwningPlayer(u)) then
call UnitRemoveAbility(u , 'A0MT')
else
call UnitAddAbility(u , 'A0MT')
call SetPlayerAbilityAvailable(GetOwningPlayer(u) , 'A0MT' , false)
endif
set u = null
endfunction


function RiftBurst_Condition takes nothing returns boolean
    return IsUnitEnemy(GetFilterUnit() , GetOwningPlayer(GetSpellAbilityUnit())) and (( not ( GetUnitMoveSpeed(GetFilterUnit()) == 0.00 ) ) and not IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE)) and IsUnitAliveBJ(GetFilterUnit()) and IsUnitVisible(GetFilterUnit() , GetOwningPlayer(GetSpellAbilityUnit())) // INLINED!!
endfunction


function RiftBurst_Func takes nothing returns nothing
local unit e=GetEnumUnit()
local unit cast=GetSpellAbilityUnit()
local real dx= GetUnitX(e) - GetUnitX(cast)
local real dy= GetUnitY(e) - GetUnitY(cast)
local integer lvl=R2I(rdg_TempReal)
call RJ_Knockback_NewThread(e , KS_AngleBetweenUnits(cast , e) , 1000 - ( SquareRoot(dx * dx + dy * dy) ) , false)
set rdg_delayhack = 3
call CasterCastAbilityLevel(GetOwningPlayer(cast) , 'A0MV' , lvl , "chainlightning" , e , false)
set e = null
set cast = null
endfunction

function RiftBurst takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local unit target=GetSpellTargetUnit()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local player p=GetOwningPlayer(cast)
local group g=CreateGroup()
local boolexpr b=Condition(function RiftBurst_Condition)
local real dx= GetUnitX(target) - GetUnitX(cast)
local real dy= GetUnitY(target) - GetUnitY(cast)
local unit e
local integer i
call GroupEnumUnitsInRange(g , GetUnitX(cast) , GetUnitY(cast) , 500 , b)
//call BJDebugMsg("Enumed nearbies")
set rdg_TempReal = I2R(lvl)
//call BJDebugMsg("Level = "+R2S(rdg_TempReal))
call GroupRemoveUnit(g , target)
//call BJDebugMsg("Removed "+GetUnitName(target))
call GroupRemoveUnit(g , cast)
//call BJDebugMsg("Removed "+GetUnitName(cast))
//call ForGroup(g,function RiftBurst_Func)
set i = 0
loop
//    call BJDebugMsg("Began loop")
    exitwhen i > 40
//    call BJDebugMsg("Knows when to quit")
    set e = FirstOfGroup(g)
//    call BJDebugMsg("Is unit group empty?")
    exitwhen e == null
//    call BJDebugMsg("No, group not empty")
    call GroupRemoveUnit(g , e)
//    call BJDebugMsg("Iterating over "+GetUnitName(e))
    call RJ_Knockback_NewThread(e , KS_AngleBetweenUnits(cast , e) , 1000 - RJ_DistanceBetweenUnits(e , cast) , false)
    call CasterCastAbilityEx(GetOwningPlayer(cast) , GetUnitX(cast) , GetUnitY(cast) , GetUnitFlyHeight(cast) , 'A0MV' , lvl , "chainlightning" , e , 3)
    set i = i + 1
endloop
//    call BJDebugMsg("Yes, group empty")
call RJ_Knockback_NewThread(target , KS_AngleBetweenUnits(target , cast) , ( SquareRoot(dx * dx + dy * dy) ) - 100 , false)
//set rdg_delayhack=3
call CasterCastAbilityEx(GetOwningPlayer(cast) , GetUnitX(cast) , GetUnitY(cast) , GetUnitFlyHeight(cast) , 'A0MW' , lvl , "chainlightning" , target , 3)
//call BJDebugMsg("WE CAST RIFT BURST")
call DestroyBoolExpr(b)
set b = null
set cast = null
call DestroyGroup(g)
set g = null
set target = null
set p = null
endfunction

function AddLightningOnUnitsTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local lightning l=GetAttachedLightning(t , "timerlightning")
local unit u1=GetAttachedUnit(t , "timerunit")
local unit u2=GetAttachedUnit(t , "timerunit2")
local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "timeri"))) // INLINED!!
local boolean checkVis=(GetStoredBoolean(cs_cache , I2S(GetHandleId((t ))) , ( "timerboolean"))) // INLINED!!
local real dur=(GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "timerreal"))) // INLINED!!
if not MoveLightning(l , checkVis , GetUnitX(u1) , GetUnitY(u1) , GetUnitX(u2) , GetUnitY(u2)) then
call SetLightningColor(l , 0 , 0 , 0 , 0)
endif
if i > dur * 100 or l == null then
if l != null then
call DestroyLightning(l)
endif
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call DestroyTimer(t)
else
if dur > 0 then
call AttachInt(t , "timeri" , i + 1)
call SetLightningColor(l , GetLightningColorR(l) , GetLightningColorG(l) , GetLightningColorB(l) , ( ( ( dur * 100 ) - i ) / ( dur * 100 ) ))
endif
//call BJDebugMsg("Setting to R: "+R2S(GetLightningColorR(l))+" G: "+R2S(GetLightningColorG(l))+" B: "+R2S(GetLightningColorB(l))+" A: "+R2S((((dur*100)-i)/(dur*100))))
endif

set t = null
set u1 = null
set u2 = null
set l = null
endfunction

function AddLightningOnUnits takes string codeName,boolean checkVisibility,unit u1,unit u2,real duration returns lightning
local timer t=CreateTimer()
local integer i
set bj_lastCreatedLightning = AddLightningEx(codeName , false , GetUnitX(u1) , GetUnitY(u1) , GetUnitFlyHeight(u1) , GetUnitX(u2) , GetUnitY(u2) , GetUnitFlyHeight(u2))
call AttachLightning(t , "timerlightning" , bj_lastCreatedLightning)
call AttachObject(bj_lastCreatedLightning , "lightningtimer" , t)
call AttachObject(t , "timerunit" , u1)
call AttachObject(t , "timerunit2" , u2)
call AttachBoolean(t , "timerboolean" , checkVisibility)
call AttachReal(t , "timerreal" , duration)
call TimerStart(t , 0.01 , true , function AddLightningOnUnitsTimer)
set t = null
return bj_lastCreatedLightning
endfunction

function RemoveLightningFromUnits takes lightning whichBolt returns nothing
local timer t= GetAttachedTimer(whichBolt , "lightningtimer")
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call DestroyTimer(t)
call DestroyLightning(whichBolt)
set t = null
endfunction

function ObliterationSpell_Condition takes nothing returns boolean
    return IsUnitEnemy(GetFilterUnit() , GetOwningPlayer(bj_lastCreatedUnit)) and (( not ( GetUnitMoveSpeed(GetFilterUnit()) == 0.00 ) ) and not IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE)) and IsUnitAliveBJ(GetFilterUnit()) and IsUnitVisible(GetFilterUnit() , GetOwningPlayer(bj_lastCreatedUnit)) // INLINED!!
endfunction


function ObliterationSpellEnum takes nothing returns nothing
local unit u=GetEnumUnit()
local unit cast=bj_lastCreatedUnit
local integer lvl=GetUnitAbilityLevel(cast , 'A0MY')
local real dist=RJ_DistanceBetweenUnits(u , cast)
local real colordist=( ( 1000 - dist ) / 1000 )
local real dmg
call SetLightningColor(AddLightningOnUnits("OBL1" , true , cast , u , 3) , 1 , colordist , colordist , 1)
if lvl == 1 then
set dmg = dist / 100
elseif lvl == 2 then
set dmg = ( dist / 75 ) + ( 5 / 3 )
elseif lvl == 3 then
set dmg = ( dist / 45 ) + ( 25 / 9 )
else
set dmg = 99999
endif
call UnitDamageTarget(cast , u , dmg , true , true , ATTACK_TYPE_MAGIC , DAMAGE_TYPE_SHADOW_STRIKE , WEAPON_TYPE_WHOKNOWS)
set u = null
set cast = null
endfunction

function ObliterationSpellTimer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "timerunit")
    local group enumz
    local boolexpr b=Condition(function ObliterationSpell_Condition)
local sound s=GetAttachedSound(Player(0) , "LightningBoltSound")
if s == null then
set s = CreateSound("Abilities\\Spells\\Orc\\LightningBolt\\LightningBolt.wav" , false , true , true , 10 , 10 , "SpellsEAX")
call SetSoundParamsFromLabel(s , "LightningBolt")
call SetSoundDuration(s , 2136)
call AttachObject(Player(0) , "LightningBoltSound" , s)
endif
call SetSoundPosition(s , GetUnitX(u) , GetUnitY(u) , 30)
call SetSoundVolume(s , 127)
call StartSound(s)
    if ( GetUnitAbilityLevel(u , 'B03N') > 0 ) then
    set enumz = GetAttachedGroup(u , "AO_enumz")
    if enumz == null then
    set enumz = CreateGroup()
    call AttachObject(u , "AO_enumz" , enumz)
    endif
    call GroupClear(enumz)
    set bj_lastCreatedUnit = u
    call GroupEnumUnitsInRange(enumz , GetUnitX(u) , GetUnitY(u) , 1000 , b)
    call ForGroup(enumz , function ObliterationSpellEnum)


    else
    call PauseTimer(t)
    call AttachBoolean(t , "isRunning" , false)
    endif
    set u = null

    set t = null
    call DestroyBoolExpr(b)
    set b = null
    set enumz = null
    set s = null
endfunction

function ObliterationSpell takes nothing returns nothing
    local unit u=GetSpellAbilityUnit()
    local timer t=GetAttachedTimer(u , "AO_ObliTim")
    if t == null then
    set t = CreateTimer()
    call AttachBoolean(t , "isRunning" , true)
    call TimerStart(t , 1.00 , true , function ObliterationSpellTimer)
    call AttachObject(t , "timerunit" , u)
    call AttachObject(u , "AO_ObliTim" , t)
    elseif (GetStoredBoolean(cs_cache , I2S(GetHandleId((t ))) , ( "isRunning"))) == false then // INLINED!!
    call PauseTimer(t)
    call TimerStart(t , 1.00 , true , function ObliterationSpellTimer)
    call AttachBoolean(t , "isRunning" , true)
    endif
set u = null
set t = null
endfunction


function RetTrig_DDND_Conditions takes nothing returns boolean
local unit u=GetSummonedUnit()
local integer i=GetUnitTypeId(u)
local boolean b= ( i == 'n034' )
set b = b or i == 'n035'
set b = b or i == 'n036'
set b = b or i == 'n03P'
set b = b or i == 'n03O'
set b = b or i == 'n03Q'
set b = b or i == 'n02Q'
set u = null
set i = 0
    return b
endfunction

function RetTrig_DDND_Actions takes nothing returns nothing
local unit spawn=GetSummonedUnit()
local unit cast=GetSummoningUnit()
local unit source
local integer i=GetUnitTypeId(spawn)
local group g
if i == 'n036' then
call AttachObject(cast , "DDND_0" , spawn)
elseif i == 'n034' then
call AttachObject(cast , "DDND_1" , spawn)
elseif i == 'n035' then
call AttachObject(cast , "DDND_2" , spawn)
elseif i == 'n03P' or i == 'n03O' or i == 'n03Q' then
set g = GetAttachedGroup(cast , "MawTent_group")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "MawTent_group" , g)
endif
call GroupAddUnit(g , spawn)
else
set source = GetAttachedUnit(cast , "caster")
call AttachObject(cast,"caster",null)
set g = GetAttachedGroup(cast , "MawTent_group")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "MawTent_group" , g)
endif
call GroupAddUnit(g , spawn)
endif
//call BJDebugMsg("INFERNAL SPAWN")
//call ShowUnit(spawn,false)
set spawn = null
set cast = null
set source = null
endfunction


function DDND_Cast takes nothing returns nothing
local unit mis=bj_lastCreatedUnit
local integer n=(GetStoredInteger(cs_cache , I2S(GetHandleId((mis ))) , ( "n"))) // INLINED!!
local real tx=(GetStoredReal(cs_cache , I2S(GetHandleId((mis ))) , ( "tx"))) // INLINED!!
local real ty=(GetStoredReal(cs_cache , I2S(GetHandleId((mis ))) , ( "ty"))) // INLINED!!
local unit cast=GetAttachedUnit(mis , "cast")
local unit cscaster
    call DestroyEffect(GetAttachedEffect(GetExpiredTimer() , "fx" + I2S(n)))
    //call ShowUnit(mis,false)
    call ProjectileLaunchEx(Player(15) , (GetAbilityEffectById('A0N0' , EFFECT_TYPE_MISSILE , n) ) , 1 , 255 , 255 , 255 , 255 , (( 800 )*1.0) , (( 0.2 )*1.0) , (( GetUnitX(mis) )*1.0) , (( GetUnitY(mis) )*1.0) , (( 30 )*1.0) , (( tx )*1.0) , (( ty )*1.0) , (( 30)*1.0)) // INLINED!!
    if n == 0 then
    set cscaster = CasterCastAbilityPointEx(GetOwningPlayer(cast) , tx , ty , 0 , 'A0N1' , 1 , "dreadlordinferno" , tx , ty , 10)
    elseif n == 1 then
    set cscaster = CasterCastAbilityPointEx(GetOwningPlayer(cast) , tx , ty , 0 , 'A0N2' , 1 , "dreadlordinferno" , tx , ty , 10)
    set rdg_delayhack = 6
call CasterCastAbilityLevelPoint((GetOwningPlayer(cast) ) , ( 'A0N3' ) , 1 , ( "howlofterror" ) , (( tx )*1.0) , (( ty )*1.0) , ( false)) // INLINED!!
    else
    set cscaster = CasterCastAbilityPointEx(GetOwningPlayer(cast) , tx , ty , 0 , 'A0N4' , 1 , "dreadlordinferno" , tx , ty , 10)
    set rdg_delayhack = 5
call CasterCastAbilityLevelPoint((GetOwningPlayer(cast) ) , ( 'A0N5' ) , 1 , ( "earthquake" ) , (( tx )*1.0) , (( ty )*1.0) , ( false)) // INLINED!!
    endif
    call PolledWait(3)
    call AttachObject(cast , "spawn" + I2S(n) , GetAttachedUnit(cscaster , "DDND_" + I2S(n)))
    set cast = null
    set cscaster = null
    set mis = null
endfunction

function DoomDeathNDest_Timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit cast=GetAttachedUnit(t , "cast")
local unit array mis
local real ang
local real cx=GetUnitX(cast)
local real cy=GetUnitY(cast)
local real dist
local integer i=0
local integer ix=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "ixJKJKJKJ"))) + 1 // INLINED!!
local real x
local real y
local location targ=GetAttachedLoc(t , "targ")
local real tx=GetLocationX(targ)
local real ty=GetLocationY(targ)
local real MAXDIST=200
local integer misnum=3
local integer ipercircle=100

//        call BJDebugMsg("Looping "+I2S(ix))
    //set dist=(-200/((ix*(25/100))+(200/198)))+200
    set dist = MAXDIST
    set ang = (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "ang"))) // INLINED!!
call AttachInt(t , "ixJKJKJKJ" , ix)
call AttachReal(t , "ang" , ang + bj_PI / ( ipercircle / 2.0 ))


    if ix < ipercircle * 8 then
        set dist = MAXDIST * ( 1 - ( 1 / ang ) )
    endif
    
//    call BJDebugMsg("Distance = "+R2S(dist))        
loop
    exitwhen i >= misnum
    set mis[i]=GetAttachedUnit(t , "mis" + I2S(i))
//    call BJDebugMsg("Angle = "+R2S((ang+((2.0*i)/I2R(misnum))*bj_PI)+GetAttachedReal(t,"ang0")))
    call SetUnitPolarPos(mis[i] , cx , cy , dist , ( ang + ( ( 2.0 * i ) / I2R(misnum) ) * bj_PI ) + (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "ang0")))) // INLINED!!
    //if ix<ipercircle*8 then
    //call SetUnitFacing(mis[i],((1/Pow((ang),2))+((2.0*i)/I2R(misnum))*bj_PI+GetAttachedReal(t,"ang0"))*bj_RADTODEG)
    //else
    call SetUnitFacing(mis[i] , ( ( ang + ( ( 2.0 * i ) / I2R(misnum) ) * bj_PI ) + (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "ang0"))) ) * bj_RADTODEG + 90) // INLINED!!
    //endif    
    set i = i + 1
endloop
    if ix == 350 then
    set bj_lastCreatedUnit = mis[0]
    call AttachInt(mis[0] , "n" , 0)
    call AttachReal(mis[0] , "tx" , tx)
    call AttachReal(mis[0] , "ty" , ty)
    call AttachObject(mis[0] , "cast" , cast)
    call ExecuteFunc("DDND_Cast")
//        call BJDebugMsg("THREE HUNDRED FIFTY MILLISECONDS")

    endif
    
    if ix == 650 then
//        call BJDebugMsg("SIX HUNDRED FIFTY MILLISECONDS") 
    set bj_lastCreatedUnit = mis[1]
    call AttachInt(mis[1] , "n" , 1)
    call AttachReal(mis[1] , "tx" , tx)
    call AttachReal(mis[1] , "ty" , ty)
    call AttachObject(mis[1] , "cast" , cast)
    call ExecuteFunc("DDND_Cast")
    
//    call ShowUnit(mis[1],false)

    endif
    
    if ix == 950 then
//        call BJDebugMsg("NINE HUNDRED FIFTY MILLISECONDS")
    set bj_lastCreatedUnit = mis[2]
    call AttachInt(mis[2] , "n" , 2)
    call AttachReal(mis[2] , "tx" , tx)
    call AttachReal(mis[2] , "ty" , ty)
    call AttachObject(mis[2] , "cast" , cast)
    call ExecuteFunc("DDND_Cast")
//    call ShowUnit(mis[2],false)

    endif

if ix > 950 then
//call DestroyEffect(GetAttachedEffect(t,"fx1"))
//call DestroyEffect(GetAttachedEffect(t,"fx2"))
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call DestroyTimer(t)
call ShowUnit(mis[0] , true)
call ShowUnit(mis[1] , true)
call ShowUnit(mis[2] , true)
call RecycleCaster((mis[0])) // INLINED!!
call RecycleCaster((mis[1])) // INLINED!!
call RecycleCaster((mis[2])) // INLINED!!
call RemoveLocation(targ)
endif


set t = null
set targ = null
set cast = null
set mis[0]=null
set mis[1]=null
set mis[2]=null
set mis[3]=null
set mis[4]=null
endfunction


function DoomDeathNDest takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local location targloc=GetSpellTargetLoc()
//local location center=GetUnitLoc(cast)
//local unit array spawn
local unit array mis
local integer i=0
local integer ix
local effect array fx
local real x
local real y
local real array ang
local real array fac
local real cx=GetUnitX(cast)
local real cy=GetUnitY(cast)
local real array dist
local timer t
local integer amtrmn=0
local timer t2
local real timeRemaining
//call UnitAddAbility(cast,'A0GO')
//call IssueImmediateOrder(cast,"elementalfury")
//call PolledWait(0.5)
//call UnitRemoveAbility(cast,'A0GO')
call ShowUnit(cast , false)
call UnitRemoveBuffs(cast , true , true)
loop
    exitwhen i > 2
    set mis[i]=GetACaster()
    set fx[i]=AddSpecialEffectTarget(GetAbilityEffectById('A0N0' , EFFECT_TYPE_MISSILE , i) , mis[i] , "origin")
    call SetUnitFlyHeight(mis[i] , 100 , 0.00)
    set ang[i]=GetUnitFacing(cast) + ( 120 * i )
    set fac[i]=ang[i]
    set dist[i]=2
    set x = cx + dist[i] * Cos(ang[i] * bj_DEGTORAD)
    set y = cy + dist[i] * Sin(ang[i] * bj_DEGTORAD)
    call CS_MoveUnit(mis[i] , x , y)
    call SetUnitFacing(mis[i] , fac[i])
    set i = i + 1
endloop


set t = CreateTimer()

    set i = 0
    loop
        exitwhen i > 2
        call AttachObject(t , "mis" + I2S(i) , mis[i])
        call AttachObject(t , "fx" + I2S(i) , fx[i])
        call AttachReal(t , "ang" + I2S(i) , ang[i] * bj_DEGTORAD)
        set i = i + 1
    endloop
    call AttachObject(t , "cast" , cast)
    call AttachObject(t , "targ" , targloc)
call AttachReal(t , "ang" , 1)
call TimerStart(t , 0.01 , true , function DoomDeathNDest_Timer)


        set t2 = CreateTimer()
        call TimerStart(t2 , 62.5 , false , null)
        loop
            set timeRemaining = TimerGetRemaining(t2)
            exitwhen timeRemaining <= 0
            exitwhen ( timeRemaining <= 52 ) and ( IsUnitDeadBJ(GetAttachedUnit(cast , "spawn0")) ) and ( IsUnitDeadBJ(GetAttachedUnit(cast , "spawn1")) ) and ( IsUnitDeadBJ(GetAttachedUnit(cast , "spawn2")) )

            // If we have a bit of time left, skip past 10% of the remaining
            // duration instead of checking every interval, to minimize the
            // polling on long waits.
            if ( timeRemaining > bj_POLLED_WAIT_SKIP_THRESHOLD ) then
                call TriggerSleepAction(0.05 * timeRemaining)
            else
                call TriggerSleepAction(bj_POLLED_WAIT_INTERVAL)
            endif
        endloop
        call DestroyTimer(t2)

    
set i = 2
set mis[3]=GetAttachedUnit(cast , "spawn0")
loop
    exitwhen i < 0
    set mis[i]=GetAttachedUnit(cast , "spawn" + I2S(i))
    if IsUnitAliveBJ(mis[i]) then
    set amtrmn = amtrmn + 1
    set mis[3]=mis[i]
    call KillUnit(mis[i])
    endif
    set i = i - 1
endloop
call CS_MoveUnit(cast , GetUnitX(mis[3]) , GetUnitY(mis[3]))
call ShowUnit(cast , true)
call SetUnitState(cast , UNIT_STATE_LIFE , ( GetUnitState(cast , UNIT_STATE_LIFE) * amtrmn ) / 3.00)
//call RemoveLocation(targloc)
set targloc = null
set cast = null
set fx[0]=null
set fx[1]=null
set fx[2]=null
set t = null
set mis[0]=null
set mis[1]=null
set mis[2]=null
set mis[3]=null
endfunction


function DDNDRegister takes nothing returns boolean
local unit u=GetEnteringUnit()
local integer i=GetUnitTypeId(u)
local boolean b= i == 'n034' or i == 'n035' or i == 'n036'
set u = null
set i = 0
    return b
endfunction

function InitRetSpells_AscendedOverlord takes nothing returns nothing
    local trigger t= CreateTrigger()
    local integer s
    local integer D
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_VoidicPossesion_Conditions))
    call TriggerAddAction(t , function RetTrig_VoidicPossesion_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SUMMON)
//    call TriggerRegisterEnterRectSimple(t,bj_mapInitialPlayableArea)//,Filter(function DDNDRegister))
    call TriggerAddCondition(t , Condition(function RetTrig_DDND_Conditions)) //function DDNDRegister))//
    call TriggerAddAction(t , function RetTrig_DDND_Actions)
    set t = null
    call OnAbilityEffect('A0MR' , "VoidicPossession")
    call OnAbilityEffect('A0MS' , "VoidicPossession")
    call OnAbilityEffect('A0MX' , "RiftBurst")
    call OnAbilityEffect('A0MY' , "ObliterationSpell")
    call OnAbilityEffect('A0N0' , "DoomDeathNDest")
 //==================================
 //Death's Nova ('A0N3')
 set s = SetSpellTemplate('A0N3' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_DEATH) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 6) // 0.5 seconds of duration for all levels
//    call SetAbilityDataReal(s,"turninc"      ,0,12 )  // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 0 , 80) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above
    
endfunction

function RetTrig_NetherGoldMineLocator_Conditions takes nothing returns boolean
    return GetUnitTypeId(GetConstructingStructure()) == 'e01L' or GetUnitTypeId(GetConstructingStructure()) == 'e003'
endfunction

function RetTrig_NetherGoldMineLocator_Actions takes nothing returns nothing
set bj_lastCreatedUnit = GetConstructingStructure()
endfunction

//==== Init Trigger NetherGoldMineLocator ====
function InitRetTrig_NetherGoldMineLocator takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_START)
    call TriggerAddCondition(t , Condition(function RetTrig_NetherGoldMineLocator_Conditions))
    call TriggerAddAction(t , function RetTrig_NetherGoldMineLocator_Actions)
endfunction

function RetTrig_NetherGoldMineLocator2_Conditions takes nothing returns boolean
    return GetUnitTypeId(GetConstructedStructure()) == 'e01L' or GetUnitTypeId(GetConstructedStructure()) == 'e003'
endfunction

function RetTrig_NetherGoldMineLocator2_Actions takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure() , 'A0NI')
endfunction

//==== Init Trigger NetherGoldMineLocator2 ====
function InitRetTrig_NetherGoldMineLocator2 takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_NetherGoldMineLocator2_Conditions))
    call TriggerAddAction(t , function RetTrig_NetherGoldMineLocator2_Actions)
endfunction

function RetTrig_Drain_Gold2_Conditions takes nothing returns boolean
    return ( ( GetIssuedOrderId() == OrderId("entangle") ) or ( GetIssuedOrderId() == OrderId("entangleinstant") ) ) and ( GetUnitAbilityLevel(GetOrderedUnit() , 'A0G6') >= 1 ) and ( RJ_DistanceBetweenUnits(GetOrderedUnit() , GetOrderTargetUnit()) <= 1500 )
endfunction

function RetTrig_Drain_Gold2_Actions takes nothing returns nothing
    local unit u=GetOrderedUnit() //GetSpellAbilityUnit()
    local unit gm
 local unit gm2= GetOrderTargetUnit()
    local integer amt=9
    local location l=GetUnitLoc(u)
    local location l2
    local boolean instant=false
    call TriggerSleepAction(0.01)
if GetIssuedOrderId() == OrderId("entangleinstant") then
set gm = DrainGoldMineForPlayerInstant(GetOrderTargetUnit() , GetOwningPlayer(u))
set instant = true
else
set gm = DrainGoldMineForPlayer(GetOrderTargetUnit() , GetOwningPlayer(u))
endif
set l2 = GetUnitLoc(gm)
if GetUnitTypeId(gm) == 'e01L' then
    if GetAttachedObject(u , "dg_GoldMine") == null then

    call UnitRemoveAbilityBJ('A0G6' , u)
    call UnitAddAbilityBJ('A0N9' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0N9')

    call AttachObject(u , "dg_GoldMine" , gm)

    call AttachLightning(u , "dg_GOLD_Effect" , AddLightningLoc("GLDP" , l , l2))
if not ( instant ) then
    loop
        exitwhen ( GetUnitAbilityLevel(gm , 'A0NI') >= 1 ) or ( IsUnitDeadBJ(u) == true ) or ( IsUnitDeadBJ(gm) == true ) or GetUnitAbilityLevel(u , 'A0N9') <= 0
        call TriggerSleepAction(0)
    endloop
endif

    loop
        exitwhen ( IsUnitDeadBJ(u) == true ) or ( IsUnitDeadBJ(gm) == true ) or GetUnitAbilityLevel(u , 'A0N9') <= 0
        call AddResourceAmount(gm , - amt)
		if GetResourceAmount(gm) <= 0 then
		  call KillUnit(gm)
		endif
		if GetResourceAmount(gm2) <= 0 then
		  call KillUnit(gm2)
		endif
        call SimResourceGet(GetOwningPlayer(u) , ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 , l2 , 100.00 , 86.27 , 0.00 , false)

        call AdjustPlayerStateBJ(( ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 ) , GetOwningPlayer(u) , PLAYER_STATE_RESOURCE_GOLD)

        call PolledWait(1.20)
    endloop

    call UnDrainGoldMine(gm,gm2)
	if GetResourceAmount(gm2) <= 0 then
	  call KillUnit(gm2)
	endif
    call AttachObject(u , "dg_GoldMine" , null)
    call UnitAddAbilityBJ('A0G6' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0G6')
    call UnitRemoveAbilityBJ('A0N9' , u)
    call DestroyLightning(GetAttachedLightning(u , "dg_GOLD_Effect"))
    call AttachLightning(u , "dg_GOLD_Effect" , null)

    endif
    endif
    call RemoveLocation(l)
    call RemoveLocation(l2)
    set gm = null
	set gm2 = null
    set u = null
    set l = null
set l2 = null
endfunction


function RetTrig_Drain_Gold2_RetTrig_2_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0N9' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold2_RetTrig_2_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call TriggerSleepAction(0.00)
    call UnitAddAbilityBJ('A0G6' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0G6')
    call UnitRemoveAbilityBJ('A0N9' , u)
  set u = null
endfunction

//===========================================================================
function InitRetTrig_Drain_Gold2_RetTrig_2 takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold2_RetTrig_2_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold2_RetTrig_2_Actions)
  set t = null
endfunction


//===========================================================================
function InitRetTrig_Drain_Gold2 takes nothing returns nothing
  local trigger t=CreateTrigger()
    call InitRetTrig_Drain_Gold2_RetTrig_2()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold2_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold2_Actions)
  set t = null
endfunction

function ProjectileLaunchExTimelessTimer takes nothing returns nothing
local timer t=bj_lastStartedTimer
call ProjectileLaunchEx(Player((GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "ownerid")))) , (GetStoredString(cs_cache , I2S(GetHandleId((t ))) , ( "modelpath"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "scale"))) , (GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "red"))) , (GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "green"))) , (GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "blue"))) , (GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "alpha"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "speed"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "arc"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "x1"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "y1"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "z1"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "x2"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "y2"))) , (GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "z2")))) // INLINED!!
call CS_KillTimer(t)
set t = null
endfunction
function ProjectileLaunchExTimeless takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns nothing
local timer t=CreateTimer()
call AttachInt(t , "ownerid" , GetPlayerId(owner))
call AttachString(t , "modelpath" , modelpath)
call AttachReal(t , "scale" , scale)
call AttachInt(t , "red" , red)
call AttachInt(t , "green" , green)
call AttachInt(t , "blue" , blue)
call AttachInt(t , "alpha" , alpha)
call AttachReal(t , "speed" , speed)
call AttachReal(t , "arc" , arc)
call AttachReal(t , "x1" , x1)
call AttachReal(t , "y1" , y1)
call AttachReal(t , "z1" , z1)
call AttachReal(t , "x2" , x2)
call AttachReal(t , "y2" , y2)
call AttachReal(t , "z2" , z2)
set bj_lastStartedTimer = t
call ExecuteFunc("ProjectileLaunchExTimelessTimer")
set t = null
endfunction

function ProjectileLaunchKill2 takes player owner,string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2,real scale returns nothing
call ProjectileLaunchExTimeless(owner , modelpath , scale , 255 , 255 , 255 , 255 , speed , arc , x1 , y1 , z1 , x2 , y2 , z2)
endfunction

function VGDestructiveFormTimer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit cast=GetAttachedUnit(t , "timerunit")
    local unit da=GetAttachedUnit(t , "da")
    local unit db=GetAttachedUnit(t , "db")
    local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "i"))) + 1 // INLINED!!
    local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "lvl"))) // INLINED!!
    

    
    
    if db != null then
//    call BJDebugMsg("Found a db unit, id "+I2S(CS_H2I(db)))
    call RemoveUnit(db)
    call AttachObject(t , "db" , null)
//    call BJDebugMsg("Removing db: "+GetUnitName(db)+", id: "+I2S(CS_H2I(db)))
    set db = null
    endif
    set db = da
    if db != null then
//    call BJDebugMsg("New db: "+GetUnitName(db)+", id: "+I2S(CS_H2I(db))+", inherited from da, storing...")
    call AttachObject(t , "db" , db)
    endif
    
    if ( i / 5 ) < ( 5 + ( 5 * lvl ) ) then
//    call BJDebugMsg("Creating da unit, timer found to be before spell end")    
    set da = CreateUnit(Player(15) , GetUnitTypeId(cast) , 0 , 0 , GetUnitFacing(cast))
    call UnitAddAbility(da , 'Aloc')
    call AddUnitAnimationProperties(da , "alternate" , true)
    call SetUnitColor(da , GetPlayerColor(GetOwningPlayer(cast)))
    call SetUnitPosition(da , GetUnitX(cast) , GetUnitY(cast))
    call SetUnitVertexColor(da , 255 , 255 , 255 , 127)
    call SetUnitVertexColor(db , 255 , 255 , 255 , 63)
    call SetUnitAnimation(da , "walk")
    call SetUnitTimeScale(da , 0)
    call AttachObject(t , "da" , da)
    else
    set da = null
    call AttachObject(t , "da" , null)
    endif
    
    if ( i ) >= ( ( 5 + ( 5 * lvl ) ) * 5 ) + 2 or IsUnitDeadBJ(cast) then
//    call BJDebugMsg("Timer termination activated, caster is dead or timer expired iterations")
    if da != null then
    call RemoveUnit(da)
    call AttachObject(t , "da" , null)
//    call BJDebugMsg("Removing da: "+GetUnitName(da)+", id: "+I2S(CS_H2I(da)))
    endif
    if db != null then
    call RemoveUnit(db)
    call AttachObject(t , "db" , null)
//    call BJDebugMsg("Removing db: "+GetUnitName(db)+", id: "+I2S(CS_H2I(db)))
    endif
//    call BJDebugMsg("Killing timer")
    call CS_KillTimer(t)
    set db = null
    set da = null
    set cast = null
    set t = null
    return 
    endif
    
    call AttachInt(t , "i" , i)
//    call BJDebugMsg("Resaving iterate")

    if ( i / 5 ) >= ( 5 + ( 5 * lvl ) ) then
//    call BJDebugMsg("Spell end occurring, creating special effect '"+GetAbilityEffectById('A0NK',EFFECT_TYPE_CASTER,1)+"'")
    call DestroyEffect(AddSpecialEffect(GetAbilityEffectById('A0NK' , EFFECT_TYPE_MISSILE , 1) , GetUnitX(cast) , GetUnitY(cast)))
    call UnitRemoveAbility(cast , 'Aetl')
    call UnitRemoveAbility(cast , 'A0NP')
    call UnitRemoveAbility(cast , 'A0NU')
    call AddUnitAnimationProperties(cast , "alternate" , false)
    call SetUnitAnimation(cast , "stand")
    endif
    

//    call BJDebugMsg("Conclusion of iteration.")
    set db = null
    set da = null
    set cast = null
    set t = null
endfunction


function VGDestructiveForm takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local timer t=CreateTimer() //=GetAttachedTimer(cast,"VGDestForm_timer")
local integer abi=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(cast , abi)
if GetUnitTypeId(cast) == 'O01U' or GetUnitTypeId(cast) == 'n042' then
//if t==null then
//set t=
//call AttachObject(cast,"VGDestForm_timer",t)
//endif
call DestroyEffect(AddSpecialEffect(GetAbilityEffectById('A0NK' , EFFECT_TYPE_MISSILE , 0) , GetUnitX(cast) , GetUnitY(cast)))
call SetPlayerAbilityAvailable(GetOwningPlayer(cast) , 'Aetl' , false)
call UnitAddAbility(cast , 'Aetl')
call UnitMakeAbilityPermanent(cast , true , 'Aetl')
call AddUnitAnimationProperties(cast , "alternate" , true)
call SetUnitAnimation(cast , "stand")
if IsUnitType(cast , UNIT_TYPE_HERO) then
call UnitAddAbility(cast , 'A0NP')
call UnitAddAbility(cast , 'A0NU')
call SetUnitAbilityLevel(cast , 'A0NU' , lvl)
call UnitMakeAbilityPermanent(cast , true , 'A0NP')

call SetPlayerAbilityAvailable(GetOwningPlayer(cast) , 'A0NP' , false)
else
call UnitAddAbility(cast , 'A0NU')
call SetUnitAbilityLevel(cast , 'A0NU' , 2)
set lvl = 3
endif
call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
call AttachObject(t , "timerunit" , cast)
call AttachInt(t , "lvl" , lvl)
call AttachInt(t , "i" , 0)
call TimerStart(t , 0.2 , true , function VGDestructiveFormTimer)
endif
set cast = null
set t = null
endfunction


function VGInvokeShadows takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local integer n=2 + lvl
local integer i=1
local player p=GetOwningPlayer(cast)
local real cx=GetUnitX(cast)
local real cy=GetUnitY(cast)
local integer unitid
local boolean sel
local unit spawn
local group g=GetAttachedGroup(cast , "VGSpawnGroup")
local real angup
if g == null then
set g = CreateGroup()
call AttachObject(cast , "VGSpawnGroup" , g)
endif
if IsUnitSelected(cast , p) then
set sel = true
endif
call ShowUnit(cast , false)
if lvl == 1 then
set unitid = 'n040'
elseif lvl == 2 then
set unitid = 'n041'
elseif lvl == 3 then
set unitid = 'n042'
endif
loop
    exitwhen i > n
    call ProjectileLaunchKill2(p , GetAbilityEffectById('A0NJ' , EFFECT_TYPE_MISSILE , 0) , 600 , 0.05 , cx , cy , 0 , cx + 350 * Cos(( 360 / n ) * i * bj_DEGTORAD) , cy + 350 * Sin(( 360 / n ) * i * bj_DEGTORAD) , 0 , 0.6)
    set i = i + 1
endloop
call PolledWait(0.1)
set i = 1
loop
    exitwhen i == n
    call ProjectileLaunchKill2(p , GetAbilityEffectById('A0NJ' , EFFECT_TYPE_MISSILE , 0) , 750 , 0.05 , cx , cy , 0 , cx + 350 * Cos(( 360 / n ) * i * bj_DEGTORAD) , cy + 350 * Sin(( 360 / n ) * i * bj_DEGTORAD) , 0 , 1.1)
    set i = i + 1
endloop
    call ProjectileLaunchEx(Player(15) , GetAbilityEffectById('A0NJ' , EFFECT_TYPE_MISSILE , 0) , 1.1 , 255 , 255 , 255 , 255 , 750 , 0.05 , cx , cy , 0 , cx + 350 * Cos(( 360 / n ) * i * bj_DEGTORAD) , cy + 350 * Sin(( 360 / n ) * i * bj_DEGTORAD) , 0)
set i = 1
set angup = GetRandomReal(0 , 360)
loop
    exitwhen i == n
    set spawn = CreateUnit(p , unitid , cx + 350 * Cos(( ( ( 360 / n ) * i ) + angup ) * bj_DEGTORAD) , cy + 350 * Sin(( ( ( 360 / n ) * i ) + angup ) * bj_DEGTORAD) , ( 360 / n ) * i)
    if sel then
    call SelectUnitAddForPlayer(spawn , p)
    endif
    call UnitApplyTimedLife(spawn , 'BTLF' , 20 + 10 * lvl)
    call GroupAddUnit(g , spawn)
    set i = i + 1
endloop
call SetUnitPosition(cast , cx + 350 * Cos(( ( ( 360 / n ) * i ) + angup ) * bj_DEGTORAD) , cy + 350 * Sin(( ( ( 360 / n ) * i ) + angup ) * bj_DEGTORAD))
call ShowUnit(cast , true)
if sel then
call SelectUnitAddForPlayer(cast , p)
endif
set cast = null
set p = null
endfunction


function VGReclaimShadowsCollider takes nothing returns nothing
local unit mis=(s__csmissile_m[(LoadInteger(CSData__ht , 0 , GetHandleId((GetTriggeringTrigger()))))]) // INLINED!!
local unit u=GetTriggerUnit()
local unit cast=GetAttachedUnit(mis , "cast")
local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((cast ))) , ( "RS_lvl"))) // INLINED!!
if u == null then
call FlushStoredMission(cs_cache , I2S(GetHandleId((mis)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(mis))
call CollisionMissile_Destroy(mis)
//call BJDebugMsg("Destroying the collision missile.")
elseif IsUnitAliveBJ(u) and IsUnitEnemy(u , GetOwningPlayer(mis)) then
call UnitDamageTarget(cast , u , 30 + lvl * 5 , true , false , ATTACK_TYPE_MAGIC , DAMAGE_TYPE_FORCE , WEAPON_TYPE_WHOKNOWS)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Voidspawn\\PrisonerBurst\\BurstStrikeEmbers.mdl" , u , "origin"))
endif

set mis = null
set u = null
set cast = null
endfunction

function VGReclaimShadowsEnum takes nothing returns nothing
local unit u=GetEnumUnit()
local unit cast=bj_lastCreatedUnit
local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((cast ))) , ( "VGReclaimCount"))) // INLINED!!
local unit mis
local player p=GetOwningPlayer(cast)
local integer n=5
local real cx=GetUnitX(cast)
local real cy=GetUnitY(cast)
local real ux=GetUnitX(u)
local real uy=GetUnitY(u)
if GetUnitState(u , UNIT_STATE_LIFE) > 0 and RJ_DistanceBetweenUnits(cast , u) <= 1200 then
call GroupRemoveUnit(bj_lastCreatedGroup , cast)
set i = i + 1
call AttachInt(cast , "VGReclaimCount" , i)
call ProjectileLaunchKill2(p , "Abilities\\Spells\\Undead\\AbsorbMana\\AbsorbManaBirthMissile.mdl" , 600 , 0.15 , GetUnitX(u) , GetUnitY(u) , 0 , cx , cy , 0 , 1)
call RemoveUnit(u)
loop
    exitwhen i > n
    set mis = CollisionMissile_Create(GetAbilityEffectById('A0NL' , EFFECT_TYPE_MISSILE , 0) , ux , uy , ( 360 / n ) * i , 600 , 0 , 350 , 20 , false , 100 , function VGReclaimShadowsCollider)
    call SetUnitOwner(mis , p , false)
    call AttachObject(mis , "cast" , cast)
    call SetUnitScale(mis , 1 , 1 , 1)
    set i = i + 1
endloop
call PolledWait(0.1)
set i = 1
loop
    exitwhen i > n
    set mis = CollisionMissile_Create(GetAbilityEffectById('A0NL' , EFFECT_TYPE_MISSILE , 0) , ux , uy , ( 360 / n ) * i , 600 , 0 , 350 , 20 , false , 0 , function VGReclaimShadowsCollider)
    call SetUnitOwner(mis , p , false)
    call AttachObject(mis , "cast" , cast)
    call SetUnitScale(mis , 1.6 , 1.6 , 1.6)
    set i = i + 1
endloop
endif
set u = null
set mis = null
set cast = null
set p = null
endfunction

function VGReclaimShadows takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local player p=GetOwningPlayer(cast)
local group g=GetAttachedGroup(cast , "VGSpawnGroup")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "VGSpawnGroup" , g)
endif
//local effect fx
set bj_lastCreatedUnit = cast
set bj_lastCreatedGroup = g
call AttachInt(cast , "RS_lvl" , lvl)
call AttachInt(cast , "VGReclaimCount" , 0)
call ForGroup(g , function VGReclaimShadowsEnum)
//call GroupClear(g)
call SetUnitState(cast , UNIT_STATE_LIFE , GetUnitState(cast , UNIT_STATE_LIFE) + ( 25 + ( 25 * lvl ) ) + (GetStoredInteger(cs_cache , I2S(GetHandleId((cast ))) , ( "VGReclaimCount"))) * 50) // INLINED!!
//set fx=AddSpecialEffectTarget(GetAbilityEffectById('A0NL',EFFECT_TYPE_CASTER,0),cast,"origin")
//call PolledWait(1.833)
//call DestroyEffect(fx)
//set fx=null
set cast = null
set p = null
set g = null
endfunction

function TextTemporaryFlash takes string text,real x,real y,real red,real green,real blue returns nothing
    local texttag tt
    local timer t=CreateTimer()
    local location where=Location(x , y)
    set tt = CreateTextTagLocBJ(text , where , 150.00 , 11.00 , red , green , blue , 0)
    call SetTextTagVelocityBJ(tt , 64 , 90)
    call SetTextTagPermanentBJ(tt , false)
    call SetTextTagAgeBJ(tt , 0)
    call SetTextTagFadepointBJ(tt , 1)
    call SetTextTagLifespan(tt , 2)
    call SetTextTagVisibility(tt , true)
    call AttachTextTag(t , "tt" , tt)
    call TimerStart(t , 2 , false , function SimResourceGet_Timer)
    set t = null
    set tt = null
    call RemoveLocation(where)
    set where = null
endfunction

function RJ_FilterCasterEnemiesLand takes nothing returns boolean
    return ( not ( GetUnitMoveSpeed(GetFilterUnit()) == 0.00 ) ) and not IsUnitType(GetFilterUnit() , UNIT_TYPE_STRUCTURE) and IsUnitEnemy(GetFilterUnit() , GetOwningPlayer(GetSpellAbilityUnit()))
endfunction


function VGNetherStrikeDot takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit u=GetAttachedUnit(t , "timerunit")
local unit cast=GetAttachedUnit(t , "cast")
local integer lvl=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "lvl"))) // INLINED!!
local player p=Player((GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "p")))) // INLINED!!
local integer i=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "i"))) + 1 // INLINED!!
local real x=(GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "x"))) // INLINED!!
local real y=(GetStoredReal(cs_cache , I2S(GetHandleId((t ))) , ( "y"))) // INLINED!!
local real bonusdps
local real speed=GetUnitMoveSpeed(u)
if IsUnitDeadBJ(u) or GetUnitAbilityLevel(u , 'B03W') < 1 then
call CS_KillTimer(t)
set t = null
set u = null
set cast = null
return 
endif
if i == 1 then
set x = GetUnitX(u)
set y = GetUnitY(u)
call UnitDamageTarget(cast , u , 10 * lvl , true , false , ATTACK_TYPE_CHAOS , DAMAGE_TYPE_DEATH , WEAPON_TYPE_WHOKNOWS)
call TextTemporaryFlash(I2S(R2I(10 * lvl)) , x , y , 62.75 , 0 , 100)
else
set x = GetUnitX(u) - x
set y = GetUnitY(u) - y
set bonusdps = ( ( speed - SquareRoot(x * x + y * y) ) / speed ) * 10 * lvl
//call BJDebugMsg("Unit with a speed of "+R2S(speed)+" has traveled " +R2S(SquareRoot(x*x+y*y))+ " distance, taking a bonus damage amount of "+R2S(bonusdps))
if bonusdps <= 0 then
set bonusdps = 0
endif
set bonusdps = ( 10 * lvl ) + bonusdps
call UnitDamageTarget(cast , u , bonusdps , true , false , ATTACK_TYPE_CHAOS , DAMAGE_TYPE_DEATH , WEAPON_TYPE_WHOKNOWS)
set x = GetUnitX(u)
set y = GetUnitY(u)
call TextTemporaryFlash(I2S(R2I(bonusdps)) , x , y , 62.75 , 0 , 100)
endif
if ( IsUnitType(u , UNIT_TYPE_HERO) and i >= lvl * 4 ) or ( i >= lvl * 5 ) then
call CS_KillTimer(t)
set t = null
set u = null
set cast = null
endif

call AttachReal(t , "x" , x) //Store the unit's X and Y values so that we can determine how far it has traveled 
call AttachReal(t , "y" , y)
call AttachInt(t , "i" , i)
set cast = null
set u = null
set t = null
endfunction

function VGNetherStrikeEnum takes nothing returns nothing
local unit u=GetEnumUnit()
local group g=bj_lastCreatedGroup
local integer abi=(GetStoredInteger(cs_cache , I2S(GetHandleId((g ))) , ( "abi"))) // INLINED!!
local timer t
call CasterCastAbilityLevel(Player((GetStoredInteger(cs_cache , I2S(GetHandleId((g ))) , ( "player")))) , abi , (GetStoredInteger(cs_cache , I2S(GetHandleId((g ))) , ( "lvl"))) , (GetStoredString(cs_cache , I2S(GetHandleId((g ))) , ( "strorder"))) , u , true) // INLINED!!
if abi == 'A0NO' and GetUnitAbilityLevel(u , 'B03W') <= 0 then
set t = CreateTimer()
call AttachObject(t , "timerunit" , u)
call AttachInt(t , "lvl" , (GetStoredInteger(cs_cache , I2S(GetHandleId((g ))) , ( "lvl")))) // INLINED!!
call AttachInt(t , "p" , (GetStoredInteger(cs_cache , I2S(GetHandleId((g ))) , ( "player")))) // INLINED!!
call AttachObject(t , "cast" , GetAttachedUnit(g , "cast"))
call TimerStart(t , 2 , true , function VGNetherStrikeDot)
endif
set u = null
endfunction

function VGNetherStrike takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local player p=GetOwningPlayer(cast)
local group g=CreateGroup()
local location targ=GetSpellTargetLoc()
local group backup=bj_lastCreatedGroup
local boolexpr b=Filter(function RJ_FilterCasterEnemiesLand)
set bj_groupEnumOwningPlayer = p
call GroupEnumUnitsInRange(g , GetLocationX(targ) , GetLocationY(targ) , 200 + 100 * lvl , b)
set bj_lastCreatedGroup = g
if GetUnitAbilityLevel(cast , 'Aetl') >= 1 then
call AttachInt(g , "abi" , 'A0NO')
call AttachString(g , "strorder" , "acidbomb")
call AttachObject(g , "cast" , cast)
else
call AttachInt(g , "abi" , 'A0NN')
call AttachString(g , "strorder" , "cripple")
endif
call AttachInt(g , "player" , GetPlayerId(p))
call AttachInt(g , "lvl" , lvl)
call ForGroup(g , function VGNetherStrikeEnum)
call RemoveLocation(targ)
set targ = null
set cast = null
set backup = null
set bj_lastCreatedGroup = backup
call DestroyBoolExpr(b)
set b = null
set g = null
endfunction

function VGNetherStrikeCaster takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(cast , abi)
local player p=GetOwningPlayer(cast)
local group g=CreateGroup()
local location targ=GetUnitLoc(cast)
local group backup=bj_lastCreatedGroup
local boolexpr b=Filter(function RJ_FilterCasterEnemiesLand)
set bj_groupEnumOwningPlayer = p
call GroupEnumUnitsInRange(g , GetLocationX(targ) , GetLocationY(targ) , 200 + 100 * lvl , b)
set bj_lastCreatedGroup = g
if GetUnitAbilityLevel(cast , 'Aetl') >= 1 then
call AttachInt(g , "abi" , 'A0NO')
call AttachString(g , "strorder" , "acidbomb")
call AttachObject(g , "cast" , cast)
else
call AttachInt(g , "abi" , 'A0NN')
call AttachString(g , "strorder" , "cripple")
endif
call AttachInt(g , "player" , GetPlayerId(p))
call AttachInt(g , "lvl" , lvl)
call ForGroup(g , function VGNetherStrikeEnum)
call RemoveLocation(targ)
set targ = null
set cast = null
set backup = null
set bj_lastCreatedGroup = backup
call DestroyBoolExpr(b)
set b = null
set g = null
endfunction

function VGBlackHolePull takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit victim=GetEnumUnit()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit cast=GetAttachedUnit(t , "timercaster")
local real x1=GetUnitX(vortex)
local real y1=GetUnitY(vortex)
local real dy=GetUnitY(victim) - y1
local real dx=GetUnitX(victim) - x1
local real inwardv=2000
local real tanv=3
local real r=SquareRoot(dy * dy + dx * dx)
local real ang=Acos(dx / ( r ))
local real x3
local real y3
if ( victim != vortex ) and victim != cast then
if dy < 0 then
set ang = - ang
endif
set dx = ( inwardv / r )
if dx > 4 then
set dx = 4
endif
set dy = ( tanv / ( r ) )
set x3 = Cos(ang + dy) * ( r - dx ) + x1
set y3 = Sin(ang + dy) * ( r - dx ) + y1
call CS_MoveUnit(victim , x3 , y3)
endif
set victim = null
set vortex = null
set t = null
set cast = null
endfunction

function VGBlackHolePullTrees takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit victim=GetEnumUnit()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit cast=GetAttachedUnit(t , "timercaster")
local real x1=GetUnitX(vortex)
local real y1=GetUnitY(vortex)
local real dy=GetUnitY(victim) - y1
local real dx=GetUnitX(victim) - x1
local real inwardv=6000
local real tanv=4
local real r=SquareRoot(dy * dy + dx * dx)
local real ang=Acos(dx / ( r ))
local real x3
local real y3
if ( victim != vortex ) and victim != cast then
if dy < 0 then
set ang = - ang
endif
set dx = ( inwardv / r )
if dx > 4 then
set dx = 4
endif
set dy = ( tanv / ( r ) )
set x3 = Cos(ang + dy) * ( r - dx ) + x1
set y3 = Sin(ang + dy) * ( r - dx ) + y1
call CS_MoveUnit(victim , x3 , y3)
call SetUnitFacing(victim , GetUnitFacing(victim) + 6)
endif
set victim = null
set vortex = null
set t = null
set cast = null
endfunction

function VGBlackHoleTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit caster=GetAttachedUnit(t , "timercaster")
local group thepulled=GetAttachedGroup(t , "timerpulled")
local group thetrees=GetAttachedGroup(t , "timertrees")
local boolexpr b=Condition(function RJ_FilterMobileEnemies)
local location targ=GetAttachedLoc(t , "timerloc")
local destructable d
local unit tree
local real x
local real y
if thepulled == null then
set thepulled = CreateGroup()
call AttachObject(t , "timerpulled" , thepulled)
else
call GroupClear(thepulled)
endif
if thetrees == null then
set thetrees = CreateGroup()
call AttachObject(t , "timertrees" , thetrees)
endif
if GetRandomInt(1 , 100) == 1 then
set d = RandomDestructableInRange(targ , 1000)
    set x = GetWidgetX(d) + 100 * Cos(Atan2(GetWidgetY(d) - GetUnitY(vortex) , GetWidgetX(d) - GetUnitX(vortex)) + bj_PI)
    set y = GetWidgetY(d) + 100 * Sin(Atan2(GetWidgetY(d) - GetUnitY(vortex) , GetWidgetX(d) - GetUnitX(vortex)) + bj_PI)
set tree = CreateUnit(Player(PLAYER_NEUTRAL_AGGRESSIVE) , 'e01M' , x , y , bj_RADTODEG * Atan2(GetWidgetY(d) - GetUnitY(vortex) , GetWidgetX(d) - GetUnitX(vortex)))
call UnitAddAbility(tree , 'Aloc')
call IssueTargetOrder(tree , "grabtree" , d)
call GroupAddUnit(thetrees , tree)
endif


call GroupEnumUnitsInRange(thepulled , GetUnitX(vortex) , GetUnitY(vortex) , 1000 , b)
call ForGroup(thepulled , function VGBlackHolePull)
call ForGroup(thetrees , function VGBlackHolePullTrees)
set t = null
set targ = null
set vortex = null
set caster = null
set bj_groupRemoveGroupDest = null
set thepulled = null
call DestroyBoolExpr(b)
set b = null
set tree = null
set thetrees = null
endfunction


function VGWhiteHoleTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit cast=GetAttachedUnit(t , "timercaster")
local destructable d
local location targ=GetAttachedLoc(t , "timerloc")
local unit tree
local real x
local real y
local unit caster=GetACaster()
local player owner=GetOwningPlayer(cast)
if GetRandomInt(1 , 3) >= 2 then
//set d=CreateDestructableLoc('B002',targ,0,1,0)
set tree = CreateUnit(Player(PLAYER_NEUTRAL_AGGRESSIVE) , 'e01N' , GetUnitX(vortex) , GetUnitY(vortex) , KS_AngleBetweenUnits(cast , vortex))
call UnitAddAbility(tree , 'Aloc')
//call IssueTargetOrder(tree,"grabtree",d)
    set x = GetWidgetX(vortex) + 1000 * Cos(KS_AngleBetweenUnits(cast , vortex) + bj_PI)
    set y = GetWidgetY(vortex) + 1000 * Sin(KS_AngleBetweenUnits(cast , vortex) + bj_PI)
call IssuePointOrder(tree , "smart" , x , y)
call SetUnitExploded(tree , true)
call UnitApplyTimedLife(tree , 'BTLF' , 4)
endif


    call SetUnitOwner(caster , owner , false)
    call UnitAddAbility(caster , 'A0NY')
    call SetUnitAbilityLevel(caster , 'A0NY' , 1)
    call CS_MoveUnit(caster , GetUnitX(vortex) , GetUnitY(vortex))

    call IssueImmediateOrderById(caster , 852609)

    call UnitRemoveAbility(caster , 'A0NY')
    call RecycleCaster((caster)) // INLINED!!
 set rdg_currentcaster = caster
 set caster = null
 
 
//call CasterCastAbilityPointLoc(GetOwningPlayer(cast),,'A0NY',targ,true)
endfunction

function RemoveEnumUnit takes nothing returns nothing
    call RemoveUnit(GetEnumUnit())
    //return
endfunction

function VGBlackHole takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local boolean white=( GetUnitAbilityLevel(cast , 'Aetl') >= 1 )
local location targ=GetSpellTargetLoc()
local timer t=CreateTimer()
local unit cs=GetACaster()
local group g
local effect fx
if not ( white ) then
call SetUnitPositionLoc(cs , targ)
call AttachObject(cs , "fx" , AddSpecialEffectTarget(GetAbilityEffectById('A0NW' , EFFECT_TYPE_AREA_EFFECT , 0) , cs , "origin"))
call AttachObject(t , "timerunit" , cs)
call AttachObject(t , "timercaster" , cast)
call AttachObject(t , "timerloc" , targ)
call TimerStart(t , (cs_TIMER_CYCLE) , true , function VGBlackHoleTimer) // INLINED!!
call PolledWait(35)
call PauseTimer(t)
set g = GetAttachedGroup(t , "timertrees")
call ForGroup(g , function RemoveEnumUnit)
call DestroyGroup(g)
set g = GetAttachedGroup(t , "timerpulled")
call DestroyGroup(g)
//call DestroyBoolExpr(GetAttachedBoolExpr(t,"timerboolexpr"))
call DestroyEffect(GetAttachedEffect(cs , "fx"))
call RecycleCaster((cs)) // INLINED!!
set fx = AddSpecialEffectLoc("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl" , targ)
call PolledWait(2)
call DestroyEffect(fx)
else
call SetUnitPositionLoc(cs , targ)
call SetUnitFacing(cs , KS_AngleBetweenUnits(cast , cs))
call AttachObject(cs , "fx" , AddSpecialEffectTarget(GetAbilityEffectById('A0NZ' , EFFECT_TYPE_AREA_EFFECT , 0) , cs , "origin"))
call AttachObject(t , "timerunit" , cs)
call AttachObject(t , "timercaster" , cast)
call AttachObject(t , "timerloc" , targ) //852609
call TimerStart(t , 1 , true , function VGWhiteHoleTimer)
call PolledWait(35)
call PauseTimer(t)
call DestroyEffect(GetAttachedEffect(cs , "fx"))
call FlushStoredMission(cs_cache , I2S(GetHandleId((cs)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(cs))
call RecycleCaster((cs)) // INLINED!!
endif

//if GetUnitCurrentOrder(caster)==OrderId("tornado") then
////call GroupEnumUnitsInRange(thepulled,GetUnitX(vortex),GetUnitY(vortex),1200,b)
//call ForGroup(thepulled,function VortexPull) 
//else
//call KillUnit(vortex)
//call PauseTimer(t)
//endif

call RemoveLocation(targ)
set targ = null
set cast = null
set fx = null
set cs = null
set g = null
endfunction

function InitRetTrig_TheVoidGodAbilities takes nothing returns nothing
call OnAbilityEffect('A0NK' , "VGDestructiveForm")
call OnAbilityEffect('A0NQ' , "VGDestructiveForm")
call OnAbilityEffect('A0NJ' , "VGInvokeShadows")
call OnAbilityEffect('A0NL' , "VGReclaimShadows")
call OnAbilityEffect('A0NM' , "VGNetherStrike")
call OnAbilityEffect('A0NR' , "VGNetherStrikeCaster")
call OnAbilityEffect('A0NW' , "VGBlackHole")
call OnAbilityEffect('A0NZ' , "VGBlackHole")
call OnAbilityLearn('A0NK' , "PermanentIfy")
call OnAbilityLearn('A0NJ' , "PermanentIfy")
call OnAbilityLearn('A0NL' , "PermanentIfy")
call OnAbilityLearn('A0NM' , "PermanentIfy")
call OnAbilityLearn('A0NR' , "PermanentIfy")
call OnAbilityLearn('A0NW' , "PermanentIfy")
call OnAbilityLearn('A0NZ' , "PermanentIfy")
endfunction

function Engorgement takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer lvl=GetUnitAbilityLevel(cast , 'A0KR')
call UnitAddAbility(cast , 'A0KU')
call SetUnitAbilityLevel(cast , 'A0KU' , lvl)
if lvl == 1 then
if GetUnitAbilityLevel(cast , 'A0KS') == 0 then
    call UnitAddAbility(cast , 'A0KS')
    call UnitAddAbility(cast , 'A0KT')
else
    call SetUnitAbilityLevel(cast , 'A0KS' , GetUnitAbilityLevel(cast , 'A0KS') + 1)
    call SetUnitAbilityLevel(cast , 'A0KT' , GetUnitAbilityLevel(cast , 'A0KT') + 1)
endif
call PolledWait(20.00 + 10.00 * lvl) //30,40,50
if GetUnitAbilityLevel(cast , 'A0KS') == 1 then
    call UnitRemoveAbility(cast , 'A0KS')
    call UnitRemoveAbility(cast , 'A0KT')
elseif GetUnitAbilityLevel(cast , 'A0KS') > 1 then
    call SetUnitAbilityLevel(cast , 'A0KS' , GetUnitAbilityLevel(cast , 'A0KS') - 1)
    call SetUnitAbilityLevel(cast , 'A0KT' , GetUnitAbilityLevel(cast , 'A0KT') - 1)
endif
elseif lvl == 2 then
if GetUnitAbilityLevel(cast , 'A0KV') == 0 then
    call UnitAddAbility(cast , 'A0KV')
    call UnitAddAbility(cast , 'A0KX')
else
    call SetUnitAbilityLevel(cast , 'A0KV' , GetUnitAbilityLevel(cast , 'A0KV') + 1)
    call SetUnitAbilityLevel(cast , 'A0KX' , GetUnitAbilityLevel(cast , 'A0KX') + 1)
endif
call PolledWait(20.00 + 10.00 * lvl) //30,40,50
if GetUnitAbilityLevel(cast , 'A0KV') == 1 then
    call UnitRemoveAbility(cast , 'A0KV')
    call UnitRemoveAbility(cast , 'A0KX')
elseif GetUnitAbilityLevel(cast , 'A0KV') > 1 then
    call SetUnitAbilityLevel(cast , 'A0KV' , GetUnitAbilityLevel(cast , 'A0KV') - 1)
    call SetUnitAbilityLevel(cast , 'A0KX' , GetUnitAbilityLevel(cast , 'A0KX') - 1)
endif
elseif lvl == 3 then
if GetUnitAbilityLevel(cast , 'A0KW') == 0 then
    call UnitAddAbility(cast , 'A0KW')
    call UnitAddAbility(cast , 'A0KY')
else
    call SetUnitAbilityLevel(cast , 'A0KW' , GetUnitAbilityLevel(cast , 'A0KW') + 1)
    call SetUnitAbilityLevel(cast , 'A0KY' , GetUnitAbilityLevel(cast , 'A0KY') + 1)
endif
call PolledWait(20.00 + 10.00 * lvl) //30,40,50
if GetUnitAbilityLevel(cast , 'A0KW') == 1 then
    call UnitRemoveAbility(cast , 'A0KW')
    call UnitRemoveAbility(cast , 'A0KY')
elseif GetUnitAbilityLevel(cast , 'A0KW') > 1 then
    call SetUnitAbilityLevel(cast , 'A0KW' , GetUnitAbilityLevel(cast , 'A0KW') - 1)
    call SetUnitAbilityLevel(cast , 'A0KY' , GetUnitAbilityLevel(cast , 'A0KY') - 1)
endif
endif
if GetUnitAbilityLevel(cast , 'A0KV') >= 1 or GetUnitAbilityLevel(cast , 'A0KW') >= 1 or GetUnitAbilityLevel(cast , 'A0KS') >= 1 then
else
    call UnitRemoveAbility(cast , 'A0KU')
endif
set cast = null
endfunction

function ViciousRage takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
call CasterCastAbilityEx(GetOwningPlayer(cast) , GetUnitX(cast) , GetUnitY(cast) , 0 , 'A0L0' , 1 , "bloodlust" , cast , 3)
set cast = null
endfunction

function TentaclePrison takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local unit targ=GetSpellTargetUnit()
local real angle
local real x
local real y
local integer i=0
local integer lvl=GetUnitAbilityLevel(cast , GetSpellAbilityId())
local unit u
local group g=GetAttachedGroup(cast , "MawTent_group")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "MawTent_group" , g)
endif
loop
    set angle = GetUnitFacing(cast) + ( 360 / ( 3 + lvl ) ) * i
    set x = GetUnitX(targ) + 120 * Cos(angle * bj_DEGTORAD)
    set y = GetUnitY(targ) + 120 * Sin(angle * bj_DEGTORAD)
    set u = CreateUnit(GetOwningPlayer(cast) , 'n03R' , x , y , angle + 180)
    call UnitApplyTimedLife(u , 'BTLF' , 30 + lvl * 5)
//    call SetUnitAnimation(u,"birth")
    call IssueImmediateOrder(u , "cripple")
    call GroupAddUnit(g , u)
    set i = i + 1
    exitwhen i == 3 + lvl
endloop

set u = null
set g = null
set cast = null
set targ = null
endfunction

function VoidTentDeathEnum takes nothing returns nothing
    call KillUnit(GetEnumUnit())
endfunction

function RetTrig_MawTentDeath_Conditions takes nothing returns boolean
    
    return ( GetUnitTypeId(GetDyingUnit()) == 'U01M' ) or ( GetUnitTypeId(GetDyingUnit()) == 'U01K' )
endfunction

function RetTrig_MawTentDeath_Actions takes nothing returns nothing
    local unit cast=GetDyingUnit()
    local group g=GetAttachedGroup(cast , "MawTent_group")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "MawTent_group" , g)
endif

    call ForGroup(g , function VoidTentDeathEnum)
    
call GroupClear(g)
set cast = null
set g = null
endfunction

function RetTrig_MawTentDeath2_Conditions takes nothing returns boolean
    return GetSpellAbilityId() == 'A0KP'
endfunction

function RetTrig_MawTentDeath2_Actions takes nothing returns nothing
    local unit cast=GetSpellAbilityUnit()
    local group g=GetAttachedGroup(cast , "MawTent_group")
if g == null then
set g = CreateGroup()
call AttachObject(cast , "MawTent_group" , g)
endif

    call ForGroup(g , function VoidTentDeathEnum)
    
call GroupClear(g)
set cast = null
set g = null
endfunction

//==== Init Trigger MawTentDeath ====
function InitRetTrig_MawTentDeath takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(t , Condition(function RetTrig_MawTentDeath_Conditions))
    call TriggerAddAction(t , function RetTrig_MawTentDeath_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_MawTentDeath2_Conditions))
    call TriggerAddAction(t , function RetTrig_MawTentDeath2_Actions)
    set t = null
endfunction

function IsUnitWard takes unit d returns boolean
    local unit u=GetACaster()
    local boolean result
    call UnitAddAbility(u , 'A0MN')
    set result = IssueTargetOrder(u , "sleep" , d)
    call UnitRemoveAbility(u , 'A0MN')
    call RecycleCaster((u)) // INLINED!!
    return result
endfunction

function WardAuraTemplate takes nothing returns nothing
 local timer t=CreateTimer()
 local unit u=(CasterSystem___acquiringunit) // INLINED!!
 local integer s=(CasterSystem___acquiredabil) // INLINED!!
 local integer l=GetUnitAbilityLevel(u , s)
 local integer nl=l
 local integer n=GetAbilityDataInt(s , l , "n")
 local integer array abis
 local integer array spb
 local integer a=n
 local group affected=null
 local group inrange=CreateGroup()
 local group aux=CreateGroup()
 local unit picked
 local real area=GetAbilityDataReal(s , l , "area")
 local integer bad=GetAbilityDataInt(s , l , "bad")
 local boolean notself=( GetAbilityDataInt(s , l , "notself") != 0 )
 local boolean halt=false
 local boolean nor=(HaveStoredInteger(cs_cache , I2S((GetHandleId(((u ))))) + ";" + ( "AuraTemplateSet" ) , "Pos" + I2S(( s)))) // INLINED!!
 local boolean enb
 local integer d
    if IsUnitIllusion(u) or ( l == 0 ) or nor then
        set n = 0
        set halt = true
//        call BJDebugMsg(GetUnitName(u)+" is not a ward.")
    else
        call AttachedSetAddInt(u , "AuraTemplateSet" , s)
//        call BJDebugMsg(GetUnitName(u)+" is a ward.")
    endif
    loop
        exitwhen ( a == 0 ) or halt
        set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
        set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
        set a = a - 1
    endloop
    loop
        exitwhen ( halt )
        set nl = GetUnitAbilityLevel(u , s)
        if ( nl != l ) then
            if ( nl == 0 ) then
                set halt = true
            else
                loop
                    set picked = FirstOfGroup(aux)
                    exitwhen ( picked == null )
                    set a = n
                    loop
                        exitwhen ( a == 0 )
                        call UnitRemoveAbility(picked , spb[a])
                        call UnitRemoveAbility(picked , abis[a])
                        set a = a - 1
                    endloop
                    call GroupRemoveUnit(aux , picked)
                endloop
                set l = nl
                set n = GetAbilityDataInt(s , l , "n")
                set a = n
                loop
                    exitwhen ( ( a == 0 ) or ( halt ) )
                    set spb[a]=GetAbilityDataInt(s , l , "spbk" + I2S(a))
                    set abis[a]=GetAbilityDataInt(s , l , "spell" + I2S(a) + "id")
                    set a = a - 1
                endloop
                set area = GetAbilityDataReal(s , l , "area")
            endif
        endif
        exitwhen ( halt )
        if ( GetWidgetLife(u) > 0 ) then
            call CS_EnumUnitsInAOE(inrange , GetUnitX(u) , GetUnitY(u) , area , null)
        else
            set halt = halt or ( GetUnitState(u , UNIT_STATE_MAX_LIFE) <= 0 ) //If max life is 0, the unit was removed
            call GroupClear(inrange)
        endif
        if ( affected != null ) then
            call DestroyGroup(affected)
        endif
        set affected = aux
        set aux = CreateGroup()
        loop
            set picked = FirstOfGroup(affected)
            exitwhen picked == null
            if not IsUnitInGroup(picked , inrange) then
                set a = n
                loop
                    exitwhen a == 0
                    call UnitRemoveAbility(picked , spb[a])
                    call UnitRemoveAbility(picked , abis[a])
                    set a = a - 1
                endloop
            else
                call GroupRemoveUnit(inrange , picked)
                call GroupAddUnit(aux , picked)
            endif
            call GroupRemoveUnit(affected , picked)
        endloop
        set d = GetAbilityDataInt(s , l , "options")
        if ( d != 0 ) then
            set d = LoadDamageOptions(d)
        endif
        loop
            set picked = FirstOfGroup(inrange)
            exitwhen ( picked == null )
            set enb = ( bad == 1 and IsUnitEnemy(picked , GetOwningPlayer(u)) )
            set enb = enb or ( bad == 0 and IsUnitAlly(picked , GetOwningPlayer(u)) and IsUnitAlly(u , GetOwningPlayer(picked)) and ( not ( notself ) or u != picked ) ) or ( bad == 2 and ( not ( notself ) or u != picked ) )
            set enb = enb and IsUnitWard(picked)
            if ( d != 0 ) then
                set enb = enb and ( GetDamageFactorByOptions(u , picked , d) > 0 )
            endif
            if enb then
                set a = n
                loop
                    exitwhen ( a == 0 )
                    if ( spb[a] != 0 ) then
                        call SetPlayerAbilityAvailable(GetOwningPlayer(picked) , spb[a] , false)
                        call UnitAddAbility(picked , spb[a])
                    else
                        call UnitAddAbility(picked , abis[a])
                    endif
                    call SetUnitAbilityLevel(picked , abis[a] , l)
                    call GroupAddUnit(aux , picked)
                    set a = a - 1
                endloop
            endif
            call GroupRemoveUnit(inrange , picked)
        endloop
        call AuraTemplate_Wait(t)
    endloop
    
    if not ( nor ) then
        call AttachedSetRemInt(u , "AuraTemplateSet" , s)
    endif
    loop
        set picked = FirstOfGroup(aux)
        exitwhen picked == null
        set a = n
        loop
            exitwhen ( a <= 0 )
            call UnitRemoveAbility(picked , spb[a])
            call UnitRemoveAbility(picked , abis[a])
            set a = a - 1
        endloop
        call GroupRemoveUnit(aux , picked)
    endloop
 call DestroyGroup(aux)
 call DestroyGroup(affected)
 call DestroyGroup(inrange)
 call DestroyTimer(t)
 set t = null
 set affected = null
 set inrange = null
 set picked = null
 set u = null
 set aux = null
endfunction

function GiveUnitAuraDamageBonus takes unit u,integer amt returns nothing
local integer array abi
local integer i=0
local boolean mod
set abi[0]='A0LD'
set abi[1]='A0LE'
set abi[2]='A0LF'
set abi[3]='A0LG'
set abi[4]='A0LH'
set abi[5]='A0LI'
set abi[6]='A0LJ'
set abi[7]='A0LK'
set abi[8]='A0LL'
set abi[9]='A0LM'
set abi[10]='A0LN'
set abi[11]='A0LO'
set abi[12]='A0LP'
set abi[13]='A0LQ'
set abi[14]='A0LR'
set abi[15]='A0LS'
set abi[16]='A0LT'
set abi[17]='A0LU'
set abi[18]='A0LV'
set abi[19]='A0LW'
set abi[20]='A0LX'
set abi[21]='A0LY'
set abi[22]='A0LZ'
loop
    exitwhen i > 22 or amt <= 0
    set mod = ModuloInteger(amt , 2) == 1
    if mod then
    call UnitAddAbility_ConsiderEvent(u , abi[i] , 1)
    call UnitMakeAbilityPermanent(u , true , abi[i])
    else
    call UnitRemoveAbility(u , abi[i])
    endif
    set amt = amt / 2
    set i = i + 1
endloop
endfunction


function EmpoweredTentacles_Action takes nothing returns nothing
local trigger t=GetTriggeringTrigger()
local unit u=GetAttachedUnit(t , "trigunit")
local integer abi=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "trigabi"))) // INLINED!!
local integer lvl=GetUnitAbilityLevel(u , abi)
local integer str=GetHeroStr(u , true)
local real percent=0 + lvl * .12
call GiveUnitAuraDamageBonus(u , R2I(str * percent))
set u = null
set t = null
endfunction


function EmpoweredTentacles takes nothing returns nothing
local unit u=GetLearningUnit()
local integer abi=GetLearnedSkill()
local trigger t
local integer lvl=GetUnitAbilityLevel(u , abi)
local integer str=GetHeroStr(u , true)
local real percent=0 + lvl * .12
call GiveUnitAuraDamageBonus(u , R2I(str * percent))
if lvl <= 1 then
set t = CreateTrigger()
call AttachInt(t , "trigabi" , abi)
call AttachObject(t , "trigunit" , u)
call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_PICKUP_ITEM)
call TriggerRegisterUnitEvent(t , u , EVENT_UNIT_HERO_LEVEL)
call TriggerRegisterTimerEvent(t , 40.00 , true)
call TriggerAddAction(t , function EmpoweredTentacles_Action)
endif

set u = null
set t = null
endfunction

function PermanentIfy takes nothing returns nothing
local unit u=GetLearningUnit()
local integer i=GetLearnedSkill()
call UnitMakeAbilityPermanent(u , true , i)
//call BJDebugMsg("Making "+GetObjectName(i)+" permanent for "+GetUnitName(u)+".")
set u = null
endfunction

function InitRetTrig_TentacleAura takes nothing returns nothing
local integer s
//====================================================================================
 set s = SetPassiveTemplate('A0LD' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M0')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LE' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M1')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LF' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M2')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LG' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M3')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LH' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M4')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LI' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M5')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LJ' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M6')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LK' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M7')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LL' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M8')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LM' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0M9')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LN' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MA')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LO' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MB')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LP' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MC')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LQ' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MD')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LR' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0ME')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LS' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MF')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LT' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MG')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LU' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MH')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LV' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MI')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LW' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MJ')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LX' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MK')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LY' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0ML')
    call SetAbilityDataInt(s , "n" , 1 , 1)
//====================================================================================
 set s = SetPassiveTemplate('A0LZ' , "WardAuraTemplate")

    call SetAbilityDataReal(s , "area" , 0 , 900)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0MM')
    call SetAbilityDataInt(s , "n" , 1 , 1)



call OnAbilityLearn('A0L9' , "EmpoweredTentacles")
call OnAbilityLearn('A0L2' , "PermanentIfy")
call OnAbilityLearn('A0L3' , "PermanentIfy")
call OnAbilityLearn('A0L6' , "PermanentIfy")
call OnAbilityLearn('A0L7' , "PermanentIfy")
call OnAbilityLearn('A0MO' , "PermanentIfy")
call OnAbilityLearn('A0MU' , "PermanentIfy")
endfunction



function InitRetTrig_Engorgement takes nothing returns nothing
call OnAbilityEffect('A0KR' , "Engorgement")
call OnAbilityEffect('A0KZ' , "ViciousRage")
call OnAbilityEffect('A0L3' , "TentaclePrison")
call InitRetTrig_MawTentDeath()
endfunction

function CallTheHounds takes nothing returns nothing
    local unit cast=GetSpellAbilityUnit()
    local unit targ=GetSpellTargetUnit()
    local player castplayer=GetOwningPlayer(cast)
    local location targloc=GetUnitLoc(targ)
    local location castloc=GetUnitLoc(cast)
    local location spawnloc
    local integer i=1
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(cast , abil)
    local integer bid='B02U'
    local integer spawnid
    local unit spawn
    local group allspawns
//    call SetHeroLevel(cast,10,true)
    if lvl == 1 then
    set spawnid = 'n037'
    elseif lvl == 2 then
    set spawnid = 'n038'
    else
    set spawnid = 'n039'
    endif
    set allspawns = GetAttachedGroup(cast , "HM_allspawns")
    if allspawns == null then
    set allspawns = CreateGroup()
    call AttachObject(cast , "HM_allspawns" , allspawns)
    endif
    loop
        exitwhen i > lvl
        set spawnloc = PolarProjectionBJ(targloc , 100 , ( ( ( 360 / lvl ) * i ) + AngleBetweenPoints(castloc , targloc) ) - 180)
        set spawn = CreateUnitAtLoc(castplayer , spawnid , spawnloc , AngleBetweenPoints(spawnloc , targloc))
        call UnitApplyTimedLife(spawn , bid , 20 + lvl * 10)
        call IssueTargetOrder(spawn , "attack" , targ)
        call DestroyEffect(AddSpellEffectById(abil , EFFECT_TYPE_TARGET , GetUnitX(spawn) , GetUnitY(spawn)))
        call RemoveLocation(spawnloc)
        call GroupAddUnit(allspawns , spawn)
        call SetUnitExploded(spawn , true)
        set i = i + 1
    endloop
    set spawn = CreateUnitAtLoc(castplayer , 'o01O' , castloc , AngleBetweenPoints(castloc , targloc))
    call UnitApplyTimedLife(spawn , bid , 20 + lvl * 10)
    call IssueTargetOrder(spawn , "attack" , targ)
    call DestroyEffect(AddSpellEffectById(abil , EFFECT_TYPE_TARGET , GetUnitX(spawn) , GetUnitY(spawn)))
    call GroupAddUnit(allspawns , spawn)
    call SetUnitExploded(spawn , true)
    if lvl > 2 then
    set spawn = CreateUnitAtLoc(castplayer , 'o01O' , castloc , AngleBetweenPoints(castloc , targloc))
    call UnitApplyTimedLife(spawn , bid , 20 + lvl * 10)
    call IssueTargetOrder(spawn , "attack" , targ)
    call DestroyEffect(AddSpellEffectById(abil , EFFECT_TYPE_TARGET , GetUnitX(spawn) , GetUnitY(spawn)))
    call GroupAddUnit(allspawns , spawn)
    call SetUnitExploded(spawn , true)
    endif
    set cast = null
    set targ = null
    set castplayer = null
    call RemoveLocation(targloc)
    call RemoveLocation(castloc)
    set targloc = null
    set castloc = null
    set spawnloc = null
    set spawn = null
endfunction

function TheOtherChargeSpellTemplate takes nothing returns nothing
 local location target=GetSpellTargetLoc()
 local integer t=0
 local trigger end=CreateTrigger()
 local unit horseman=GetTriggerUnit()
 local location loc=GetUnitLoc(horseman)
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(horseman , s)
 local effect shock=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , horseman , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
 local real sp
 local timer dur=CreateTimer()
 local real next=0
 local unit da=null
 local unit db=null
 local integer h=GetTerrainCliffLevelBJ(loc)
 local boolean img= GetAbilityDataInt(s , l , "eyecandy") == 1
 local boolean cliffcheck= GetAbilityDataInt(s , l , "cliffcheck") == 1
 local integer n=GetAbilityDataInt(s , l , "abiln")
 local integer a=n
 local integer array abi

 local integer spell=GetAbilityDataInt(s , l , "spellid")
 local integer orderid=GetAbilityDataInt(s , l , "orderid")
 local real delay=GetAbilityDataReal(s , l , "delay")

 local real dmg=GetAbilityDataReal(s , l , "damage")
 local integer dmgid=GetAbilityDataInt(s , l , "damageoptions")
 local real area=GetAbilityDataReal(s , l , "area")
 local boolean all=GetAbilityDataInt(s , l , "hurtallies") == 1
 local boolean nopathing= GetAbilityDataInt(s , l , "nopathing") == 1

 local real acq
    loop
        exitwhen a == 0
        set abi[a]=GetAbilityDataInt(s , l , "abil" + I2S(a) + "id")
        call UnitAddAbility(horseman , abi[a])
        set a = a - 1
    endloop
    if nopathing then
        call SetUnitPathing(horseman , false)
    endif
    call TimerStart(dur , GetAbilityDataReal(s , l , "durlimit") , false , null)
    set sp = GetUnitMoveSpeed(horseman)
    set acq = GetUnitAcquireRange(horseman)
    call SetUnitAcquireRange(horseman , 0.01)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_DEATH)
    loop
        if cliffcheck and GetTerrainCliffLevel(GetUnitX(horseman) , GetUnitY(horseman)) != h then
             call SetUnitPositionLoc(horseman , loc)
        endif
        call MoveLocation(loc , GetUnitX(horseman) , GetUnitY(horseman))
        exitwhen GetTriggerEvalCount(end) > t or TimerGetRemaining(dur) <= 0
        exitwhen DistanceBetweenPoints(loc , target) < 50.00
        call IssuePointOrderLoc(horseman , "move" , target)
        set t = t + 1
        if TimerGetElapsed(dur) >= next then
            set rdg_delayhack = delay
            call CasterCastAbilityLevelPoint(GetOwningPlayer(horseman) , spell , l , I2S(orderid) , GetUnitX(horseman) , GetUnitY(horseman) , false)
            set rdg_delayhack = 0
            if dmg != 0 then
                call DamageUnitsInAOEEx(horseman , dmg , GetUnitX(horseman) , GetUnitY(horseman) , area , all , LoadDamageOptions(dmgid))
            endif
            set next = next + 0.25
            if img then
                call RemoveUnit(db)
                set db = da
                set da = CreateUnit(Player(15) , GetUnitTypeId(horseman) , 0 , 0 , GetUnitFacing(horseman))
                call UnitAddAbility(da , 'Aloc')
                call SetUnitColor(da , GetPlayerColor(GetOwningPlayer(horseman)))
                call SetUnitPosition(da , GetUnitX(horseman) , GetUnitY(horseman))
                call SetUnitVertexColor(da , 255 , 255 , 255 , 127)
                call SetUnitVertexColor(db , 255 , 255 , 255 , 63)
                call SetUnitTimeScale(da , 0)
            endif
        endif
        call TriggerSleepAction(0)
    endloop
    if nopathing then
        call SetUnitPathing(horseman , true)
    endif
    call RemoveLocation(loc)
    call TriggerSleepAction(0)
    call SetUnitPathing(horseman , true)
    call SetUnitAcquireRange(horseman , acq)
    set a = n
    loop
        exitwhen a == 0
        call UnitRemoveAbility(horseman , abi[a])
        set a = a - 1
    endloop
    call RemoveUnit(db)
    call TriggerSleepAction(0)
    call RemoveUnit(da)
 call DestroyTimer(dur)
 call DestroyEffect(shock)
 call RemoveLocation(target)
 call DestroyTrigger(end)
 set shock = null
 set target = null
 set loc = null
 set horseman = null
 set end = null
 set dur = null
 set da = null
 set db = null
endfunction

function Overrun_Charge takes unit horseman,location target,integer s,integer l,boolean purge returns nothing
 //This is borrowed from the Charge Spell Template function from Vexorian, many thanks to him
 //s is the spell id, I use one but the unit won't really have it
 //l is the level of the spell the hero really does have (overrun)
 local integer t=0
 local trigger end=CreateTrigger()
 local location loc=GetUnitLoc(horseman)
 local effect shock=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , horseman , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
 local real sp
 local timer dur=CreateTimer()
 local real next=0
 local unit da=null
 local unit db=null
 local integer h=GetTerrainCliffLevelBJ(loc)
 local boolean img= GetAbilityDataInt(s , l , "eyecandy") == 1
 local boolean cliffcheck= GetAbilityDataInt(s , l , "cliffcheck") == 1
 local integer n=GetAbilityDataInt(s , l , "abiln")
 local integer a=n
 local integer array abi
// local boolean purge = GetAbilityDataInt(s,l,"purge")!=0

 local integer spell=GetAbilityDataInt(s , l , "spellid")
 local integer orderid=GetAbilityDataInt(s , l , "orderid")
 local real delay=GetAbilityDataReal(s , l , "delay")

 local real dmg=GetAbilityDataReal(s , l , "damage")
 local integer dmgid=GetAbilityDataInt(s , l , "damageoptions")
 local real area=GetAbilityDataReal(s , l , "area")
 local boolean all=GetAbilityDataInt(s , l , "hurtallies") == 1
 local boolean nopathing= GetAbilityDataInt(s , l , "nopathing") == 1

 local real acq
    loop
        exitwhen a == 0
        set abi[a]=GetAbilityDataInt(s , l , "abil" + I2S(a) + "id")
        call UnitAddAbility(horseman , abi[a])
        set a = a - 1
    endloop
    if nopathing then
        call SetUnitPathing(horseman , false)
    endif
    call TimerStart(dur , GetAbilityDataReal(s , l , "durlimit") , false , null)
    if ( purge ) then
        call UnitRemoveBuffs(horseman , true , true)
    endif
    set sp = GetUnitMoveSpeed(horseman)
    set acq = GetUnitAcquireRange(horseman)
    call SetUnitAcquireRange(horseman , 0.01)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_ISSUED_ORDER)
    call TriggerRegisterUnitEvent(end , horseman , EVENT_UNIT_DEATH)
    loop
        if cliffcheck and GetTerrainCliffLevel(GetUnitX(horseman) , GetUnitY(horseman)) != h then
             call SetUnitPositionLoc(horseman , loc)
        endif
        call MoveLocation(loc , GetUnitX(horseman) , GetUnitY(horseman))
        exitwhen GetTriggerEvalCount(end) > t or TimerGetRemaining(dur) <= 0
        exitwhen DistanceBetweenPoints(loc , target) < 50.00
        call IssuePointOrderLoc(horseman , "move" , target)
        set t = t + 1
        if TimerGetElapsed(dur) >= next then
            set rdg_delayhack = delay
//            call CasterCastAbilityLevelPoint( GetOwningPlayer(horseman), spell,l, I2S(orderid), GetUnitX(horseman), GetUnitY(horseman), false )
            set rdg_delayhack = 0
            if dmg != 0 then
                call DamageUnitsInAOEEx(horseman , dmg , GetUnitX(horseman) , GetUnitY(horseman) , area , all , LoadDamageOptions(dmgid))
            endif
            set next = next + 0.25
            if img then
                call RemoveUnit(db)
                set db = da
                set da = CreateUnit(Player(15) , GetUnitTypeId(horseman) , 0 , 0 , GetUnitFacing(horseman))
                call UnitAddAbility(da , 'Aloc')
                call SetUnitColor(da , GetPlayerColor(GetOwningPlayer(horseman)))
                call SetUnitPosition(da , GetUnitX(horseman) , GetUnitY(horseman))
                call SetUnitVertexColor(da , 255 , 255 , 255 , 127)
                call SetUnitVertexColor(db , 255 , 255 , 255 , 63)
                call SetUnitTimeScale(da , 0)
            endif
        endif
        call TriggerSleepAction(0)
    endloop
    if nopathing then
        call SetUnitPathing(horseman , true)
    endif
    call RemoveLocation(loc)
    call TriggerSleepAction(0)
    call SetUnitPathing(horseman , true)
    call SetUnitAcquireRange(horseman , acq)
    set a = n
    loop
        exitwhen a == 0
        call UnitRemoveAbility(horseman , abi[a])
        set a = a - 1
    endloop
    call RemoveUnit(db)
    call TriggerSleepAction(0)
    call RemoveUnit(da)
 call DestroyTimer(dur)
 call DestroyEffect(shock)
 call RemoveLocation(target)
 call DestroyTrigger(end)
 set shock = null
 set target = null
 set loc = null
 set horseman = null
 set end = null
 set dur = null
 set da = null
 set db = null
endfunction

//function Overrun_TimerEnd takes nothing returns nothing
//    local timer t=GetExpiredTimer()
//    local unit spawn=GetAttachedUnit(t,"spawn")
//    local location targetloc=GetAttachedLoc(t,"targetloc")
//    call CS_KillTimer(t)
//    call Overrun_Charge(spawn,targetloc,'A0I7',bj_forLoopBIndex,false)
//    set t=null
//    set spawn=null
//    set targetloc=null    
//endfunction

function Overrun_Enum takes nothing returns nothing
    local unit caster=bj_lastCreatedUnit //I'm using this to store the caster unit
    local unit spawn=GetEnumUnit()
    local location targetloc=rdg_sourcehack
    local real dx=GetUnitX(caster) - GetUnitX(spawn)
    local real dy=GetUnitY(caster) - GetUnitY(spawn)
//    local timer t=CreateTimer()
    if SquareRoot(dx * dx + dy * dy) <= 1000 then //The 1000 here defines max wolf recall distance
    set bj_forLoopAIndex = bj_forLoopAIndex + 1
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"Overrun: Enumming successful unit #"+I2S(bj_forLoopAIndex))

    //I'm using this to store how many units are being affected by this function

    set dx = GetUnitX(caster) + ( bj_forLoopAIndex / 2 ) * 128 * Cos(( GetUnitFacing(caster) + 180 * bj_forLoopAIndex + 90 ) * bj_DEGTORAD)
    set dy = GetUnitY(caster) + ( bj_forLoopAIndex / 2 ) * 128 * Sin(( GetUnitFacing(caster) + 180 * bj_forLoopAIndex + 90 ) * bj_DEGTORAD)
    //I reuse these to do a polar projection without location handles
    call CS_MoveUnit(spawn , dx , dy)
    call SetUnitFacing(spawn , GetUnitFacing(caster))
    call UnitAddAbility(spawn , 'A0I7')
    call SetUnitAbilityLevel(spawn , 'A0I7' , bj_forLoopBIndex)
    call IssuePointOrderLoc(spawn , "flamestrike" , rdg_sourcehack)
//    call UnitResetCooldown(spawn)//This could be a little risky if the units get out of range, but we'll hope for the best
//    call UnitRemoveAbility(spawn,'A0I7')
//    call TimerStart(t,0.05,false,function Overrun_TimerEnd)
//    call AttachObject(t,"spawn",spawn)
//    call AttachObject(t,"targetloc",targetloc)
//    set t=null
//    call Overrun_Charge(spawn,targetloc,'A0I7',bj_forLoopBIndex,false)
    endif
    set spawn = null
    set caster = null
    set targetloc = null
endfunction

function Overrun_Enum2 takes nothing returns nothing
    local unit spawn=GetEnumUnit()
    call UnitRemoveAbility(spawn , 'A0I7')
    set spawn = null
endfunction

function Overrun takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local group allspawns=GetAttachedGroup(caster , "HM_allspawns")
    set rdg_sourcehack = GetSpellTargetLoc()
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"OverrunActivated")
    if allspawns != null then
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"Overrun:UnitGroup Found")
    set bj_lastCreatedUnit = caster
    set bj_forLoopAIndex = 0
    set bj_forLoopBIndex = GetUnitAbilityLevel(caster , 'A0HZ')
    call ForGroup(allspawns , function Overrun_Enum)
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"Overrun:Finished with "+I2S(bj_forLoopAIndex)+" known hounds, ability level "+I2S(bj_forLoopBIndex))
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"Overrun: Pinging rdg_sourcehack, confirm spell target location")
//    call PingMinimapForPlayer(GetOwningPlayer(caster),GetLocationX(rdg_sourcehack),GetLocationY(rdg_sourcehack),10)    
    set allspawns = null
    endif
    
    call Overrun_Charge(caster , rdg_sourcehack , 'A0I6' , bj_forLoopBIndex , false)
//    call UnitAddAbility(caster,'A0I6')
//    call SetUnitAbilityLevel(caster,'A0I6',bj_forLoopBIndex)
//    call IssuePointOrder(caster,"flamestrike",GetLocationX(rdg_sourcehack),GetLocationY(rdg_sourcehack))
//    call UnitResetCooldown(spawn)//This could be a little risky if the units get out of range, but we'll hope for the best

    call RemoveLocation(rdg_sourcehack)
//    call PolledWait(3)
//    call UnitRemoveAbility(caster,'A0I6')
//    set allspawns=GetAttachedGroup(caster,"HM_allspawns")
//    if allspawns!=null then    
    call ForGroup(allspawns , function Overrun_Enum2)
//    set allspawns=null    
//    endif    
//    call DisplayTextToPlayer(GetOwningPlayer(caster),0,0,"Overrun: Killing bad caster as punishment for failed scripts")
//    call KillUnit(bj_lastCreatedUnit)
    set rdg_sourcehack = null
    set caster = null
endfunction

function PhantomHoundsPres takes nothing returns nothing
  local timer t=GetExpiredTimer()
  local group g=GetAttachedGroup(t , "timergroup")
  local unit u=GetAttachedUnit(t , "timerunit")
  call GroupRemoveUnit(g , u)
  call UnitAddAbility(u , 'S00V')
  call UnitRemoveAbility(u , 'Aloc')
  set rdg_delayhack = 3
call CasterCastAbilityLevel((GetOwningPlayer(u) ) , ( 'A0I4' ) , 1 , ( "soulpreservation" ) , ( u ) , ( false)) // INLINED!!
  set rdg_delayhack = 0
  call CS_KillTimer(t)
  set t = null
  set g = null
  set u = null
endfunction

function PhantomHounds_Check takes nothing returns boolean
    local unit u=GetFilterUnit()
    local unit caster=GetAttachedUnit(GetExpiredTimer() , "timerunit")
    local boolean bool=IsUnitEnemy(u , GetOwningPlayer(caster))
    set u = null
    set caster = null
    return bool
endfunction

function PhantomHoundsTimer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "timerunit")
    local unit spawn
    local unit victim
    local location uloc=GetUnitLoc(u)
    local group allspawns
//    local timer deathtime
    if ( GetUnitAbilityLevel(u , 'B02W') > 0 ) then
    if GetRandomInt(1 , 2) >= 2 then
    set bj_wantDestroyGroup = true
    set victim = GroupPickRandomUnit(GetUnitsInRangeOfLocMatching(1000 , uloc , Condition(function PhantomHounds_Check)))
    if victim != null then
    set spawn = CreateUnit(GetOwningPlayer(u) , 'o01J' , GetUnitX(victim) , GetUnitY(victim) , GetUnitFacing(u))

    call UnitApplyTimedLife(spawn , 'BTLF' , 15)
    call IssueTargetOrder(spawn , "channel" , victim)
    call DestroyEffect(AddSpellEffectById('A0I1' , EFFECT_TYPE_TARGET , GetUnitX(spawn) , GetUnitY(spawn)))
    set allspawns = GetAttachedGroup(u , "HM_allspawns")
    if allspawns == null then
    set allspawns = CreateGroup()
    call AttachObject(u , "HM_allspawns" , allspawns)
    endif
    call GroupAddUnit(allspawns , spawn)
    call SetUnitExploded(spawn , true)
//    set deathtime=CreateTimer()
//    call TimerStart(deathtime,15,false,function PhantomHoundsPres)    
//    call AttachObject(deathtime,"timerunit",spawn)    
//    call AttachObject(deathtime,"timergroup",allspawns)
    set spawn = null
    set allspawns = null
//    set deathtime=null
    set victim = null
    endif

    endif
    else
    call PauseTimer(t)
//    call AttachBoolean(t,"isRunning",false)
    endif
    set u = null
    call RemoveLocation(uloc)
    set uloc = null
    set t = null
endfunction

function PhantomHounds takes nothing returns nothing
    local unit u=GetSpellAbilityUnit()
    local timer t=GetAttachedTimer(u , "HM_PhantTim")
    if t == null then
    set t = CreateTimer()
    call TimerStart(t , 4.00 , true , function PhantomHoundsTimer)
    call AttachObject(t , "timerunit" , u)
    call AttachObject(u , "HM_PhantTim" , t)
//    call AttachBoolean(t,"isRunning",true)
//    call ResumeTimer(t)
    elseif (GetStoredBoolean(cs_cache , I2S(GetHandleId((t ))) , ( "isRunning"))) == false then // INLINED!!
//    call AttachBoolean(t,"isRunning",true)
    call PauseTimer(t)
    call TimerStart(t , 4.00 , true , function PhantomHoundsTimer)
    endif
set u = null
set t = null
endfunction



function AuraOfMadness_Actions takes nothing returns nothing
    local unit u=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local integer lvl=GetUnitAbilityLevel(u , 'A0HY')
    local unit atker=GetAttacker()
    local integer i=GetRandomInt(1 , 100)
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwnedmore"+I2S(lvl))    
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"Auratest: Is "+I2S(i)+" <= 7? and is Player "+I2S(GetPlayerId(GetOwningPlayer(atker)))+" ( attacker's player) the same as Player "+I2S(GetPlayerId(GetOwningPlayer(atker)))+"?  also lvl "+I2S(lvl))
    if i <= ( 7 ) and IsUnitAlly(atker , GetOwningPlayer(u)) and IsUnitDeadBJ(u) != true then
        if GetUnitAbilityLevel(atker , 'Aloc') >= 1 then
        else
        call CasterCastAbilityLevel(GetOwningPlayer(u) , 'A0I0' , lvl , "innerfire" , atker , true)
//        call KillUnit(atker)
        endif
    endif
    set u = null
    set atker = null
endfunction

function AuraMadnessCond takes nothing returns boolean
    local unit u=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local unit atker=GetAttacker()
    local real dx=GetUnitX(u) - GetUnitX(atker)
    local real dy=GetUnitY(u) - GetUnitY(atker)
    local boolean bool=SquareRoot(dx * dx + dy * dy) <= 1000
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwningcondition")
    set u = null
    set atker = null
    return bool
endfunction

function AuraOfMadness takes nothing returns nothing
    local unit u=GetLearningUnit()
    local integer lvl=GetLearnedSkillLevel()
    local trigger t
    local integer index

    set index = 0

    if lvl > 1 then
    set t = GetAttachedTrigger(u , "auraofmadnesstrig")
    else
    set t = CreateTrigger()
    call AttachObject(u , "auraofmadnesstrig" , t)
    loop
        if IsPlayerEnemy(Player(index) , GetOwningPlayer(u)) then
        call TriggerRegisterPlayerUnitEvent(t , Player(index) , EVENT_PLAYER_UNIT_ATTACKED , null)

        endif
        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop
    call TriggerAddCondition(t , Condition(function AuraMadnessCond))
    call TriggerAddAction(t , function AuraOfMadness_Actions)
    
    call AttachObject(t , "trigunit" , u)
    endif
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwned"+I2S(lvl))
    set u = null
    set t = null
endfunction



//(Lord of the Blue inferno)
function TouchOfFrost takes nothing returns nothing
    local location l=GetUnitLoc(GetSpellTargetUnit())
    local unit u=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(u , abil)
    set rdg_sourcehack = l
    call CasterCastAbilityLevelAOELoc(GetOwningPlayer(u) , 'A0IQ' , lvl , "acidbomb" , l , 650 , false , true)
    set rdg_sourcehack = null
    call RemoveLocation(l)
    set l = null
    set u = null
endfunction

function BlueBloodlustTimer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "timerunit")
    call UnitRemoveAbility(u , 'A0IW')
    call UnitRemoveAbility(u , 'A0IX')
    call UnitRemoveAbility(u , 'A0IS')
    
    call AttachObject(u , "LotBI_timer" , null)
//    call AttachBoolean(u,"LotBI_buffed",false)

    call CS_KillTimer(t)
    set t = null
    set u = null
endfunction


function BlueBloodlust takes nothing returns nothing
    local unit u=GetSpellTargetUnit()
    local unit caster=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local timer t
if GetAttachedObject(u , "LotBI_timer") == null then
    set t = CreateTimer()
    
    call AttachObject(u , "LotBI_timer" , t)
//    call AttachBoolean(u,"LotBI_buffed",true)
//    call CasterCastAbilityLevel(GetOwningPlayer(caster),'A0IY',lvl,"acidbomb",u,true)
//    call UnitAddAbility(u,'A0IW')
    call UnitAddAbility(u , 'A0IX')
//    call UnitMakeAbilityPermanent(u,true,'A0IW') 
//    call UnitMakeAbilityPermanent(u,true,'A0IS')     
//    call UnitMakeAbilityPermanent(u,true,'A0IT')     
//    call UnitMakeAbilityPermanent(u,true,'A0IU')     
//    call UnitMakeAbilityPermanent(u,true,'A0IV')
    call UnitMakeAbilityPermanent(u , true , 'A0IX')
//    call SetUnitAbilityLevel(u,'A0IS',lvl)
    call SetUnitAbilityLevel(u , 'A0IX' , lvl)
    call AttachObject(t , "timerunit" , u)
    call TimerStart(t , 20 + 5 * lvl , false , function BlueBloodlustTimer)
    else
    call TimerStart(GetAttachedTimer(u , "LotBI_timer") , 20 + 5 * lvl , false , function BlueBloodlustTimer)
endif
    set t = null
    set u = null
    set caster = null
endfunction



function RetTrig_IssueOrderCheck_Actions takes nothing returns nothing
    call DisplayTextToForce(GetPlayersAll() , I2S(GetIssuedOrderId()))
    call DisplayTextToForce(GetPlayersAll() , OrderId2StringBJ(GetIssuedOrderId()))
endfunction

//===========================================================================
function InitRetTrig_IssueOrderCheck takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_ORDER)
    call TriggerAddAction(t , function RetTrig_IssueOrderCheck_Actions)
    set t = null
endfunction




function InitRetTrig_Testified2345 takes nothing returns nothing
 local integer s
 local integer D
     //Houndmaster abilities
    call OnAbilityEffect('A0HW' , "CallTheHounds")
    call OnAbilityEffect('A0HZ' , "Overrun")
    call OnAbilityEffect('A0I1' , "PhantomHounds")
    call OnAbilityLearn('A0HY' , "AuraOfMadness")
//    call InitRetTrig_IssueOrderCheck()
    
 //===================================================================================================
 // Overrun Charging Clone ('A0I6')
 // For wolf-charging functionality, see the Overrun function
 //
 set s = SetSpellTemplate('A0I6' , "ChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 8) //Level 1: 5 damage
    call SetAbilityDataReal(s , "damage" , 2 , 16) //Level 2: 7 damage
    call SetAbilityDataReal(s , "damage" , 3 , 24) //Level 3: 10 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus
 //===================================================================================================
 // Overrun Clone ('A0I7')
 // For wolf-charging functionality, see the Overrun function
 // I made this clone because wolves can be farther from the target point than the caster and need to still
 // cast immediately
 // Seeing opportunity, I also reduced wolf damage
 set s = SetSpellTemplate('A0I7' , "TheOtherChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 3) //Level 1: 5 damage
    call SetAbilityDataReal(s , "damage" , 2 , 5) //Level 2: 7 damage
    call SetAbilityDataReal(s , "damage" , 3 , 7) //Level 3: 10 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus
    call SetAbilityDataInt(s , "eyecandy" , 0 , 1) //Show eyecandy is 1 by default
    call SetAbilityDataInt(s , "nopathing" , 0 , 1) //No pathing is 1 by default
    call SetAbilityDataInt(s , "cliffcheck" , 0 , 1) //Cliff Level check is 1 by default
    call SetAbilityDataReal(s , "durlimit" , 0 , 1000000) //Maximum duration is 1000000 by default

 //===================================================================================================
 // Chaotic Fury Replica ('A0I3')
 //
 set s = SetSpellTemplate('A0I3' , "SlashTemplate")
 set D = 0 //Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Hero damage
 set D = DamageOnlyEnemies() //Only hurt enemies
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "totalhits" , 0 , 5) //7 Hits

    call SetAbilityDataReal(s , "dmg" , 0 , 25) //Level 1: 450 damage

    call SetAbilityDataReal(s , "area" , 0 , 600) //Always 600 of area

    call SetAbilityDataInt(s , "SlashKind" , 0 , 1) //Slash Kind is 0
    call SetAbilityDataInt(s , "canrepeat" , 0 , 1) //It can't repeat targets!


    call SetAbilityDataString(s , "animation" , 0 , "attack") //Use attack animation

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before

//Berserker spells
//===================================================================================================
 // Chaos Rain ('A0I9')
 //
 set s = SetSpellTemplate('A0I9' , "ConeSpellTemplate") //The ability Rawcode
 set D = 0 //Frost Breath options
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FIRE) //spell cold (magical) damage
 set D = D + DamageOnlyEnemies() //Don't harm allies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "initialarea" , 0 , 150) //Initial area is 150
    call SetAbilityDataReal(s , "distance" , 0 , 800) //Distance is 800
    call SetAbilityDataReal(s , "finalarea" , 0 , 500) //Final area is 500
    call SetAbilityDataInt(s , "maxtargets" , 1 , 5) //Maximum number of targets is 3
    call SetAbilityDataInt(s , "maxtargets" , 2 , 6) //Maximum number of targets is 5
    call SetAbilityDataInt(s , "maxtargets" , 3 , 7) //Maximum number of targets is 7
    call SetAbilityDataInt(s , "spell" , 0 , 'A0I8') //Spell to cast is "Chain Lightning (forked chain lightning)" (A01V)
    call SetAbilityDataInt(s , "castfromcaster" , 0 , 1) //Casters cast the spell from the position of the caster
    call SetAbilityDataReal(s , "recycledelay" , 0 , 4.0) //The spell has a 4 seconds delay before recycling casters
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("acidbomb")) //The orderstring of that spell is chainlightning

//===================================================================================================
 // Acid Splash ('A0JM')
 //
 set s = SetSpellTemplate('A0JM' , "ConeSpellTemplate") //The ability Rawcode
 set D = 0 //Frost Breath options
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_ACID) //spell cold (magical) damage
 set D = D + DamageOnlyEnemies() //Don't harm allies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "initialarea" , 0 , 150) //Initial area is 150
    call SetAbilityDataReal(s , "distance" , 0 , 800) //Distance is 800
    call SetAbilityDataReal(s , "finalarea" , 0 , 500) //Final area is 500
    call SetAbilityDataInt(s , "maxtargets" , 0 , 3) //Maximum number of targets is 3
    call SetAbilityDataInt(s , "spell" , 0 , 'A0JN') //Spell to cast is "Chain Lightning (forked chain lightning)" (A01V)
    call SetAbilityDataInt(s , "castfromcaster" , 0 , 1) //Casters cast the spell from the position of the caster
    call SetAbilityDataReal(s , "recycledelay" , 0 , 4.0) //The spell has a 4 seconds delay before recycling casters
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("acidbomb")) //The orderstring of that spell is chainlightning

 //==================================
 //Fost Nova ('A0J3')
 set s = SetSpellTemplate(0 , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_COLD) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 500) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 1 , 1) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 2 , 2) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 3 , 3) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 15) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 80) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 160) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 240) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above


 //===================================================================================================
 // Chaotic Fury Firey Hero Ability ('A0J4')
 //
 set s = SetSpellTemplate('A0J4' , "SlashTemplate")
 set D = 0 //Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_FIRE) //Hero damage
 set D = DamageOnlyEnemies() //Only hurt enemies
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "totalhits" , 1 , 5) //7 Hits
    call SetAbilityDataInt(s , "totalhits" , 2 , 6) //7 Hits
    call SetAbilityDataInt(s , "totalhits" , 3 , 7) //7 Hits

    call SetAbilityDataReal(s , "dmg" , 0 , 25) //Level 1: 450 damage
    call SetAbilityDataReal(s , "dmg" , 0 , 40) //Level 1: 450 damage
    call SetAbilityDataReal(s , "dmg" , 0 , 55) //Level 1: 450 damage

    call SetAbilityDataReal(s , "area" , 0 , 600) //Always 600 of area

    call SetAbilityDataInt(s , "SlashKind" , 0 , 0) //Slash Kind is 0
    call SetAbilityDataInt(s , "canrepeat" , 0 , 1) //It can repeat targets!


    call SetAbilityDataString(s , "animation" , 0 , "attack") //Use attack animation

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before


endfunction
function RetTrig_Cant_Cast_Conditions takes nothing returns boolean
    return GetUnitAbilityLevelSwapped('A0J8' , GetSpellAbilityUnit()) >= 1
endfunction

function RetTrig_Cant_Cast_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetSpellAbilityUnit() , "stop")
endfunction

function InitElementalRage takes nothing returns nothing
local integer s
local integer D
local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_CHANNEL)
    call TriggerAddCondition(t , Condition(function RetTrig_Cant_Cast_Conditions))
    call TriggerAddAction(t , function RetTrig_Cant_Cast_Actions)
    set t = null
//===================================================================================================
 // Aura of Bad Sight ('A0JF')
 //
 set s = SetPassiveTemplate('A0JF' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageOnlyAllies() //Ignores enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 512)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0J7') //A0J7, Negative sight ability
    call SetAbilityDataInt(s , "n" , 0 , 1)
    
 //===================================================================================================
 // Aura of Bad Attack ('A0JH')
 //
 set s = SetPassiveTemplate('A0JH' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageOnlyAllies() //Ignores enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 512)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0JI') //A0J7, Negative attack ability
    call SetAbilityDataInt(s , "n" , 0 , 1)
    
 //===================================================================================================
 // Aura of Can't Cast ('A0JG')
 //
 set s = SetPassiveTemplate('A0JG' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageOnlyAllies() //Ignores enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 512)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0J8') //A0J7, Inability to channel spells ability (Triggered)
    call SetAbilityDataInt(s , "n" , 0 , 1)
    
//===================================================================================================
 // Ring of Fire ('A0JZ')
 //

 //
 set s = SetSpellTemplate('A0JZ' , "ShieldTemplate")
    call SetAbilityDataInt(s , "n" , 0 , 8) //Level 1: 5 bolts

    call SetAbilityDataInt(s , "pasN" , 0 , 1) //1 passive

    call SetAbilityDataInt(s , "pas1id" , 0 , 'A0JY') //phoenix fire ability
    call SetAbilityDataReal(s , "dur" , 1 , 30) //Level 1: Lasts 52 seconds
    call SetAbilityDataInt(s , "goodspell" , 0 , 0) //This is a positive spell

 //=================================
 //Bonecrushing Strength

 set s = SetSpellTemplate('A0JS' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'B037') //The buff of the spell is B037
    call SetAbilityDataInt(s , "AbilN" , 0 , 2) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'A0K0') //ability1
    call SetAbilityDataInt(s , "Abil2" , 0 , 'A0K4') //ability2
//    call SetAbilityDataInt(s,"Abil3" ,0,'A0K6') //ability3
    call SetAbilityDataInt(s , "SPB1" , 0 , 'A0K7') //spellbook
    call SetAbilityDataInt(s , "SPB2" , 0 , 'A0K7') //spellbook
//===================================================================================================
 // Destructive Shield ('A0KK')
 //

 //
 set s = SetSpellTemplate('A0KK' , "ShieldTemplate")
    call SetAbilityDataInt(s , "n" , 0 , 6) //6 bolts
    call SetAbilityDataReal(s , "dur" , 1 , 30) //Lasts 30 seconds
    call SetAbilityDataInt(s , "goodspell" , 0 , 0) //This is a positive spell
    call SetAbilityDataReal(s , "area" , 0 , 500) //Target acquire area is 600
    call SetAbilityDataInt(s , "spell" , 0 , 'A0KL') //The ability to cast is 'A0KL', shadow strike
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("shadowstrike")) //The ability orderid is shadowstrike
    call SetAbilityDataReal(s , "cooldown" , 0 , 3) //cooldown for the spell is 3





    //Ghost Visible and Permanent invisibility are the perfect combination to create cloaking)

endfunction

function ElementalRage_Timer takes nothing returns nothing
local timer t=GetExpiredTimer()
local boolean fire=(GetStoredBoolean(cs_cache , I2S(GetHandleId((t ))) , ( "fire"))) // INLINED!!
local unit victim=GetAttachedUnit(t , "timerunit")
if fire then
        call KS_UnitAddAbilityStack(victim , 'A0JH' , false)
        //call KS_UnitAddAbilityLevel(victim,'A0JK',true)
        call KS_UnitAddAbilityStack(victim , 'A0JK' , false)
        call KS_UnitAddAbilityStack(victim , 'A0JP' , false)
else
        call KS_UnitAddAbilityStack(victim , 'A0JG' , false)
        //call KS_UnitAddAbilityLevel(victim,'A0JJ',true)
        call KS_UnitAddAbilityStack(victim , 'A0JJ' , false)
        call KS_UnitAddAbilityStack(victim , 'A0JP' , false)
endif
call KS_UnitAddAbilityStack(victim , 'A0JF' , false)
call CS_KillTimer(t)
set t = null
set victim = null
endfunction

function ElementalRage_Actions takes nothing returns nothing
    local unit u=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local integer lvl=GetUnitAbilityLevel(u , 'A0J0')
    local unit victim=GetTriggerUnit()
    local real i=GetRandomReal(1 , 100)
    local real duration=10 + lvl * 5 //(Thus 15, 20, and 25 second duration)
    local timer t


    if i <= ( 5 + 2.5 * lvl ) then //The total chance of proc'ing the ability is 10, 14, 18 based on level, so if its in the lower half we do a fiery effect
        set t = CreateTimer()
        //call KS_UnitAddAbilityStack2(victim,'A0JF',true)
        //call KS_UnitAddAbilityStack2(victim,'A0JH',true)
        //call KS_UnitAddAbilityLevel(victim,'A0JK',true)
        //call KS_UnitAddAbilityStack2(victim,'A0JK',true,lvl)
        call KS_UnitAddAbilityStack(victim , 'A0JP' , true)
        call UnitAddAbility_ConsiderEvent(victim , 'A0JK' , lvl)
        call AttachInt(victim , "KS_AbilNum" + I2S('A0JK') , (GetStoredInteger(cs_cache , I2S(GetHandleId((victim ))) , ( "KS_AbilNum" + I2S('A0JK')))) + 1) // INLINED!!

//        call SetUnitAbilityLevel(victim,'A0JK',lvl)
        call AttachBoolean(t , "fire" , true)
        call AttachObject(t , "timerunit" , victim)
        call TimerStart(t , duration , false , function ElementalRage_Timer)

    elseif i <= ( 10 + 5 * lvl ) then
        set t = CreateTimer()
        //call KS_UnitAddAbilityStack2(victim,'A0JF',true)
        //call KS_UnitAddAbilityStack2(victim,'A0JG',true)
        //call KS_UnitAddAbilityLevel(victim,'A0JJ',true)
        //call KS_UnitAddAbilityStack2(victim,'A0JJ',true,lvl)
//        call SetUnitAbilityLevel(victim,'A0JJ',lvl)
        call KS_UnitAddAbilityStack(victim , 'A0JP' , true)
        call UnitAddAbility_ConsiderEvent(victim , 'A0JJ' , lvl)
        call AttachInt(victim , "KS_AbilNum" + I2S('A0JJ') , (GetStoredInteger(cs_cache , I2S(GetHandleId((victim ))) , ( "KS_AbilNum" + I2S('A0JJ')))) + 1) // INLINED!!

        call AttachObject(t , "timerunit" , victim)
        call TimerStart(t , duration , false , function ElementalRage_Timer)
    
    endif
    set u = null
    set victim = null
    set t = null
endfunction

function ElementalRageCond takes nothing returns boolean
    local unit u=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local unit atker=GetAttacker()
    local boolean bool=u == atker
    set u = null
    set atker = null
    return bool
endfunction

function ElementalRage takes nothing returns nothing
    local unit u=GetLearningUnit()
    local integer lvl=GetLearnedSkillLevel()
    local trigger t
    local integer index

    set index = 0

    if lvl > 1 then
    set t = GetAttachedTrigger(u , "ElementalRagetrig")
    else
    set t = CreateTrigger()
    call AttachObject(u , "ElementalRagetrig" , t)
    loop
   //     if IsPlayerEnemy(Player(index),GetOwningPlayer(u)) then
        call TriggerRegisterPlayerUnitEvent(t , Player(index) , EVENT_PLAYER_UNIT_ATTACKED , null)

    //    endif
        set index = index + 1
        exitwhen index == bj_MAX_PLAYER_SLOTS
    endloop
    call TriggerAddCondition(t , Condition(function ElementalRageCond))
    call TriggerAddAction(t , function ElementalRage_Actions)
    
    call AttachObject(t , "trigunit" , u)
    endif
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwned"+I2S(lvl))
    set u = null
    set t = null
endfunction

function FrostShield takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local location targ=GetSpellTargetLoc()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer icen=18
    local integer projn=2 + lvl
    local integer i=1
    local unit spawn
    //x=GetLocationX(source) + dist * Cos(angle * bj_DEGTORAD)
    call ProjectileLaunchEx(Player(15) , ("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltMissile.mdl" ) , 1 , 255 , 255 , 255 , 255 , (( 900 )*1.0) , (( 0.5 )*1.0) , (( GetUnitX(caster) )*1.0) , (( GetUnitY(caster) )*1.0) , (( 0 )*1.0) , (( GetLocationX(targ) )*1.0) , (( GetLocationY(targ) )*1.0) , (( 0)*1.0)) // INLINED!!

    loop
        exitwhen i > projn
        if i == projn then
        call TriggerSleepAction(0)
        call ProjectileLaunchEx(Player(15) , ("Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" ) , 1 , 255 , 255 , 255 , 255 , (( 700 )*1.0) , (( 1 )*1.0) , (( GetLocationX(targ) )*1.0) , (( GetLocationY(targ) )*1.0) , (( 0 )*1.0) , (( GetLocationX(targ) + 300 * Cos(( 360 / projn ) * i * bj_DEGTORAD) )*1.0) , (( GetLocationY(targ) + 300 * Sin(( 360 / projn ) * i * bj_DEGTORAD) )*1.0) , (( 0)*1.0)) // INLINED!!
        else
        call ProjectileLaunchExTimeless(Player(15) , "Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" , 1 , 255 , 255 , 255 , 255 , 700 , 1 , GetLocationX(targ) , GetLocationY(targ) , 0 , GetLocationX(targ) + 300 * Cos(( 360 / projn ) * i * bj_DEGTORAD) , GetLocationY(targ) + 300 * Sin(( 360 / projn ) * i * bj_DEGTORAD) , 0)

        endif
        set i = i + 1
    endloop
    set i = 1
    loop
        exitwhen i > icen
        set spawn = CreateUnit(GetOwningPlayer(caster) , 'u01P' , GetLocationX(targ) + 300 * Cos(( 360 / icen ) * i * bj_DEGTORAD) , GetLocationY(targ) + 300 * Sin(( 360 / icen ) * i * bj_DEGTORAD) , bj_RADTODEG * Atan2(GetLocationY(targ) - GetLocationY(targ) + 300 * Sin(( 360 / icen ) * i * bj_DEGTORAD) , GetLocationX(targ) - GetLocationX(targ) + 300 * Cos(( 360 / icen ) * i * bj_DEGTORAD)))
        call UnitApplyTimedLife(spawn , 'BFfs' , 20 + lvl * 10)
        if lvl >= 2 then
        call UnitAddAbility(spawn , 'A0J5')
        endif
        if lvl >= 3 then
        call UnitAddAbility(spawn , 'A0J6')
        endif
        set i = i + 1
    endloop
    set caster = null
    call RemoveLocation(targ)
    set targ = null
    set spawn = null
endfunction

function ImpalingFrostNova takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer castn=8 + lvl * 4
    local integer i=1

    loop
        exitwhen i > castn
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0J9' , lvl , "impale" , GetUnitX(caster) + 30 * Cos(( 360 / castn ) * i * bj_DEGTORAD) , GetUnitY(caster) + 30 * Sin(( 360 / castn ) * i * bj_DEGTORAD) , 3)
        set i = i + 1
    endloop

    set caster = null
endfunction

function RetTrig_VortexFinder_Conditions takes nothing returns boolean
    return GetUnitTypeId(GetSummonedUnit()) == 'n03G'
endfunction

function RetTrig_VortexFinder_Actions takes nothing returns nothing
    local unit caster=GetSummoningUnit()
    local unit vortex=GetSummonedUnit()
    call AttachObject(caster , "IC_vortex" , vortex)
    set caster = null
    set vortex = null
endfunction

//===========================================================================
function InitRetTrig_VortexFinder takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SUMMON)
    call TriggerAddCondition(t , Condition(function RetTrig_VortexFinder_Conditions))
    call TriggerAddAction(t , function RetTrig_VortexFinder_Actions)
    set t = null
endfunction


function VortexPull takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit victim=GetEnumUnit()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit cast=GetAttachedUnit(t , "timercaster")
local real x1=GetUnitX(vortex)
local real y1=GetUnitY(vortex)
local real dy=GetUnitY(victim) - y1
local real dx=GetUnitX(victim) - x1
local real inwardv=2000
local real tanv=- 2
local real r=SquareRoot(dy * dy + dx * dx)
local real ang=Acos(dx / ( r ))
local real x3
local real y3
if ( victim != vortex ) and victim != cast then
if dy < 0 then
set ang = - ang
endif
set dx = ( inwardv / r )
if dx > 4 then
set dx = 4
endif
set dy = ( tanv / ( r ) )
set x3 = Cos(ang + dy) * ( r - dx ) + x1
set y3 = Sin(ang + dy) * ( r - dx ) + y1
call CS_MoveUnit(victim , x3 , y3)
endif
set victim = null
set vortex = null
set t = null
set cast = null
endfunction

function VortexTimer takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit vortex=GetAttachedUnit(t , "timerunit")
local unit caster=GetAttachedUnit(t , "timercaster")
local group thepulled=GetAttachedGroup(t , "timerpulled")
local boolexpr b=GetAttachedBoolExpr(t , "timerboolexpr")
if thepulled == null then
set thepulled = CreateGroup()
call AttachObject(t , "timerpulled" , thepulled)
else
call GroupClear(thepulled)
endif
if b == null then
set b = Condition(function RJ_FilterMobileEnemies)
call AttachObject(t , "timerboolexpr" , b)
endif
if GetUnitCurrentOrder(caster) == OrderId("tornado") then
call GroupEnumUnitsInRange(thepulled , GetUnitX(vortex) , GetUnitY(vortex) , 1200 , b)
call ForGroup(thepulled , function VortexPull)
else
call KillUnit(vortex)
call PauseTimer(t) //NONHEIIGHT
endif
set t = null
set vortex = null
set caster = null
set bj_groupRemoveGroupDest = null
set thepulled = null
set b = null
endfunction

function Vortex takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local unit vortex
    local timer t=GetAttachedTimer(caster , "IC_timer")
    call TriggerSleepAction(0)
    set vortex = GetAttachedUnit(caster , "IC_vortex")
    if t == null then
    set t = CreateTimer()
    call AttachObject(t , "timerunit" , vortex)
    call AttachObject(t , "timercaster" , caster)
    call AttachObject(caster , "IC_timer" , t)
    call TimerStart(t , (cs_TIMER_CYCLE) , true , function VortexTimer) // INLINED!!
    else
    call AttachObject(t , "timerunit" , vortex)
    call AttachObject(t , "timercaster" , caster)
    call PauseTimer(t)
    call TimerStart(t , (cs_TIMER_CYCLE) , true , function VortexTimer) // INLINED!!
    endif
    set t = null
    set caster = null
    set vortex = null
endfunction

function InitVortex takes nothing returns nothing
    call OnAbilityEffect('A0JB' , "Vortex")
    call InitRetTrig_VortexFinder()
endfunction


function RetTrig_Dont_Warp_Self_Copy_Conditions takes nothing returns boolean
    local unit u=GetOrderedUnit()
    local location l1=GetUnitLoc(u)
    local location l2=GetOrderPointLoc()
    local real x=GetLocationX(l1)
    local real y=GetLocationY(l1)
    local rect r=Rect(x - 383 , y - 383 , x + 383 , y + 383)
    local boolean b=RectContainsLoc(r , l2)
    if ( GetUnitAbilityLevel(u , 'A0G1') == 1 ) then
    call RemoveRect(r)
    set r = Rect(x - 511 , y - 511 , x + 511 , y + 511)
    set b = RectContainsLoc(r , l2)
    endif
    call RemoveLocation(l1)
    call RemoveLocation(l2)
    call RemoveRect(r)
    set l1 = null
    set l2 = null
    set r = null
    set b = b and ( GetUnitAbilityLevel(u , 'A0G1') == 1 or GetUnitAbilityLevel(u , 'A0G2') == 1 or GetUnitAbilityLevel(u , 'A0K8') == 1 )
    set u = null
        return b and GetIssuedOrderId() == 852619
    return true
endfunction

function RetTrig_Dont_Warp_Self_Copy_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetOrderedUnit() , "stop")
//    call DisplayTextToForce( GetPlayersAll(), I2S(GetIssuedOrderId()) )
endfunction

//===========================================================================
function InitRetTrig_Dont_Warp_Self_Aetherrift takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Dont_Warp_Self_Copy_Conditions))
    call TriggerAddAction(t , function RetTrig_Dont_Warp_Self_Copy_Actions)
    set t = null
endfunction


function IsTypeWagon takes integer wagonType returns boolean
    if ( ( wagonType == 'e00E' ) ) then
        return true
    endif
    if ( ( wagonType == 'e00F' ) ) then
        return true
    endif
    if ( ( wagonType == 'e00G' ) ) then
        return true
    endif
    if ( ( wagonType == 'e00H' ) ) then
        return true
    endif
    if ( ( wagonType == 'e00J' ) ) then
        return true
    endif
    if ( ( wagonType == 'e00I' ) ) then
        return true
    endif
    if ( ( wagonType == 'h019' ) ) then
        return true
    endif
    return false
endfunction

function IsTypeWagonTop takes integer wagonType returns boolean
    if ( ( wagonType == 'e01E' ) ) then
        return true
    endif
    if ( ( wagonType == 'e01F' ) ) then
        return true
    endif
    if ( ( wagonType == 'e01G' ) ) then
        return true
    endif
    if ( ( wagonType == 'e01H' ) ) then
        return true
    endif
    if ( ( wagonType == 'e01J' ) ) then
        return true
    endif
    if ( ( wagonType == 'e01I' ) ) then
        return true
    endif
    if ( ( wagonType == 'h02N' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_Wagons_Conditions takes nothing returns boolean
    return IsTypeWagon(GetTrainedUnitType())
endfunction

function RetTrig_Wagons_Actions takes nothing returns nothing
local unit bottomunit=GetTrainedUnit()
local unit topunit
local integer bottype=GetTrainedUnitType()
local integer toptype
local location rally=GetUnitRallyPoint(GetTriggerUnit())
    call ShowUnitHide(bottomunit)
    call PauseUnit(bottomunit , true)
if bottype == 'e00E' then
set toptype = 'e01E'
elseif bottype == 'e00F' then
set toptype = 'e01F'
elseif bottype == 'e00G' then
set toptype = 'e01G'
elseif bottype == 'e00H' then
set toptype = 'e01H'
elseif bottype == 'e00I' then
set toptype = 'e01J'
elseif bottype == 'e00J' then
set toptype = 'e01I'
elseif bottype == 'h019' then
set toptype = 'h02N'
endif
    set topunit = CreateUnit(GetOwningPlayer(bottomunit) , toptype , GetUnitX(bottomunit) , GetUnitY(bottomunit) , GetUnitFacing(bottomunit))
	call IssuePointOrderLoc(topunit , "attack" , rally)
    call AttachObject(bottomunit , "WG_topunit" , topunit)
    call AttachObject(topunit , "WG_bottomunit" , bottomunit)
set bottomunit = null
set topunit = null
call RemoveLocation(rally)
set rally = null
endfunction

//Wagonorder

function RetTrig_Wagonorder_Conditions takes nothing returns boolean
    return IsTypeWagon(GetUnitTypeId(GetOrderedUnit()))
endfunction

function RetTrig_Wagonorder_Actions takes nothing returns nothing
    // change Trained Unit to Ordered Unit
    call TriggerSleepAction(0)
    call IssuePointOrderById(GetAttachedUnit(GetOrderedUnit() , "WG_topunit") , GetIssuedOrderId() , GetOrderPointX() , GetOrderPointY())
    call IssueTargetOrderById(GetAttachedUnit(GetOrderedUnit() , "WG_topunit") , GetIssuedOrderId() , GetOrderTarget())
endfunction

//Wagonsdeath

function RetTrig_Wagonsdeath_Conditions takes nothing returns boolean
    return IsTypeWagonTop(GetUnitTypeId(GetDyingUnit()))
endfunction

function RetTrig_Wagonsdeath_Actions takes nothing returns nothing
local unit topunit=GetDyingUnit()
local unit bottomunit=GetAttachedUnit(GetDyingUnit() , "WG_bottomunit")
    call KillUnit(bottomunit)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((topunit)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(topunit))
    call FlushStoredMission(cs_cache , I2S(GetHandleId((bottomunit)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(bottomunit))
set bottomunit = null
set topunit = null
endfunction

function RetTrig_WagonFilteration takes nothing returns boolean
    return IsTypeWagon(GetUnitTypeId(GetFilterUnit()))
endfunction

function SwapWagonsEnum takes nothing returns nothing
local unit bottomunit=GetEnumUnit()
local unit topunit
local integer bottype=GetUnitTypeId(bottomunit)
local integer toptype
    call ShowUnitHide(bottomunit)
    call PauseUnit(bottomunit , true)
if bottype == 'e00E' then
set toptype = 'e01E'
elseif bottype == 'e00F' then
set toptype = 'e01F'
elseif bottype == 'e00G' then
set toptype = 'e01G'
elseif bottype == 'e00H' then
set toptype = 'e01H'
elseif bottype == 'e00I' then
set toptype = 'e01J'
elseif bottype == 'e00J' then
set toptype = 'e01I'
elseif bottype == 'h019' then
set toptype = 'h02N'
endif
    set topunit = CreateUnit(GetOwningPlayer(bottomunit) , toptype , GetUnitX(bottomunit) , GetUnitY(bottomunit) , GetUnitFacing(bottomunit))
    call AttachObject(bottomunit , "WG_topunit" , topunit)
    call AttachObject(topunit , "WG_bottomunit" , bottomunit)
set bottomunit = null
set topunit = null
endfunction

//===========================================================================
function InitRetTrig_Wagons takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_TRAIN_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_Wagons_Conditions))
    call TriggerAddAction(t , function RetTrig_Wagons_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Wagonorder_Conditions))
    call TriggerAddAction(t , function RetTrig_Wagonorder_Actions)
    set t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(t , Condition(function RetTrig_Wagonsdeath_Conditions))
    call TriggerAddAction(t , function RetTrig_Wagonsdeath_Actions)
    set t = null
    set bj_wantDestroyGroup = true
    call ForGroupBJ(GetUnitsInRectMatching(GetEntireMapRect() , Condition(function RetTrig_WagonFilteration)) , function SwapWagonsEnum)

endfunction

function LocustFollowerTemplateSetup takes nothing returns nothing
    local integer s
//*************************************************************************
//                         Locust Follower Template
//*************************************************************************
// instant (No Target) ability
//
// integer "unitid"           the id of the units to be spawned
// integer "unitcount"        the number of units to be spawned
// real    "unitspacing"      the distance (spacing) between spawned units
//                            I would suggest 128.00, it works pretty well
// real    "duration"         the duration of the spell
// real    "leash"            leash range for summoned units, not strictly enforced
//                            suggested 1000
// real     "deathduration"   the duration of the death animation for the unit

//initial angle and angle spacing should be added

     call SetTemplateDefaultInt("LocustFollowerTemplate" , "unitcount" , 2)
    call SetTemplateDefaultReal("LocustFollowerTemplate" , "unitspacing" , 128)
    call SetTemplateDefaultReal("LocustFollowerTemplate" , "leash" , 1000)
    
 //===================================================================================================
 // Aid of the Demonic Helpers ('A085')
 //
 set s = SetSpellTemplate('A085' , "LocustFollowerTemplate")

    call SetAbilityDataInt(s , "unitid" , 0 , 'E017')
    call SetAbilityDataInt(s , "unitcount" , 1 , 2)
    call SetAbilityDataInt(s , "unitcount" , 2 , 3)
    call SetAbilityDataInt(s , "unitcount" , 3 , 4)
    call SetAbilityDataReal(s , "duration" , 1 , 20)
    call SetAbilityDataReal(s , "duration" , 2 , 40)
    call SetAbilityDataReal(s , "duration" , 3 , 60)
    call SetAbilityDataReal(s , "deathduration" , 0 , 3)

 //===================================================================================================
 // Aqua Sphere Escort ('A0SG')
 //
 set s=SetSpellTemplate('A0SG',"LocustFollowerTemplate")

    call SetAbilityDataInt(s ,"unitid",0,'u01T')
    call SetAbilityDataInt(s ,"unitcount",0,10)
    call SetAbilityDataReal(s ,"duration",0,35)
    call SetAbilityDataReal(s ,"unitspacing",0,80)
    call SetAbilityDataReal(s ,"deathduration",0,3)
                              
endfunction

function RetTrig_VoidUpgradeFunc_Conditions takes nothing returns boolean
local unit u=GetTriggerUnit()
    if ( ( GetUnitTypeId(u) == 'n03H' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'o01S' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'n02Z' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'h02G' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'h02K' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'h02W' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'o01S' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'n03N' ) ) then
        set u = null
        return true
    endif
    if ( ( GetUnitTypeId(u) == 'o01T' ) ) then
        set u = null
        return true
    endif
    set u = null
    return false
endfunction

function RetTrig_VoidUpgradeFunc_Actions takes nothing returns nothing
local unit u=GetTriggerUnit()
local real life=GetUnitState(u , UNIT_STATE_LIFE)
local unit u2
local boolean sel
local location rally=GetUnitRallyPoint(u)

set sel = IsUnitSelected(u , GetOwningPlayer(u))
call ShowUnit(u , false)
call WaygateActivate(u , false)
call UnitRemoveAbility(u , 'Awrp')
set u2 = CreateUnit(GetOwningPlayer(u) , GetUnitTypeId(u) , GetUnitX(u) , GetUnitY(u) , GetUnitFacing(u))
if sel then
call SelectUnitAddForPlayer(u2 , GetOwningPlayer(u))
endif
call IssuePointOrder(u , "attack" , GetLocationX(rally) , GetLocationY(rally))
call SetUnitState(u2 , UNIT_STATE_LIFE , life)
call KillUnit(u)
call RemoveUnit(u)
call RemoveLocation(rally)
set rally = null
set u = null
set u2 = null
endfunction

//===========================================================================
function InitRetTrig_VoidUpgradeFunc takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_UPGRADE_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_VoidUpgradeFunc_Conditions))
    call TriggerAddAction(t , function RetTrig_VoidUpgradeFunc_Actions)
	set t = null
endfunction

function RetTrig_MawOblivionAttack_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'U01K' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_MawOblivionAttack_Actions takes nothing returns nothing
local unit caster=GetAttacker()
local unit target=GetTriggerUnit()
local unit cs

    set cs = CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0KQ' , GetHeroLevel(caster) , "ward" , GetUnitX(target) , GetUnitY(target) , 4)
call AttachObject(cs , "caster" , caster)
    //call CreateTrackable("Doodads\\LordaeronSummer\\Props\\TorchHuman\\TorchHuman.mdl",GetUnitX(cs),GetUnitY(cs),0)
//    call BJDebugMsg(GetHeroProperName(caster)+" attacks "+GetUnitName(target) + " for " + I2S(GetHeroLevel(caster)) + " tentacles.")
//    call BJDebugMsg(GetPlayerName(GetOwningPlayer(caster))+","+R2S(GetUnitX(caster))+","+R2S(GetUnitY(caster))+","+I2S(0)+","+GetObjectName('A0KQ')+","+I2S(GetHeroLevel(caster))+","+"ward"+","+R2S(GetUnitX(target))+","+R2S(GetUnitY(target))+","+I2S(4))

set caster = null
set target = null
endfunction

//===========================================================================
function InitRetTrig_MawOblivionAttack takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(t , Condition(function RetTrig_MawOblivionAttack_Conditions))
    call TriggerAddAction(t , function RetTrig_MawOblivionAttack_Actions)
	set t = null
endfunction

function RetTrig_TentacleAttackfix_Conditions takes nothing returns boolean
    if GetUnitTypeId(GetAttacker()) == 'n03P' or GetUnitTypeId(GetAttacker()) == 'n03O' or GetUnitTypeId(GetAttacker()) == 'n03Q' or GetUnitTypeId(GetAttacker()) == 'n03S' then
        return true
    endif
    return false
endfunction

function RetTrig_TentacleAttackfix_Actions takes nothing returns nothing
    call SetUnitFacingToFaceUnitTimed(GetAttacker() , GetAttackedUnitBJ() , 0.00)
endfunction

//===========================================================================
function InitRetTrig_TentacleAttackfix takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(t , Condition(function RetTrig_TentacleAttackfix_Conditions))
    call TriggerAddAction(t , function RetTrig_TentacleAttackfix_Actions)
	set t = null
endfunction

function SnappySpits takes nothing returns nothing
    local unit cast=GetSpellAbilityUnit()
    call UnitAddAbility(cast , 'A0O2')
    call SetPlayerAbilityAvailable(GetOwningPlayer(cast) , 'A0O2' , false)
    call PolledWait(18)
    call UnitRemoveAbility(cast , 'A0O2')
    set cast = null
    //A0O0 adds A0A8 in spbk A0O1
endfunction

function CryOfInspiration takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local player p=GetOwningPlayer(cast)
call CasterCastAbilityLevelPoint(p , 'A0IN' , GetUnitAbilityLevel(cast , GetSpellAbilityId()) , "spellshieldaoe" , GetUnitX(cast) , GetUnitY(cast) , true)
set cast = null
set p = null
endfunction

function MoltenRainUniqueCasting takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local player p=GetOwningPlayer(cast)
call AttachObject(cast , "MoltenRainCaster" , CasterCastAbilityPointEx(p , GetUnitX(cast) , GetUnitY(cast) , GetUnitFlyHeight(cast) , 'A0DZ' , 1 , "starfall" , GetUnitX(cast) , GetUnitY(cast) , 15))
set cast = null
set p = null
endfunction

function MoltenRainUniqueCastingEndcast takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local player p=GetOwningPlayer(cast)
local unit cs=GetAttachedUnit(cast , "MoltenRainCaster")
call IssueImmediateOrder(cs , "stop")
call RecycleCaster((cs)) // INLINED!!
set cast = null
set p = null
set cs = null
endfunction

function InitRetSpellCorrections takes nothing returns nothing
call OnAbilityEffect('A0P9' , "CryOfInspiration")
call OnAbilityEffect('A0PA' , "MoltenRainUniqueCasting")
call OnAbilityEndCast('A0PA' , "MoltenRainUniqueCastingEndcast")
endfunction

function LoadCustomBuildSpell takes integer buildingTypeId,integer ChargeGnLSpell,integer spbkForBuildSpell,integer goldCost,integer lumberCost,integer foodCost,string hotKey,real minRange returns nothing
    //Make both Hot Keys match, for simplicity
    //MinRange for small void buildings is 384, for big is 512
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "goldCost" , goldCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "lumberCost" , lumberCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "foodCost" , foodCost)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "spbkForBuildSpell" , spbkForBuildSpell)
    call StoreString(CSCache() , I2S(ChargeGnLSpell) , "hotKey" , hotKey)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "buildingTypeId" , buildingTypeId)
//    call StoreReal(CSCache(),I2S(ChargeGnLSpell),"minRange",minRange) 
    call StoreReal(CSCache() , I2S(spbkForBuildSpell) , "minRange" , minRange)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "numSpells" , GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells") + 1)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "spell" + I2S(GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells")) , spbkForBuildSpell)
    
endfunction

function LoadCustomBuildSpellMinXY takes integer buildingTypeId,integer ChargeGnLSpell,integer spbkForBuildSpell,integer goldCost,integer lumberCost,integer foodCost,string hotKey,real minRangeX,real minRangeY returns nothing
    //Make both Hot Keys match, for simplicity
    //MinRange for small void buildings is 384, for big is 512
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "goldCost" , goldCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "lumberCost" , lumberCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "foodCost" , foodCost)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "spbkForBuildSpell" , spbkForBuildSpell)
    call StoreString(CSCache() , I2S(ChargeGnLSpell) , "hotKey" , hotKey)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "buildingTypeId" , buildingTypeId)
//    call StoreReal(CSCache(),I2S(ChargeGnLSpell),"minRange",minRange) 
    call StoreReal(CSCache() , I2S(spbkForBuildSpell) , "minRangeX" , minRangeX)
    call StoreReal(CSCache() , I2S(spbkForBuildSpell) , "minRangeY" , minRangeY)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "numSpells" , GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells") + 1)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "spell" + I2S(GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells")) , spbkForBuildSpell)
    
endfunction

function LoadCustomBuildSpellExtendedXY takes integer buildingTypeId,integer ChargeGnLSpell,integer spbkForBuildSpell,integer goldCost,integer lumberCost,integer foodCost,string hotKey,real minRangeX,real minRangeY returns nothing
    //This function for use with Morphing spells instead of Charge Gold and Lumber. That way, requirements, mana cost, and food cost will function properly.
    //Make both Hot Keys match, for simplicity
    //MinRange for small void buildings is 384, for big is 512
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "goldCost" , goldCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "lumberCost" , lumberCost)
    call StoreInteger(CSCache() , I2S(buildingTypeId) , "foodCost" , foodCost)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "spbkForBuildSpell" , spbkForBuildSpell)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "dummySpellType" , 1)
    call StoreString(CSCache() , I2S(ChargeGnLSpell) , "hotKey" , hotKey)
    call StoreInteger(CSCache() , I2S(ChargeGnLSpell) , "buildingTypeId" , buildingTypeId)
//    call StoreReal(CSCache(),I2S(ChargeGnLSpell),"minRange",minRange) 
    call StoreReal(CSCache() , I2S(spbkForBuildSpell) , "minRangeX" , minRangeX)
    call StoreReal(CSCache() , I2S(spbkForBuildSpell) , "minRangeY" , minRangeY)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "numSpells" , GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells") + 1)
    call StoreInteger(CSCache() , "BuildCustomGlobals" , "spell" + I2S(GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells")) , spbkForBuildSpell)
    
endfunction


function LoadCustomBuildSpellExtended takes integer buildingTypeId,integer ChargeGnLSpell,integer spbkForBuildSpell,integer goldCost,integer lumberCost,integer foodCost,string hotKey,real minRange returns nothing
call LoadCustomBuildSpellExtendedXY(buildingTypeId , ChargeGnLSpell , spbkForBuildSpell , goldCost , lumberCost , foodCost , hotKey , minRange , minRange)
endfunction

function RetTrig_CustomBuildMinRange_Conditions takes nothing returns boolean
    local unit u
    local location l1
    local location l2
    local real x
    local real y
    local rect r
    local boolean b
    local integer numBuilds
    local integer iBuildId
    local integer i=1
    local real minRange
    local real minRangeX
    local real minRangeY
	if GetIssuedOrderId() != 852619 then
	    return false //  important to do this early!!!
	else
	    set u=GetOrderedUnit()
		set l1=GetUnitLoc(u)
		set l2=GetOrderPointLoc()
		set x=GetLocationX(l1)
		set y=GetLocationY(l1)
		set b=false //=RectContainsLoc(r,l2)
		set numBuilds=GetStoredInteger(CSCache() , "BuildCustomGlobals" , "numSpells")
		
	endif
    loop
        exitwhen i > numBuilds
        set iBuildId = GetStoredInteger(CSCache() , "BuildCustomGlobals" , "spell" + I2S(i))
        if ( GetUnitAbilityLevel(u , iBuildId) >= 1 ) then
        
        if not ( HaveStoredReal(CSCache() , I2S(iBuildId) , "minRangeX") ) then
        set minRange = GetStoredReal(CSCache() , I2S(iBuildId) , "minRange")
        set minRange = minRange - 1 //Converts a minimum range into a box width
        set r = Rect(x - minRange , y - minRange , x + minRange , y + minRange)
        else
        set minRangeX = GetStoredReal(CSCache() , I2S(iBuildId) , "minRangeX")
        set minRangeY = GetStoredReal(CSCache() , I2S(iBuildId) , "minRangeY")
        set minRangeX = minRangeX - 1 //Converts a minimum range into a box width
        set minRangeY = minRangeY - 1 //Converts a minimum range into a box width
        set r = Rect(x - minRangeX , y - minRangeY , x + minRangeX , y + minRangeY)
        endif
        
        set b = RectContainsLoc(r , l2)
        call RemoveRect(r)
        endif
        set i = i + 1
    endloop
    call RemoveLocation(l1)
    call RemoveLocation(l2)
    set l1 = null
    set l2 = null
    set r = null
    set u = null
        return b
    return true
endfunction

function RetTrig_CustomBuildMinRange_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetOrderedUnit() , "stop")
//    call DisplayTextToForce( GetPlayersAll(), I2S(GetIssuedOrderId()) )
endfunction

//===========================================================================
function InitRetTrig_CustomBuildMinRange takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_CustomBuildMinRange_Conditions))
    call TriggerAddAction(t , function RetTrig_CustomBuildMinRange_Actions)
    set t = null
endfunction

function RetTrig_CustomBuildSpellswapper_Conditions takes nothing returns boolean
    return HaveStoredInteger(CSCache() , I2S(GetSpellAbilityId()) , "spbkForBuildSpell")
endfunction

function CustomBuildSpellswapperTimerEnd2 takes nothing returns nothing
local timer t=GetExpiredTimer()
local unit cast=GetAttachedUnit(t , "cast")
local integer spbk=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "spbk"))) // INLINED!!
local player p=GetOwningPlayer(cast)
local string hotKey=(GetStoredString(cs_cache , I2S(GetHandleId((t ))) , ( "hotKey"))) // INLINED!!

call SetPlayerAbilityAvailable(p , spbk , false)

call CS_KillTimer(t)
set t = null
endfunction

function CustomBuildSpellswapperTimerEnd takes nothing returns nothing
local timer t=GetExpiredTimer()
local timer t2=CreateTimer()
local unit cast=GetAttachedUnit(t , "cast")
local integer spbk=(GetStoredInteger(cs_cache , I2S(GetHandleId((t ))) , ( "spbk"))) // INLINED!!
local player p=GetOwningPlayer(cast)
local string hotKey=(GetStoredString(cs_cache , I2S(GetHandleId((t ))) , ( "hotKey"))) // INLINED!!

    call ForceUICancelBJ(p)
    call ForceUIKeyBJ(p , hotKey)
    call ForceUIKeyBJ(p , hotKey)

call AttachObject(t2 , "cast" , cast)
call AttachInt(t2 , "spbk" , spbk)
call AttachString(t2 , "hotKey" , hotKey)
call TimerStart(t2 , 0.01 , false , function CustomBuildSpellswapperTimerEnd2)

//call SetPlayerAbilityAvailable(p,spbk,false)
call CS_KillTimer(t)
set t = null
set t2 = null
endfunction
         
function RetTrig_CustomBuildSpellswapper_Actions takes nothing returns nothing
local timer t=CreateTimer()
local gamecache g=CSCache()
local integer ChargeId=GetSpellAbilityId()
local integer buildnId=GetStoredInteger(g , I2S(ChargeId) , "buildingTypeId")
local integer goldCost=GetStoredInteger(g , I2S(buildnId) , "goldCost")
local integer lumberCost=GetStoredInteger(g , I2S(buildnId) , "lumberCost")
local integer spbk=GetStoredInteger(g , I2S(ChargeId) , "spbkForBuildSpell")
local string hotKey=GetStoredString(g , I2S(ChargeId) , "hotKey")
local unit cast=GetSpellAbilityUnit()
local player p=GetOwningPlayer(GetSpellAbilityUnit())
local integer numBuilds=GetStoredInteger(g , "BuildCustomGlobals" , "numSpells")
local integer iBuildId
local integer i=1
loop
    exitwhen i > numBuilds
    set iBuildId = GetStoredInteger(g , "BuildCustomGlobals" , "spell" + I2S(i))
    if iBuildId != spbk then
    call UnitRemoveAbility(cast , iBuildId)
    endif
    set i = i + 1
endloop
    call UnitAddAbility(cast , spbk)
    call SetPlayerAbilityAvailable(p , spbk , true)
    
call AttachObject(t , "cast" , cast)
call AttachInt(t , "spbk" , spbk)
call AttachString(t , "hotKey" , hotKey)

if GetStoredInteger(g , I2S(ChargeId) , "dummySpellType") == 1 then
call IssueImmediateOrder(cast , "stop")
else
call AdjustPlayerStateSimpleBJ(p , PLAYER_STATE_RESOURCE_GOLD , goldCost)
call AdjustPlayerStateSimpleBJ(p , PLAYER_STATE_RESOURCE_LUMBER , lumberCost)
endif
call TimerStart(t , 0.04 , false , function CustomBuildSpellswapperTimerEnd)
set g = null
set t = null
set cast = null
set p = null
endfunction

//===========================================================================
function InitRetTrig_CustomBuildSpellswapper takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_CustomBuildSpellswapper_Conditions))
    call TriggerAddAction(t , function RetTrig_CustomBuildSpellswapper_Actions)
    set t = null
endfunction


function RetTrig_CustomBuildForcedPrice_Conditions takes nothing returns boolean
    return HaveStoredInteger(CSCache() , I2S(GetUnitTypeId(GetConstructingStructure())) , "goldCost") and GetPlayerController(GetOwningPlayer(GetConstructingStructure())) != MAP_CONTROL_COMPUTER
endfunction

function RetTrig_CustomBuildForcedPrice_Actions takes nothing returns nothing
local unit bu=GetConstructingStructure()
local gamecache g=CSCache()
local integer ut=GetUnitTypeId(bu)
local player p=GetOwningPlayer(bu)
local integer goldCost=GetStoredInteger(g , I2S(ut) , "goldCost")
local integer lumberCost=GetStoredInteger(g , I2S(ut) , "lumberCost")
local integer foodCost=GetStoredInteger(g , I2S(ut) , "foodCost")
local integer foodRemaining=GetPlayerState(p , PLAYER_STATE_RESOURCE_FOOD_CAP) - GetPlayerState(p , PLAYER_STATE_RESOURCE_FOOD_USED)
local boolean cancelStruct=false
    if not ( GetPlayerState(p , PLAYER_STATE_RESOURCE_GOLD) >= goldCost ) then
    call CS_Error(p , "Not enough gold.")
    set cancelStruct = true
    elseif not ( GetPlayerState(p , PLAYER_STATE_RESOURCE_LUMBER) >= lumberCost ) then
    call CS_Error(p , "Not enough lumber.")
    set cancelStruct = true
    elseif not ( ( foodCost == 0 ) or ( foodRemaining >= foodCost ) ) then
    call CS_Error(p , "You need more food available.")
    set cancelStruct = true
    endif
    if cancelStruct then
    call RemoveUnit(bu)
    else
    call AdjustPlayerStateSimpleBJ(p , PLAYER_STATE_RESOURCE_GOLD , 0 - goldCost)
    call AdjustPlayerStateSimpleBJ(p , PLAYER_STATE_RESOURCE_LUMBER , 0 - lumberCost)
    endif
    
set bu = null
set p = null
set g = null
endfunction

//==== Init Trigger CustomBuildForcedPrice ====
function InitRetTrig_CustomBuildForcedPrice takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_START)
    call TriggerAddCondition(t , Condition(function RetTrig_CustomBuildForcedPrice_Conditions))
    call TriggerAddAction(t , function RetTrig_CustomBuildForcedPrice_Actions)
    set t = null
endfunction

function RetTrig_CustomBuildCancel_Conditions takes nothing returns boolean
    return HaveStoredInteger(CSCache() , I2S(GetUnitTypeId(GetCancelledStructure())) , "goldCost")
endfunction

function RetTrig_CustomBuildCancel_Actions takes nothing returns nothing
local unit cast= GetCancelledStructure()
local player owner= GetOwningPlayer(cast)
local gamecache g=CSCache()
local integer ut=GetUnitTypeId(cast)
local integer goldCost=GetStoredInteger(g , I2S(ut) , "goldCost")
local integer lumberCost=GetStoredInteger(g , I2S(ut) , "lumberCost")

    call AdjustPlayerStateSimpleBJ(owner , PLAYER_STATE_RESOURCE_GOLD , R2I(goldCost * 0.75))
    call AdjustPlayerStateSimpleBJ(owner , PLAYER_STATE_RESOURCE_LUMBER , R2I(lumberCost * 0.75))

set cast = null
set owner = null
set g = null
endfunction

//==== Init Trigger CustomBuildCancel ====
function InitRetTrig_CustomBuildCancel takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL)
    call TriggerAddCondition(t , Condition(function RetTrig_CustomBuildCancel_Conditions))
    call TriggerAddAction(t , function RetTrig_CustomBuildCancel_Actions)
    set t = null
endfunction

function InitRetCustomBuild takes nothing returns nothing
call InitRetTrig_CustomBuildForcedPrice()
call InitRetTrig_CustomBuildSpellswapper()
call InitRetTrig_CustomBuildMinRange()
call InitRetTrig_CustomBuildCancel()
endfunction

function RetTrig_ReqSys_TechComplete_Conditions takes nothing returns boolean
    
    return IsUnitType(GetTriggerUnit() , UNIT_TYPE_STRUCTURE) //HaveStoredInteger(CSCache(),I2S(CS_H2I(GetConstructedStructure())),"ReqSys_NumAbils")
endfunction

function ReqSys_AbilFilter takes nothing returns boolean
    return ( GetUnitAbilityLevel(GetFilterUnit() , bj_forceCountPlayers) >= 1 )
endfunction


function ReqSys_SwapSpells takes nothing returns nothing
    local integer rabilid=bj_forceCountPlayers
    local integer abilid=bj_groupCountUnits
    local unit e=GetEnumUnit()
    call UnitRemoveAbility(e , rabilid)
//    call BJDebugMsg(GetAbilityName(rabilid)+" is being removed from "+GetUnitName(e)+".")    
    call UnitAddAbility(e , abilid)
//    call BJDebugMsg(GetAbilityName(abilid)+" is being added to "+GetUnitName(e)+".")    
    return 
endfunction

function LivingDonePlayerUnitsOfTypeIdFilter takes nothing returns boolean
    local unit filterUnit= GetFilterUnit()
    return ( IsUnitAliveBJ(filterUnit) and GetUnitTypeId(filterUnit) == bj_livingPlayerUnitsTypeId ) and GetUnitAbilityLevel(filterUnit , 'A0H9') >= 1
endfunction

function CountLivingDonePlayerUnitsOfTypeId takes integer unitId,player whichPlayer returns integer
    local group g
    local integer matchedCount
    local boolexpr b=Filter(function LivingDonePlayerUnitsOfTypeIdFilter)

    set g = CreateGroup()
    set bj_livingPlayerUnitsTypeId = unitId
    call GroupEnumUnitsOfPlayer(g , whichPlayer , b)
    set matchedCount = CountUnitsInGroup(g)
    call DestroyGroup(g)
    call DestroyBoolExpr(b)
    set b = null
    set g = null

    return matchedCount
endfunction

function ReqSys_PlayerRefreshAll takes player p returns nothing
    local integer n=GetStoredInteger(CSCache() , "ReqSys" , "NumAbils")
    local integer i=0
    local integer ix=0
    local integer nx
    local integer abilid
    local integer rabilid
    local group g
    local boolexpr b
    local boolean hasreqs
    loop
        exitwhen i == n
        set rabilid = GetStoredInteger(CSCache() , "ReqSys" , "ReqAbil" + I2S(i))
        set abilid = GetStoredInteger(CSCache() , "ReqSys" , "Abil" + I2S(i))
        set ix = 0
        set nx = GetStoredInteger(CSCache() , I2S(abilid) , "StructN")
        set hasreqs = true
        loop
            exitwhen ix == nx
            if not ( CountLivingDonePlayerUnitsOfTypeId(GetStoredInteger(CSCache() , I2S(abilid) , "Struct" + I2S(ix)) , p) >= 1 ) then
            set hasreqs = false
            endif
            set ix = ix + 1
        endloop
        
        if hasreqs == true then
        set bj_groupCountUnits = abilid
        set bj_forceCountPlayers = rabilid
        else
        set bj_groupCountUnits = rabilid
        set bj_forceCountPlayers = abilid
        endif
        
        set g = CreateGroup()
        set b = Filter(function ReqSys_AbilFilter)
        call GroupEnumUnitsOfPlayer(g , p , b)
        
        call ForGroup(g , function ReqSys_SwapSpells)
        call DestroyGroup(g)
        call DestroyBoolExpr(b)
        
        set i = i + 1
    endloop
    set g = null
    set b = null
endfunction

function ReqSys_RefreshAllEnum takes nothing returns nothing
    local player p=GetEnumPlayer()
    call ReqSys_PlayerRefreshAll(p)
endfunction

function ReqSys_RefreshAll takes nothing returns nothing
    call ForForce(bj_FORCE_ALL_PLAYERS , function ReqSys_RefreshAllEnum)

endfunction

function RetTrig_ReqSys_TechComplete_Actions takes nothing returns nothing
//    local unit u=GetConstructedStructure()
//    local string uid=I2S(CS_H2I(u))
//    local integer n=GetStoredInteger(CSCache(),uid,"ReqSys_NumAbils")
//    local integer i=0
//    local integer abilid
//    local integer rabilid
//    local group g
//    local boolexpr b
//    
//    loop
//        exitwhen i=n
//        set rabilid=GetStoredInteger(CSCache(),uid,"ReqAbil"+I2S(i))
//        set abilid=GetStoredInteger(CSCache(),uid,"Abil"+I2S(i))
//        if HaveStoredInteger(CSCache(),abilid,"Reqs"
//        set bj_groupCountUnits=rabilid
//        set g=CreateGroup()
//        set b=Filter(function ReqSys_AbilFilter)
//        call GroupEnumUnitsOfPlayer(g,GetOwningPlayer(u),b)
//        set bj_groupCountUnits=abilid
//        set bj_forceCountPlayers=rabilid
//        call ForGroup(b,function ReqSys_SwapSpells)
//        call DestroyGroup(g)
//        call DestroyBoolExpr(b)
//        set i=i+1
//    endloop
//    set g=null
//    set b=null
//    set u=null
call ReqSys_PlayerRefreshAll(GetOwningPlayer(GetTriggerUnit()))
if ( GetTriggerUnit() == GetConstructedStructure() ) then
call UnitAddAbility(GetTriggerUnit() , 'A0H9') //This is an ability with no art and no effect that declares a unit is completed building, because there's no native for that
call UnitMakeAbilityPermanent(GetTriggerUnit() , true , 'A0H9')
endif
endfunction

//==== Init Trigger ReqSys_TechComplete ====
function InitRetTrig_ReqSys_TechComplete takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_UPGRADE_FINISH)
    call TriggerRegisterEnterRectSimple(t , GetWorldBounds())
    call TriggerAddCondition(t , Condition(function RetTrig_ReqSys_TechComplete_Conditions))
    call TriggerAddAction(t , function RetTrig_ReqSys_TechComplete_Actions)
    set t = null
endfunction

function RetTrig_ReqSys_TechLoss_Conditions takes nothing returns boolean
    
    return HaveStoredInteger(CSCache() , I2S((GetHandleId((GetDyingUnit())))) , "ReqSys_NumAbils") // INLINED!!
endfunction

function RetTrig_ReqSys_TechLoss_Actions takes nothing returns nothing
call ReqSys_PlayerRefreshAll(GetOwningPlayer(GetDyingUnit()))
endfunction

//==== Init Trigger ReqSys_TechLoss ====
function InitRetTrig_ReqSys_TechLoss takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_DEATH)
//    call TriggerAddCondition(t, Condition(function RetTrig_ReqSys_TechLoss_Conditions))
    call TriggerAddAction(t , function RetTrig_ReqSys_TechLoss_Actions)
    set t = null
endfunction


function ReqSys_DisableSpbk takes nothing returns nothing
local player p=GetEnumPlayer()
call SetPlayerAbilityAvailable(p , bj_groupCountUnits , false)
call SetPlayerAbilityAvailable(p , bj_forceCountPlayers , false)
set p = null
endfunction

function ReqSys_AddSpellStructReq takes integer abilityId,integer disableAbilityId,integer structId,boolean spbk returns nothing
local integer n=GetStoredInteger(CSCache() , "ReqSys" , "NumAbils")
local integer nx=GetStoredInteger(CSCache() , I2S(abilityId) , "StructN")
if HaveStoredInteger(CSCache() , I2S(abilityId) , "ReqN") then
set n = GetStoredInteger(CSCache() , I2S(abilityId) , "ReqN")
endif
if spbk then
    set bj_groupCountUnits = abilityId
    set bj_forceCountPlayers = disableAbilityId
    call ForForce(bj_FORCE_ALL_PLAYERS , function ReqSys_DisableSpbk)
endif
call StoreInteger(CSCache() , "ReqSys" , "ReqAbil" + I2S(n) , disableAbilityId)
call StoreInteger(CSCache() , "ReqSys" , "Abil" + I2S(n) , abilityId)
call StoreInteger(CSCache() , I2S(abilityId) , "Struct" + I2S(nx) , structId)
call StoreInteger(CSCache() , I2S(abilityId) , "ReqN" , n)
call StoreInteger(CSCache() , "ReqSys" , "NumAbils" , n + 1)
call StoreInteger(CSCache() , I2S(abilityId) , "StructN" , nx + 1)
endfunction


function InitRetReqSys takes nothing returns nothing
call InitRetTrig_ReqSys_TechLoss()
call InitRetTrig_ReqSys_TechComplete()
call ReqSys_AddSpellStructReq('A0PP' , 'A0PX' , 'h02I' , true)
call ReqSys_AddSpellStructReq('A0PQ' , 'A0PY' , 'h02F' , true)
call ReqSys_AddSpellStructReq('A0Q0' , 'A0Q5' , 'h02I' , true)
call ReqSys_AddSpellStructReq('A0PR' , 'A0PZ' , 'h02F' , true)
call ReqSys_AddSpellStructReq('A0PR' , 'A0PZ' , 'h02I' , false)
//call ReqSys_AddSpellStructReq('A0O7','A0Q8','h012',false)
endfunction

function SelectNetherChildrenEnum takes nothing returns nothing
local unit e= GetEnumUnit()
if RJ_DistanceBetweenUnits(bj_lastCreatedUnit , e) <= 3500 then
call SelectUnitAddForPlayer(e , GetOwningPlayer(e))
endif
set e = null
endfunction

function SelectNetherChildren takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local player p= GetOwningPlayer(cast)
local group g=GetUnitsOfPlayerAndTypeId(p , 'n03A')
set bj_lastCreatedUnit = cast
call ClearSelectionForPlayer(p)
if FirstOfGroup(g) != null then
call ForGroup(g , function SelectNetherChildrenEnum)
else
call CS_Error(p,"No Children of the Nether were found.")
endif
set cast = null
call DestroyGroup(g)
set g = null
endfunction

function SelectNetherChildrenLvl2 takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local player p= GetOwningPlayer(cast)
local group g=GetUnitsOfPlayerAndTypeId(p , 'n03J')
set bj_lastCreatedUnit = cast
call ClearSelectionForPlayer(p)
if FirstOfGroup(g) != null then
call ForGroup(g , function SelectNetherChildrenEnum)
else
call CS_Error(p,"No Empowered Netherlings were found.")
endif
set cast = null
call DestroyGroup(g)
set g = null
endfunction

function RetTrig_SupaShroomVoid_Conditions_New takes nothing returns boolean
    return ( GetUnitTypeId(GetConstructedStructure()) == 'n02X' )
endfunction

function CountSporeUnitsInGroupEnum takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetEnumUnit()
    local unit struct=GetAttachedUnit(t , "timerunit")
    if GetUnitTypeId(u) == 'u01R' and not IsUnitDeadBJ(u) then
    set bj_groupCountUnits = bj_groupCountUnits + 1
    call IssuePointOrder(u , "attack" , GetUnitX(struct) , GetUnitY(struct))
    endif
    set u = null
    set t = null
    set struct = null
endfunction

function FinishSporeUnitsInGroupEnum takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetEnumUnit()
    local unit struct=GetAttachedUnit(t , "timerunit")
    if GetUnitTypeId(u) == 'u01R' and not IsUnitDeadBJ(u) then
    call UnitApplyTimedLife(u , 'BTLF' , 30)
    call IssuePointOrder(u , "attack" , GetUnitX(struct) , GetUnitY(struct))
    endif
    set u = null
    set t = null
    set struct = null
endfunction

function CountSporeUnitsInGroup takes group g returns integer
    set bj_groupCountUnits = 0
    call ForGroup(g , function CountSporeUnitsInGroupEnum)
    return bj_groupCountUnits
endfunction

function SupaShroomVoid_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "timerunit")
//    local unit spawn
    local group g=GetAttachedGroup(u , "spawnsgroup")
    local real dist
    local real ang
    if g == null then
    set g = CreateGroup()
    call AttachObject(u , "spawnsgroup" , g)
    endif
    if IsUnitDeadBJ(u) != true then
    if CountSporeUnitsInGroup(g) < 5 then
    set dist = GetRandomReal(0 , 750)
    set ang = GetRandomReal(0 , 360) * bj_DEGTORAD
    call GroupAddUnit(g , CreateUnit(GetOwningPlayer(u) , 'u01R' , GetUnitX(u) , GetUnitY(u) , GetRandomReal(0 , 360)))
    endif
    else
    call ForGroup(g , function FinishSporeUnitsInGroupEnum)
    call FlushStoredMission(cs_cache , I2S(GetHandleId((t)))) // INLINED!!
    call FlushChildHashtable(rdg_cstable, GetHandleId(t))
    call DestroyGroup(g)
    call DestroyTimer(t)
    endif
    set g = null
//    set spawn=null
    set u = null
    set t = null
endfunction

function RetTrig_SupaShroomVoid_Actions_New takes nothing returns nothing
  local unit u=GetConstructedStructure()
  local location l=GetUnitLoc(u)
  local timer t

    set t = CreateTimer()
    call AttachObject(t , "timerunit" , u)
    call TimerStart(t , 8.00 , true , function SupaShroomVoid_Timer)
    set t = null

  call RemoveLocation(l)
  set l = null
  set u = null

endfunction

//===========================================================================
function InitRetTrig_SupaShroomVoid takes nothing returns nothing
  local trigger t= CreateTrigger()

    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_SupaShroomVoid_Conditions_New))
    call TriggerAddAction(t , function RetTrig_SupaShroomVoid_Actions_New)

  set t = null
endfunction

function RetTrig_VoidUpgradeRally_Func001C takes nothing returns boolean
    if ( ( GetUnitRace(GetTriggerUnit()) == RACE_DEMON ) ) then
        return true
    endif
    if ( ( GetUnitTypeId(GetTriggerUnit()) == 'e01K' ) ) then
        return true
    endif
    return false
endfunction

function RetTrig_VoidUpgradeRally_Conditions takes nothing returns boolean
    if ( not RetTrig_VoidUpgradeRally_Func001C() ) then
        return false
    endif
    if ( not ( IsUnitType(GetTriggerUnit() , UNIT_TYPE_STRUCTURE) != true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_VoidUpgradeRally_Actions takes nothing returns nothing
    call IssuePointOrderLocBJ(GetTriggerUnit() , "attack" , GetUnitRallyPoint(GetTriggerUnit()))
    call UnitRemoveAbilityBJ('ARal' , GetTriggerUnit())
endfunction

//===========================================================================
function InitRetTrig_VoidUpgradeRally takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_UPGRADE_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_VoidUpgradeRally_Conditions))
    call TriggerAddAction(t , function RetTrig_VoidUpgradeRally_Actions)
	set t = null
endfunction

function DetonateRift takes nothing returns nothing
local unit cast=GetSpellAbilityUnit()
local integer abi=GetSpellAbilityId()
local real hpRemainPerc= 0
call PolledWait(2.7)
if IsUnitAliveBJ(cast) then
call ShowUnit(cast , false)
call DestroyEffect(AddSpellEffectById(abi , EFFECT_TYPE_AREA_EFFECT , GetUnitX(cast) , GetUnitY(cast)))
set hpRemainPerc = GetUnitState(cast , UNIT_STATE_LIFE) / GetUnitState(cast , UNIT_STATE_MAX_LIFE)
call KillUnit(cast)
call SimResourceGet(GetOwningPlayer(cast) , R2I(hpRemainPerc * 50) , GetUnitLoc(cast) , 100.00 , 86.27 , 0.00 , true)
call AdjustPlayerStateSimpleBJ(GetOwningPlayer(cast) , PLAYER_STATE_RESOURCE_GOLD , R2I(hpRemainPerc * 50))
call DamageUnitsInAOE(GetOwningPlayer(cast) , ( 1.0 - hpRemainPerc ) * 100 , GetUnitX(cast) , GetUnitY(cast) , 400 , false)
call DestroyEffect(AddSpellEffectById(abi , EFFECT_TYPE_SPECIAL , GetUnitX(cast) , GetUnitY(cast)))
endif
set cast = null
endfunction

function RetTrig_Villagers_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTrainedUnit()) == 'n049' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Villagers_Actions takes nothing returns nothing
local location l= GetUnitLoc(GetTrainedUnit())
local location l2
    local unit wife= CreateUnit(GetOwningPlayer(GetTriggerUnit()) , 'n04A' , GetUnitX(GetTrainedUnit()) , GetUnitY(GetTrainedUnit()) , GetUnitFacing(GetTrainedUnit()))
call RemoveLocation(l)
set l = null
set l2 = GetUnitRallyPoint(GetTriggerUnit())

    if not IssueTargetOrderById(wife , GetUnitCurrentOrder(GetTrainedUnit()) , GetUnitRallyUnit(GetTriggerUnit())) then
	if not IssueTargetOrder(wife , "smart" , GetUnitRallyUnit(GetTriggerUnit())) then

    call IssuePointOrderByIdLoc(wife , OrderId("attack") , l2)
	endif
    endif

call RemoveLocation(l2)
set l2 = null
endfunction

//===========================================================================
function InitRetTrig_Villagers takes nothing returns nothing
    local trigger gg_trg_Villagers= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Villagers , EVENT_PLAYER_UNIT_TRAIN_FINISH)
    call TriggerAddCondition(gg_trg_Villagers , Condition(function RetTrig_Villagers_Conditions))
    call TriggerAddAction(gg_trg_Villagers , function RetTrig_Villagers_Actions)
	set gg_trg_Villagers = null
endfunction

function RJ_DistanceBetweenUnitLoc takes unit unitA,location locB returns real
    local real dx= GetLocationX(locB) - GetUnitX(unitA)
    local real dy= GetLocationY(locB) - GetUnitY(unitA)
    return SquareRoot(dx * dx + dy * dy)
endfunction

function RetTrig_Drain_Gold3_Conditions takes nothing returns boolean
    return ( ( GetIssuedOrderId() == OrderId("entangle") ) or ( GetIssuedOrderId() == OrderId("entangleinstant") ) ) and ( GetUnitAbilityLevel(GetOrderedUnit() , 'A0S3') >= 1 ) and ( RJ_DistanceBetweenUnits(GetOrderedUnit() , GetOrderTargetUnit()) <= 400 )
endfunction

function RetTrig_Drain_Gold3_Actions takes nothing returns nothing
    local unit u=GetOrderedUnit() //GetSpellAbilityUnit()
    local unit gm
 local unit gm2= GetOrderTargetUnit()
    local integer amt=9
    local location l=GetUnitLoc(u)
    local location l2
    local boolean instant=false
    call TriggerSleepAction(0.01)
if GetIssuedOrderId() == OrderId("entangleinstant") then

if( GetUnitTypeId(u) =='u02O' ) then
set gm = RisenifyGoldMineForPlayerInstant(GetOrderTargetUnit() , GetOwningPlayer(u))
else
set gm = DrainGoldMineForPlayerInstant(GetOrderTargetUnit() , GetOwningPlayer(u))
endif

set instant = true
else


if( GetUnitTypeId(u) =='u02O' ) then
set gm = RisenifyGoldMineForPlayer(GetOrderTargetUnit() , GetOwningPlayer(u))
else
set gm = DrainGoldMineForPlayer(GetOrderTargetUnit() , GetOwningPlayer(u))
endif

endif
set l2 = GetUnitLoc(gm)
if GetUnitTypeId(gm) == 'e01L' or GetUnitTypeId(gm) == 'e003' then
    if GetAttachedObject(u , "dg_GoldMine") == null then

    call UnitRemoveAbilityBJ('A0S3' , u)
    call UnitAddAbilityBJ('A0S4' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0S4')

    call AttachObject(u , "dg_GoldMine" , gm)

if GetUnitTypeId(u) == 'u02O' then
    call AttachLightning(u , "dg_GOLD_Effect" , AddLightningOnUnits("LRTG" , true , u , gm , 0))
else
    call AttachLightning(u , "dg_GOLD_Effect" , AddLightningOnUnits("GLDP" , true , u , gm , 0))
endif

if not ( instant ) then
    loop
        exitwhen ( GetUnitAbilityLevel(gm , 'A0NI') >= 1 ) or ( IsUnitDeadBJ(u) == true ) or ( IsUnitDeadBJ(gm) == true ) or GetUnitAbilityLevel(u , 'A0S4') <= 0 or ( RJ_DistanceBetweenUnits(u , gm) > 1500 )
        call TriggerSleepAction(0)
    endloop
endif

    loop
        exitwhen ( IsUnitDeadBJ(u) == true ) or ( IsUnitDeadBJ(gm) == true ) or GetUnitAbilityLevel(u , 'A0S4') <= 0 or ( RJ_DistanceBetweenUnits(u , gm) > 1500 )
        call AddResourceAmount(gm , - amt)
		if GetResourceAmount(gm) <= 0 then
		  call KillUnit(gm)
		endif
		if GetResourceAmount(gm2) <= 0 then
		  call KillUnit(gm2)
		endif
        call SimResourceGet(GetOwningPlayer(u) , ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 , l2 , 100.00 , 86.27 , 0.00 , false)

        call AdjustPlayerStateBJ(( ( amt * ( 100 - GetPlayerState(GetOwningPlayer(u) , PLAYER_STATE_GOLD_UPKEEP_RATE) ) ) / 100 ) , GetOwningPlayer(u) , PLAYER_STATE_RESOURCE_GOLD)

if GetUnitTypeId(u) == 'e01R' then
        call PolledWait(2.0)
else
		call PolledWait(1.2)
endif

    endloop

    call UnDrainGoldMine(gm,gm2)
	if GetResourceAmount(gm2) <= 0 then
	  call KillUnit(gm2)
	endif
    call AttachObject(u , "dg_GoldMine" , null)
    call UnitAddAbilityBJ('A0S3' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0S3')
    call UnitRemoveAbilityBJ('A0S4' , u)
    call RemoveLightningFromUnits(GetAttachedLightning(u , "dg_GOLD_Effect"))
    call AttachLightning(u , "dg_GOLD_Effect" , null)

    endif
    endif
    call RemoveLocation(l)
    call RemoveLocation(l2)
    set gm = null
	set gm2 = null
    set u = null
    set l = null
set l2 = null
endfunction


function RetTrig_Drain_Gold3_RetTrig_2_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0S4' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Drain_Gold3_RetTrig_2_Actions takes nothing returns nothing
  local unit u=GetSpellAbilityUnit()
    call TriggerSleepAction(0.00)
    call UnitAddAbilityBJ('A0S3' , u)
    call UnitMakeAbilityPermanent(u , true , 'A0S3')
    call UnitRemoveAbilityBJ('A0S4' , u)
  set u = null
endfunction

//===========================================================================
function InitRetTrig_Drain_Gold3_RetTrig_2 takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold3_RetTrig_2_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold3_RetTrig_2_Actions)
  set t = null
endfunction


//===========================================================================
function InitRetTrig_Drain_Gold3 takes nothing returns nothing
  local trigger t=CreateTrigger()
    call InitRetTrig_Drain_Gold3_RetTrig_2()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
    call TriggerAddCondition(t , Condition(function RetTrig_Drain_Gold3_Conditions))
    call TriggerAddAction(t , function RetTrig_Drain_Gold3_Actions)
  set t = null
endfunction

//BEGIN HARBINGER OF ARMAGEDDON

function MightyLeapStompBurst takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer castn=4 + lvl * 1
    local integer i=1

    loop
        exitwhen i > castn
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0QB' , lvl , "shockwave" , GetUnitX(caster) + 30 * Cos(( 360 / castn ) * i * bj_DEGTORAD) , GetUnitY(caster) + 30 * Sin(( 360 / castn ) * i * bj_DEGTORAD) , 3)
        set i = i + 1
    endloop

    set caster = null
endfunction

//===========================================================================
function InitRetTrig_Mighty_Leap takes nothing returns nothing
local integer s
local integer D
 //===================================================================================================
 // Mighty Leap ('A0QD')
 //
 set s = SetSpellTemplate('A0QD' , "JumpTemplate")
 //(Earth Crush doesn't need damage options)

    call SetAbilityDataInt(s , "UseOtherModel" , 0 , 0) //Don't Use another model

    call SetAbilityDataInt(s , "Spell" , 0 , 'A0QC') //Spell to cast is A02E (Earth crush war stomp)
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("stomp")) //Its orderid is stomp

    call SetAbilityDataString(s , "JumpAnim" , 0 , "attack slam") //Play birth animation when jump ends
    call SetAbilityDataString(s , "EndAnim" , 0 , "attack walk stand spin") //Play birth animation when jump ends
    call SetAbilityDataReal(s , "AnimSpeed" , 0 , 1)

 //==================================
 //Forcewave ('A0QB')
 set s = SetSpellTemplate('A0QB' , "WaveTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //Spell poison damage
 set D = D + DamageOnlyEnemies()
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "WaveArea" , 0 , 200) //Area Is 200 for all levels
    call SetAbilityDataReal(s , "AdvanceDist" , 0 , 75) //AdvanceDist is 50
    call SetAbilityDataReal(s , "dmg" , 1 , 35) //10 seconds of recycle delay ensure chain lightning to be cast
    call SetAbilityDataReal(s , "dmg" , 2 , 55) //10 seconds of recycle delay ensure chain lightning to be cast
    call SetAbilityDataReal(s , "dmg" , 3 , 70) //10 seconds of recycle delay ensure chain lightning to be cast

    call SetAbilityDataInt(s , "WaveN" , 0 , 12) //Level 1: 6 waves
    call SetAbilityDataInt(s , "DamageOptions" , 0 , D) //Using the damage options saved before

    call SetAbilityDataInt(s , "AvoidHitTwice" , 0 , 1) //Won't hit the same unit twice with direct chain ligthing
   

call OnAbilityEffect('A0QC' , "MightyLeapStompBurst")
endfunction

function CombatProwess_Enum takes nothing returns nothing
local unit cast= bj_lastCreatedUnit
local unit u= GetEnumUnit()
local real i= RJ_DistanceBetweenUnits(cast , u)
local string dmgModel
if ( IsUnitDeadBJ(cast) ) then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
set cast = null
set u = null
return 
endif
if ( i > 320 ) and ( i < 750 ) then //The 750 is a max damage range, for some reason it was otherwise occasionally damaging all units
call GroupRemoveUnit(bj_lastCreatedGroup , u)
call DamageUnit(GetOwningPlayer(cast) , ( rdg_TempReal - 1 ) * 50 + 25 , u)
//call AddSpecialEffectLoc("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",GetUnitLoc(u))
if ( not IsUnitType(u , UNIT_TYPE_STRUCTURE) ) then
set dmgModel = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
else
set dmgModel = "Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
endif
call DestroyEffect(AddSpecialEffectTarget(dmgModel , u , "origin"))
elseif ( i >= 230 ) and ( i <= 320 ) then
call DamageUnit(GetOwningPlayer(cast) , rdg_TempReal , u)
//call AddSpecialEffectLoc("Objects\\RandomObject\\RandomObject.mdl",GetUnitLoc(u))
if ( not IsUnitType(u , UNIT_TYPE_STRUCTURE) ) then
set dmgModel = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
else
set dmgModel = "Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
endif
call DestroyEffect(AddSpecialEffectTarget(dmgModel , u , "origin"))
elseif i >= 750 then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
//call BJDebugMsg("As a note, unit "+GetUnitName(u)+" has somehow ended up in the group and is beyond range.")
endif
if ( IsUnitDeadBJ(u) ) then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
endif
set cast = null
set u = null
endfunction


function CombatProwess_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "caster")
    local group g=GetAttachedGroup(u , "CombProwGroup")
    set bj_lastCreatedUnit = u
    set bj_lastCreatedGroup = g
    set rdg_TempReal = GetUnitAbilityLevel(u , 'A0QE') + 1 //*50.00+25.00
    call ForGroup(g , function CombatProwess_Enum)
endfunction

function CombatProwess_Actions takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit cast=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local integer lvl=GetUnitAbilityLevel(cast , 'A0HQ')
    local group g=GetAttachedGroup(cast , "CombProwGroup")
    call GroupAddUnit(g , u)
//    call AddSpecialEffectLoc("Doodads\\LordaeronSummer\\Props\\TorchHuman\\TorchHuman.mdl",GetUnitLoc(u))
    set u = null
    set cast = null
    set g = null
endfunction

function ReteraAOE_IsFilterEnemy_OfTrig takes nothing returns boolean
    return IsUnitEnemy(GetFilterUnit() , GetOwningPlayer(GetAttachedUnit(GetTriggeringTrigger() , "trigunit"))) and not ( IsUnitDeadBJ(GetFilterUnit()) )
endfunction

function CombatProwess takes nothing returns nothing
    local unit u=GetLearningUnit()
    local integer lvl=GetLearnedSkillLevel()
    local trigger t
    local group g
    local timer tim
    if not ( lvl > 1 ) then
    set t = CreateTrigger()
    set g = CreateGroup()
    call AttachObject(u , "CombProwGroup" , g)
    call AttachObject(u , "combprowtrig" , t)
    call AttachObject(t , "trigunit" , u)
    call TriggerRegisterUnitInRange(t , u , 320 , Filter(function ReteraAOE_IsFilterEnemy_OfTrig))
    call TriggerAddAction(t , function CombatProwess_Actions)
    set tim = CreateTimer()
    call AttachObject(tim , "caster" , u)
    call TimerStart(tim , 0.2 , true , function CombatProwess_Timer)
    endif
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwned"+I2S(lvl))
    set u = null
    set t = null
    set g = null
    set tim = null
endfunction


function BladeShield_Enum takes nothing returns nothing
local unit cast= bj_lastCreatedUnit
local unit u= GetEnumUnit()
local real i= RJ_DistanceBetweenUnits(cast , u)
local string dmgModel
if ( IsUnitDeadBJ(cast) ) then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
set cast = null
set u = null
return 
endif
if ( i > 320 ) and ( i < 750 ) then //The 750 is a max damage range, for some reason it was otherwise occasionally damaging all units
call GroupRemoveUnit(bj_lastCreatedGroup , u)
call UnitDamageTarget((cast ) , ( u ) , (( ( rdg_TempReal - 1 ) * 25 + 12 )*1.0) , true , false , ( ATTACK_TYPE_NORMAL ) , ( DAMAGE_TYPE_DEATH) , null) //Damage was *50 + 25, halved here. The ability is too good. // INLINED!!
//call AddSpecialEffectLoc("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",GetUnitLoc(u))
if ( not IsUnitType(u , UNIT_TYPE_STRUCTURE) ) then
set dmgModel = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
else
set dmgModel = "Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
endif
call DestroyEffect(AddSpecialEffectTarget(dmgModel , u , "origin"))
elseif ( i >= 230 ) and ( i <= 320 ) then
call DamageUnit(GetOwningPlayer(cast) , rdg_TempReal , u)
//call AddSpecialEffectLoc("Objects\\RandomObject\\RandomObject.mdl",GetUnitLoc(u))
if ( not IsUnitType(u , UNIT_TYPE_STRUCTURE) ) then
set dmgModel = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
else
set dmgModel = "Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
endif
call DestroyEffect(AddSpecialEffectTarget(dmgModel , u , "origin"))
elseif i >= 750 then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
//call BJDebugMsg("As a note, unit "+GetUnitName(u)+" has somehow ended up in the group and is beyond range.")
endif
if ( IsUnitDeadBJ(u) ) then
call GroupRemoveUnit(bj_lastCreatedGroup , u)
endif
set cast = null
set u = null
endfunction

function BladeShield_IsFilterEnemy takes nothing returns boolean
    return IsUnitEnemy(GetFilterUnit() , Player((GetStoredInteger(cs_cache , I2S(GetHandleId((GetTriggeringTrigger() ))) , ( "COMPAT_PROWESS_PLAYER"))))) and not ( IsUnitDeadBJ(GetFilterUnit()) ) // INLINED!!
endfunction

function BladeShield_Timer takes nothing returns nothing
    local timer t=GetExpiredTimer()
    local unit u=GetAttachedUnit(t , "caster")
    local group g=GetAttachedGroup(u , "CombProwGroup")
    if ( GetUnitAbilityLevel(u , 'B04L') >= 1 ) then
    
    set bj_lastCreatedUnit = u
    set bj_lastCreatedGroup = g
    set rdg_TempReal = GetUnitAbilityLevel(u , 'A0QE') + 1 //*50.00+25.00 
    call ForGroup(g , function BladeShield_Enum)
    else
   // call PauseTimer(t)
    
    endif
    
    set g = null
    set u = null
    set t = null
endfunction

function BladeShield_Actions takes nothing returns nothing
    local unit u=GetTriggerUnit()
    local unit cast=GetAttachedUnit(GetTriggeringTrigger() , "trigunit")
    local integer lvl=GetUnitAbilityLevel(cast , 'A0HQ')
    local group g=GetAttachedGroup(cast , "CombProwGroup")
    call GroupAddUnit(g , u)
  //  call AddSpecialEffectLoc("Doodads\\LordaeronSummer\\Props\\TorchHuman\\TorchHuman.mdl",GetUnitLoc(u))
    set u = null
    set cast = null
    set g = null
endfunction

function BladeShield_Get takes nothing returns nothing
    local unit u=GetLearningUnit()
    local integer lvl=GetLearnedSkillLevel()
    local trigger t
    local group g
    local timer tim
    if not ( lvl > 1 ) then
    set t = CreateTrigger()
    set g = CreateGroup()
    call AttachObject(u , "CombProwGroup" , g)
    call AttachObject(u , "combprowtrig" , t)
    call AttachObject(t , "trigunit" , u)
//    set bj_groupEnumOwningPlayer=GetOwningPlayer(u)
    call AttachInt(t , "COMPAT_PROWESS_PLAYER" , GetPlayerId(GetOwningPlayer(u)))
    call TriggerRegisterUnitInRange(t , u , 320 , Filter(function BladeShield_IsFilterEnemy))
    call TriggerAddAction(t , function BladeShield_Actions)
    set tim = CreateTimer()
    call AttachObject(tim , "caster" , u)
    call AttachObject(u , "bs_timer" , tim)
    call TimerStart(tim , 0.2 , true , function BladeShield_Timer)
    endif
//    call DisplayTextToPlayer(GetOwningPlayer(u),0,0,"pwned"+I2S(lvl))
    set u = null
    set t = null
    set g = null
    set tim = null
endfunction

function BladeShield takes nothing returns nothing
   local unit u= GetSpellAbilityUnit()
   local timer t= GetAttachedTimer(u , "bs_timer")
   // call ResumeTimer(t)
    set t = null
    set u = null
endfunction

//===========================================================================
function InitRetTrig_BladeShield takes nothing returns nothing
    call OnAbilityGet('A0SB' , "BladeShield_Get")
    call OnAbilityEffect('A0SB' , "BladeShield")
endfunction

function Vigor takes nothing returns nothing
    local unit cast=GetSpellAbilityUnit()
    local integer abi=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(cast , abi)
    call UnitAddAbility(cast , 'A0RW')
    call UnitAddAbility(cast , 'A0RX')
    call UnitAddAbility(cast , 'A0RV')
    call SetPlayerAbilityAvailable(GetOwningPlayer(cast) , 'A0RW' , false)
    call SetUnitAbilityLevel(cast , 'A0RX' , lvl)
    call SetUnitAbilityLevel(cast , 'A0RV' , lvl)
    call PolledWait(15)
    call UnitRemoveAbility(cast , 'A0RW')
    call UnitRemoveAbility(cast , 'A0RX')
    call UnitRemoveAbility(cast , 'A0RV')
    set cast = null
endfunction

function BladeSpell takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local integer abi= GetSpellAbilityId()
call UnitAddAbility(cast , 'A0RZ')
call UnitAddAbility(cast , 'A0S0')
call UnitAddAbility(cast , 'A0S1')
call SetHeroAgi(cast , GetHeroAgi(cast , false) + 50 , false)
call PolledWait(30)
call UnitRemoveAbility(cast , 'A0RZ')
call UnitRemoveAbility(cast , 'A0S0')
call UnitRemoveAbility(cast , 'A0S1')
call SetHeroAgi(cast , GetHeroAgi(cast , false) - 50 , false)
set cast = null
endfunction

//END HARBINGER ABILITIES




function HawkEyes takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local integer spawnType= 'n04B'
local unit hawk
local location targ= GetSpellTargetLoc()
local integer lvl= GetUnitAbilityLevel(cast , GetSpellAbilityId())

    if lvl == 2 then
        set spawnType = 'n04C'
    elseif lvl == 3 then
        set spawnType = 'n04D'
    endif

    set hawk = CreateUnit(GetOwningPlayer(cast) , spawnType , GetUnitX(cast) , GetUnitY(cast) , GetUnitFacing(cast))
    call IssuePointOrderLoc(hawk , "move" , targ)
    loop
        exitwhen ( RJ_DistanceBetweenUnitLoc(hawk , targ) <= 50 )
        call TriggerSleepAction(RMaxBJ(bj_WAIT_FOR_COND_MIN_INTERVAL , 1))
    endloop
    call IssuePointOrder(hawk , "move" , GetUnitX(cast) , GetUnitY(cast))
    loop
        exitwhen ( RJ_DistanceBetweenUnits(hawk , cast) <= 150 )
        call IssuePointOrder(hawk , "move" , GetUnitX(cast) , GetUnitY(cast))
        call TriggerSleepAction(RMaxBJ(bj_WAIT_FOR_COND_MIN_INTERVAL , 1))
    endloop
call RemoveUnit(hawk)
call RemoveLocation(targ)
set cast = null
set hawk = null
set targ = null
endfunction

function Redemption takes nothing returns nothing
local unit cast= GetSpellAbilityUnit()
local unit targ= GetSpellTargetUnit()
local timer t= CreateTimer()

call TimerStart(t , 60 , false , null)
call KS_UnitAddAbilityStack(targ , 'A0RE' , true)
loop
    exitwhen TimerGetRemaining(t) <= 0.1 or IsUnitDeadBJ(targ)
    call TriggerSleepAction(2)
endloop
call KS_UnitAddAbilityStack(targ , 'A0RE' , false)

if IsUnitDeadBJ(targ) then
call CasterCastAbilityLevelPoint((GetOwningPlayer(targ) ) , ( 'A0RC' ) , 1 , ( "resurrection" ) , (( GetUnitX(targ) )*1.0) , (( GetUnitY(targ) )*1.0) , ( true)) // INLINED!!
endif

call DestroyTimer(t)
set t = null
set cast = null
set targ = null
endfunction

function RetTrig_Upgrades_Conditions takes nothing returns boolean
    return GetResearched() == 'R035'
endfunction

function RetTrig_Upgrades_Actions takes nothing returns nothing
    if ( GetPlayerTechCountSimple('R035' , GetOwningPlayer(GetTriggerUnit())) > 1 ) then
        call SetPlayerTechResearchedSwap('R03Y' , 1 , GetOwningPlayer(GetTriggerUnit()))
    endif
endfunction

//===========================================================================
function InitRetTrig_Upgrades takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_RESEARCH_FINISH)
    call TriggerAddCondition(t , Condition(function RetTrig_Upgrades_Conditions))
    call TriggerAddAction(t , function RetTrig_Upgrades_Actions)
    set t = null
endfunction

function InitNewHumans takes nothing returns nothing
local integer s
local integer D

    call InitRetTrig_Villagers()
	call InitRetTrig_Upgrades()
    call OnAbilityEffect('A0R8' , "HawkEyes")
    call OnAbilityEffect('A0RD' , "Redemption")

 //===================================================================================================
 // Horsemasters Charge ('A0QW')
 //
 set s = SetSpellTemplate('A0QW' , "TheOtherChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 8) //Level 1: 5 damage
    call SetAbilityDataReal(s , "damage" , 2 , 16) //Level 2: 7 damage
    call SetAbilityDataReal(s , "damage" , 3 , 24) //Level 3: 10 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus


 //===================================================================================================
 // Celestial Cavalry ('A0R0')
 //
 set s = SetSpellTemplate('A0R0' , "LocustFollowerTemplate")
    call SetAbilityDataInt(s , "unitid" , 0 , 'h03R')
    call SetAbilityDataInt(s , "unitcount" , 0 , 8)
    call SetAbilityDataReal(s , "duration" , 0 , 50)
    call SetAbilityDataReal(s , "unitspacing" , 0 , 80)
    call SetAbilityDataReal(s , "deathduration" , 0 , 0.1)

//===================================================================================================
 // Nova ('A0R3')
 //
 set s = SetSpellTemplate('A0R3' , "SpellCastTemplate")

    call SetAbilityDataInt(s , "ChannelType" , 0 , 0)
    call SetAbilityDataReal(s , "Timer" , 0 , 9)
    call SetAbilityDataInt(s , "Times" , 0 , 1)
    call SetAbilityDataInt(s , "spell1type" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'A0R2')
    call SetAbilityDataInt(s , "spell1OrderId" , 0 , OrderId("howlofterror"))
    call SetAbilityDataInt(s , "spell1FromSource" , 0 , 0)
    call SetAbilityDataReal(s , "spell1RecDelay" , 0 , 7)
    call SetAbilityDataInt(s , "spellN" , 0 , 1)
    call SetAbilityDataInt(s , "instantStart" , 0 , 1)

 //==================================
 // Nova's Nova ('A0R2')
 set s = SetSpellTemplate('A0R2' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_POISON) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 0 , 6) // 0.5 seconds of duration for all levels
//    call SetAbilityDataReal(s,"turninc"      ,0,12 )  // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 125) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 250) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 375) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above

 //===================================================================================================
 // Hammer of Justice ('A0RA')
 //
 set s = SetSpellTemplate('A0RA' , "SpiralBeamTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = D + DamageOnlyEnemies() //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "damage" , 1 , 45)
    call SetAbilityDataReal(s , "damage" , 2 , 60)
    call SetAbilityDataReal(s , "damage" , 3 , 75)
    call SetAbilityDataReal(s , "duration" , 0 , 7)
    call SetAbilityDataReal(s , "DistanceSpeed" , 0 , 0.30) //Distance Speed is 0.55
    call SetAbilityDataReal(s , "TanSpeed" , 0 , 720) //Tangential speed is -720 (goes anti-clockwise))

 //===================================================================================================
 // Vorpal Glaive ('A0R7')
 //
 set s = SetSpellTemplate('A0R7' , "ChainSpellTemplate")
 set D = 0 //chain freezing target Options :
 set D = D + DamageTypes(ATTACK_TYPE_PIERCE , DAMAGE_TYPE_NORMAL) //Do pierce cold (magical) damage
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options
 
 
    call SetAbilityDataInt(s , "options" , 0 , D) //// Use the damage option D for damage/target options.
    call SetAbilityDataInt(s , "bounces" , 0 , 5) //// Chain Freezing has 3 targets
    call SetAbilityDataInt(s , "bounces" , 1 , 4) //// Chain Freezing has 3 targets
    call SetAbilityDataInt(s , "bounces" , 2 , 5) //// Chain Freezing has 3 targets
    call SetAbilityDataInt(s , "bounces" , 3 , 6) //// Chain Freezing has 3 targets
    call SetAbilityDataReal(s , "speed" , 0 , 600) //// Chain Freezing 's missile allows instant speed
    call SetAbilityDataReal(s , "damage" , 1 , 90) //// Chain Freezing has a 110 initial damage
    call SetAbilityDataReal(s , "damage" , 2 , 180) //// Chain Freezing has a 110 initial damage
    call SetAbilityDataReal(s , "damage" , 3 , 270) //// Chain Freezing has a 110 initial damage
    call SetAbilityDataReal(s , "factor" , 0 , 0.75) //// Chain Freezing has a 0.75 damage factor
    call SetAbilityDataReal(s , "factor" , 1 , 0.75) //// Chain Freezing has a 0.75 damage factor
    call SetAbilityDataReal(s , "factor" , 2 , 0.77) //// Chain Freezing has a 0.75 damage factor
    call SetAbilityDataReal(s , "factor" , 3 , 0.79) //// Chain Freezing has a 0.75 damage factor

 //===================================================================================================
 // Charge ('A0RJ')
 //
 set s = SetSpellTemplate('A0RJ' , "ChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 5) //Level 1: 140 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus

 //===================================================================================================
 // Charge ('A0RM')
 //
 set s = SetSpellTemplate('A0RM' , "ChargeSpellTemplate")
 set D = 0 //Charge damage Options :
 set D = DamageTypes(ATTACK_TYPE_MELEE , DAMAGE_TYPE_NORMAL) //Siege Lightning damage
 set D = D + DamageOnlyTo(UNIT_TYPE_GROUND) //Don't hurt Flying units
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Don't affect buildings
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "damage" , 1 , 5) //Level 1: 140 damage
    call SetAbilityDataReal(s , "area" , 0 , 200) //Over an area of 200
    call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using damage options saved in D
    call SetAbilityDataInt(s , "abiln" , 0 , 1) //Adds 1 ability which is:
    call SetAbilityDataInt(s , "abil1id" , 0 , 'A0A1') //Charge move speed bonus



endfunction

function RetTrig_AICommoner_Conditions takes nothing returns boolean
    
    return ( GetUnitTypeId(GetEnteringUnit()) == 'n049' or GetUnitTypeId(GetEnteringUnit()) == 'n04A' ) and GetPlayerController(GetOwningPlayer(GetEnteringUnit())) == MAP_CONTROL_COMPUTER
endfunction

function RetTrig_AICommoner_Filter takes nothing returns boolean
	return IsUnitInTransport(GetFilterUnit(),bj_lastCreatedUnit)
endfunction

function AICom_Garrison takes unit who returns nothing
    local unit me=who
    local group garrisons= CreateGroup()
    local boolean done= false
    local unit gar
	local integer x = 0
	local boolean iPlus
	
    call GroupEnumUnitsOfType(garrisons , "custom_h03N" , null)
    loop
        exitwhen CountUnitsInGroup(garrisons) <= 0 or done == true
        set gar = FirstOfGroup(garrisons)
        call GroupRemoveUnit(garrisons , gar)
        set done = IssueTargetOrder(gar , "load" , me)
		if done then
			set done = (GetUnitUserData(gar) < 10)
		endif
		//call SetUnitVertexColor(me,255,245,245,255)
		//call SetUnitVertexColor(gar,245,245,255,255)
    endloop
	
	if not done then
		call GroupClear(garrisons)
		call GroupEnumUnitsOfType(garrisons , "custom_h03M" , null)
		loop
			exitwhen CountUnitsInGroup(garrisons) <= 0 or done == true
			set gar = FirstOfGroup(garrisons)
			call GroupRemoveUnit(garrisons , gar)
			set done = IssueTargetOrder(gar , "load" , me)
			if done then
				set done = (GetUnitUserData(gar) < 4)
			endif
			//call SetUnitVertexColor(me,255,245,245,255)
			//call SetUnitVertexColor(gar,245,245,255,255)
		endloop
	endif
	
	
	if not done then
		call GroupClear(garrisons)
		call GroupEnumUnitsOfType(garrisons , "custom_h03T" , null)
		loop
			exitwhen CountUnitsInGroup(garrisons) <= 0 or done == true
			set gar = FirstOfGroup(garrisons)
			call GroupRemoveUnit(garrisons , gar)
			set done = IssueTargetOrder(gar , "load" , me)
			if done then
				set done = (GetUnitUserData(gar) < 4)
			endif
			//call SetUnitVertexColor(me,255,245,245,255)
			//call SetUnitVertexColor(gar,245,245,255,255)
		endloop
	endif
	
	if not done then
		call GroupClear(garrisons)
		call GroupEnumUnitsOfType(garrisons , "custom_h03U" , null)
		loop
			exitwhen CountUnitsInGroup(garrisons) <= 0 or done == true
			set gar = FirstOfGroup(garrisons)
			call GroupRemoveUnit(garrisons , gar)
			set done = IssueTargetOrder(gar , "load" , me)
			if done then
				set done = (GetUnitUserData(gar) < 4)
			endif
			//call SetUnitVertexColor(me,255,245,245,255)
			//call SetUnitVertexColor(gar,245,245,255,255)
		endloop
	endif
	
	if not done then
		call GroupClear(garrisons)
		call GroupEnumUnitsOfType(garrisons , "custom_h03V" , null)
		loop
			exitwhen CountUnitsInGroup(garrisons) <= 0 or done == true
			set gar = FirstOfGroup(garrisons)
			call GroupRemoveUnit(garrisons , gar)
			set done = IssueTargetOrder(gar , "load" , me)
			if done then
				set done = (GetUnitUserData(gar) < 4)
			endif
			//call SetUnitVertexColor(me,255,245,245,255)
			//call SetUnitVertexColor(gar,245,245,255,255)
		endloop
	endif
	
	if gar != null and done then
	call SetUnitUserData(gar,GetUnitUserData(gar)+1)
	set iPlus = true
    
    loop
        exitwhen IsUnitInTransport(me , gar) or IsUnitDeadBJ(me) or IsUnitDeadBJ(gar) or x > 12
		set x = x + 1
		if ( x > 8 ) then
		    call SetUnitPosition(me,GetUnitX(gar),GetUnitY(gar))
		endif
        call IssueTargetOrder(gar , "load" , me)
        call IssueTargetOrder(me , "smart" , gar)
        call TriggerSleepAction(0.5)
    endloop
	
	endif
	
    call DestroyGroup(garrisons)
		if not IsUnitInTransport(me,gar) then
			call TriggerSleepAction(5)
			if gar != null and not IsUnitDeadBJ(gar) and iPlus then
				call SetUnitUserData(gar,GetUnitUserData(gar)-1)
			endif
			set garrisons = null
			set gar = null
			call BJDebugMsg("We got a bogus villager lagging the game.")
			call AICom_Garrison(me)
			//call SetUnitVertexColor(me,4,255,4,120)
			//call PauseUnit(me,true)
			//call SetUnitTimeScale(me,0.00)
		endif
    
    set me = null
    set garrisons = null
    set gar = null
endfunction

function RetTrig_AICommoner_Actions takes nothing returns nothing
    local unit me= GetEnteringUnit()
	call AICom_Garrison(me)
	
	set me = null
endfunction

//==== Init Trigger AICommoner ====
function InitRetTrig_AICommoner takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterEnterRectSimple(t , GetWorldBounds())
    call TriggerAddCondition(t , Condition(function RetTrig_AICommoner_Conditions))
    call TriggerAddAction(t , function RetTrig_AICommoner_Actions)
    set t = null
endfunction

function ActivateAICustom takes nothing returns nothing
    local player enum= GetEnumPlayer()
    if ( GetPlayerController(enum) == MAP_CONTROL_COMPUTER ) then
    
        call CommandAI(enum , 5 , 5)
    endif
    set enum = null
endfunction

function InitCustomAICode takes nothing returns nothing
    if ( IsMapFlagSet(MAP_RANDOM_HERO) ) then
    call TriggerSleepAction(3)
    call StartTimerBJ(rdg_AITimer , false , 900.00)
    set rdg_AI = CreateTimerDialogBJ(rdg_AITimer , "Armistice ends:")
    call TimerDialogDisplayBJ(true , rdg_AI)
    
    loop
        call TriggerSleepAction(2)
        exitwhen TimerGetRemaining(rdg_AITimer) <= 0
    endloop
    //call TimerDialogDisplayBJ( false, rdg_AI )
    call DisplayTextToForce(GetPlayersAll() , "The Armistice with your opponents has ended and they will now begin constructing military units.")
    call TimerDialogDisplay(rdg_AI, false)
    call ForForce(GetPlayersAll() , function ActivateAICustom)
    endif
endfunction



//Struct method generated initializers/callers:
function sa___prototype10_DamagerGroup_Destroy takes nothing returns boolean
    call DamagerGroup_Destroy(f__arg_timer1)
    return true
endfunction

//Functions for BigArrays:
function sa__CSDamagers__damagerdata_onDestroy takes nothing returns boolean
local integer this=f__arg_this
           call GroupRemoveUnit(CSDamagers__damagerflag , s__CSDamagers__damagerdata_u[this])
           if ( s__CSDamagers__damagerdata_prev[this] == this ) then
               set s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]]=0
           else
               if ( s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]] == this ) then
                   set s__CSDamagers__data_damagers[s__CSDamagers__damagerdata_parent[this]]=s__CSDamagers__damagerdata_prev[this]
               endif
               set s__CSDamagers__damagerdata_next[s__CSDamagers__damagerdata_prev[this]]=s__CSDamagers__damagerdata_next[this]
               set s__CSDamagers__damagerdata_prev[s__CSDamagers__damagerdata_next[this]]=s__CSDamagers__damagerdata_prev[this]
           endif
           call ReleaseTimer(s__CSDamagers__damagerdata_lifespan[this])
           if ( s__CSDamagers__damagerdata_abil[this] != 0 ) then
               call UnitRemoveAbility(s__CSDamagers__damagerdata_u[this] , s__CSDamagers__damagerdata_abil[this])
           endif
           call RecycleCasterAfterCastEx((s__CSDamagers__damagerdata_u[this] ) , (( 4 )*1.0) , ( 0 ) , ( false)) // INLINED!!
           call DestroyEffect(s__CSDamagers__damagerdata_fx[this])
   return true
endfunction

function jasshelper__initstructs246758044 takes nothing returns nothing
    set st___prototype10[1]=CreateTrigger()
    call TriggerAddAction(st___prototype10[1],function sa___prototype10_DamagerGroup_Destroy)
    call TriggerAddCondition(st___prototype10[1],Condition(function sa___prototype10_DamagerGroup_Destroy))
    set st__CSDamagers__damagerdata_onDestroy=CreateTrigger()
    call TriggerAddCondition(st__CSDamagers__damagerdata_onDestroy,Condition( function sa__CSDamagers__damagerdata_onDestroy))
    set st__csmissile_onDestroy[6]=null
    set st__csmissile_onDestroy[5]=null

endfunction


function RetTrig_Chaos_Demon_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0SN' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Chaos_Demon_Cast_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0SO' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Chaos_Demon_Actions takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local player p = GetOwningPlayer(cast)
    if( GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD) >= 670 and GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER) >= 200 )then
        call AdjustPlayerStateBJ( -670, p, PLAYER_STATE_RESOURCE_GOLD )
        call AdjustPlayerStateBJ( -200, p, PLAYER_STATE_RESOURCE_LUMBER )
        call UnitRemoveAbility( cast, 'A0SN' )
        call IssueImmediateOrder( cast, "stop" )
        call UnitAddAbility( cast, 'A0SO' )
        call ForceUIKeyBJ(p , "H")
    endif

    
set cast = null
endfunction


function RetTrig_Chaos_Demon_Cast_Actions takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
    call UnitRemoveAbility( cast, 'A0SO' )
    call UnitAddAbility( cast, 'A0SP' )
    call PolledWait(180.00)
    call UnitRemoveAbility( cast, 'A0SP' )
    call UnitAddAbility( cast, 'A0SN' )

set cast = null
endfunction

//===========================================================================
function InitRetTrig_Chaos_Demon takes nothing returns nothing
    local trigger zgg_trg_Chaos_Demon = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( zgg_trg_Chaos_Demon, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition( zgg_trg_Chaos_Demon, Condition( function RetTrig_Chaos_Demon_Conditions ) )
    call TriggerAddAction( zgg_trg_Chaos_Demon, function RetTrig_Chaos_Demon_Actions )

    set zgg_trg_Chaos_Demon = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( zgg_trg_Chaos_Demon, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition( zgg_trg_Chaos_Demon, Condition( function RetTrig_Chaos_Demon_Cast_Conditions ) )
    call TriggerAddAction( zgg_trg_Chaos_Demon, function RetTrig_Chaos_Demon_Cast_Actions )
    set zgg_trg_Chaos_Demon = null
endfunction

  //===================================================================================================
 // Template Info:
 //
 // Template Name Id = "SlashTemplate"
 //
 // The hero just gets teleported and attacks the targets fast, it looks nice and allows to cast
 // a spell, do damage, damage per second, and also has options for the way to choose targets and
 // factor for each target and that stuff.
 //
 //
 // integer "totalhits"  The maximum number of hits done per cast
 // real    "dmg"        The initial damage
 // real    "PDmg"       The initial Periodic Damage
 // real    "PDmgPeriod" The period of the Periodic Damage
 // real    "PDmgDur"    The Duration of the periodic Damage
 //
 // real    "dmgfct"     The factor per target for the damage, each time the unit hits a target,
 //                      the damage will be multiplied by this value to get reduced or incremented
 //
 // integer "Spell"      Rawcode of the Spell to cast (if any)
 // real    "SpellHeight" Height of the caster that casts the spell to cast
 // integer "OrderId"    Order Id of that spell
 // real    "RecDelay"   Caster Recycle delay for that spell
 //
 //
 // real    "area"       The new target detection range
 // integer "canrepeat"  Is 1 if the slash can repeat targets, otherwise 0
 //
 // integer "SelMethod"  Is 0 if the slash should pick the closest unit, 1 to pick random units
 // integer "SlashKind"  The kind of the Slash, 0 will try to get to the back of the unit, 1
 //                      will attack in random direction, and 2 is a combination of both
 //
 // integer "AngleKind"  Is 0 for the default angle kind, is 1 to multiple the angle by -1
 //
 // string  "animation"  The animation used by the slash
 //
 // integer "colorize"   If it is 1 enables casting unit "colorizing"
 // integer "SlashColor" Color in 0xAARRGGBB form for the duration of the slash 
 // integer "EndColor"   Color in 0xAARRGGBB form after the slash (original color of the hero)
 // 

 // integer "DamageOptions" Caster System Damage Options in saveable form, used to determine which
 //                         units can be attacked by the slash, if the damage factor is 0 the unit
 //                         is not affected by the target spells nor damage, otherwise the value
 //                         is only important as a damage factor.


 


//===========================================================================
function InitRetTrig_DextrousSweep takes nothing returns nothing
    local integer D
    local integer s
    

 //===================================================================================================
 // Slash template Defaults:
 //
    call SetTemplateDefaultInt(   "SlashInPlaceTemplate", "totalhits", 1) //Default Total Hits is 1
    call SetTemplateDefaultInt(   "SlashInPlaceTemplate", "canrepeat", 0) //Can't repeat targets
    call SetTemplateDefaultReal(  "SlashInPlaceTemplate", "area", 100)    //Default area is 100
    call SetTemplateDefaultReal(  "SlashInPlaceTemplate", "dmg", 150)     //Default initial damage is 150
    call SetTemplateDefaultReal(  "SlashInPlaceTemplate", "dmgfct", 1)    //Default damage factor is 1
    call SetTemplateDefaultString("SlashInPlaceTemplate", "animation", "attack slam") //Default animation is attack slam
    call SetTemplateDefaultInt(   "SlashInPlaceTemplate", "SlashColor", 0xFFFFFFFF)   //Default slash color is 255-255-255-255
    call SetTemplateDefaultInt(   "SlashInPlaceTemplate", "EndColor"  , 0xFFFFFFFF)   //Default end color is 255-255-255-255


 //===================================================================================================
 // Dextrous Sweep ('A0SC')
 //
 set s=SetSpellTemplate('A0SC',"SlashInPlaceTemplate")
 set D=0                                                //Options :
 set D=DamageTypes(ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL) //Hero damage
 set D=DamageOnlyEnemies()                              //Only hurt enemies
 set D=D+DamageOnlyTo(UNIT_TYPE_GROUND)                     //Don't hurt Flying units
 set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D=CreateDamageOptions(D)                           //Save the damage options

    call SetAbilityDataInt( s,"totalhits",1,5) //5 Hits
    call SetAbilityDataInt( s,"totalhits",2,7) //7 Hits
    call SetAbilityDataInt( s,"totalhits",3,10) //10 Hits

    call SetAbilityDataReal(s,"dmg",1,45) //Level 1: 45 damage
    call SetAbilityDataReal(s,"dmg",2,65) //Level 1: 65 damage
    call SetAbilityDataReal(s,"dmg",3,85) //Level 1: 85 damage

    call SetAbilityDataReal(s,"area",0,50) //Always 600 of area

    call SetAbilityDataInt( s,"SlashKind",0,0)   //Slash Kind is 0
    call SetAbilityDataInt( s,"canrepeat",0,1)   //It can repeat targets!


    call SetAbilityDataString(s,"animation",0,"attack") //Use attack animation

    call SetAbilityDataInt( s,"DamageOptions",0,D)   //Using the damage options saved before

 //===================================================================================================
 // Dextrous Sweep ('A0SX')
 //
 set s=SetSpellTemplate('A0SX',"SlashInPlaceTemplate")
 set D=0                                                //Options :
 set D=DamageTypes(ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL) //Hero damage
 set D=DamageOnlyEnemies()                              //Only hurt enemies
 set D=D+DamageOnlyTo(UNIT_TYPE_GROUND)                     //Don't hurt Flying units
 set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D=CreateDamageOptions(D)                           //Save the damage options

    call SetAbilityDataInt( s,"totalhits",1,5) //5 Hits
    call SetAbilityDataInt( s,"totalhits",2,7) //7 Hits
    call SetAbilityDataInt( s,"totalhits",3,10) //10 Hits

    call SetAbilityDataReal(s,"dmg",1,90) //Level 1: 45 damage
    call SetAbilityDataReal(s,"dmg",2,130) //Level 1: 65 damage
    call SetAbilityDataReal(s,"dmg",3,170) //Level 1: 85 damage

    call SetAbilityDataReal(s,"area",0,50) //Always 600 of area

    call SetAbilityDataInt( s,"SlashKind",0,0)   //Slash Kind is 0
    call SetAbilityDataInt( s,"canrepeat",0,1)   //It can repeat targets!


    call SetAbilityDataString(s,"animation",0,"attack") //Use attack animation

    call SetAbilityDataInt( s,"DamageOptions",0,D)   //Using the damage options saved before


 //===================================================================================================
 // Dextrous Sweep ('A0T5')
 //
 set s=SetSpellTemplate('A0T5',"SlashInPlaceTemplate")
 set D=0                                                //Options :
 set D=DamageTypes(ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL) //Hero damage
 set D=DamageOnlyEnemies()                              //Only hurt enemies
 set D=D+DamageOnlyTo(UNIT_TYPE_GROUND)                     //Don't hurt Flying units
 set D=D+DamageIgnore(UNIT_TYPE_STRUCTURE)
 set D=CreateDamageOptions(D)                           //Save the damage options

    call SetAbilityDataInt( s,"totalhits",1,10) //10 Hits

    call SetAbilityDataReal(s,"dmg",1,170) //Level 1: 85 damage

    call SetAbilityDataReal(s,"area",0,50) //Always 600 of area

    call SetAbilityDataInt( s,"SlashKind",0,1)   //Slash Kind is 0
    call SetAbilityDataInt( s,"canrepeat",0,1)   //It can repeat targets!


    call SetAbilityDataString(s,"animation",0,"attack") //Use attack animation

    call SetAbilityDataInt( s,"DamageOptions",0,D)   //Using the damage options saved before

 //===================================================================================================
 // Duelist Superpower Aura ('A0T1')
 //
 //set s = SetPassiveTemplate('A0T1' , "AuraTemplate")
 //set D = 0 //Winds Aura target Options :
 //set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 //set D = CreateDamageOptions(D) //Save the damage options

 //   call SetAbilityDataInt(s , "options" , 0 , D)
 //   call SetAbilityDataReal(s , "area" , 0 , 1000)
 //   call SetAbilityDataInt(s , "notself" , 0 , 1)
 //   call SetAbilityDataInt(s , "spell1id" , 0 , 'A0T0')
 //   call SetAbilityDataInt(s , "spell2id" , 0 , 'AUan')
 //   call SetAbilityDataInt(s , "n" , 0 , 2)

 //===================================================================================================
 // Spirit Twin ('A0T2')
 //
 set s=SetSpellTemplate('A0T2',"LocustFollowerTemplate")

    call SetAbilityDataInt(s ,"unitid",0,'H03W')
    call SetAbilityDataInt(s ,"unitcount",0,1)
    call SetAbilityDataReal(s ,"duration",0,20)
    call SetAbilityDataReal(s ,"unitspacing",0,100)
    call SetAbilityDataReal(s ,"deathduration",0,2)
                              

endfunction

function SlashInPlaceTemplate takes nothing returns nothing
 local unit u=GetTriggerUnit()
 local integer s=GetSpellAbilityId()
 local integer l=GetUnitAbilityLevel(u , s)
 local group targetlog=CreateGroup()
 local group inrange=CreateGroup()
 local integer i=GetAbilityDataInt(s , l , "totalhits")
 local unit target=GetSpellTargetUnit()
 local unit picked
 local unit other=GetSpellTargetUnit()
 local real grad=GetUnitX(u)
 local real damage=GetAbilityDataReal(s , l , "dmg")
 local effect fx1=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 1))
 local effect fx2=AddSpellEffectTargetById(s , EFFECT_TYPE_CASTER , u , GetAbilityEffectById(s , EFFECT_TYPE_CASTER , 2))

 local real x
 local real y
 local real tx
 local real ty
 local real d
 local integer dop
 local real fc

 local real dmgps=GetAbilityDataReal(s , l , "PDmg")
 local real period=GetAbilityDataReal(s , l , "PDmgPeriod")
 local real dur=GetAbilityDataReal(s , l , "PDmgDur")

 local integer ki=GetAbilityDataInt(s , l , "SlashKind")

 local boolean closest=( GetAbilityDataInt(s , l , "SelMethod") == 0 )
 local boolean color= ( GetAbilityDataInt(s , l , "colorize") == 1 )

 local sound soundHandle

    call PauseUnit(u , true)
    call SetUnitTimeScalePercent(u, 200)
    call SetUnitPathing(u , false)
    if ( color ) then
        call SlashTemplate_Colorize(u , GetAbilityDataInt(s , l , "SlashColor"))
    endif

    loop
        call GroupAddUnit(targetlog , target)
        set x = GetUnitX(u)
        set y = GetUnitY(u)
        set tx = GetUnitX(target)
        set ty = GetUnitY(target)

        call DestroyEffect(AddSpellEffectById(s , EFFECT_TYPE_SPECIAL , x , y))

        call SetUnitAnimation(u , GetAbilityDataString(s , l , "animation"))
        call TriggerSleepAction(0)

        //if ( ( ki == 0 ) or ( ( ki == 2 ) and ( GetRandomInt(0 , 1) == 0 ) ) ) then
        if (ki == 0) then
            set grad = Atan2(y - ty , x - tx)
        else
            set grad = Atan2(ty - y , tx - x)
        endif
        //else
        //    set grad = GetRandomReal(0 , 2 * bj_PI)
        //endif
        set x = 100 * Cos(grad)
        set y = 100 * Sin(grad)
        //if ( GetAbilityDataInt(s , l , "AngleKind") == 1 ) then
        //    set x = - x
        //    set y = - y
        //endif
        set x = tx + x
        set y = ty + y
        
        if( ki == 1 ) then
            call SetUnitFacing(u , 0-(grad * bj_RADTODEG))
        endif
        call SetUnitPosition(u , x , y)

        set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        set fc = GetDamageFactorByOptions(u , target , dop)

        if ( fc != 0 ) then
            call UnitDamageTarget(u , target , damage * fc , true , false , null , null , null)
            call SlashTemplate_DoSpell(GetOwningPlayer(u) , target , s , l)
            if ( dmgps != 0 ) then
                call UnitDamageUnitTimed(u , dmgps * fc , period , dur , target , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 0) , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1) , null , null)
            else
                call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_TARGET , target , GetAbilityEffectById(s , EFFECT_TYPE_TARGET , 1)))
            endif
        endif

        set soundHandle = CreateSoundFromLabel("MetalHeavySliceFlesh", false, true, true, 12700,12700)
        call SetSoundPosition(soundHandle, x, y, 20)
        call StartSound(soundHandle)
        call KillSoundWhenDone(soundHandle)




        call TriggerSleepAction(0)

        set x = GetAbilityDataReal(s , l , "dmgfct")
        set damage = damage * x
        set dmgps = dmgps * x

        set x = GetUnitX(u)
        set y = GetUnitY(u)
        set tx = GetUnitX(target)
        set ty = GetUnitY(target)

        set i = i - 1
        exitwhen ( i == 0 ) or ( GetWidgetLife(u) < 1 ) or ( GetWidgetLife(target) < 1 )
        call GroupClear(inrange)
        //call GroupEnumUnitsInRange(inrange , tx , ty , GetAbilityDataReal(s , l , "area") , null)
        //set target = null
        //set other = null
        //if closest then
        //    set grad = 1000000
        //else
        //    set grad = 0
        //endif
        //set dop = LoadDamageOptions(GetAbilityDataInt(s , l , "DamageOptions"))
        //loop
        //    set picked = FirstOfGroup(inrange)
        //    exitwhen ( picked == null )
        //    set fc = GetDamageFactorByOptions(u , picked , dop)
        //    if ( fc != 0 ) then
        //        if closest then
        //            set d = SquareRoot(Pow(x - GetUnitX(picked) , 2) + Pow(y - GetUnitY(picked) , 2))
        //        else
        //            set d = GetRandomInt(0 , R2I(grad + 1))
        //        endif
        //        if ( d <= grad ) then
        //            if not ( IsUnitInGroup(picked , targetlog) ) then
        //                if closest then
        //                    set grad = d
        //                endif
        //                set target = picked
        //            endif
        //            if not ( closest ) then
        //                set grad = grad + 1
        //            endif
        //            set other = picked
        //        endif
        //    endif
        //    call GroupRemoveUnit(inrange , picked)
        //endloop
        //if ( target == null ) and ( GetAbilityDataInt(s , l , "canrepeat") == 1 ) then
        //    set target = other
        //endif
        exitwhen ( target == null )
    endloop
    if ( color ) then
        call SlashTemplate_Colorize(u , GetAbilityDataInt(s , l , "EndColor"))
    endif
    call DestroyEffect(AddSpellEffectTargetById(s , EFFECT_TYPE_SPECIAL , u , "origin"))
    call PauseUnit(u , false)
    call SetUnitTimeScalePercent(u, 100)
    call SetUnitPathing(u , true)
    call SetUnitPosition(u , GetUnitX(u) , GetUnitY(u))
 call DestroyEffect(fx1)
 call DestroyEffect(fx2)
 set fx1 = null
 set fx2 = null
 set u = null
 call DestroyGroup(targetlog)
 set targetlog = null
 call DestroyGroup(inrange)
 set inrange = null
 set target = null
 set other = null
endfunction

function LungeAlternate takes nothing returns nothing
local unit caster = GetSpellAbilityUnit()
local unit targ = GetSpellTargetUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer castn=5 + lvl
    local integer i=1
    if lvl == 3 then
        set castn = castn+2
    endif
    call KS_PauseUnit(caster,true)
    loop
        exitwhen i > castn
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0SZ' , lvl , "shockwave" , GetUnitX(caster) + 30 * Cos(( 360 / castn ) * i * bj_DEGTORAD) , GetUnitY(caster) + 30 * Sin(( 360 / castn ) * i * bj_DEGTORAD) , 3)
        set i = i + 1
    endloop

    call UnitMoveToAsProjectileAnySpeed(caster,1200,0.08,0,0,targ,0)
    call KS_PauseUnit(caster,false)
    set i = 1
    loop
        exitwhen i > castn
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'A0SZ' , lvl , "shockwave" , GetUnitX(caster) + 30 * Cos(( 360 / castn ) * i * bj_DEGTORAD) , GetUnitY(caster) + 30 * Sin(( 360 / castn ) * i * bj_DEGTORAD) , 3)
        set i = i + 1
    endloop
    set caster = null
    set targ = null
endfunction

function Lunge takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local unit targ = GetSpellTargetUnit()
    call KS_PauseUnit(cast,true)
    call UnitMoveToAsProjectileAnySpeed(cast,1200,0.08,0,0,targ,0)
    call KS_PauseUnit(cast,false)
    set cast = null
    set targ = null
endfunction

//===========================================================================
function InitRetTrig_Lunge takes nothing returns nothing

    call OnAbilityEffect('A0SD',"Lunge")
    call OnAbilityEffect('A0SY',"LungeAlternate")
    call OnAbilityEffect('A0T4',"Lunge")
endfunction

function GetLunge takes nothing returns nothing
    local integer lvl = GetLearnedSkillLevel()
    local unit u = GetLearningUnit()
    
    call UnitAddAbility(u,'A0SV')
    call SetUnitAbilityLevel(u,'A0SV',lvl)
    
    set u = null
endfunction

//===========================================================================
function InitRetTrig_Lungescripts takes nothing returns nothing
call OnAbilityLearn('A0SD',"GetLunge")
call OnAbilityLearn('A0SY',"GetLunge")
endfunction

function RetTrig_Spirit_Twin_Bonuses_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0T2' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Spirit_Twin_Bonuses_Actions takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
call UnitAddAbility(cast,'A0T0')
call SetPlayerAbilityAvailable(GetOwningPlayer(cast),'A0T0',false)
call PolledWait(20.00)
call UnitRemoveAbility(cast,'A0T0')

set cast = null
endfunction

//===========================================================================
function InitRetTrig_Spirit_Twin_Bonuses takes nothing returns nothing
    local trigger Spirit_Twin_Bonuses = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( Spirit_Twin_Bonuses, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition( Spirit_Twin_Bonuses, Condition( function RetTrig_Spirit_Twin_Bonuses_Conditions ) )
    call TriggerAddAction( Spirit_Twin_Bonuses, function RetTrig_Spirit_Twin_Bonuses_Actions )
	set Spirit_Twin_Bonuses = null
endfunction

function InitRetTrig_OversightAura takes nothing returns nothing
local integer s
local integer D
 //===================================================================================================
 // Oversight Aura ('A0TA')
 //
 set s = SetPassiveTemplate('A0TA' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options
    //call BJDebugMsg("Oversight Aura has been initialized")
    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 1200)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 1 , 'A0T7')
    call SetAbilityDataInt(s , "spell1id" , 2 , 'A0T8')
    call SetAbilityDataInt(s , "spell1id" , 3 , 'A0T9')
    call SetAbilityDataInt(s , "n" , 0 , 1)


endfunction

function RallySpellStartEnum takes nothing returns nothing
local unit enum = GetEnumUnit()
local integer lvl = GetAttachedInt(bj_lastCreatedGroup,"lvl")  
    call KS_UnitAddAbilityStack(enum,'A0TB',true)
    call KS_UnitAddAbilityStack(enum,'A0TC',true)
    if( GetUnitAbilityLevel(enum,'A0TB') < lvl ) then
        call SetUnitAbilityLevel(enum,'A0TB',lvl)
        call SetUnitAbilityLevel(enum,'A0TC',lvl)
    endif
set enum = null
endfunction

function RallySpellEndEnum takes nothing returns nothing
local unit enum = GetEnumUnit()
local integer lvl = GetAttachedInt(bj_lastCreatedGroup,"lvl")  
    call KS_UnitAddAbilityStack(enum,'A0TB',false)
set enum = null
endfunction

function RallySpellSecondEndEnum takes nothing returns nothing
local unit enum = GetEnumUnit()
local integer lvl = GetAttachedInt(bj_lastCreatedGroup,"lvl")  
    call KS_UnitAddAbilityStack(enum,'A0TC',false)
set enum = null
endfunction

function RallySpell takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local integer abi = GetSpellAbilityId()
local group targs = CreateGroup()
local boolexpr bx = Condition(function CasterAOE_IsFilterAlly)
    set bj_groupEnumOwningPlayer = GetOwningPlayer(cast)
    call CS_EnumUnitsInAOE(targs,GetUnitX(cast),GetUnitY(cast),650,bx)
    call DestroyBoolExpr(bx)
    set bj_lastCreatedGroup = targs
    call AttachInt(targs,"lvl",GetUnitAbilityLevel(cast,abi))
    call ForGroup(targs, function RallySpellStartEnum)
    call PolledWait(14)
    call ForGroup(targs, function RallySpellEndEnum)
    call PolledWait(1)
    call ForGroup(targs, function RallySpellSecondEndEnum)

call DestroyGroup(targs)
set targs = null
set bx = null
set cast = null
endfunction

//===========================================================================
function InitRetTrig_Rally takes nothing returns nothing
    call OnAbilityEffect('A0TD',"RallySpell")
endfunction

function SiegeSpell takes nothing returns nothing
local unit caster= GetSpellAbilityUnit()
local integer spellid=GetSpellAbilityId()
local integer lvl=GetUnitAbilityLevel(caster , spellid)
local unit array spawn
local integer spawntype='n04E'
local integer spawnnum=8
local real spawnspacing=90
local real dur=15
local real deathtime=0.5
local integer i=1
local player p=GetOwningPlayer(caster)
local real x
local real y
local real cx=GetUnitX(caster)
local real cy=GetUnitY(caster)
local real tx = GetSpellTargetX()
local real ty = GetSpellTargetY()
local real cf=GetUnitFacing(caster)
local timer t=CreateTimer()
        set y = ( cf + 180 ) * bj_DEGTORAD
        set cx = cx + 200 * Cos(y)
        set cy = cy + 200 * Sin(y)
loop
    exitwhen i > spawnnum
    if i == spawnnum and spawnnum - ( ( spawnnum / 2 ) * 2 ) > 0 then
        set y = ( cf + 180 ) * bj_DEGTORAD
        set x = cx + spawnspacing * Cos(y)
        set y = cy + spawnspacing * Sin(y)
    else
        set y = ( cf + 180 * i + 90 ) * bj_DEGTORAD
        set x = cx + spawnspacing * ( ( i + 1 ) / 2 ) * Cos(y)
        set y = cy + spawnspacing * ( ( i + 1 ) / 2 ) * Sin(y)
    endif

    set spawn[i]=CreateUnit(p , spawntype , x , y , cf)
    call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl",x,y))
    call UnitAddAbility(spawn[i] , 'Aloc')
    call IssuePointOrder(spawn[i],"attackground",tx+GetRandomReal(-150,150),ty+GetRandomReal(-150,150))
    set i = i + 1
endloop
call TimerStart(t , dur , false , null)
loop
    set y = TimerGetRemaining(t)
    exitwhen TimerGetRemaining(t) <= 0
    call TriggerSleepAction(0)
endloop
set i = 1
call DestroyTimer(t)
loop
    exitwhen i > spawnnum
    call KillUnit(spawn[i])
    call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl",GetUnitX(spawn[i]),GetUnitY(spawn[i])))
    call RemoveUnit(spawn[i])
    set spawn[i] = null
    set i = i + 1
endloop
set t = null
set caster = null
endfunction

function InitRetTrig_Siege takes nothing returns nothing
    call OnAbilityEffect('A0TE',"SiegeSpell")
endfunction

function HornOfHonroHeroFilter takes nothing returns boolean
    return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(GetSpellAbilityUnit())) and IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO)
endfunction

function HornOfHonroFilter takes nothing returns boolean
    return GetOwningPlayer(GetFilterUnit()) == GetOwningPlayer(GetSpellAbilityUnit()) and not IsUnitType(GetFilterUnit(),UNIT_TYPE_PEON)
endfunction

function HornOfHonroEnum takes nothing returns nothing
if bj_lastCreatedUnit != null then
    call IssueTargetOrder(GetEnumUnit(),"attack",bj_lastCreatedUnit)
endif
endfunction

function HornOfHonro takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local group eHeroes = CreateGroup()
local group allies = CreateGroup()
local boolexpr b = Filter(function HornOfHonroFilter)
local boolexpr bh = Filter(function HornOfHonroHeroFilter)
call GroupEnumUnitsInRange(eHeroes,GetUnitX(cast),GetUnitY(cast),1200,bh)
call GroupEnumUnitsInRange(allies,GetUnitX(cast),GetUnitY(cast),1200,b)
set bj_lastCreatedUnit = FirstOfGroup(eHeroes)
call ForGroup(allies,function HornOfHonroEnum)
call CasterCastAbility(GetOwningPlayer(cast),'A0UH',"acidbomb",bj_lastCreatedUnit,true)

call DestroyGroup(eHeroes)
call DestroyGroup(allies)
call DestroyBoolExpr(b)
call DestroyBoolExpr(bh)

set cast = null
set eHeroes = null
set allies = null
set b = null
set bh = null 
endfunction

function InitHornOfHonro takes nothing returns nothing
    call OnAbilityEffect('A0UI',"HornOfHonro")
endfunction

function RetTrig_HornOfHonroGet_Conditions takes nothing returns boolean
    
    return IsUnitIdType(GetTrainedUnitType(),UNIT_TYPE_HERO)
endfunction

function RetTrig_HornOfHonroGet_Actions takes nothing returns nothing
    //call UnitAddAbility(GetTrainedUnit(),'A0UI')
endfunction

function RetTrig_HornOfHonroGet2_Conditions takes nothing returns boolean
    
    return IsUnitType(GetSoldUnit(),UNIT_TYPE_HERO)
endfunction

function RetTrig_HornOfHonroGet2_Actions takes nothing returns nothing
    //call UnitAddAbility(GetSoldUnit(),'A0UI')
endfunction

//==== Init Trigger HornOfHonroGet ====
function InitRetTrig_HornOfHonroGet takes nothing returns nothing
    local trigger trg_HornOfHonroGet = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(trg_HornOfHonroGet, EVENT_PLAYER_UNIT_TRAIN_FINISH)
    call TriggerAddCondition(trg_HornOfHonroGet, Condition(function RetTrig_HornOfHonroGet_Conditions))
    call TriggerAddAction(trg_HornOfHonroGet, function RetTrig_HornOfHonroGet_Actions)
    set trg_HornOfHonroGet = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(trg_HornOfHonroGet, EVENT_PLAYER_UNIT_SELL)
    call TriggerAddCondition(trg_HornOfHonroGet, Condition(function RetTrig_HornOfHonroGet2_Conditions))
    call TriggerAddAction(trg_HornOfHonroGet, function RetTrig_HornOfHonroGet2_Actions)
    set trg_HornOfHonroGet = null
endfunction

function RetTrig_Rotsteel_Cannon_Lightning_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'hZZS' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Rotsteel_Cannon_Lightning_Actions takes nothing returns nothing
    call CasterCastAbilityEx( GetOwningPlayer(GetAttacker()), GetUnitX(GetAttacker()), GetUnitY(GetAttacker()), GetUnitFlyHeight(GetAttacker()), 'A0U5', 1, "chainlightning", GetAttackedUnitBJ(), 5.00)
endfunction

//===========================================================================
function InitRetTrig_Rotsteel_Cannon_Lightning takes nothing returns nothing
    local trigger Rotsteel_Cannon_Lightning = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( Rotsteel_Cannon_Lightning, EVENT_PLAYER_UNIT_ATTACKED )
    call TriggerAddCondition( Rotsteel_Cannon_Lightning, Condition( function RetTrig_Rotsteel_Cannon_Lightning_Conditions ) )
    call TriggerAddAction( Rotsteel_Cannon_Lightning, function RetTrig_Rotsteel_Cannon_Lightning_Actions )
	set Rotsteel_Cannon_Lightning = null
endfunction

function RetTrig_Plague_Wyrm_Spikes_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'u00T' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Plague_Wyrm_Spikes_Actions takes nothing returns nothing
    call CasterCastAbilityEx( GetOwningPlayer(GetAttacker()), GetUnitX(GetAttacker()), GetUnitY(GetAttacker()), GetUnitFlyHeight(GetAttacker()), 'AZZL', 1, "impale", GetAttackedUnitBJ(), 5.00)
endfunction

//===========================================================================
function InitRetTrig_Plague_Wyrm_Spikes takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_ATTACKED )
    call TriggerAddCondition( t, Condition( function RetTrig_Plague_Wyrm_Spikes_Conditions ) )
    call TriggerAddAction( t, function RetTrig_Plague_Wyrm_Spikes_Actions )
	set t = null
endfunction



function rise takes nothing returns nothing
    local timer t = GetExpiredTimer()
    local unit u = GetAttachedUnit(t, "unit")
    local trigger tri = GetAttachedTrigger(t, "trigger")
    
    if ( GetUnitFlyHeight(u) >= GetUnitDefaultFlyHeight(u) ) then
        call SetUnitFlyHeight( u, GetUnitDefaultFlyHeight(u), 200.00 )
        call UnitRemoveType( u, UNIT_TYPE_GROUND ) 
        call UnitAddType( u, UNIT_TYPE_FLYING )
        call CleanAttachedVars(t)
        call DestroyTimer(t)
        call CleanAttachedVars(tri)
        call DestroyTrigger(tri)  
    else
        call SetUnitFlyHeight( u, GetUnitFlyHeight(u) + 5.0, 10.0 )    
    endif
    
    set tri = null
    set t = null
    //return
endfunction

function smackDown_clearTimer takes nothing returns nothing
    local trigger tri = GetTriggeringTrigger()
    local timer t = GetAttachedTimer(tri, "timer")
    call CleanAttachedVars(t)
    call DestroyTimer(t)
    call CleanAttachedVars(tri)
    call DestroyTrigger(tri)
    set tri = null
    set t = null
    //return
endfunction

function SmackDown takes unit u returns nothing
    local timer t = CreateTimer()
    local trigger tri = CreateTrigger()
    
    call AttachObject(t, "unit", u)
    call AttachObject(t, "trigger", tri)
    call TimerStart(t, .5, true, function rise)
    
    call AttachObject(tri, "unit", u)
    call AttachObject(tri, "timer", t)
    call TriggerAddAction(tri, function smackDown_clearTimer)
    call TriggerRegisterDeathEvent(tri, u)
    
    
    set tri = null
    set t = null
    //return
endfunction


function RetTrig_Smack_Down_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetAttacker()) == 'u00R' ) ) then
        return false
    endif
    if ( not ( GetPlayerTechCountSimple('R048', GetOwningPlayer(GetAttacker())) == 1 ) ) then
        return false
    endif
    if ( not ( IsUnitType(GetAttackedUnitBJ(), UNIT_TYPE_FLYING) == true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Smack_Down_Actions takes nothing returns nothing
    call UnitAddType( GetAttackedUnitBJ(), UNIT_TYPE_GROUND )
    call UnitRemoveType( GetAttackedUnitBJ(), UNIT_TYPE_FLYING )
    call SetUnitFlyHeight( GetAttackedUnitBJ(), 150.00, 500.00 )
    call SmackDown( GetAttackedUnitBJ() )                     
endfunction

//===========================================================================
function InitRetTrig_Smack_Down takes nothing returns nothing
    local trigger gg_trg_Smack_Down = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Smack_Down, EVENT_PLAYER_UNIT_ATTACKED )
    call TriggerAddCondition( gg_trg_Smack_Down, Condition( function RetTrig_Smack_Down_Conditions ) )
    call TriggerAddAction( gg_trg_Smack_Down, function RetTrig_Smack_Down_Actions )
	set gg_trg_Smack_Down = null
endfunction

                      
function eggSack_Timer takes nothing returns nothing
    local timer t = GetExpiredTimer()
    local unit eggs = GetAttachedUnit(t, "eggs")
    call SetUnitUserData( eggs, GetUnitUserData(eggs) + 1 )
    set t = null
    //return
endfunction

function eggSack_death takes nothing returns nothing
    local trigger tri = GetTriggeringTrigger()
    local timer t = GetAttachedTimer(tri, "timer")
    local unit eggs = GetAttachedUnit(t, "eggs")
    call CreateNUnitsAtLoc( GetUnitUserData(eggs)+1, 'n01H', GetOwningPlayer(eggs), GetUnitLoc(eggs), bj_UNIT_FACING )
    call CleanAttachedVars(t)
    call DestroyTimer(t)
    call CleanAttachedVars(tri)
    call DestroyTrigger(tri)
    set tri = null
    set t = null
    //return
endfunction

function EggSack takes unit eggs returns nothing
    local timer t = CreateTimer()
    local trigger tri = CreateTrigger()
    
    call AttachObject(t, "eggs", eggs)
    call TimerStart(t, 15, true, function eggSack_Timer)
    
    call AttachObject(tri, "eggs", eggs)
    call AttachObject(tri, "timer", t)
    call TriggerAddAction(tri, function eggSack_death)
    call TriggerRegisterDeathEvent(tri, eggs)
    
    
    set tri = null
    set t = null
    //return
endfunction

function RetTrig_Egg_Sack_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetSummonedUnit()) == 'o009' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Egg_Sack_Actions takes nothing returns nothing
    call EggSack(GetSummonedUnit())
endfunction

//===========================================================================
function InitRetTrig_Egg_Sack takes nothing returns nothing
    local trigger gg_trg_Egg_Sack = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Egg_Sack, EVENT_PLAYER_UNIT_SUMMON )
    call TriggerAddCondition( gg_trg_Egg_Sack, Condition( function RetTrig_Egg_Sack_Conditions ) )
    call TriggerAddAction( gg_trg_Egg_Sack, function RetTrig_Egg_Sack_Actions )
	set gg_trg_Egg_Sack = null
endfunction


function infestTimer takes nothing returns nothing
    local timer t = GetExpiredTimer()
    local unit target = GetAttachedUnit(t, "target")
    local integer caster = GetAttachedInt(t, "caster")
    local trigger tri = GetAttachedTrigger(t, "trigger")
    call CreateNUnitsAtLoc( 3, 'n01H', Player(caster), GetUnitLoc(target), bj_UNIT_FACING )
    call UnitShareVisionBJ( false, target, Player(caster) )
    call CleanAttachedVars(t)
    call DestroyTimer(t)
    call CleanAttachedVars(tri)
    call DestroyTrigger(tri)
    set tri = null
    set t = null
    //return
endfunction

function infest_clearTimer takes nothing returns nothing
    local trigger tri = GetTriggeringTrigger()
    local timer t = GetAttachedTimer(tri, "timer")
    call CleanAttachedVars(t)
    call DestroyTimer(t)
    call CleanAttachedVars(tri)
    call DestroyTrigger(tri)
    set tri = null
    set t = null
    //return
endfunction

function Infest takes unit tar, player caster returns nothing
    local timer t = CreateTimer()
    local trigger tri = CreateTrigger()
    
    call AttachObject(t, "target", tar)
    call AttachInt(t, "caster", GetPlayerId(caster) )
    call AttachObject(t, "trigger", tri)
    call UnitShareVisionBJ( true, tar, caster )
    call TimerStart(t, 90, false, function infestTimer)
    
    call AttachObject(tri, "timer", t)
    call TriggerAddAction(tri, function infest_clearTimer)
    call TriggerRegisterDeathEvent(tri, tar)
    
    
    set tri = null
    set t = null
    //return
endfunction

function RetTrig_Infest_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0TY' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Infest_Actions takes nothing returns nothing
    call Infest( GetSpellTargetUnit(), GetOwningPlayer(GetSpellAbilityUnit()) )
endfunction

//===========================================================================
function InitRetTrig_Infest takes nothing returns nothing
    local trigger gg_trg_Infest = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Infest, EVENT_PLAYER_UNIT_SPELL_CAST )
    call TriggerAddCondition( gg_trg_Infest, Condition( function RetTrig_Infest_Conditions ) )
    call TriggerAddAction( gg_trg_Infest, function RetTrig_Infest_Actions )
	set gg_trg_Infest = null
endfunction

function RetTrig_AtkDrainMoment_Conditions takes nothing returns boolean
    
    return GetEventDamageSource() == GetAttachedUnit(GetTriggeringTrigger(),"source")
endfunction

function RetTrig_AtkDrainMoment_Actions takes nothing returns nothing
    local unit cast = GetEventDamageSource()
    local unit targ = GetTriggerUnit()
    local trigger t = GetTriggeringTrigger()
    local integer abi = GetAttachedInt(cast,"attackDrain")
    local integer lvl = GetAttachedInt(cast,"attackDrainLev")
    
    local real percent = GetAbilityDataReal(abi,lvl,"percent")
    local real life = GetAbilityDataReal(abi,lvl,"life")
    local real mana = GetAbilityDataReal(abi,lvl,"mana")
    local string model = GetAbilityEffectById(abi,EFFECT_TYPE_MISSILE,0)
    local boolean reverse = GetAbilityDataInt(abi,lvl,"reverse") == 1
    local integer d = GetAbilityDataInt(abi , lvl , "options")
    
    local boolean good = true
    
    local real atkLife = 0.00
    local real atkMana = 0.00
    
        call DestroyTrigger(t)
        call AttachObject(t,"source",null)

        if ( d != 0 ) then
            set d = LoadDamageOptions(d)
             set good = ( GetDamageFactorByOptions(cast , targ , d) > 0 )
        endif
    
    
    if( GetRandomReal(0,100) <= percent) and good then
        set atkLife = GetUnitState(targ,UNIT_STATE_LIFE)
        call UnitDamageTarget(cast,targ,life,true,false,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_ENHANCED,WEAPON_TYPE_WHOKNOWS)
        set atkLife = atkLife - GetUnitState(targ,UNIT_STATE_LIFE)
        if( GetUnitState(targ,UNIT_STATE_MAX_MANA) > 0 ) then
            set atkMana = GetUnitState(targ,UNIT_STATE_MANA)
            
            call SetUnitState(targ,UNIT_STATE_MANA,atkMana-mana)
            set atkMana = atkMana - GetUnitState(targ,UNIT_STATE_MANA)
        endif
        
        
        if( atkMana > 0 or atkLife > 0 ) then
            if( reverse == true ) then
                call ProjectileLaunchToUnit(model,700,0.15,GetUnitX(cast),GetUnitY(cast),GetUnitFlyHeight(cast),targ,GetUnitFlyHeight(targ))
            else
                call ProjectileLaunchToUnit(model,700,0.15,GetUnitX(targ),GetUnitY(targ),GetUnitFlyHeight(targ),cast,GetUnitFlyHeight(cast))
            endif
            
            call SetUnitState(cast,UNIT_STATE_LIFE,GetUnitState(cast,UNIT_STATE_LIFE)+atkLife)
            call SetUnitState(cast,UNIT_STATE_MANA,GetUnitState(cast,UNIT_STATE_MANA)+atkMana)
        endif
        
        
    endif
    
    
    set cast = null
    set targ = null
    
endfunction

function InitRetTrig_AtkDrainMoment takes unit who, unit targ returns nothing
    local trigger t = CreateTrigger()
    call TriggerRegisterUnitEvent(t,targ,EVENT_UNIT_DAMAGED)
    call TriggerAddCondition(t, Condition(function RetTrig_AtkDrainMoment_Conditions))
    call TriggerAddAction(t, function RetTrig_AtkDrainMoment_Actions)
    call AttachObject(t,"source",who)
    
    
    call PolledWait(0.5+RJ_DistanceBetweenUnits(who,targ)/200)
    if ( t != null ) then
        call DestroyTrigger(t)
        call AttachObject(t,"source",null)
    endif
endfunction



function RetTrig_AttackDrain_Conditions takes nothing returns boolean
    
    return GetAttachedInt(GetAttacker(),"attackDrain") != 0
endfunction

function RetTrig_AttackDrain_Actions takes nothing returns nothing
    call InitRetTrig_AtkDrainMoment(GetAttacker(),GetTriggerUnit())
endfunction

function RetTrig_AttackDrain_Death_Actions takes nothing returns nothing
    local unit cast = GetAttacker()
    call CleanAttachedVars(cast)
    
    //Left for compat
    call FlushChildHashtable(rdg_cstable,GetHandleId(cast))
    set cast = null
endfunction

//==== Init Trigger AttackDrain ====
function InitRetTrig_AttackDrain takes nothing returns nothing
    local trigger attackDrain = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(attackDrain,EVENT_PLAYER_UNIT_ATTACKED)
    call TriggerAddCondition(attackDrain, Condition(function RetTrig_AttackDrain_Conditions))
    call TriggerAddAction(attackDrain, function RetTrig_AttackDrain_Actions)
    set attackDrain = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(attackDrain,EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(attackDrain, Condition(function RetTrig_AttackDrain_Conditions))
    call TriggerAddAction(attackDrain, function RetTrig_AttackDrain_Death_Actions)     
    set attackDrain = null
endfunction


function AttackDrainTemplate takes nothing returns nothing
local unit cast = CasterSystem___acquiringunit
local integer abi = CasterSystem___acquiredabil
local integer lvl = GetUnitAbilityLevel(cast,abi)

call AttachInt(cast,"attackDrain",abi) 
call AttachInt(cast,"attackDrainLev",lvl)

set cast = null
endfunction

function Init_AttackDrainTemplate takes nothing returns nothing
local integer s
local integer D
//*************************************************************************
//                         Drain Attack Template
//*************************************************************************
// passive ability
//
// real    "percent"          percent chance to activate
// real    "life"             life drained on hit
// real    "mana"             mana drained on hit
//                            I would suggest 128.00, it works pretty well
// int     "reverse"          should be 0 if you want the projectile to launch from
//                             the attacked unit to the caster, 1 if you want
//                             to launch it from caster to victim
// int     "options"          The damage options for which units can be affected
//  The ability's missile art determines what missile to launch between the units.




    call InitRetTrig_AttackDrain()
    call SetTemplateDefaultReal("AttackDrainTemplate","percent",100.00) 
    call SetTemplateDefaultReal("AttackDrainTemplate","mana",20.00)
    call SetTemplateDefaultReal("AttackDrainTemplate","life",20.00)

    
//===================================================================================================
 // Life Drain Attack ('A0TR')
 //
 set s = SetPassiveTemplate('A0TR' , "AttackDrainTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "life" , 0 , 20)
    call SetAbilityDataReal(s , "mana" , 0 , 10)
    call SetAbilityDataReal(s , "percent" , 0 , 100)
    
endfunction

function RetTrig_Absorb_Corpse_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0TQ' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellAbilityUnit()) == 'u01X' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Absorb_Corpse_Actions takes nothing returns nothing
    call SetUnitUserData( GetSpellAbilityUnit(), ( GetUnitUserData(GetSpellAbilityUnit()) + 3 ) )
    call AddUnitToStockBJ( 'u023', GetSpellAbilityUnit(), GetUnitUserData(GetSpellAbilityUnit()), GetUnitUserData(GetSpellAbilityUnit()) )
endfunction

//===========================================================================
function InitRetTrig_Absorb_Corpse takes nothing returns nothing
    local trigger gg_trg_Absorb_Corpse = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Absorb_Corpse, EVENT_PLAYER_UNIT_SPELL_CAST )
    call TriggerAddCondition( gg_trg_Absorb_Corpse, Condition( function RetTrig_Absorb_Corpse_Conditions ) )
    call TriggerAddAction( gg_trg_Absorb_Corpse, function RetTrig_Absorb_Corpse_Actions )
	set gg_trg_Absorb_Corpse = null
endfunction

function RetTrig_Create_Cauldron_Born_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A0TW' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellAbilityUnit()) == 'u01Y' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Create_Cauldron_Born_Actions takes nothing returns nothing
    call CreateNUnitsAtLoc( 1, 'uZZE', GetOwningPlayer(GetSpellAbilityUnit()), GetUnitLoc(GetSpellAbilityUnit()), bj_UNIT_FACING )
endfunction

//===========================================================================
function InitRetTrig_Create_Cauldron_Born takes nothing returns nothing
    local trigger gg_trg_Create_Cauldron_Born = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Create_Cauldron_Born, EVENT_PLAYER_UNIT_SPELL_CAST )
    call TriggerAddCondition( gg_trg_Create_Cauldron_Born, Condition( function RetTrig_Create_Cauldron_Born_Conditions ) )
    call TriggerAddAction( gg_trg_Create_Cauldron_Born, function RetTrig_Create_Cauldron_Born_Actions )
	set gg_trg_Create_Cauldron_Born = null
endfunction

function RetTrig_Sell_Invasion_Skeleton_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetSellingUnit()) == 'u01X' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Sell_Invasion_Skeleton_Actions takes nothing returns nothing
    call SetUnitUserData( GetSellingUnit(), ( GetUnitUserData(GetSellingUnit()) - 1 ) )
    call AddUnitToStockBJ( 'u023', GetSellingUnit(), GetUnitUserData(GetSellingUnit()), GetUnitUserData(GetSellingUnit()) )
	call UnitApplyTimedLife(GetSoldUnit(), 'BFig', 120.00)
endfunction

//===========================================================================
function InitRetTrig_Sell_Invasion_Skeleton takes nothing returns nothing
    local trigger gg_trg_Sell_Invasion_Skeleton = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( gg_trg_Sell_Invasion_Skeleton, EVENT_PLAYER_UNIT_SELL )
    call TriggerAddCondition( gg_trg_Sell_Invasion_Skeleton, Condition( function RetTrig_Sell_Invasion_Skeleton_Conditions ) )
    call TriggerAddAction( gg_trg_Sell_Invasion_Skeleton, function RetTrig_Sell_Invasion_Skeleton_Actions )
	set gg_trg_Sell_Invasion_Skeleton = null
endfunction

function InitRetTrig_CauldronBornAura takes nothing returns nothing
local integer s
local integer D
 //===================================================================================================
 // Cauldron Revive Aura ('AZZR')
 //
 set s = SetPassiveTemplate('AZZR' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = D + DamageOnlyTo(UNIT_TYPE_ANCIENT) //Only Cauldron Born
 //set D = D + DamageOnlyTo(UNIT_TYPE_UNDEAD) //Only Cauldron Born
 set D = CreateDamageOptions(D) //Save the damage options
    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 512)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 1 , 'AZZQ')
    call SetAbilityDataInt(s , "n" , 0 , 1)

 //===================================================================================================
 // Smoke Bomb Aura ('A0TU')
 //
 set s = SetPassiveTemplate('A0TU' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options
    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 200)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 1 , 'Apiv')
    call SetAbilityDataInt(s , "n" , 0 , 1)


endfunction

function NuclearStrike takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local location targ = GetSpellTargetLoc()
local unit bomb = GetACaster()

call PolledWait(0.5)
call CasterCastAbilityPointEx(GetOwningPlayer(cast),GetLocationX(targ),GetLocationY(targ),GetLocationZ(targ),'A0UE',1,"flamestrike",GetLocationX(targ),GetLocationY(targ),8)
call PolledWait(0.5)
call SetUnitScale(bomb,6,6,6)
call SetUnitTimeScale(bomb,0.2)
call SetUnitPositionLoc(bomb,targ)
call DestroyEffect(AddSpellEffectTargetById('Arng',EFFECT_TYPE_TARGET,bomb,"origin"))
call DestroyEffect(AddSpellEffectTargetById('Arng',EFFECT_TYPE_CASTER,bomb,"origin"))
call DestroyEffect(AddSpellEffectTargetById('Arng',EFFECT_TYPE_SPECIAL,bomb,"origin"))

call PolledWait(8)
call SetUnitScale(bomb,1,1,1)
call SetUnitTimeScale(bomb,1)
call RecycleCaster(bomb)
set cast = null
call RemoveLocation(targ)
set targ = null
endfunction


//===========================================================================
function InitRetTrig_Nuke takes nothing returns nothing

    call OnAbilityEffect('A0UD',"NuclearStrike")
endfunction


function SoundSys_Store takes integer buildingId, string soundLabel returns nothing
    call SaveSoundHandle(rj_soundTable,buildingId,0,CreateSoundFromLabel(soundLabel,false,false,false,1,1))
endfunction 


function RetTrig_SoundSys_Conditions takes nothing returns boolean    
    return HaveSavedHandle(rj_soundTable,GetUnitTypeId(GetConstructedStructure()),0)
endfunction

function RetTrig_SoundSys_Actions takes nothing returns nothing
    if( GetOwningPlayer(GetConstructedStructure()) == GetLocalPlayer() ) then
		call StartSound(LoadSoundHandle(rj_soundTable,GetUnitTypeId(GetConstructedStructure()),0))
	else
		//call StartSound(null)
	endif
endfunction

//==== Init Trigger SoundSys ====
function InitRet_BuildSoundSys takes nothing returns nothing
    local trigger t = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
    call TriggerAddCondition(t, Condition(function RetTrig_SoundSys_Conditions))
    call TriggerAddAction(t, function RetTrig_SoundSys_Actions)
    
    call SoundSys_Store('h030',"JobDoneFallyTownSquare")
    call SoundSys_Store('h03N',"JobDoneFallyCastle")
    call SoundSys_Store('h031',"JobDoneFallyHouse")
    call SoundSys_Store('h032',"JobDoneFallyAltar")
    call SoundSys_Store('h033',"JobDoneFallyArcheryGuild")
    call SoundSys_Store('h03A',"JobDoneFallyBarracks")
    call SoundSys_Store('h039',"JobDoneFallyLumberMill")
    call SoundSys_Store('h034',"JobDoneFallyMiningCamp")
    call SoundSys_Store('h03F',"JobDoneFallyWorkshop")
    call SoundSys_Store('h03G',"JobDoneFallyStables")
    call SoundSys_Store('h03L',"JobDoneFallyChapel")
    call SoundSys_Store('h03M',"JobDoneFallyArrowTower")
    call SaveSoundHandle(rj_soundTable,'h03T',0,LoadSoundHandle(rj_soundTable,'h03M',0))
    call SoundSys_Store('h03U',"JobDoneFallyBombardTower")
    call SaveSoundHandle(rj_soundTable,'h03V',0,LoadSoundHandle(rj_soundTable,'h03U',0))
    call SoundSys_Store('h03O',"JobDoneFallyArmory")
    
    
    set t = null
endfunction 

function RisenSacKill takes nothing returns nothing
    call KillUnit(GetSpellTargetUnit())
endfunction

//==== Init Trigger RisenSacKill ====
function InitRetTrig_RisenSacKill takes nothing returns nothing
    call OnAbilityEffect('A0RG',"RisenSacKill")
endfunction

function BannerOfProtection_Summon takes nothing returns nothing
//    function CasterCastAbilityPoint takes player owner,integer abilid,string order,real x,real y,boolean instant returns unit
    call CasterCastAbilityPoint(GetOwningPlayer(GetSpellAbilityUnit()), 'Abpc', "healingward", GetSpellTargetX(), GetSpellTargetY(), true)
endfunction

//===========================================================================
function InitTrig_BannerOfProtection takes nothing returns nothing
call OnAbilityEffect('Abpd', "BannerOfProtection_Summon")
endfunction

function Trig_Taunt_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AZXt' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Taunt_Actions takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
    call UnitAddAbilityBJ( 'AZXa', cast )
    call SetUnitAbilityLevel( cast, 'AZXa', GetUnitAbilityLevel(cast, 'AZXt'))
    
    call PolledWait( 12.00 )
    call UnitRemoveAbilityBJ( 'AZXa', cast )
set cast=null
endfunction

//player owner,integer abilid,string order,widget target,boolean instant
function Spell_SelfHeal_Jugger takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local integer level = GetUnitAbilityLevel(cast, 'AZsh')
call CasterCastAbilityLevel(GetOwningPlayer(cast),'Asht',level,"rejuvination",cast,true)

    call UnitAddAbilityBJ( 'AZha', cast )
    call SetUnitAbilityLevel( cast, 'AZha', level)
    
    call PolledWait( 5.00 )
    call UnitRemoveAbilityBJ( 'AZha', cast )
    
set cast = null
endfunction

function Spell_Ulti_Jugger_Damaged takes nothing returns nothing
local unit cast = GetTriggerUnit()
local real amount = GetEventDamage()
local real damageCounter = GetAttachedReal(cast, "ulti_damage_counter")
local unit source = GetEventDamageSource()
local integer powerLevel
local integer lastLevel = GetUnitAbilityLevel(cast, 'AZga')
    if( IsUnitEnemy(source, GetOwningPlayer(cast)) ) then
        set damageCounter = damageCounter + amount
        set powerLevel = R2I( damageCounter / 350.00 )
        //if( powerLevel > 30 ) then
        //    set powerLevel = 30
        //endif
        call AttachReal(cast, "ulti_damage_counter", damageCounter)
        if( lastLevel == 0 and powerLevel != 0 ) then
            call UnitAddAbility(cast, 'AZga')
            call UnitAddAbility(cast, 'AZua')
            call UnitAddAbility(cast, 'AZur')
        endif
        if( lastLevel != powerLevel ) then
            call SetUnitAbilityLevel(cast, 'AZga', powerLevel)
            call SetUnitAbilityLevel(cast, 'AZua', powerLevel)
            call SetUnitAbilityLevel(cast, 'AZur', powerLevel)
        endif
    endif
set source = null
set cast = null
endfunction

function Spell_Ulti_Jugger takes nothing returns nothing
local unit cast = GetLearningUnit()
call UnitAddAbility(cast, 'AZst')
//local trigger t = CreateTrigger()
//    call TriggerRegisterUnitEvent(t, cast, EVENT_UNIT_DAMAGED)
//    call TriggerAddAction(t, function Spell_Ulti_Jugger_Damaged)
set cast = null
endfunction

//===========================================================================
function InitTrig_Taunt takes nothing returns nothing
 local trigger Taunt
 local integer s
            call PreloadAbility('AZga')
            call PreloadAbility('AZua')
            call PreloadAbility('AZur')
    call OnAbilityEffect('AZsh', "Spell_SelfHeal_Jugger")
    call OnAbilityLearn('AZul', "Spell_Ulti_Jugger")
 
    set Taunt = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( Taunt, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition( Taunt, Condition( function Trig_Taunt_Conditions ) )
    call TriggerAddAction( Taunt, function Trig_Taunt_Actions )
	set Taunt = null
    
     //=================================
 //Defensive Stance

 set s = SetSpellTemplate('AZXd' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'BZXd') //The buff of the spell is B014
    call SetAbilityDataInt(s , "AbilN" , 0 , 5) //It Adds 1 ability in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'AZsc') //ability
    call SetAbilityDataInt(s , "Abil2" , 0 , 'AZDr') //ability
    call SetAbilityDataInt(s , "Abil3" , 0 , 'AZHp') //ability
    call SetAbilityDataInt(s , "Abil4" , 0 , 'AZss') //ability
    call SetAbilityDataInt(s , "Abil5" , 0 , 'AZDa') //ability
    call SetAbilityDataInt(s , "SPB1" , 0 , 'AZXx') //ability
    call SetAbilityDataInt(s , "SPB2" , 0 , 'AZXx') //ability
endfunction

// function ProjectileLaunch takes string modelpath,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns nothing
// function CasterCastAbilityPoint takes player owner,integer abilid,string order,real x,real y,boolean instant returns unit
    
//function ProjectileLaunchExTimeless takes player owner,string modelpath,real scale,integer red,integer green,integer blue,integer alpha,real speed,real arc,real x1,real y1,real z1,real x2,real y2,real z2 returns nothing

function ShockStorm_Hit takes nothing returns nothing
    local timer t = GetExpiredTimer()
    local real x = GetAttachedReal(t, "x")
    local real y = GetAttachedReal(t, "y")
    local unit cast = GetAttachedUnit(t, "trig_unit")
    call CasterCastAbilityPoint(GetOwningPlayer(cast), 'ALZs', "thunderclap", x, y, false)
    call DestroyTimer(t)
    set t = null
endfunction

function ShockStorm_Timer takes nothing returns nothing
    local timer t = GetExpiredTimer()
    local unit cast = GetAttachedUnit(t, "trig_unit")
    local real x = GetUnitX(cast)
    local real y = GetUnitY(cast)
    local real ang = GetRandomReal(0, bj_PI * 2)
    local real dist = GetRandomReal(330, 550)
    local real tx = Cos(ang) * dist + x
    local real ty = Sin(ang) * dist + y
    local real speed = GetRandomReal(200, 1000)
    local timer timer2 = CreateTimer()
    call ProjectileLaunchExTimeless(GetOwningPlayer(cast), "Abilities\\Spells\\Orc\\LightningBolt\\LightningBoltMissile.mdl", 1.00, 255, 255, 255, 255, speed, 0.55, x, y, 0, tx, ty, 0)
    call AttachReal(timer2, "x", tx)
    call AttachReal(timer2, "y", ty)
    call AttachObject(timer2, "trig_unit", cast)
    call TimerStart(timer2, dist / speed, false, function ShockStorm_Hit)
    call DestroyTimer(t)
    set t = null
    set cast = null
endfunction

function ShockStorm_Spell takes nothing returns nothing
    local unit cast = GetSpellAbilityUnit()
    local real x = GetUnitX(cast)
    local real y = GetUnitY(cast)
    local integer i = 0
    local timer t
    local integer num_bolts = GetUnitAbilityLevel(cast, 'ALsb') * 10 + 10
    
    loop
        exitwhen not (i < num_bolts)
        set t = CreateTimer()
        call AttachObject(t, "trig_unit", cast)
        call TimerStart(t, GetRandomReal(0.5, 1.5), false, function ShockStorm_Timer)
        set i = i + 1
    endloop
    
    set t = null
    set cast = null
endfunction

//===========================================================================
function InitTrig_Shock_Storm takes nothing returns nothing
    call OnAbilityEffect('ALsb', "ShockStorm_Spell")
endfunction

function Thunderstep_Spell takes nothing returns nothing
    local unit cast = GetSpellAbilityUnit()
    call PolledWait(0.15)
    call SetPlayerAbilityAvailable(GetOwningPlayer(cast),'ALta',false)
    call UnitAddAbility(cast, 'ALts')
    call SetUnitAbilityLevel(cast, 'ALts', GetUnitAbilityLevel(cast, 'ALbl'))
    //call PolledWait(1.00)
    call IssueImmediateOrder(cast, "berserk")
    call UnitRemoveAbility(cast, 'ALts')
    set cast = null
endfunction

//===========================================================================
function InitTrig_Thunderstep takes nothing returns nothing
    call OnAbilityEffect('ALbl', "Thunderstep_Spell")
endfunction

//===========================================================================
function InitTrig_Boulder_Wave takes nothing returns nothing
local integer s
local integer D

 set s = SetSpellTemplate('ARbw' , "ConeSpellTemplate") //The ability Rawcode
 set D = 0 //Frost Breath options
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //spell cold (magical) damage
 set D = D + DamageOnlyEnemies() //Don't harm allies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "initialarea" , 0 , 950) //Initial area is 150
    call SetAbilityDataReal(s , "distance" , 0 , 1600) //Distance is 800
    call SetAbilityDataReal(s , "finalarea" , 0 , 1450) //Final area is 500
    call SetAbilityDataInt(s , "maxtargets" , 1 , 5) //Maximum number of targets is 3
    call SetAbilityDataInt(s , "maxtargets" , 2 , 7) //Maximum number of targets is 5
    call SetAbilityDataInt(s , "maxtargets" , 3 , 10) //Maximum number of targets is 7
    call SetAbilityDataInt(s , "spell" , 0 , 'ARhb') //Spell to cast is "Chain Lightning (forked chain lightning)" (A01V)
    call SetAbilityDataInt(s , "castfromcaster" , 0 , 1) //Casters cast the spell from the position of the caster
    call SetAbilityDataReal(s , "recycledelay" , 0 , 1.0) //The spell has a 4 seconds delay before recycling casters
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("creepthunderbolt")) //The orderstring of that spell is chainlightning
endfunction

function EarthTsunami_Spell takes nothing returns nothing
local real tx = GetSpellTargetX()
local real ty = GetSpellTargetY()
local unit cast = GetSpellAbilityUnit()
local real cx = GetUnitX(cast)
local real cy = GetUnitY(cast)
local real ang = bj_RADTODEG * Atan2(ty - cy, tx - cx)

local real dist = SquareRoot((ty - cy) * (ty - cy) + (tx - cx) * (tx - cx))

local real x = 0
local real y = 0
local real delta = 0

// function CasterCastAbilityPoint takes player owner,integer abilid,string order,real x,real y,boolean instant returns unit
// function CasterCastAbilityPointEx takes player owner,real x1,real y1,real z1,integer abilid,integer level,string order,real x2,real y2,real delay returns unit
    
set delta = 22.5
set x = CosBJ(ang + delta) * dist + cx
set y = SinBJ(ang + delta) * dist + cy

call CasterCastAbilityPointEx(GetOwningPlayer(cast), cx, cy, 0, 'ARts', 1, "impale", x, y, 3.00)

set delta = -22.5
set x = CosBJ(ang + delta) * dist + cx
set y = SinBJ(ang + delta) * dist + cy

call CasterCastAbilityPointEx(GetOwningPlayer(cast), cx, cy, 0, 'ARts', 1, "impale", x, y, 3.00)

set delta = 45
set x = CosBJ(ang + delta) * dist + cx
set y = SinBJ(ang + delta) * dist + cy

call CasterCastAbilityPointEx(GetOwningPlayer(cast), cx, cy, 0, 'ARts', 1, "impale", x, y, 3.00)

set delta = -45
set x = CosBJ(ang + delta) * dist + cx
set y = SinBJ(ang + delta) * dist + cy

call CasterCastAbilityPointEx(GetOwningPlayer(cast), cx, cy, 0, 'ARts', 1, "impale", x, y, 3.00)

endfunction

//===========================================================================
function InitTrig_Earth_Tsunami takes nothing returns nothing
    call OnAbilityEffect('ARsi', "EarthTsunami_Spell")
endfunction

function Trig_Firestream_Spell_Finish_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AXfs' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Firestream_Spell_Finish_Actions takes nothing returns nothing
    call AttachBoolean(GetSpellAbilityUnit(), "casting_continues", false)
endfunction

//===========================================================================
function InitTrig_Firestream_Spell_Finish takes nothing returns nothing
    local trigger Firestream_Spell_Finish = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( Firestream_Spell_Finish, EVENT_PLAYER_UNIT_SPELL_ENDCAST )
    call TriggerAddCondition( Firestream_Spell_Finish, Condition( function Trig_Firestream_Spell_Finish_Conditions ) )
    call TriggerAddAction( Firestream_Spell_Finish, function Trig_Firestream_Spell_Finish_Actions )
    set Firestream_Spell_Finish = null
endfunction

function Trig_Firestream_Spell_Channel_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AXfs' ) ) then
        return false
    endif
    return true
endfunction

//   function CollisionMissile_Create takes string MissileModelPath,real x,real y,real dirangle,real speed,real AngleSpeed,real MaxDist,real height,boolean UseNewCaster,real Collision,code OnImpact returns unit

function Firestream_Collider takes nothing returns nothing
    local unit missile = GetTriggerCollisionMissile()
    local unit hit = GetTriggerUnit()
    local unit cast = GetAttachedUnit(missile, "trig_unit")
    if( IsUnitEnemy(hit, GetOwningPlayer(cast)) and not IsUnitType(hit, UNIT_TYPE_STRUCTURE) and not IsUnitType(hit, UNIT_TYPE_MAGIC_IMMUNE) ) then
        call UnitDamageTarget(cast, hit, 35, true, false, ATTACK_TYPE_MAGIC, DAMAGE_TYPE_FIRE, WEAPON_TYPE_WHOKNOWS)
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIfb\\AIfbSpecialArt.mdl", hit, "origin"))
    endif
    set hit = null
    set missile = null
    set cast = null
endfunction

function Trig_Firestream_Spell_Channel_Actions takes nothing returns nothing
    local unit cast = GetSpellAbilityUnit()
    local real cx = GetUnitX(cast)
    local real cy = GetUnitY(cast)
    local real x = GetSpellTargetX()
    local real y = GetSpellTargetY()
    local unit missile = null
    local real ang = Atan2BJ( y - cy, x - cx )
    local integer i = 0
    call AttachBoolean(cast, "casting_continues", true)
    
    loop
        exitwhen i > 150 or not GetAttachedBoolean(cast, "casting_continues")
        set missile = CollisionMissile_Create("Abilities\\Weapons\\FireBallMissile\\FireBallMissile.mdl", cx, cy, ang, GetRandomReal(800,1200), GetRandomReal(-10,10), GetRandomReal(800,1400),GetRandomReal(45,130),true,80, function Firestream_Collider)
        call AttachObject(missile, "trig_unit", cast)
        call PolledWait(GetRandomReal(0.02, 0.08))
    endloop
    
    set cast = null
    set missile = null
endfunction

//===========================================================================
function InitTrig_Firestream_Spell_Channel takes nothing returns nothing
    local trigger Firestream_Spell_Channel = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( Firestream_Spell_Channel, EVENT_PLAYER_UNIT_SPELL_CAST )
    call TriggerAddCondition( Firestream_Spell_Channel, Condition( function Trig_Firestream_Spell_Channel_Conditions ) )
    call TriggerAddAction( Firestream_Spell_Channel, function Trig_Firestream_Spell_Channel_Actions )
    set Firestream_Spell_Channel = null
endfunction

function WallOfFlame_Spell takes nothing returns nothing
    local unit cast = GetSpellAbilityUnit()
    local real cx = GetUnitX(cast)
    local real cy = GetUnitY(cast)
    local real x = GetSpellTargetX()
    local real y = GetSpellTargetY()
    local real ang = Atan2BJ( y - cy, x - cx )
    local integer i = 0
    local real x2
    local real y2
    local real delta_ang
    local real dist
    local integer lvl = GetUnitAbilityLevel(cast, 'AXfw')
    local integer wallChunks = 3 + lvl * 2
    if (wallChunks < 5) then
        call BJDebugMsg("Script for wall of fire has failed- give retera this error number: " + I2S(wallChunks))
    endif
    
// function CasterCastAbilityPoint takes player owner,integer abilid,string order,real x,real y,boolean instant returns unit
// function CasterCastAbilityPointEx takes player owner,real x1,real y1,real z1,integer abilid,integer level,string order,real x2,real y2,real delay returns unit

    //call CasterCastAbilityPoint(GetOwningPlayer(cast), 'AXwT', "flamestrike", x, y, false)

    loop
        exitwhen not (i < wallChunks)
        
        set delta_ang = 90 * ( -1 + 2 * ModuloInteger(i, 2))
        set dist = 150 * ((i + 1) / 2) 
        set x2 = x + CosBJ(ang + delta_ang) * dist
        set y2 = y + SinBJ(ang + delta_ang) * dist
        call CasterCastAbilityLevelPoint(GetOwningPlayer(cast), 'AXwT', lvl, "flamestrike", x2, y2, false)
        
        set i = i + 1
    endloop
    
    set cast = null
endfunction

//===========================================================================
function InitTrig_Wall_of_Flame takes nothing returns nothing
    call OnAbilityEffect('AXfw', "WallOfFlame_Spell")
endfunction

function IncendiaryScout_Spell takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local unit mis = null
local real x = GetSpellTargetX()
local real y = GetSpellTargetY()
local integer lvl = GetUnitAbilityLevel(cast, 'AXis')
if( lvl == 1 ) then
    set mis = CreateUnit(GetOwningPlayer(cast),'nfff',GetUnitX(cast),GetUnitY(cast),GetUnitFacing(cast))
elseif (lvl == 2) then
    set mis = CreateUnit(GetOwningPlayer(cast),'nff2',GetUnitX(cast),GetUnitY(cast),GetUnitFacing(cast))
else
    set mis = CreateUnit(GetOwningPlayer(cast),'nff3',GetUnitX(cast),GetUnitY(cast),GetUnitFacing(cast))
endif
call UnitAddAbility(mis, cs_FlyingHeightHack)
call UnitRemoveAbility(mis, cs_FlyingHeightHack)
call SetUnitFlyHeight(mis, 240, 0.01)
call UnitMoveToAsProjectileAnySpeed(mis, 350 + lvl * 100, 0.00, x, y, null, 240)
if not (IsUnitDeadBJ(mis)) then
call AddUnitAnimationProperties(mis, "spell", true)
call KillUnit(mis)
call CasterCastAbilityLevelAOE(GetOwningPlayer(cast), 'AXff', lvl, "faeriefire", x, y, I2R(lvl * 400), false, true)
endif
set mis = null
set cast = null
endfunction


function InitTrig_Incendiary_Scout takes nothing returns nothing
call OnAbilityEffect('AXis', "IncendiaryScout_Spell")
endfunction

function Trig_MakeTheCamp_Func001001001002001001 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_STRUCTURE) == true )
endfunction

function Trig_MakeTheCamp_Func001001001002001002 takes nothing returns boolean
    return ( GetUnitTypeId(GetFilterUnit()) != 'ngol' )
endfunction

function Trig_MakeTheCamp_Func001001001002001 takes nothing returns boolean
    return GetBooleanAnd( Trig_MakeTheCamp_Func001001001002001001(), Trig_MakeTheCamp_Func001001001002001002() )
endfunction

function Trig_MakeTheCamp_Func001001001002002 takes nothing returns boolean
    return ( GetUnitTypeId(GetFilterUnit()) != 'ntav' )
endfunction

function Trig_MakeTheCamp_Func001001001002 takes nothing returns boolean
    return GetBooleanAnd( Trig_MakeTheCamp_Func001001001002001(), Trig_MakeTheCamp_Func001001001002002() )
endfunction

function Trig_MakeTheCamp_Actions takes nothing returns nothing
local unit u = GroupPickRandomUnit(GetUnitsOfPlayerMatching(Player(PLAYER_NEUTRAL_PASSIVE), Condition(function Trig_MakeTheCamp_Func001001001002)))
if u != null then
    call ReplaceUnitBJ( u, 'nm00', bj_UNIT_STATE_METHOD_RELATIVE )
endif
set u = null
endfunction

function InitElementalNeutralHeroes takes nothing returns nothing
	call InitTrig_BannerOfProtection()
	call InitTrig_Taunt()
    call OnAbilityEffect('ALsb', "ShockStorm_Spell")
	call OnAbilityEffect('ALbl', "Thunderstep_Spell")
	call InitTrig_Boulder_Wave()
    call OnAbilityEffect('ARsi', "EarthTsunami_Spell")
	call InitTrig_Firestream_Spell_Finish()
	call InitTrig_Firestream_Spell_Channel()
	call InitTrig_Wall_of_Flame()
	call InitTrig_Incendiary_Scout()
	call Trig_MakeTheCamp_Actions()
endfunction


// shifted up for fishing ability




//***************************************************************************
//*
//*  Random distribution
//*
//*  Used to select a random object from a given distribution of chances
//*
//*  - RandomDistReset clears the distribution list
//*
//*  - RandomDistAddItem adds a new object to the distribution list
//*    with a given identifier and an integer chance to be chosen
//*
//*  - RandomDistChoose will use the current distribution list to choose
//*    one of the objects randomly based on the chance distribution
//*  
//*  Note that the chances are effectively normalized by their sum,
//*  so only the relative values of each chance are important
//*
//***************************************************************************

//===========================================================================
function RandomDistReset takes nothing returns nothing
    set bj_randDistCount = 0
endfunction

//===========================================================================
function RandomDistAddItem takes integer inID, integer inChance returns nothing
    set bj_randDistID[bj_randDistCount] = inID
    set bj_randDistChance[bj_randDistCount] = inChance
    set bj_randDistCount = bj_randDistCount + 1
endfunction

//===========================================================================
function RandomDistChoose takes nothing returns integer
    local integer sum = 0
    local integer chance = 0
    local integer index
    local integer foundID = -1
    local boolean done

    // No items?
    if (bj_randDistCount == 0) then
        return -1
    endif

    // Find sum of all chances
    set index = 0
    loop
        set sum = sum + bj_randDistChance[index]

        set index = index + 1
        exitwhen index == bj_randDistCount
    endloop

    // Choose random number within the total range
    set chance = GetRandomInt(1, sum)

    // Find ID which corresponds to this chance
    set index = 0
    set sum = 0
    set done = false
    loop
        set sum = sum + bj_randDistChance[index]

        if (chance <= sum) then
            set foundID = bj_randDistID[index]
            set done = true
        endif

        set index = index + 1
        if (index == bj_randDistCount) then
            set done = true
        endif

        exitwhen done == true
    endloop

    return foundID
endfunction



//***************************************************************************
//*
//*  Drop item
//*
//*  Makes the given unit drop the given item
//*
//*  Note: This could potentially cause problems if the unit is standing
//*        right on the edge of an unpathable area and happens to drop the
//*        item into the unpathable area where nobody can get it...
//*
//***************************************************************************

function UnitDropItem takes unit inUnit, integer inItemID returns item
    local real x
    local real y
    local real radius = 32
    local real unitX
    local real unitY
    local item droppedItem

    if (inItemID == -1) then
        return null
    endif

    set unitX = GetUnitX(inUnit)
    set unitY = GetUnitY(inUnit)

    set x = GetRandomReal(unitX - radius, unitX + radius)
    set y = GetRandomReal(unitY - radius, unitY + radius)

    set droppedItem = CreateItem(inItemID, x, y)

    call SetItemDropID(droppedItem, GetUnitTypeId(inUnit))
    call UpdateStockAvailability(droppedItem)

    return droppedItem
endfunction

//===========================================================================
function WidgetDropItem takes widget inWidget, integer inItemID returns item
    local real x
    local real y
    local real radius = 32
    local real widgetX
    local real widgetY

    if (inItemID == -1) then
        return null
    endif

    set widgetX = GetWidgetX(inWidget)
    set widgetY = GetWidgetY(inWidget)

    set x = GetRandomReal(widgetX - radius, widgetX + radius)
    set y = GetRandomReal(widgetY - radius, widgetY + radius)

    return CreateItem(inItemID, x, y)
endfunction

function Fishing_Spell takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local real x = GetSpellTargetX()
local real y = GetSpellTargetY()
local real ang = GetUnitFacing(cast) //Atan2(y - GetUnitY(cast), x - GetUnitX(cast))
local real fish_x = CosBJ(ang) * 605.00 + GetUnitX(cast)
local real fish_y = SinBJ(ang) * 605.00 + GetUnitY(cast)
local integer catchChance
local integer fishType
//call CreateUnit(GetOwningPlayer(cast), 'hpea', fish_x, fish_y, 270)
if( not IsTerrainPathable(fish_x, fish_y, PATHING_TYPE_FLOATABILITY) ) then
else
    call IssueImmediateOrder(cast, "stop")
    call CS_Error(GetOwningPlayer(cast), "Cast didn't land in fishable water.")
endif
set cast = null
endfunction

function RetTrig_FishThrow_Conditions takes nothing returns boolean
    if ( not ( OrderId2StringBJ(GetIssuedOrderIdBJ()) == "ward" ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_FishThrow_Actions takes nothing returns nothing
local unit cast = GetOrderedUnit()
local real ang = GetUnitFacing(cast) //Atan2(y - GetUnitY(cast), x - GetUnitX(cast))
local real fish_x = CosBJ(ang) * 605.00 + GetUnitX(cast)
local real fish_y = SinBJ(ang) * 605.00 + GetUnitY(cast)
local integer catchChance
local integer fishType
//call CreateUnit(GetOwningPlayer(cast), 'hpea', fish_x, fish_y, 270)
if( not IsTerrainPathable(fish_x, fish_y, PATHING_TYPE_FLOATABILITY) ) then
else
    call TriggerSleepAction(0.00)
    call IssueImmediateOrder(cast, "stop")
    call CS_Error(GetOwningPlayer(cast), "Cast didn't land in fishable water.")
endif
set cast = null
endfunction

//===========================================================================
function InitRetTrig_FishThrow takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_ISSUED_ORDER )
    call TriggerAddCondition( t, Condition( function RetTrig_FishThrow_Conditions ) )
    call TriggerAddAction( t, function RetTrig_FishThrow_Actions )
    set t = null
endfunction

function RetTrig_UnitDropItems takes nothing returns nothing
    local widget  trigWidget = null
    local unit    trigUnit   = null
    local integer itemID     = 0
    local boolean canDrop    = true

    set trigWidget = bj_lastDyingWidget
    if (trigWidget == null) then
        set trigUnit = GetTriggerUnit()
    endif

    if (trigUnit != null) then
        set canDrop = not IsUnitHidden(trigUnit)
        if (canDrop and GetChangingUnit() != null) then
            set canDrop = (GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE))
        endif
    endif

    if (canDrop) then
        if (trigUnit != null) then
            set itemID = GetAttachedInt( trigUnit, "dropID" )
            call UnitDropItem( trigUnit, itemID )
            call AttachInt( trigUnit, "dropID", 0 ) //flush data
        else
            set itemID = GetAttachedInt( trigWidget, "dropID" )
            call WidgetDropItem( trigWidget, itemID )
            call AttachInt( trigWidget, "dropID", 0 ) //flush data
        endif

    endif

    set bj_lastDyingWidget = null
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

function RetTrig_FishCatch_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AFfi' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_FishCatch_Actions takes nothing returns nothing
local unit cast = GetSpellAbilityUnit()
local unit murloc = null
local real x = GetSpellTargetX()
local real y = GetSpellTargetY()
local real ang = GetUnitFacing(cast) //Atan2(y - GetUnitY(cast), x - GetUnitX(cast))
local real fish_x = CosBJ(ang) * 605.00 + GetUnitX(cast)
local real fish_y = SinBJ(ang) * 605.00 + GetUnitY(cast)
local integer catchChance
local integer fishType
local integer lvl = GetUnitAbilityLevel(cast, 'AFfi')
local integer fishChance = 4777 + 2000 * lvl // in 12346
local trigger t = null
    if( lvl == 1 ) then
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( 'Ighf', 24)
        call RandomDistAddItem( 'Imlf', 25 )
        call RandomDistAddItem( 'Ibsm', 10 )
        call RandomDistAddItem( 'phea', 20 )
        call RandomDistAddItem( 'pclr', 30 )
        call RandomDistAddItem( 'mcri', 2 )
        call RandomDistAddItem( 'Ilms', 1000 )
        call RandomDistAddItem( 'Irfs', 3200 )
        call RandomDistAddItem( 'Ifsm', 3390 )
        call RandomDistAddItem( 'Ivlp', 900 )
        call RandomDistAddItem( -1, 453 )//~3%
        call RandomDistAddItem( 0, 6500 )
        set fishType = RandomDistChoose()
    elseif( lvl == 2 ) then
        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( 'Ighf', 24)
        call RandomDistAddItem( 'Imlf', 25 )
        call RandomDistAddItem( 'Ibsm', 10 )
        call RandomDistAddItem( 'phea', 32 )
        call RandomDistAddItem( 'pman', 20 )
        call RandomDistAddItem( 'pclr', 30 )
        call RandomDistAddItem( 'mcri', 2 )
        call RandomDistAddItem( 'vddl', 8 )
        call RandomDistAddItem( 'pdiv', 8 )
        call RandomDistAddItem( 'rej3', 10 )
        call RandomDistAddItem( 'Ilms', 100 )
        call RandomDistAddItem( 'Ibwc', 450 )
        call RandomDistAddItem( 'Irfs', 300 )
        call RandomDistAddItem( 'Ifsm', 1600 )
        call RandomDistAddItem( 'Ibtf', 1600 )
        call RandomDistAddItem( 'Isgf', 900 )
        call RandomDistAddItem( 'Ivlp', 3200 )
        call RandomDistAddItem( 'Ims1', 30 )
        call RandomDistAddItem( 'Ims2', 10 )
        call RandomDistAddItem( 'Ims3', 8 )
        call RandomDistAddItem( -1, 416 ) //~3%
        call RandomDistAddItem( 0, 5500 )
        set fishType = RandomDistChoose()
    else
        // Item set 1
        call RandomDistReset(  )
        call RandomDistAddItem( 'Ighf', 240)
        call RandomDistAddItem( 'Imlf', 25 )
        call RandomDistAddItem( 'Ibsm', 10 )
        call RandomDistAddItem( 'phea', 32 )
        call RandomDistAddItem( 'pman', 20 )
        call RandomDistAddItem( 'pclr', 30 )
        call RandomDistAddItem( 'mcri', 2 )
        call RandomDistAddItem( 'vddl', 8 )
        call RandomDistAddItem( 'pdiv', 8 )
        call RandomDistAddItem( 'rej3', 10 )
        call RandomDistAddItem( 'Ilms', 100 )
        call RandomDistAddItem( 'Ibwc', 950 )
        call RandomDistAddItem( 'Irfg', 1100 )
        call RandomDistAddItem( 'Irfs', 400 )
        call RandomDistAddItem( 'Ifsm', 800 )
        call RandomDistAddItem( 'Ibtf', 1700 )
        call RandomDistAddItem( 'Idfa', 350 )
        call RandomDistAddItem( 'Ipyg', 650 )
        call RandomDistAddItem( 'Isgf', 700 )
        call RandomDistAddItem( 'Ibss', 3200 )
        call RandomDistAddItem( 'Ivlp', 700 )
        call RandomDistAddItem( 'Imbs', 500 )
        call RandomDistAddItem( 'Iimr', 10 )
        call RandomDistAddItem( 'klmm', 1 )
        call RandomDistAddItem( 'Ims1', 40 )
        call RandomDistAddItem( 'Ims2', 20 )
        call RandomDistAddItem( 'Ims3', 16 )
        call RandomDistAddItem( -1, 454 ) //~3%
        call RandomDistAddItem( 0, 3500 )
        set fishType = RandomDistChoose()
    endif
    if( fishType == -1 ) then
        call DestroyEffect(AddSpellEffectById('AFfi', EFFECT_TYPE_EFFECT, fish_x, fish_y))
        if( GetHeroLevel(cast) > 7 ) then
            set fishType = 'nmmu'
        elseif (GetHeroLevel(cast) > 5) then
            set fishType = 'nmfs'
        elseif (GetHeroLevel(cast) > 2) then
            set fishType = 'nmrr'
        else
            set fishType = 'nmrl'
        endif
        set murloc = CreateUnit(Player(PLAYER_NEUTRAL_AGGRESSIVE), fishType, GetUnitX(cast), GetUnitY(cast), 270)
        
        // Item set 0
        call RandomDistReset(  )
        call RandomDistAddItem( 'rnsp', 1)
        call RandomDistAddItem( 'Irfs', 39 )
        call RandomDistAddItem( 'Ifsm', 60 )
        set fishType = RandomDistChoose()
        call AttachInt( murloc, "dropID", fishType )
        set t = CreateTrigger(  )
        call TriggerRegisterUnitEvent( t, murloc, EVENT_UNIT_DEATH )
        call TriggerRegisterUnitEvent( t, murloc, EVENT_UNIT_CHANGE_OWNER )
        call TriggerAddAction( t, function RetTrig_UnitDropItems )
        
    elseif( fishType != 0 ) then
        call DestroyEffect(AddSpellEffectById('AFfi', EFFECT_TYPE_EFFECT, fish_x, fish_y))
        call UnitAddItemById(cast, fishType)
    else
        //call CS_Error(GetOwningPlayer(cast), "No fish caught.")
    endif
set cast = null
set murloc = null
set t = null
endfunction

//===========================================================================
function InitRetTrig_FishCatch takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_SPELL_FINISH )
    call TriggerAddCondition( t, Condition( function RetTrig_FishCatch_Conditions ) )
    call TriggerAddAction( t, function RetTrig_FishCatch_Actions )
    set t = null
endfunction

function RetTrig_SnowSmash_Actions takes nothing returns nothing
    local destructable pile = GetDyingDestructable()
    local unit aura = GetAttachedUnit(pile, "trig_unit")
    call KillUnit(aura)
    call RemoveUnit(aura)
    call CleanAttachedVars(pile)
    set pile = null
    set aura = null
endfunction

function RetTrig_BlizzardNP_Actions takes nothing returns nothing
    local unit aura_caster
    local trigger snowSmash = CreateTrigger()
    local destructable pile
    local real x = GetSpellTargetX()
    local real y = GetSpellTargetY()
    call SetTerrainType(GetSpellTargetX(), GetSpellTargetY(), 'Nsnw' , - 1 , 2 , 0)
    set aura_caster = CreateUnit(GetOwningPlayer(GetSpellAbilityUnit()), 'dumb', GetSpellTargetX(), GetSpellTargetY(), 0)
    set pile = CreateDestructable('Zsnw', x, y, 270, 1, 0) 
    call UnitAddAbility(aura_caster, 'Aloc')
    call UnitAddAbility_ConsiderEvent(aura_caster, 'AFsn', 1)
    
    call TriggerRegisterDeathEvent(snowSmash, pile)
    call AttachObject(pile, "trig_unit", aura_caster)
    call TriggerAddAction(snowSmash, function RetTrig_SnowSmash_Actions)
    
    set snowSmash = null
    set pile = null
    set aura_caster = null
endfunction

//===========================================================================
// Trigger: Summon Wall
//===========================================================================
function RetTrig_NP_Summon_Wall_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AFsw' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetSpellTargetUnit()) == 'fwac' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_NP_Summon_Wall_Func001Func003001001002 takes nothing returns boolean
    return ( GetUnitTypeId(GetFilterUnit()) == 'fwac' )
endfunction

function RetTrig_NP_Summon_Wall_Func001C takes nothing returns boolean
    if ( not ( IsUnitGroupEmptyBJ(GetUnitsInRectAll(RectFromCenterSizeBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , 64.00 , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , 64.00 , 64.00))) == true ) ) then
        return false
    endif
    if ( not ( IsUnitGroupDeadBJ(GetUnitsInRectMatching(RectFromCenterSizeBJ(PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , 64.00 , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , 64.00 , 64.00) , Condition(function RetTrig_NP_Summon_Wall_Func001Func003001001002))) == true ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_NP_Summon_Wall_Actions takes nothing returns nothing
    local integer array wallVars
    set wallVars[1] = 'fwa0'
    set wallVars[2] = 'fwa1'
    set wallVars[3] = 'fwa2'
    set wallVars[4] = 'fwa3'
    set wallVars[5] = 'fwa4'
    set wallVars[6] = 'fwa5'
    set wallVars[7] = 'fwa6'
    set wallVars[8] = 'fwa7'
    set wallVars[9] = 'fwa8'
    set wallVars[10] = 'fwa9'
    if ( RetTrig_NP_Summon_Wall_Func001C() ) then
        set bj_forLoopAIndex = 1
        set bj_forLoopAIndexEnd = ( R2I(DistanceBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) / 64 )
        loop
            exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
            call CreateNUnitsAtLoc(1 , wallVars[GetRandomInt(1 , 10)] , GetOwningPlayer(GetSpellAbilityUnit()) , PolarProjectionBJ(GetUnitLoc(GetSpellAbilityUnit()) , ( I2R(GetForLoopIndexA()) * 64.00 ) , AngleBetweenPoints(GetUnitLoc(GetSpellAbilityUnit()) , GetUnitLoc(GetSpellTargetUnit()))) , bj_UNIT_FACING)
            set bj_forLoopAIndex = bj_forLoopAIndex + 1
        endloop
    else
    endif
endfunction

//===========================================================================
function InitRetTrig_NP_Summon_Wall takes nothing returns nothing
    local trigger rj_trg_Summon_Wall = CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(rj_trg_Summon_Wall , EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(rj_trg_Summon_Wall , Condition(function RetTrig_NP_Summon_Wall_Conditions))
    call TriggerAddAction(rj_trg_Summon_Wall , function RetTrig_NP_Summon_Wall_Actions)
    set rj_trg_Summon_Wall = null
endfunction

function RetTrig_Frostwave_Spell_Finish_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AFfw' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Frostwave_Spell_Finish_Actions takes nothing returns nothing
    call AttachBoolean(GetSpellAbilityUnit() , "casting_continues" , false)
endfunction

//===========================================================================
function InitRetTrig_Frostwave_Spell_Finish takes nothing returns nothing
    local trigger Frostwave_Spell_Finish= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(Frostwave_Spell_Finish , EVENT_PLAYER_UNIT_SPELL_ENDCAST)
    call TriggerAddCondition(Frostwave_Spell_Finish , Condition(function RetTrig_Frostwave_Spell_Finish_Conditions))
    call TriggerAddAction(Frostwave_Spell_Finish , function RetTrig_Frostwave_Spell_Finish_Actions)
    set Frostwave_Spell_Finish = null
endfunction

function RetTrig_Frostwave_Spell_Channel_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'AFfw' ) ) then
        return false
    endif
    return true
endfunction

//   function CollisionMissile_Create takes string MissileModelPath,real x,real y,real dirangle,real speed,real AngleSpeed,real MaxDist,real height,boolean UseNewCaster,real Collision,code OnImpact returns unit

function Frostwave_Collider takes nothing returns nothing
    local unit missile= GetTriggerCollisionMissile()
    local unit hit= GetTriggerUnit()
    local unit cast= GetAttachedUnit(missile , "RetTrig_unit")
    if ( IsUnitEnemy(hit , GetOwningPlayer(cast)) and not IsUnitType(hit , UNIT_TYPE_STRUCTURE) and not IsUnitType(hit , UNIT_TYPE_MAGIC_IMMUNE) ) then
        call UnitDamageTarget(cast , hit , 35 , true , false , ATTACK_TYPE_MAGIC , DAMAGE_TYPE_COLD , WEAPON_TYPE_WHOKNOWS)
        call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIob\\AIobSpecialArt.mdl" , hit , "origin"))
    endif
    set hit = null
    set missile = null
    set cast = null
endfunction

function RetTrig_Frostwave_Spell_Channel_Actions takes nothing returns nothing
    local unit cast= GetSpellAbilityUnit()
    local real cx= GetUnitX(cast)
    local real cy= GetUnitY(cast)
    local real x= GetSpellTargetX()
    local real y= GetSpellTargetY()
    local unit missile= null
    local real ang= Atan2BJ(y - cy , x - cx)
    local integer i= 0
    
    if ( not GetAttachedBoolean(cast , "frostwave_is_active") ) then
        call AttachBoolean(cast , "casting_continues" , true)
        call AttachBoolean(cast , "frostwave_is_active" , true)
        
        loop
            exitwhen i > 1500 or not GetAttachedBoolean(cast , "casting_continues")
            set missile = CollisionMissile_Create("Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" , cx , cy , ang + GetRandomReal(- 30 , 30) , GetRandomReal(800 , 1200) , GetRandomReal(- 100 , 100) , GetRandomReal(800 , 1400) , GetRandomReal(45 , 130) , true , 80 , function Frostwave_Collider)
            call AttachObject(missile , "RetTrig_unit" , cast)
            call PolledWait(GetRandomReal(0.00 , 0.03))
        endloop
        
        call AttachBoolean(cast , "frostwave_is_active" , false)
    endif
    
    set cast = null
    set missile = null
endfunction

//===========================================================================
function InitRetTrig_Frostwave_Spell_Channel takes nothing returns nothing
    local trigger Frostwave_Spell_Channel= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(Frostwave_Spell_Channel , EVENT_PLAYER_UNIT_SPELL_CAST)
    call TriggerAddCondition(Frostwave_Spell_Channel , Condition(function RetTrig_Frostwave_Spell_Channel_Conditions))
    call TriggerAddAction(Frostwave_Spell_Channel , function RetTrig_Frostwave_Spell_Channel_Actions)
    set Frostwave_Spell_Channel = null
endfunction

function InitRetTrig_Frostwave takes nothing returns nothing
	call InitRetTrig_Frostwave_Spell_Finish()
	call InitRetTrig_Frostwave_Spell_Channel()
endfunction


function RetTrig_NP_VortexFinder_Conditions takes nothing returns boolean
    return GetUnitTypeId(GetSummonedUnit()) == 'fvor'
endfunction

//===========================================================================
function InitRetTrig_NP_VortexFinder takes nothing returns nothing
    local trigger t= CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(t , EVENT_PLAYER_UNIT_SUMMON)
    call TriggerAddCondition(t , Condition(function RetTrig_NP_VortexFinder_Conditions))
    call TriggerAddAction(t , function RetTrig_VortexFinder_Actions)
    set t = null
endfunction

function InitNPVortex takes nothing returns nothing
    call OnAbilityEffect('AFiv' , "Vortex")
    call InitRetTrig_NP_VortexFinder()
endfunction

function NPFrostShield takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local location targ=GetSpellTargetLoc()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer icen=18
    local integer projn=2 + lvl
    local integer i=1
    local unit spawn
    //x=GetLocationX(source) + dist * Cos(angle * bj_DEGTORAD)
    call ProjectileLaunchEx(Player(15) , ("Abilities\\Spells\\Other\\FrostBolt\\FrostBoltMissile.mdl" ) , 1 , 255 , 255 , 255 , 255 , (( 900 )*1.0) , (( 0.5 )*1.0) , (( GetUnitX(caster) )*1.0) , (( GetUnitY(caster) )*1.0) , (( 0 )*1.0) , (( GetLocationX(targ) )*1.0) , (( GetLocationY(targ) )*1.0) , (( 0)*1.0)) // INLINED!!

    loop
        exitwhen i > projn
        if i == projn then
        call TriggerSleepAction(0)
        call ProjectileLaunchEx(Player(15) , ("Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" ) , 1 , 255 , 255 , 255 , 255 , (( 700 )*1.0) , (( 1 )*1.0) , (( GetLocationX(targ) )*1.0) , (( GetLocationY(targ) )*1.0) , (( 0 )*1.0) , (( GetLocationX(targ) + 300 * Cos(( 360 / projn ) * i * bj_DEGTORAD) )*1.0) , (( GetLocationY(targ) + 300 * Sin(( 360 / projn ) * i * bj_DEGTORAD) )*1.0) , (( 0)*1.0)) // INLINED!!
        else
        call ProjectileLaunchExTimeless(Player(15) , "Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl" , 1 , 255 , 255 , 255 , 255 , 700 , 1 , GetLocationX(targ) , GetLocationY(targ) , 0 , GetLocationX(targ) + 300 * Cos(( 360 / projn ) * i * bj_DEGTORAD) , GetLocationY(targ) + 300 * Sin(( 360 / projn ) * i * bj_DEGTORAD) , 0)

        endif
        set i = i + 1
    endloop
    set i = 1
    loop
        exitwhen i > icen
        set spawn = CreateUnit(GetOwningPlayer(caster) , 'ffsi' , GetLocationX(targ) + 300 * Cos(( 360 / icen ) * i * bj_DEGTORAD) , GetLocationY(targ) + 300 * Sin(( 360 / icen ) * i * bj_DEGTORAD) , bj_RADTODEG * Atan2(GetLocationY(targ) - GetLocationY(targ) + 300 * Sin(( 360 / icen ) * i * bj_DEGTORAD) , GetLocationX(targ) - GetLocationX(targ) + 300 * Cos(( 360 / icen ) * i * bj_DEGTORAD)))
        call UnitApplyTimedLife(spawn , 'BFfs' , 20 + lvl * 10)
        if lvl >= 2 then
        call UnitAddAbility(spawn , 'AFl1')
        endif
        if lvl >= 3 then
        call UnitAddAbility(spawn , 'AFl2')
        endif
        set i = i + 1
    endloop
    set caster = null
    call RemoveLocation(targ)
    set targ = null
    set spawn = null
endfunction

function NPImpalingFrostNova takes nothing returns nothing
    local unit caster=GetSpellAbilityUnit()
    local integer abil=GetSpellAbilityId()
    local integer lvl=GetUnitAbilityLevel(caster , abil)
    local integer castn= 3 //8 + lvl * 4
    local integer i=1
    local real radAng
    local real angBetween = Atan2(GetSpellTargetY()-GetUnitY(caster),GetSpellTargetX()-GetUnitX(caster))*bj_RADTODEG
    loop
        exitwhen i > castn
        set radAng = (angBetween-( 45 / castn ) * i) * bj_DEGTORAD
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'AFt1' , lvl , "impale" , GetUnitX(caster) + 30 * Cos(radAng) , GetUnitY(caster) + 30 * Sin(radAng) , 3)
        set i = i + 1
    endloop
    
    set i = 1
    loop
        exitwhen i > castn
        set radAng = (angBetween+( 45 / castn ) * i) * bj_DEGTORAD
        call CasterCastAbilityPointEx(GetOwningPlayer(caster) , GetUnitX(caster) , GetUnitY(caster) , 0 , 'AFt2' , lvl , "impale" , GetUnitX(caster) + 30 * Cos(radAng) , GetUnitY(caster) + 30 * Sin(radAng) , 3)
        set i = i + 1
    endloop

    set caster = null
endfunction

function RetTrig_Tunnel_Conditions takes nothing returns boolean
    return ( GetSpellAbilityId() == 'AFwt' )
endfunction

function RetTrig_Tunnel_Collapse_Actions takes nothing returns nothing
    local unit source = GetTriggerUnit() // either caster or dying unit
    local unit partner = GetAttachedUnit(source, "partner")
    if not ( partner == null ) then
        call CleanAttachedVars(source)
        call CleanAttachedVars(partner)
        call WaygateActivate(source, false)
        call WaygateActivate(partner, false)
        call KillUnit(source)
        call KillUnit(partner)
    endif
    set source = null
    set partner = null
endfunction

function RetTrig_Tunnel_Actions takes nothing returns nothing
    local unit cast = GetSpellAbilityUnit()
    local player owner = GetOwningPlayer(cast)
    local real tx = GetSpellTargetX()
    local real ty = GetSpellTargetY()
    local real cx = GetUnitX(cast)
    local real cy = GetUnitY(cast)
    local unit gateA = CreateUnit(owner, 'frct', cx, cy, 270)
    local unit gateB = CreateUnit(owner, 'frct', tx, ty, 270)
    local trigger deathTrigger = CreateTrigger()
    set tx = GetUnitX(gateB)
    set ty = GetUnitY(gateB)
    set cx = GetUnitX(gateA)
    set cy = GetUnitY(gateA)
    call WaygateSetDestination( gateA, tx, ty )
    call WaygateSetDestination( gateB, cx, cy )
    call WaygateActivate( gateA, true )
    call WaygateActivate( gateB, true )
    call UnitApplyTimedLife(gateA, 'Btlf', 120.00)
    call UnitApplyTimedLife(gateB, 'Btlf', 120.00)
    
    // Setup for when the waygates close or die
    call AttachObject(gateA, "partner", gateB)
    call AttachObject(gateB, "partner", gateA)
    call TriggerRegisterDeathEvent(deathTrigger, gateA)
    call TriggerRegisterDeathEvent(deathTrigger, gateB)
    call TriggerAddAction(deathTrigger, function RetTrig_Tunnel_Collapse_Actions)
    set cast = null
    set owner = null
    set gateA = null
    set gateB = null
endfunction

//===========================================================================
function InitRetTrig_Tunnel takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_SPELL_EFFECT )
    call TriggerAddCondition( t, Condition( function RetTrig_Tunnel_Conditions ) )
    call TriggerAddAction( t, function RetTrig_Tunnel_Actions )
    call OnAbilityEffect('AFct', "RetTrig_Tunnel_Collapse_Actions")
    set t = null
endfunction

function RetTrig_PoisonStingAnimations_Conditions takes nothing returns boolean
    return ( GetUnitAbilityLevelSwapped('AFpa', GetOrderedUnit()) > 0 ) and (( GetIssuedOrderIdBJ() == String2OrderIdBJ("poisonarrows") ) or ( GetIssuedOrderIdBJ() == String2OrderIdBJ("unpoisonarrows") ))
endfunction

function RetTrig_PoisonStingAnimations_Attacks_Conditions takes nothing returns boolean
    return ( GetUnitAbilityLevelSwapped( 'AFpa', GetAttacker()) > 0 ) and (GetAttachedBoolean(GetAttacker(), "poisonarrows"))
endfunction

function RefreshPoisonStingAnims takes unit who returns boolean
local boolean active = GetAttachedBoolean(who, "poisonarrows")
local boolean add = ( active and (GetUnitState(who, UNIT_STATE_MANA) > 10) )
local boolean pastState = GetAttachedBoolean(who, "slam_anims")
if( add != pastState ) then
    call AddUnitAnimationProperties(who, "Slam", add)
    call AttachBoolean(who, "slam_anims", add)
endif
//if active then
//call BJDebugMsg(" - active: true")
//endif
//if (GetUnitState(who, UNIT_STATE_MANA) > 10) then
//call BJDebugMsg(" - mana > 10: true")
//endif
//if add then
//call BJDebugMsg("add")
//else
//call BJDebugMsg("remove")
//endif
return add
endfunction

function RetTrig_PoisonStingAnimations_Attacks_Actions takes nothing returns nothing
local unit cast = GetAttacker()
local boolean pastState = GetAttachedBoolean(cast, "slam_anims")
local boolean add = RefreshPoisonStingAnims(cast)
if( add != pastState ) then
    if add then
        call SetUnitAnimation(cast, "Attack Slam")
    else
        call SetUnitAnimation(cast, "Attack")
    endif
    call QueueUnitAnimation(cast, "Stand")
endif
//if RefreshPoisonStingAnims(cast) then
//    call SetUnitAnimation(cast, "Attack Slam")
//else
//    call SetUnitAnimation(cast, "Attack")
//endif
set cast = null
endfunction

function RetTrig_PoisonStingAnimations_Actions takes nothing returns nothing
local unit cast = GetOrderedUnit()
local boolean active = (GetIssuedOrderIdBJ() == String2OrderIdBJ("poisonarrows"))
call AttachBoolean(cast, "poisonarrows", active)
call RefreshPoisonStingAnims(cast)

set cast = null
endfunction

//===========================================================================
function InitRetTrig_PoisonStingAnimations takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_ISSUED_ORDER )
    call TriggerAddCondition( t, Condition( function RetTrig_PoisonStingAnimations_Conditions ) )
    call TriggerAddAction( t, function RetTrig_PoisonStingAnimations_Actions )
    set t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_ATTACKED )
    call TriggerAddCondition( t, Condition( function RetTrig_PoisonStingAnimations_Attacks_Conditions ) )
    call TriggerAddAction( t, function RetTrig_PoisonStingAnimations_Attacks_Actions )
    set t = null
endfunction

function RetTrig_SpearBurst_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetDyingUnit()) == 'ficm' ) ) then
        return false
    endif
    if ( not ( GetKillingUnitBJ() == null ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_SpearBurst_Actions takes nothing returns nothing
local unit source = GetDyingUnit()
local real x = GetUnitX(source)
local real y = GetUnitY(source)
call CasterCastAbilityPointEx(GetOwningPlayer(source), x, y, 0, 'AFsp', GetUnitAbilityLevel(source,'AFib'), "channel", GetUnitX(source), GetUnitY(source), 5 )
set source = null
endfunction

//===========================================================================
function InitRetTrig_SpearBurst takes nothing returns nothing
    local trigger t = CreateTrigger(  )
    call TriggerRegisterAnyUnitEventBJ( t, EVENT_PLAYER_UNIT_DEATH )
    call TriggerAddCondition( t, Condition( function RetTrig_SpearBurst_Conditions ) )
    call TriggerAddAction( t, function RetTrig_SpearBurst_Actions )
endfunction

function RetTrig_Make_Dirt_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'dumb' ) ) then
        return false
    endif
    return true
endfunction

function RetTrig_Make_Dirt_Actions takes nothing returns nothing
local unit caster = GetEnteringUnit()
call TriggerSleepAction(0)
if( GetUnitAbilityLevel(caster, 'AFsa') > 0 ) then
    call SetTerrainType( GetUnitX(caster), GetUnitY(caster), 'Orok', -1, 1, 0 )
endif
set caster = null
endfunction

//===========================================================================
function InitRetTrig_Make_Dirt takes nothing returns nothing
    local integer i
    local trigger t = CreateTrigger(  )
    call TriggerRegisterEnterRectSimple( t, GetEntireMapRect() )
    call TriggerAddCondition( t, Condition( function RetTrig_Make_Dirt_Conditions ) )
    call TriggerAddAction( t, function RetTrig_Make_Dirt_Actions )
    set t = null
    
    set i = 0
    loop
        exitwhen i >= 12
        call SetPlayerAbilityAvailable(Player(i), 'AFba', false) // burrow abilities (engineering)
        call SetPlayerAbilityAvailable(Player(i), 'AFbd', false) // build (worker spellbook)
        set i = i + 1
    endloop
endfunction

function RetTrig_AbilityFix_Actions takes nothing returns nothing
    call UnitRemoveAbility( GetSpellAbilityUnit(), 'BFrt' )
    call UnitRemoveAbility( GetSpellAbilityUnit(), 'BFit' )
    call UnitMakeAbilityPermanent( GetSpellAbilityUnit(), true, 'AFrt' )
    call UnitMakeAbilityPermanent( GetSpellAbilityUnit(), true, 'AFit' )
endfunction

function InitNorthpact takes nothing returns nothing
local integer s
local integer D

    call OnAbilityEffect('AFfi', "Fishing_Spell")
    call OnAbilityEffect('AFbz', "RetTrig_BlizzardNP_Actions")
    call OnAbilityPreCast('AFis' , "NPFrostShield")
	call ExecuteFunc("InitRetTrig_FishThrow")
	call ExecuteFunc("InitRetTrig_FishCatch")
	call ExecuteFunc("InitRetTrig_NP_Summon_Wall")
	call ExecuteFunc("InitRetTrig_Frostwave")
	call ExecuteFunc("InitNPVortex")
	call ExecuteFunc("InitRetTrig_Tunnel")
	call ExecuteFunc("InitRetTrig_PoisonStingAnimations")
	call ExecuteFunc("InitRetTrig_SpearBurst")
	call ExecuteFunc("InitRetTrig_Make_Dirt")
    call OnAbilityEffect('AFb3', "RetTrig_AbilityFix_Actions")
	call OnAbilityEffect('AFt3', "NPImpalingFrostNova")
	
 //===================================================================================================
 // Leap ('AFlw')
 //
 set s = SetSpellTemplate('AFlw' , "JumpTemplateNX")
 //(Earth Crush doesn't need damage options)
    call SetAbilityDataInt(s , "UseOtherModel" , 0 , 1) //Use another model
    call SetAbilityDataInt(s , "OModelColor" , 0 , 0xFFFFFFFF) //Use another model
    call SetAbilityDataInt(s , "Spell" , 0 , 'AFls') //Spell to cast is AFls (flashy stomp)
    call SetAbilityDataInt(s , "OrderId" , 0 , OrderId("thunderclap")) //Its orderid is thunderclap
    call SetAbilityDataString(s , "OtherModel" , 0 , "war3mapImported\\WolfMissile2.mdl")
    call SetAbilityDataString(s , "JumpAnim" , 0 , "birth") //Play walk animation in jump
    call SetAbilityDataString(s , "EndAnim" , 0 , "morph") //Play birth animation when jump ends
    call SetAbilityDataReal(s , "RecDelay" , 0 , 0.00)
	
 //==================================
 //Tuskarr Spears ('AFts')
 set s = SetSpellTemplate('AFts' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_NORMAL , DAMAGE_TYPE_FORCE) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "n" , 0 , 4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "speed" , 0 , 1000) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 1 , 0.4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 2 , 0.6) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 3 , 0.8) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 0) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 50) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 70) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 100) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above
 //===================================================================================================
 // Elder's Aura (Memorial) ('AFea')
 //
 set s = SetPassiveTemplate('AFea' , "AuraTemplate")
 set D = 0 //Elder's Aura target Options :
 set D = D + DamageOnlyAllies() //Ignores enemies
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 600)
    call SetAbilityDataInt(s , "notself" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'AFaa') // aura armor
    call SetAbilityDataInt(s , "spell2id" , 0 , 'AFam') // aura magic resist
    call SetAbilityDataInt(s , "n" , 0 , 2)
 //===================================================================================================
 // Snow Aura 1 ('AFsn')
 //
 set s = SetPassiveTemplate('AFsn' , "AuraTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "options" , 0 , D)
    call SetAbilityDataReal(s , "area" , 0 , 256)
    call SetAbilityDataInt(s , "notself" , 0 , 1)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'AFsd')
    call SetAbilityDataInt(s , "n" , 0 , 1)
//===================================================================================================
 // Water Shield ('A0CQ')
 //

 //
 set s = SetSpellTemplate('AFvs' , "ShieldTemplate")
 set D = 0 //Shield of divinity damage Options :
 set D = DamageTypes(ATTACK_TYPE_MAGIC , DAMAGE_TYPE_COLD) //
 set D = CreateDamageOptions(D) //Save the damage options
    call SetAbilityDataInt(s , "n" , 1 , 1) //Level 1: 5 bolts
    call SetAbilityDataInt(s , "n" , 2 , 1) //Level 2: 6 bolts
    call SetAbilityDataInt(s , "n" , 3 , 1) //Level 3: 7 bolts
    call SetAbilityDataReal(s , "dur" , 1 , 50) //Level 1: Lasts 52 seconds
    call SetAbilityDataReal(s , "dur" , 2 , 70) //Level 2: Lasts 59 seconds
    call SetAbilityDataReal(s , "dur" , 3 , 90) //Level 3: Lasts 66 seconds
    call SetAbilityDataReal(s , "area" , 0 , 300) //Target acquire area is 300
    //call SetAbilityDataReal(s , "damage" , 1 , 15) //Level 1: Heals 200 hp
    //call SetAbilityDataReal(s , "damage" , 2 , 25) //Level 2: Heals 300 hp
    //call SetAbilityDataReal(s , "damage" , 3 , 35) //Level 3: Heals 400 hp
    call SetAbilityDataReal(s , "dmgoptions" , 0 , D) //Using damage options D
    call SetAbilityDataInt(s , "goodspell" , 0 , 1) //This is a positive spell
    call SetAbilityDataReal(s , "maxpercent" , 0 , 25) //Maximum percentage life required is 50%
    //call SetAbilityDataReal(s , "mainspeed" , 0 , 1000)
    call SetAbilityDataReal(s , "mainspeed" , 0 , 10000)
    call SetAbilityDataInt(s , "spell" , 0 , 'AFbh') //This is a positive spell
    call SetAbilityDataInt(s , "orderid" , 0 , OrderId("holybolt")) //This is a positive spell
    call SetAbilityDataReal(s , "cooldown" , 0 , 2.00) //This is a positive spell
    call SetAbilityDataInt(s , "fromfacing" , 0 , 1)
    call SetAbilityDataInt(s , "opposite" , 0 , 1)
	
	
 //=================================
 //Elemental Rage (AFer)

 set s = SetSpellTemplate('AFer' , "ToggleableTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'BFer') //The buff of the spell is BFer
    call SetAbilityDataInt(s , "AbilN" , 0 , 2) //It Adds 2 abilities in total
    call SetAbilityDataInt(s , "Abil1" , 0 , 'AF5a') //5 armor per level
    call SetAbilityDataInt(s , "Abil2" , 0 , 'AFfa') //frost attack at all levels

 //===================================================================================================
 // Leaping Attack ('AFle')
 //
 set s=SetSpellTemplate('AFle',"JumpTemplate")

    call SetAbilityDataInt(s ,"UseOtherModel",0,1)    //Use another model
    call SetAbilityDataInt(s ,"UseFacing",0,1)    //Use another model
    call SetAbilityDataReal(s,"OModelScale"  ,0,1) //Its scale is 1
    call SetAbilityDataReal(s,"RecDelay"  ,0,30) //Its scale is 1

    call SetAbilityDataInt(s,"Spell"  ,0,'AFt3')           //Spell to cast is AOws (war stomp)
    call SetAbilityDataInt(s,"OrderId",0,OrderId("shockwave")) //Its orderid is stomp

    call SetAbilityDataString(s,"EndAnim",0,"Spell Slam")  //Play spell slam animation when jump ends
    
 //==================================
 //Tuskarr Spears ('AFts')
 set s = SetSpellTemplate('AFsp' , "NovaSpellTemplate")
 set D = 0 //Incineration Nova Options :
 set D = DamageTypes(ATTACK_TYPE_MAGIC, DAMAGE_TYPE_COLD) //Spell poison damage
 set D = D + DamageOnlyEnemies() //Don't hurt self
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataReal(s , "n" , 0 , 4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "speed" , 0 , 1900) //200 of speed for all levels
    call SetAbilityDataReal(s , "dur" , 1 , 1.4) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 2 , 2.5) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "dur" , 3 , 3.6) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "turninc" , 0 , 0) // 0.5 seconds of duration for all levels
    call SetAbilityDataReal(s , "collision" , 0 , 55) // Always a collision of 55
    call SetAbilityDataInt(s , "TargetLog" , 0 , 1) // Always log targets

    call SetAbilityDataReal(s , "dmg" , 1 , 5) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 2 , 10) //Level 1: 20 initial damage
    call SetAbilityDataReal(s , "dmg" , 3 , 15) //Level 1: 20 initial damage

   call SetAbilityDataInt(s , "damageoptions" , 0 , D) //Using the damage options saved above
   
 //=================================
 //Icy Trail (AFit)

 set s = SetSpellTemplate('AFit' , "ToggleableUSTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'BFit') //The buff of the spell is B00N
    call SetAbilityDataInt(s , "UnitId" , 0 , 'ficm') //Ice unit
    call SetAbilityDataInt(s , "UAbilN" , 0 , 1) //It uses 2 abilities in total for the spawned unit
    call SetAbilityDataInt(s , "UAbil1" , 0 , 'AFib') //Aura of Death for the spawned units lvl 1 (you cant set abl lvl of permanent immolation)
//    call SetAbilityDataInt(s , "UAbilN" , 0 , 2) //It uses 2 abilities in total for the spawned unit
//    call SetAbilityDataInt(s , "UAbil1" , 0 , 'A0D3') //Aura of Slow for the spawned units
//    call SetAbilityDataInt(s , "UAbil2" , 1 , 'A0UO') //Aura of Death for the spawned units lvl 1 (you cant set abl lvl of permanent immolation)
//    call SetAbilityDataInt(s , "UAbil2" , 2 , 'A0UP') //Aura of Death for the spawned units lvl 2
//    call SetAbilityDataInt(s , "UAbil2" , 3 , 'A0UQ') //Aura of Death for the spawned units lvl 3
 //=================================
 //Rocky Trail (AFrt)

 set s = SetSpellTemplate('AFrt' , "ToggleableUSTemplate")

    call SetAbilityDataInt(s , "BuffId" , 0 , 'BFrt') //The buff of the spell is B00N
    call SetAbilityDataInt(s , "UnitId" , 0 , 'dumb') //Ice unit
    call SetAbilityDataInt(s , "UAbilN" , 0 , 2) //It uses 2 abilities in total for the spawned unit
    call SetAbilityDataInt(s , "UAbil1" , 0 , 'Aloc') //Aura of Slow for the spawned units
    call SetAbilityDataInt(s , "UAbil2" , 0 , 'AFsa') //Aura of Death for the spawned units lvl 1 (you cant set abl lvl of permanent immolation)
    

 //===================================================================================================
 // Mass Web ('AFmw')
 //
 set s = SetSpellTemplate('AFmw' , "SpellCastTemplate")
 set D = 0 //Winds Aura target Options :
 set D = D + DamageIgnore(UNIT_TYPE_STRUCTURE) //Ignores structures
 set D = CreateDamageOptions(D) //Save the damage options

    call SetAbilityDataInt(s , "DamageOptions" , 0 , D)
    call SetAbilityDataInt(s , "ChannelType" , 0 , 0)
    call SetAbilityDataInt(s , "Times" , 0 , 1)
    call SetAbilityDataReal(s , "area" , 0 , 350)
    call SetAbilityDataInt(s , "spell1type" , 0 , 0)
    call SetAbilityDataInt(s , "spell1id" , 0 , 'AFwb')
    call SetAbilityDataInt(s , "spell1OrderId" , 0 , OrderId("ensnare"))
    call SetAbilityDataInt(s , "spell1FromSource" , 0 , 1)
    call SetAbilityDataReal(s , "spell1RecDelay" , 0 , 6)
    call SetAbilityDataInt(s , "spellN" , 0 , 1)
    call SetAbilityDataInt(s , "instantStart" , 0 , 1)
//    call SetAbilityDataInt( s,"maxtargets",0,5)   //Max Targets cap is 5 for all levels
    
endfunction



function initRetera takes nothing returns nothing

  local integer i

call ExecuteFunc("jasshelper__initstructs246758044")
call ExecuteFunc("CSData__init")
call ExecuteFunc("TimerUtils___init")
call ExecuteFunc("CSSafeCache__init")
call ExecuteFunc("CasterSystem___InitCasterSystem")
call ExecuteFunc("CSDamagers__init")

    set i = 0
    loop
        exitwhen ( i > 1 )
        set rdg_csarray1[i]=0
        set i = i + 1
    endloop

    set i = 0
    loop
        exitwhen ( i > 1 )
        set rdg_csarray3[i]=0
        set i = i + 1
    endloop

    set i = 0
    loop
        exitwhen ( i > 1 )
        set rdg_csarray2[i]=0
        set i = i + 1
    endloop

    set i = 0
    loop
        exitwhen ( i > 1 )
        set rdg_castervars[i]=0
        set i = i + 1
    endloop

    set rdg_casters = CreateGroup()
    set rdg_currentabi = 0
    set rdg_delayhack = 0
    set rdg_TempReal = 0
    set rdg_RaceChoice = DialogCreate()
    set rdg_numberofdoneplayers = 0
    set rdg_BlueMoonT = CreateTimer()
    call InitNewDraenei()


//debug
    call InitRetTrig_fastunit()
    call InitRetTrig_fastbuild()
    call InitRetTrig_fasttech()
    call InitRetTrig_fast()
    call InitRetTrig_vision()
    call InitRetTrig_reset()
    call InitRetTrig_money()
	call InitRetTrig_EnableCheats()
	call InitRetTrig_EnableOldies()
//end debug

    call InitRetTrig_Learn_Soul_Steal()
    call InitRetTrig_Invincibility_Initialize()
    call InitRetTrig_Invincibility_Initialize_Copy()
    call InitRetTrig_Game_Initialization()
    call InitRetTrig_Turtle_Grow()
    call InitRetTrig_FL_Orb_Knockback()
    call InitRetTrig_Untitled_Trigger_020()
    call InitRetTrig_Tidal_Pool_Attack()
    call InitRetTrig_Gold_Mine_Fix()
    call InitRetTrig_Corruption()
    call InitRetTrig_Blood_Frenzy()
    call InitRetTrig_Untitled_Trigger_001()
 //   call InitRetTrig_Morph_Fix(  )
//    call InitRetTrig_Aid_of_Demonic_Helpers(  )
//    call InitRetTrig_Demonic_Helper_Movement(  )
//    call InitRetTrig_Demonic_Helper_Attack(  )
//    call InitRetTrig_Demonic_Helper_Death(  )
    call InitRetTrig_Blizzard()
    call InitRetTrig_Snitch_Spell_Trigger_Copy()
    call InitRetTrig_ForceWall()
    call InitRetTrig_Forcewall_Death()
    call InitRetTrig_Forcewall_Unsummon()
    call InitRetTrig_ForceWall_Fix_Bug()
    call InitRetTrig_Summon_Wall()
    call InitRetTrig_ForceWall_Copy_Copy()
    call InitRetTrig_Eat()
    call InitRetTrig_Firey_Attack()
    call InitRetTrig_Firey_Attack_Copy_2()
    call InitRetTrig_Firey_Attack_Copy()
    call InitRetTrig_Invincibility_Cast()
    call InitRetTrig_Invulnerablize()
    call InitRetTrig_Invulnerablize_Turn_Off()
    call InitRetTrig_Steal_Trees()
    call InitRetTrig_Snitch()
    call InitRetTrig_Splitting_Strike()
    call InitRetTrig_Narcolepsy_Cast()
    call InitRetTrig_Narcolepsy_Timer()
    call InitRetTrig_Explosion()
    call CreateCasters(12) // INLINED!!
    call ExecuteFunc("NovaTemplateSetup") // INLINED!!
    call ExecuteFunc("TimedBarrelSetup") // INLINED!!
    call ExecuteFunc("SetupChargeTemplate") // INLINED!!
    call ExecuteFunc("FireSpawnerSetup") // INLINED!!
    call ExecuteFunc("ShieldTemplateSetup") // INLINED!!
    call ExecuteFunc("AuraTemplateSetup") // INLINED!!
    call ExecuteFunc("SetupSpiralBeamTemplate") // INLINED!!
    call ExecuteFunc("BeamTemplateSetup") // INLINED!!
    call ExecuteFunc("SetupConeSpellTemplate") // INLINED!!
    call ExecuteFunc("SpellCastTemplateSetup") // INLINED!!
    call ExecuteFunc("WaveTemplateSetup") // INLINED!!
    call ExecuteFunc("WaveKBTemplateSetup") // INLINED!!
    call ExecuteFunc("ToggleableTemplateSetup") // INLINED!!
    call ExecuteFunc("ToggleableTemplateXSetup") // INLINED!!
    call ExecuteFunc("SlashTemplateSetup") // INLINED!!
    call ExecuteFunc("JumpTemplateSetup") // INLINED!!
    call ExecuteFunc("ChannelAuraTemplateSetup") // INLINED!!
    call InitRetTrig_Chain_Template()
    call InitRetTrig_Get()
    call InitRetTrig_CasterDeath()
    call InitRetTrig_BuildingDeath()
    call InitRetTrig_TimerExpire()
    call InitRetTrig_Coral_of_the_Gentle_Rain()
//    call InitRetTrig_Leap_Fixer_Trigger()
    call InitRetTrig_Freezing_Legion_Blue_Moon_AI()
    call OnAbilityGet('A0QE' , "CombatProwess")
    call OnAbilityEffect('A0QF' , "Vigor")
    call OnAbilityEffect('A0RY' , "BladeSpell")
	call InitRetTrig_BladeShield()

    call InitRetTrig_Abyss_Creation()
    call InitRetTrig_Mine_Lumber_Lasers()
    call InitRetTrig_Drain_Gold()
    call InitRetTrig_Drain_Gold_Fixer()
    call InitRetTrig_Drain_Gold3()
    call InitRetTrig_Drain_Gold3_RetTrig_2()
    call InitRetTrig_Portal_Link()
    call InitRetTrig_Portal_Link_Snap()
//    call InitRetTrig_SpellCastPhoenixBerserk()
//    call InitRetTrig_Phoenix()
//    call InitRetTrig_Begin_Phoenix()
//Phoenix abilities are shut down due to game crash
    call InitRetTrig_Fortifier_Tent()
    call InitRetTrig_Netherfield()
    call ExecuteFunc("KS_Field_Template_Setup")
    call InitRetTrig_Dont_Warp_Self_Aetherrift()
	call InitRetTrig_VoidUpgradeFunc()
	call InitRetTrig_MawOblivionAttack()
	call InitRetTrig_VoidRiftTimerFunc()
	call InitRetTrig_Mighty_Leap()

    call InitRetTrig_SummonBeast() // INLINED!!

    call InitRetTrig_Melee_Initialization_B()
    call InitRetTrig_Untitled_Trigger_002()

    call ConditionalTriggerExecute(rj_trg_Invincibility_Initialize)
    call ConditionalTriggerExecute(rj_trg_Invincibility_Initialize_Copy)
    call ConditionalTriggerExecute(rj_trg_Game_Initialization)
    call ConditionalTriggerExecute(rj_trg_Caster_Setup)


    call OnAbilityEffect('A0HH' , "DemonicPossession")
    call OnAbilityEffect('A0HL' , "HealingBolt")
    call OnAbilityEffect('A0IK' , "MurgulBolt")
    call OnAbilityEffect('A0JV' , "FlameBurstAbility")
    call OnAbilityEffect('A0K1' , "RollStone")
    call OnAbilityEffect('A0HM' , "WarlockBolt")
    call OnAbilityLearn('A0HQ' , "DarkArmor")

    call ExecuteFunc("InitRetTrig_Testified2345")


    call OnAbilityLearn('A0J0' , "ElementalRage")
    call OnAbilityPreCast('A0JE' , "FrostShield")
    call OnAbilityEffect('A0JA' , "ImpalingFrostNova")
    call OnAbilityPreCast('A0JA' , "ImpalingFrostNova")
    call OnAbilityEffect('A0IP' , "TouchOfFrost")
    call OnAbilityEffect('A0IR' , "BlueBloodlust")
    call InitVortex()
    call InitElementalRage()
    call InitRetTrig_Wagons()
    call LocustFollowerTemplateSetup()
    call InitRetTrig_AetherUnleashed()
    call OnAbilityEffect('A0N7' , "VoidFissure")
	call InitRetSpells_AscendedOverlord()
    call ExecuteFunc("InitRetTrig_Drain_Gold2")
    call ExecuteFunc("InitRetTrig_NetherGoldMineLocator")
    call ExecuteFunc("InitRetTrig_NetherGoldMineLocator2")
    call InitRetTrig_TheVoidGodAbilities()
    call InitRetTrig_Engorgement()
    call InitRetTrig_TentacleAura()
    call OnAbilityEffect('A0O1' , "SnappySpits")
    call InitRetTrig_TentacleAttackfix()
    call InitRetSpellCorrections()
    call InitRetCustomBuild()
    call OnAbilityEffect('A0Q9' , "SelectNetherChildren")
    call OnAbilityEffect('A0QA' , "SelectNetherChildrenLvl2")
    call InitRetTrig_SupaShroomVoid()
    call InitRetTrig_VoidUpgradeRally()
    call OnAbilityEffect('A0Q7' , "DetonateRift")
    call OnAbilityEffect('A0S7' , "SacVoidFood")
    call InitNewHumans()
    call InitRetTrig_AICommoner()
    call InitRetTrig_Chaos_Demon()
    call ExecuteFunc("InitCustomAICode")

//Void custom builds:
//function LoadCustomBuildSpell takes integer buildingTypeId, integer ChargeGnLSpell, integer spbkForBuildSpell, integer goldCost, integer lumberCost, integer foodCost, string hotKey, real minRange returns nothing

call LoadCustomBuildSpell('n02W' , 'A0O5' , 'A0O8' , 85 , 0 , 0 , "M" , 384) //Abyss Rift
call LoadCustomBuildSpell('u00W' , 'A0OC' , 'A0OD' , 180 , 50 , 0 , "M" , 384) //Altar of Aether
call LoadCustomBuildSpell('h02H' , 'A0OE' , 'A0OZ' , 160 , 60 , 0 , "M" , 384) //The Demon Gate pathing is not a square >.<
call LoadCustomBuildSpell('h02I' , 'A0OF' , 'A0P0' , 140 , 60 , 0 , "M" , 448) //Void-Crafted Hall
call LoadCustomBuildSpell('h02E' , 'A0OG' , 'A0P1' , 100 , 50 , 0 , "M" , 384) //Shadow Bunker
call LoadCustomBuildSpell('u01S' , 'A0S9' , 'A0SA' , 100 , 75 , 0 , "M" , 448) //Vortex of Sacrifice
call LoadCustomBuildSpellExtended('h02E' , 'A0PL' , 'A0P1' , 100 , 50 , 0 , "M" , 384) //Shadow Bunker (Req)
call LoadCustomBuildSpell('h02Q' , 'A0OI' , 'A0P2' , 160 , 140 , 0 , "M" , 448) //Prison of the Tortured
call LoadCustomBuildSpell('h02V' , 'A0OJ' , 'A0P3' , 155 , 140 , 0 , "M" , 448) //Aetherstorm Tower
call LoadCustomBuildSpell('n02Z' , 'A0OK' , 'A0P4' , 240 , 60 , 0 , "M" , 576) //TransloPortal   previously minRange was 640, which is now believe to be mathematically incorrect
call LoadCustomBuildSpell('h02G' , 'A0OH' , 'A0P6' , 130 , 30 , 0 , "M" , 448) //Vault of the Aether
call LoadCustomBuildSpell('n02X' , 'A0OL' , 'A0P5' , 150 , 85 , 0 , "M" , 384) //Monstrous Growth
call LoadCustomBuildSpellExtended('n02X' , 'A0PM' , 'A0P5' , 150 , 85 , 0 , "M" , 384) //Monstrous Growth (Req)
call InitRetReqSys()
call ForForce(bj_FORCE_ALL_PLAYERS , function ReqSys_RefreshAllEnum) // INLINED!!

//RISEN and NEW NEUTRAL
call InitRetTrig_DextrousSweep()
call InitRetTrig_Lunge()
call InitRetTrig_Lungescripts()
call InitRetTrig_Spirit_Twin_Bonuses()
call InitRetTrig_OversightAura()
call InitRetTrig_Rally()
call InitRetTrig_Siege()

call InitRetTrig_RisenSacKill()
call InitRetTrig_Rotsteel_Cannon_Lightning()
call InitRetTrig_Plague_Wyrm_Spikes()
call InitRetTrig_Smack_Down()
call InitRetTrig_Egg_Sack()
call Init_AttackDrainTemplate()
call InitRetTrig_Absorb_Corpse()
call InitRetTrig_Create_Cauldron_Born()
call InitRetTrig_Sell_Invasion_Skeleton()
call InitRetTrig_CauldronBornAura()
call InitRetTrig_Nuke()
call InitRet_BuildSoundSys()
call InitHornOfHonro()
call InitRetTrig_HornOfHonroGet()
call InitElementalNeutralHeroes()
call ExecuteFunc("InitNorthpact")
endfunction

function MeleeStartingUnitsDeprecated takes nothing returns nothing
    local integer  index
    local player   indexPlayer
    local location indexStartLoc
    local race     indexRace

    call Preloader( "scripts\\SharedMelee.pld" )

    set index = 0
    loop
        set indexPlayer = Player(index)
        if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
        if (GetPlayerController(indexPlayer) == MAP_CONTROL_COMPUTER) then
            set indexStartLoc = GetStartLocationLoc(GetPlayerStartLocation(indexPlayer))
            set indexRace = GetPlayerRace(indexPlayer)

            // Create initial race-specific starting units
            if (indexRace == RACE_HUMAN) then
                call MeleeStartingUnitsFinalHumans(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_ORC) then
                call MeleeStartingUnitsOrc(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_UNDEAD) then
                call MeleeStartingUnitsFreezingLegion(indexPlayer, indexStartLoc, true, true, true)
            elseif (indexRace == RACE_NIGHTELF) then
                call MeleeStartingUnitsNightElf(indexPlayer, indexStartLoc, true, true, true)
            else
                call MeleeStartingUnitsUnknownRace(indexPlayer, indexStartLoc, true, true, true)
            endif
        endif
        endif

        set index = index + 1
        exitwhen index == bj_MAX_PLAYERS
    endloop
    

    call BOBTwo()
endfunction


//===========================================================================
function InitBlizzard takes nothing returns nothing
    // Set up the Neutral Victim player slot, to torture the abandoned units
    // of defeated players.  Since some triggers expect this player slot to
    // exist, this is performed for all maps.
    call ConfigureNeutralVictim()

    call InitBlizzardGlobals()
    call InitQueuedTriggers()
    call InitRescuableBehaviorBJ()
    call InitDNCSounds()
    call InitMapRects()
    call InitSummonableCaps()
    call InitNeutralBuildings()
    call DetectGameStarted()
    
    call initRetera()
endfunction
